{"version":3,"file":"main.js","mappings":";;;;;;;;;;;;;;;;;;AAAkC;AACF;AAC8B;AACa;AACwB;AACtD;AAC+B;AACtB;;AAEtD;AACA,IAAI,uDAAuD;AAC3D,IAAI,gDAAgD;AACpD,IAAI,yDAAyD;AAC7D,IAAI,sDAAsD;AAC1D,IAAI,uDAAuD;AAC3D,IAAI,sDAAsD;AAC1D,IAAI,wDAAwD;AAC5D,IAAI,yDAAyD;AAC7D,IAAI,sDAAsD;AAC1D,IAAI,sDAAsD;AAC1D,IAAI,iDAAiD;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAW,mBAAmB,WAAW;AACjD,cAAc,oFAAsB;AACpC;AACA,cAAc,6EAAQ;AACtB;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,WAAW;AAClE,UAAU;AACV,UAAU,kEAAW,mBAAmB,WAAW;AACnD;AACA,sCAAsC,6EAAQ;AAC9C;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA,OAAO;AACP;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA,OAAO;AACP;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA,OAAO;AACP;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,EAAE,4FAAgB;AAClB;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,GAAG;AACH,EAAE,sFAAa;AACf;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA,OAAO;AACP;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;;AAEA;AACA,IAAI,oEAAY,kCAAkC,aAAa;AAC/D;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,IAAI,oEAAY;AAChB;;AAEA,yBAAyB,2FAAuB,oCAAoC,WAAW;;AAE/F;AACA;AACA,MAAM,oEAAY;AAClB;AACA,+BAA+B,0GAAgC;AAC/D;AACA;AACA,4BAA4B,sGAA8B;AAC1D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gEAAgE,WAAW;;AAE3E;AACA;AACA;AACA;AACA,kDAAkD,wFAAc;AAChE,mBAAmB;AACnB,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,0BAA0B,MAAM,gCAAgC;AAC7G;;AAEA;AACA,2CAA2C,+BAA+B,iBAAiB,kCAAkC,kBAAkB,iCAAiC;AAChL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,uFAAc,OAAO,8DAAU;AAClE;AACA;;AAEA;AACA;AACA;;AAEA,QAAQ,wFAAc;AACtB;AACA;;AAEA,0BAA0B,wFAAc;AACxC;AACA,sBAAsB,oGAA6B;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,QAAQ,8FAAiB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,MAAM,oEAAY;AAClB;AACA,KAAK;AACL,6BAA6B,mFAAa;AAC1C;AACA,IAAI,oEAAY;;AAEhB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,YAAY;AACzC;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;AAEL,IAAI,oEAAY;;AAEhB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,oEAAY;AACpB,uBAAuB,8FAAyB;AAChD;AACA;;AAEA,4BAA4B,yEAAW;AACvC,UAAU,oFAAe;;AAEzB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,IAAI,oEAAY;AAChB,IAAI,oEAAY;AAChB,IAAI;AACJ;AACA,MAAM,oEAAY,cAAc,cAAc,KAAK,eAAe;AAClE;AACA,KAAK;AACL;AACA;;;;;;;;;;;;ACtlBO;;AAEP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,MAAM,sBAAsB;AAC5B,MAAM,wBAAwB;AAC9B,MAAM,wBAAwB;AAC9B,MAAM,0BAA0B;AAChC,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,wBAAwB;AAC9B,MAAM,0BAA0B;AAChC,MAAM,0BAA0B;AAChC,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,4BAA4B;AAClC,MAAM,4BAA4B;AAClC,MAAM,8BAA8B;AACpC,MAAM,8BAA8B;AACpC,MAAM,6BAA6B;AACnC,MAAM,6BAA6B;AACnC,MAAM,+BAA+B;AACrC,MAAM,8BAA8B;AACpC,MAAM,8BAA8B;AACpC,MAAM,4BAA4B;AAClC;AACA;AACA;AACA,QAAQ,oBAAoB;AAC5B,QAAQ,8BAA8B;AACtC,QAAQ,oBAAoB;AAC5B,QAAQ,6BAA6B;AACrC,QAAQ,yBAAyB;AACjC,QAAQ,yBAAyB;AACjC,QAAQ,2BAA2B;AACnC,QAAQ,6BAA6B;AACrC,QAAQ,wBAAwB;AAChC,QAAQ,0BAA0B;AAClC,QAAQ,uBAAuB;AAC/B,QAAQ,uBAAuB;AAC/B;AACA;AACA,QAAQ,sBAAsB;AAC9B,QAAQ,uBAAuB;AAC/B,QAAQ,wBAAwB;AAChC,QAAQ,qBAAqB;AAC7B,QAAQ,qBAAqB;AAC7B,QAAQ,uBAAuB;AAC/B;AACA,GAAG;AACH;AACA,MAAM,oBAAoB;AAC1B,MAAM,8BAA8B;AACpC,MAAM,0BAA0B;AAChC,MAAM,0BAA0B;AAChC,MAAM,oBAAoB;AAC1B,MAAM,6BAA6B;AACnC,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,0BAA0B;AAChC,MAAM,0BAA0B;AAChC,MAAM,oCAAoC;AAC1C,MAAM,+BAA+B;AACrC,MAAM,mBAAmB;AACzB,MAAM,qBAAqB;AAC3B,MAAM,qBAAqB;AAC3B,MAAM,yBAAyB;AAC/B;AACA;AACA;AACA,QAAQ,uCAAuC;AAC/C,QAAQ,wCAAwC;AAChD,QAAQ,2CAA2C;AACnD,QAAQ,2CAA2C;AACnD,QAAQ,qCAAqC;AAC7C,QAAQ,uCAAuC;AAC/C;AACA;AACA,QAAQ,qFAAqF;AAC7F,QAAQ,gGAAgG;AACxG,QAAQ,6EAA6E;AACrF,QAAQ,mFAAmF;AAC3F,QAAQ,oFAAoF;AAC5F,QAAQ,+EAA+E;AACvF,QAAQ,gFAAgF;AACxF,QAAQ,0FAA0F;AAClG,QAAQ,2FAA2F;AACnG,QAAQ,kFAAkF;AAC1F,QAAQ,6EAA6E;AACrF,QAAQ,sFAAsF;AAC9F,QAAQ,wFAAwF;AAChG,QAAQ,sFAAsF;AAC9F,QAAQ,kFAAkF;AAC1F,QAAQ,+FAA+F;AACvG,QAAQ,+EAA+E;AACvF,QAAQ,kFAAkF;AAC1F;AACA;AACA;AACA;AACA,QAAQ,yBAAyB;AACjC,QAAQ,2BAA2B;AACnC,QAAQ,yBAAyB;AACjC,QAAQ,yBAAyB;AACjC;AACA;AACA,QAAQ,yCAAyC;AACjD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD,QAAQ,4CAA4C;AACpD,QAAQ,0CAA0C;AAClD,QAAQ,6CAA6C;AACrD,QAAQ,yCAAyC;AACjD,QAAQ,0CAA0C;AAClD,QAAQ,0CAA0C;AAClD;AACA;AACA,QAAQ,oCAAoC;AAC5C,QAAQ,mCAAmC;AAC3C,QAAQ,qCAAqC;AAC7C,QAAQ,mCAAmC;AAC3C,QAAQ,oCAAoC;AAC5C,QAAQ,yCAAyC;AACjD;AACA;AACA,QAAQ,2BAA2B;AACnC,QAAQ,2BAA2B;AACnC,QAAQ,4BAA4B;AACpC,QAAQ,0BAA0B;AAClC;AACA;AACA,QAAQ,wCAAwC;AAChD,QAAQ,4CAA4C;AACpD,QAAQ,0CAA0C;AAClD,QAAQ,sCAAsC;AAC9C,QAAQ,yCAAyC;AACjD;AACA;AACA,QAAQ,iCAAiC;AACzC,QAAQ,uCAAuC;AAC/C,QAAQ,mCAAmC;AAC3C,QAAQ,+BAA+B;AACvC,QAAQ,+BAA+B;AACvC,QAAQ,uCAAuC;AAC/C,QAAQ,oCAAoC;AAC5C,QAAQ,qCAAqC;AAC7C,QAAQ,mCAAmC;AAC3C,QAAQ,qCAAqC;AAC7C,QAAQ,iCAAiC;AACzC,QAAQ,+BAA+B;AACvC,QAAQ,6BAA6B;AACrC,QAAQ,mCAAmC;AAC3C,QAAQ,iCAAiC;AACzC,QAAQ,+BAA+B;AACvC,QAAQ,qCAAqC;AAC7C,QAAQ,+BAA+B;AACvC,QAAQ,qCAAqC;AAC7C,QAAQ,2BAA2B;AACnC,QAAQ,yCAAyC;AACjD,QAAQ,iCAAiC;AACzC,QAAQ,iCAAiC;AACzC,QAAQ,sCAAsC;AAC9C,QAAQ,sCAAsC;AAC9C,QAAQ,2CAA2C;AACnD;AACA;AACA,QAAQ,qCAAqC;AAC7C,QAAQ,qCAAqC;AAC7C,QAAQ,uCAAuC;AAC/C,QAAQ,qCAAqC;AAC7C,QAAQ,uCAAuC;AAC/C,QAAQ,yCAAyC;AACjD,QAAQ,iCAAiC;AACzC;AACA;AACA,QAAQ,+EAA+E;AACvF,QAAQ,yEAAyE;AACjF,QAAQ,yEAAyE;AACjF,QAAQ,2EAA2E;AACnF,QAAQ,uEAAuE;AAC/E,QAAQ,qEAAqE;AAC7E,QAAQ,iEAAiE;AACzE,QAAQ,uEAAuE;AAC/E,QAAQ,iEAAiE;AACzE,QAAQ,0EAA0E;AAClF,QAAQ,kEAAkE;AAC1E,QAAQ,wEAAwE;AAChF,QAAQ,qJAAqJ;AAC7J,QAAQ,yKAAyK;AACjL,QAAQ,2KAA2K;AACnL,WAAW,+JAA+J;AAC1K,QAAQ,8EAA8E;AACtF,QAAQ,wEAAwE;AAChF,QAAQ,wEAAwE;AAChF,QAAQ,0EAA0E;AAClF,QAAQ,sEAAsE;AAC9E,QAAQ,oEAAoE;AAC5E,QAAQ,gEAAgE;AACxE,QAAQ,sEAAsE;AAC9E,QAAQ,gEAAgE;AACxE,QAAQ,wEAAwE;AAChF,QAAQ,gEAAgE;AACxE,QAAQ,sEAAsE;AAC9E,QAAQ,mJAAmJ;AAC3J,QAAQ,uKAAuK;AAC/K,QAAQ,yKAAyK;AACjL,WAAW,6JAA6J;AACxK,QAAQ,mFAAmF;AAC3F,QAAQ,6EAA6E;AACrF,QAAQ,6EAA6E;AACrF,QAAQ,+EAA+E;AACvF,QAAQ,2EAA2E;AACnF,QAAQ,yEAAyE;AACjF,QAAQ,qEAAqE;AAC7E,QAAQ,2EAA2E;AACnF,QAAQ,qEAAqE;AAC7E,QAAQ,6EAA6E;AACrF,QAAQ,qEAAqE;AAC7E,QAAQ,2EAA2E;;AAEnF,QAAQ,oEAAoE;AAC5E,QAAQ,kEAAkE;AAC1E,QAAQ,uEAAuE;AAC/E,QAAQ,6DAA6D;AACrE,QAAQ,oEAAoE;AAC5E,QAAQ,mFAAmF;;AAE3F,QAAQ,qEAAqE;AAC7E,QAAQ,qEAAqE;AAC7E,QAAQ,uEAAuE;AAC/E,QAAQ,2EAA2E;AACnF,QAAQ,2EAA2E;AACnF,QAAQ,uEAAuE;AAC/E,QAAQ,iFAAiF;AACzF,QAAQ,yEAAyE;AACjF,QAAQ,yEAAyE;AACjF,QAAQ,0EAA0E;AAClF,QAAQ,wEAAwE;AAChF,QAAQ,kEAAkE;AAC1E,QAAQ,4EAA4E;AACpF,QAAQ,sEAAsE;AAC9E,QAAQ,8EAA8E;AACtF;AACA,QAAQ,iGAAiG;AACzG;AACA;AACA;AACA,QAAQ,gEAAgE;AACxE,QAAQ,4DAA4D;AACpE,QAAQ,kDAAkD;AAC1D,QAAQ,uDAAuD;AAC/D,QAAQ,wDAAwD;AAChE,QAAQ,sDAAsD;AAC9D,QAAQ,6DAA6D;AACrE,QAAQ,6DAA6D;AACrE,QAAQ,4DAA4D;AACpE,QAAQ,0DAA0D;AAClE,QAAQ,2DAA2D;AACnE,QAAQ,uDAAuD;AAC/D,QAAQ,sDAAsD;AAC9D,QAAQ,8DAA8D;;AAEtE;AACA,QAAQ,qFAAqF;AAC7F,QAAQ,6EAA6E;AACrF,QAAQ,4EAA4E;AACpF,QAAQ,gFAAgF;AACxF,QAAQ,0EAA0E;AAClF,QAAQ,+EAA+E;AACvF,QAAQ,6EAA6E;AACrF,QAAQ,6EAA6E;AACrF,QAAQ,kFAAkF;AAC1F,QAAQ,0EAA0E;AAClF,QAAQ,kFAAkF;AAC1F,QAAQ,4EAA4E;AACpF,QAAQ,2EAA2E;AACnF,QAAQ,qFAAqF;AAC7F,QAAQ,0EAA0E;AAClF,QAAQ,8EAA8E;AACtF,QAAQ,2EAA2E;AACnF,QAAQ,gFAAgF;AACxF,QAAQ,4EAA4E;AACpF,QAAQ,+EAA+E;AACvF,QAAQ,iFAAiF;AACzF,QAAQ,8EAA8E;AACtF,QAAQ,4EAA4E;AACpF,QAAQ,2EAA2E;AACnF,QAAQ,kFAAkF;AAC1F,QAAQ,2EAA2E;AACnF,QAAQ,6EAA6E;AACrF,QAAQ,+EAA+E;AACvF,QAAQ,iFAAiF;AACzF,QAAQ,8EAA8E;AACtF,QAAQ,+EAA+E;AACvF,QAAQ,gFAAgF;AACxF,QAAQ,2EAA2E;AACnF,QAAQ,8EAA8E;AACtF,QAAQ,sFAAsF;AAC9F,QAAQ,8EAA8E;AACtF,QAAQ,0EAA0E;AAClF,QAAQ,+EAA+E;AACvF,QAAQ,2EAA2E;AACnF,QAAQ,6EAA6E;AACrF,QAAQ,6EAA6E;AACrF,QAAQ,wFAAwF;AAChG,QAAQ,+EAA+E;AACvF,QAAQ,qFAAqF;AAC7F,QAAQ,uFAAuF;AAC/F,QAAQ,8EAA8E;AACtF,QAAQ,mFAAmF;AAC3F,QAAQ,uFAAuF;AAC/F,QAAQ,kFAAkF;AAC1F,QAAQ,6FAA6F;AACrG,QAAQ,sGAAsG;AAC9G,QAAQ,gFAAgF;;AAExF;AACA,QAAQ,4GAA4G;AACpH,QAAQ,kHAAkH;AAC1H,QAAQ,wGAAwG;AAChH,QAAQ,qGAAqG;AAC7G,QAAQ,gHAAgH;AACxH,QAAQ,wGAAwG;AAChH,QAAQ,oHAAoH;AAC5H,QAAQ,oGAAoG;AAC5G,QAAQ,uGAAuG;AAC/G,QAAQ,sGAAsG;AAC9G,QAAQ,oGAAoG;AAC5G,QAAQ,qGAAqG;AAC7G,QAAQ,sGAAsG;AAC9G,QAAQ,sGAAsG;AAC9G,QAAQ,8GAA8G;AACtH,QAAQ,yFAAyF;AACjG,QAAQ,iGAAiG;AACzG,QAAQ,iGAAiG;AACzG,QAAQ,kGAAkG;AAC1G,QAAQ,sFAAsF;AAC9F,QAAQ,sFAAsF;AAC9F,QAAQ,uFAAuF;AAC/F,QAAQ,wFAAwF;AAChG,QAAQ,qGAAqG;AAC7G,QAAQ,8FAA8F;AACtG,QAAQ,6FAA6F;AACrG,QAAQ,qGAAqG;AAC7G,QAAQ,+FAA+F;AACvG,QAAQ,0FAA0F;AAClG,QAAQ,8FAA8F;AACtG,QAAQ,6FAA6F;AACrG,QAAQ,6FAA6F;AACrG,QAAQ,6FAA6F;AACrG,QAAQ,6FAA6F;AACrG,QAAQ,8FAA8F;AACtG,QAAQ,0FAA0F;AAClG,QAAQ,6FAA6F;AACrG,QAAQ,2FAA2F;AACnG,QAAQ,4FAA4F;AACpG,QAAQ,2FAA2F;AACnG,QAAQ,6FAA6F;AACrG,QAAQ,4FAA4F;AACpG,QAAQ,4FAA4F;AACpG,QAAQ,4FAA4F;AACpG,QAAQ,wGAAwG;AAChH,QAAQ,kGAAkG;AAC1G,QAAQ,8GAA8G;AACtH,QAAQ,6FAA6F;AACrG,QAAQ,8FAA8F;AACtG,QAAQ,4FAA4F;AACpG,QAAQ,gGAAgG;AACxG;AACA;AACA,QAAQ,gCAAgC;AACxC,QAAQ,gCAAgC;AACxC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,QAAQ,0BAA0B;AAClC,aAAa,0BAA0B;AACvC,QAAQ,4BAA4B;AACpC,QAAQ,6BAA6B;AACrC;AACA,GAAG;AACH;AACA,MAAM,4HAA4H;AAClI,MAAM,8HAA8H;AACpI,MAAM,0HAA0H;AAChI,MAAM,wHAAwH;AAC9H,MAAM,8HAA8H;AACpI,MAAM,4HAA4H;AAClI,MAAM,0HAA0H;AAChI,MAAM,8HAA8H;AACpI,MAAM,2IAA2I;AACjJ;AACA;AACA,MAAM,2IAA2I;AACjJ,MAAM,mHAAmH;AACzH,MAAM,2HAA2H;AACjI,MAAM,iIAAiI;AACvI,MAAM,uHAAuH;AAC7H,MAAM,mIAAmI;AACzI,MAAM,qIAAqI;AAC3I,MAAM,+HAA+H;AACrI,MAAM,uHAAuH;AAC7H,MAAM,qHAAqH;AAC3H,MAAM,uHAAuH;AAC7H,MAAM,6HAA6H;AACnI;AACA,MAAM,yHAAyH;AAC/H;AACA;AACA;AACA,QAAQ,4CAA4C;AACpD,QAAQ,8CAA8C;AACtD,QAAQ,4CAA4C;AACpD,QAAQ,wCAAwC;AAChD,QAAQ,uCAAuC;AAC/C,QAAQ,gDAAgD;AACxD,QAAQ,iDAAiD;AACzD,QAAQ,+CAA+C;AACvD,QAAQ,6CAA6C;AACrD;AACA,GAAG;AACH;AACA;AACA,QAAQ,2BAA2B;AACnC,QAAQ,2BAA2B;AACnC,QAAQ,8BAA8B;AACtC;AACA;AACA,QAAQ,gCAAgC;AACxC,QAAQ,iCAAiC;AACzC,QAAQ,iCAAiC;AACzC,QAAQ,gCAAgC;AACxC;AACA;AACA,QAAQ,kCAAkC;AAC1C,QAAQ,6CAA6C;AACrD,QAAQ,+BAA+B;AACvC,QAAQ,6BAA6B;AACrC,QAAQ,6BAA6B;AACrC,QAAQ,+BAA+B;AACvC,QAAQ,6BAA6B;AACrC,QAAQ,6BAA6B;AACrC,QAAQ,8BAA8B;AACtC,QAAQ,+BAA+B;AACvC,QAAQ,8BAA8B;AACtC,QAAQ,kCAAkC;AAC1C,QAAQ,iCAAiC;AACzC,QAAQ,iCAAiC;AACzC,QAAQ,6BAA6B;AACrC,QAAQ,kCAAkC;AAC1C,QAAQ,+BAA+B;AACvC,QAAQ,gCAAgC;AACxC;AACA,GAAG;AACH;AACA;AACA,QAAQ,sBAAsB;AAC9B,QAAQ,wBAAwB;AAChC,QAAQ,wBAAwB;AAChC,QAAQ,uBAAuB;AAC/B,QAAQ,0BAA0B;AAClC,QAAQ,wBAAwB;AAChC,QAAQ,wBAAwB;AAChC,QAAQ,sBAAsB;AAC9B,QAAQ,yBAAyB;AACjC;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,QAAQ,oCAAoC;AAC5C,QAAQ,oCAAoC;AAC5C;AACA;AACA,QAAQ,4BAA4B;AACpC,QAAQ,yBAAyB;AACjC,QAAQ,yBAAyB;AACjC,QAAQ,yBAAyB;AACjC,QAAQ,qBAAqB;AAC7B,QAAQ,qBAAqB;AAC7B,QAAQ,qBAAqB;AAC7B,QAAQ,0BAA0B;AAClC,QAAQ,wBAAwB;AAChC,QAAQ,wBAAwB;AAChC,QAAQ,yBAAyB;AACjC,QAAQ,yBAAyB;AACjC,QAAQ,uBAAuB;AAC/B,QAAQ,sBAAsB;AAC9B;AACA;AACA,QAAQ,sBAAsB;AAC9B,QAAQ,kBAAkB;AAC1B,QAAQ,kBAAkB;AAC1B,QAAQ,sBAAsB;AAC9B;AACA;AACA,GAAG;AACH;AACA;AACA,QAAQ,2IAA2I;AACnJ,QAAQ,6IAA6I;AACrJ,QAAQ,2IAA2I;AACnJ,QAAQ,6IAA6I;AACrJ,QAAQ,yIAAyI;AACjJ,QAAQ,uIAAuI;AAC/I,QAAQ,2IAA2I;AACnJ,QAAQ,iJAAiJ;AACzJ;AACA;AACA,QAAQ,uCAAuC;AAC/C,QAAQ,4CAA4C;AACpD,QAAQ,6BAA6B;AACrC,QAAQ,kCAAkC;AAC1C,QAAQ,qCAAqC;AAC7C,QAAQ,gDAAgD;AACxD,QAAQ,+BAA+B;AACvC,QAAQ,8BAA8B;AACtC,QAAQ,iCAAiC;AACzC,QAAQ,+BAA+B;AACvC,QAAQ,gCAAgC;AACxC,QAAQ,+BAA+B;AACvC,QAAQ,+BAA+B;AACvC,QAAQ,iCAAiC;AACzC,QAAQ,gCAAgC;AACxC,QAAQ,+BAA+B;AACvC,QAAQ,6BAA6B;AACrC;AACA;AACA,QAAQ,sCAAsC;AAC9C,QAAQ,2CAA2C;AACnD,QAAQ,+BAA+B;AACvC,QAAQ,qCAAqC;AAC7C,QAAQ,gDAAgD;AACxD,QAAQ,mCAAmC;AAC3C,QAAQ,kCAAkC;AAC1C,QAAQ,kCAAkC;AAC1C,QAAQ,iCAAiC;AACzC,QAAQ,oCAAoC;AAC5C,QAAQ,iCAAiC;AACzC,QAAQ,gCAAgC;AACxC,QAAQ,mCAAmC;AAC3C,QAAQ,gCAAgC;AACxC,QAAQ,mCAAmC;AAC3C,QAAQ,+BAA+B;AACvC;AACA;AACA,QAAQ,qDAAqD;AAC7D,QAAQ,qDAAqD;AAC7D,QAAQ,qDAAqD;AAC7D,QAAQ,yDAAyD;AACjE,QAAQ,yDAAyD;AACjE,QAAQ,sDAAsD;AAC9D,QAAQ,oDAAoD;AAC5D,QAAQ,gDAAgD;AACxD,QAAQ,sDAAsD;AAC9D;AACA,GAAG;AACH;;AAEA,iEAAe,UAAU,EAAC;;;;;;;;;;;;;;;;;ACtjBM;AACE;AACQ;AAC8C;;AAExF;AACA,KAAK,uCAAuC;AAC5C;AACA,KAAK,+CAA+C;AACpD;AACA,KAAK,iDAAiD;;AAEtD;AACA;AACA,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACO;AACP;;AAEA;AACA,WAAW,mCAAmC;AAC9C,mBAAmB,kFAAkF;AACrG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,8GAAmC;AAC3D;AACA;AACA,UAAU;AACV;AACA;AACA,iCAAiC,cAAc;AAC/C,OAAO;AACP,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,UAAU;AACV,iDAAiD,WAAW,SAAS,SAAS,IAAI,WAAW,SAAS,SAAS;AAC/G;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;;AAEA,IAAI,oEAAY,eAAe,SAAS,aAAa,KAAK,IAAI,aAAa;AAC3E;AACA,MAAM,4EAAqB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uFAAqB;AACrC;AACA,IAAI,oEAAY,eAAe,MAAM,YAAY,KAAK;AACtD,oBAAoB,qFAAoB;AACxC;AACA,2BAA2B,6GAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA,qBAAqB,wEAAiB;AACtC,QAAQ;AACR,qBAAqB,wEAAiB;AACtC;AACA,MAAM;AACN,mBAAmB,wEAAiB;AACpC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,6GAAgC;AACvD;;AAEA;AACA,4BAA4B,iBAAiB;AAC7C,EAAE,oEAAY,wCAAwC,kBAAkB,aAAa,aAAa;;AAElG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACO;AACP;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACO;AACP;AACA;;AAEA;AACA,4BAA4B,iBAAiB;AAC7C,EAAE,oEAAY,wCAAwC,iBAAiB;;AAEvE,eAAe,qEAAc,qBAAqB,iBAAiB;;AAEnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnTsB;;AAEtB;AACA;AACA,WAAW,GAAG;AACd;AACO;AACP;AACA;AACA;AACA;AACA,mBAAmB,cAAc,cAAc,eAAe;AAC9D,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc,cAAc,eAAe;AAC9D,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA,mBAAmB,cAAc,cAAc,eAAe;AAC9D,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc,cAAc,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA,QAAQ,oBAAoB;AAC5B,QAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,WAAW,GAAG;AACd;AACO;;AAEP;AACA;;;;;ACfgC;AACE;AACQ;AAMI;AACsB;AACF;AACP;AACC;AACK;AACD;;AAEhE;AACA;AACA;AACA;AACA,IAAI,yCAAyC;AAC7C,IAAI,0CAA0C;AAC9C,IAAI,wCAAwC;AAC5C,IAAI,6CAA6C;;AAEjD,IAAI,wCAAwC;AAC5C,IAAI,yCAAyC;AAC7C,IAAI,4CAA4C;AAChD,IAAI,sCAAsC;AAC1C,IAAI,4CAA4C;AAChD,IAAI,wCAAwC;;AAE5C;AACA,IAAI,sCAAsC;AAC1C,IAAI,2CAA2C;AAC/C,IAAI,kCAAkC;AACtC,IAAI,qCAAqC;AACzC,IAAI,qCAAqC;AACzC,IAAI,mCAAmC;AACvC,IAAI,mCAAmC;AACvC,IAAI,wCAAwC;AAC5C,IAAI,yCAAyC;AAC7C,IAAI,oCAAoC;AACxC,IAAI,kCAAkC;AACtC,IAAI,sCAAsC;AAC1C,IAAI,uCAAuC;AAC3C,IAAI,sCAAsC;AAC1C,IAAI,oCAAoC;AACxC,IAAI,2CAA2C;AAC/C,IAAI,mCAAmC;AACvC,IAAI,oCAAoC;AACxC;AACA,OAAO,0CAA0C;;AAEjD;AACA,IAAI,0CAA0C;;AAE9C,IAAI,mDAAmD;AACvD,IAAI,oDAAoD;AACxD,IAAI,uDAAuD;AAC3D,IAAI,iDAAiD;AACrD,IAAI,uDAAuD;AAC3D,IAAI,mDAAmD;;AAEvD,IAAI,kDAAkD;AACtD,IAAI,mDAAmD;AACvD,IAAI,sDAAsD;AAC1D,IAAI,gDAAgD;AACpD,IAAI,sDAAsD;AAC1D,IAAI,kDAAkD;;AAEtD;AACA,IAAI,0CAA0C;AAC9C,IAAI,yCAAyC;AAC7C,IAAI,0CAA0C;AAC9C,IAAI,gDAAgD;AACpD,IAAI,iDAAiD;AACrD,IAAI,+BAA+B;AACnC;;AAEA;AACA,IAAI,yCAAyC;AAC7C,IAAI,yCAAyC;AAC7C,IAAI,iDAAiD;AACrD,IAAI,iDAAiD;AACrD,IAAI,gDAAgD;AACpD;;AAEA;AACA,IAAI,gDAAgD;AACpD,IAAI,sCAAsC;AAC1C;;AAEA;AACA;AACA,IAAI,yCAAyC;AAC7C,IAAI,sCAAsC;AAC1C,IAAI,yCAAyC;AAC7C,IAAI,sCAAsC;AAC1C,IAAI,0CAA0C;AAC9C,IAAI,uCAAuC;AAC3C,IAAI,wCAAwC;AAC5C,IAAI,qCAAqC;AACzC;;AAEA;AACA;AACA,IAAI,8CAA8C;AAClD,IAAI,+CAA+C;AACnD,IAAI,+CAA+C;AACnD,IAAI,6CAA6C;AACjD;;AAEA;AACA,IAAI,iCAAiC;AACrC,IAAI,yCAAyC;AAC7C,IAAI,0CAA0C;AAC9C,IAAI,0CAA0C;AAC9C,IAAI,wCAAwC;AAC5C;;AAEA;;AAEA;AACA,IAAI,8CAA8C;AAClD;;AAEA;;AAEA;AACA,IAAI,0CAA0C;AAC9C,IAAI,2CAA2C;AAC/C,IAAI,8CAA8C;AAClD,IAAI,wCAAwC;AAC5C,IAAI,8CAA8C;AAClD,IAAI,0CAA0C;AAC9C;;AAEA;AACA;AACA,IAAI,oCAAoC;AACxC;;AAEA;AACA;AACA,IAAI,iCAAiC;AACrC;;AAEA;AACA;AACA,IAAI,mCAAmC;AACvC,IAAI,iCAAiC;AACrC,IAAI,sCAAsC;AAC1C;;AAEA;AACA,IAAI,iDAAiD;AACrD,IAAI,uCAAuC;AAC3C,IAAI,+CAA+C;AACnD,IAAI,kDAAkD;AACtD;;AAEA;AACA,IAAI,+CAA+C;AACnD,IAAI,mDAAmD;AACvD,IAAI,6CAA6C;AACjD;;AAEO;AACP;;AAEA;AACA;AACA,4FAA4F,KAAK;AACjG,4FAA4F,KAAK;AACjG,yFAAyF,KAAK;AAC9F,iGAAiG,KAAK;AACtG,6FAA6F,KAAK;;AAElG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd;;AAEO;AACP;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,GAAG;AACnC;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,aAAa,kDAAoB;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP,4BAA4B,MAAM;AAClC;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,iCAAY,iDAAiD,YAAY,KAAK,MAAM;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,2EAAmC;AACvD,+CAA+C,QAAQ,wBAAwB,QAAQ;AACvF;;AAEA,uDAAuD,yBAAyB;;AAEhF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,uBAAuB,oDAAqB;;AAE5C;AACA,IAAI,iCAAY,eAAe,iBAAiB,EAAE,cAAc,MAAM,KAAK;AAC3E;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM,iCAAY,yBAAyB,iBAAiB,EAAE,cAAc,MAAM,KAAK;AACvF,MAAM;AACN,MAAM,iCAAY,8BAA8B,iBAAiB,EAAE,cAAc,MAAM,KAAK;AAC5F;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,QAAQ;AACjD,IAAI,iCAAY,gBAAgB,MAAM,YAAY,KAAK;AACvD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,oDAAqB;;AAEhD;AACA,IAAI,iCAAY,eAAe,MAAM,YAAY,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wCAAwC,QAAQ;AAChD,IAAI,iCAAY,gBAAgB,MAAM,YAAY,KAAK;AACvD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAqB;AACrC;AACA,IAAI,iCAAY,eAAe,MAAM,YAAY,KAAK;AACtD,yCAAyC,MAAM,EAAE,qBAAqB;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,iCAAY,eAAe,MAAM,YAAY,KAAK;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,6DAAyB;;AAE7C;AACA,IAAI,iCAAY,wBAAwB,MAAM,MAAM,KAAK;AACzD;AACA,GAAG;AACH;AACA,IAAI,iCAAY,wBAAwB,kBAAkB,MAAM,KAAK;AACrE;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAqB;AAC1C;AACA;AACA;AACA,eAAe,oDAAqB,8CAA8C,YAAY;AAC9F,QAAQ;AACR,eAAe,oDAAqB,oCAAoC,YAAY;AACpF;AACA,KAAK;AACL;AACA,IAAI,iCAAY,gCAAgC,KAAK;AACrD,yCAAyC,uBAAuB;AAChE;AACA;AACA,sBAAsB,oDAAqB;AAC3C;AACA;AACA;AACA,eAAe,oDAAqB,8CAA8C,YAAY;AAC9F,QAAQ;AACR,eAAe,oDAAqB,oCAAoC,YAAY;AACpF;AACA,KAAK;AACL;AACA,IAAI,iCAAY,iCAAiC,KAAK;AACtD,yCAAyC,wBAAwB;AACjE;AACA,gBAAgB,oDAAqB;AACrC;AACA;AACA;AACA,eAAe,oDAAqB,8CAA8C,YAAY;AAC9F,QAAQ;AACR,eAAe,oDAAqB,oCAAoC,YAAY;AACpF;AACA,KAAK;AACL;AACA,IAAI,iCAAY,8BAA8B,KAAK;AACnD,yCAAyC,kBAAkB;AAC3D,yCAAyC,kBAAkB;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,mFACX;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDACK;AACpB;AACA;AACA,oBAAoB,+EAAqC;AACzD;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,4BAA4B,oDAAqB;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,iCAAY,eAAe,SAAS,iBAAiB,KAAK;AAChE,sBAAsB,2EAAmC;AACzD;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,cAAc,WAAW,aAAa,IAAI,KAAK,IAAI,KAAK,eAAe,cAAc,WAAW,YAAY;AACpJ,4EAA4E,cAAc;AAC1F,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,iCAAY,eAAe,SAAS,eAAe,KAAK;AAC9D,sBAAsB,2EAAmC;AACzD,2EAA2E,QAAQ;AACnF,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,oDAAqB;;AAEvC;AACA;AACA,IAAI,iCAAY,eAAe,SAAS,6BAA6B,KAAK;AAC1E,oBAAoB,2EAAmC;AACvD,gFAAgF,KAAK,GAAG,QAAQ;AAChG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,2EAAmC;AACvD,4DAA4D,KAAK;AACjE,+EAA+E,KAAK;AACpF,gFAAgF,KAAK;AACrF,gEAAgE,KAAK,mCAAmC,cAAc;AACtH,iEAAiE,KAAK,oCAAoC,cAAc;AACxH;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,iCAAY,eAAe,OAAO,WAAW,KAAK;AACxD,uFAAuF,MAAM;AAC7F;AACA;AACA;AACA;AACA;AACA,MAAM,iCAAY,eAAe,OAAO,YAAY,KAAK;AACzD,oFAAoF,MAAM;AAC1F;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,oDAAqB;AACrC;AACA,IAAI,iCAAY,qCAAqC,KAAK;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,iCAAY,eAAe,SAAS,gBAAgB,KAAK;AAC/D;AACA,wBAAwB,qEAAgC;AACxD;AACA;AACA,+EAA+E,UAAU;AACzF,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,iCAAY,eAAe,SAAS,kBAAkB,KAAK;AAC/D;AACA;AACA,kBAAkB,qEAAgC;AAClD;AACA;AACA;AACA,6CAA6C,WAAW,kCAAkC,UAAU;AACpG,MAAM;AACN,gFAAgF,UAAU;AAC1F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,mFAAmF;;AAEnF;AACA;;AAEA;AACA;AACA,EAAE,2EAAmC;AACrC,iBAAiB,qCAAmB;AACpC;AACA,iEAAiE,WAAW;AAC5E;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf,KAAK;;AAEL;AACA,mBAAmB,wDAAoB;AACvC,qBAAqB,0DAAsB;AAC3C,oBAAoB,yDAAqB;;AAEzC;AACA,IAAI,iCAAY,sCAAsC,KAAK;AAC3D;AACA,GAAG;AACH;AACA,IAAI,iCAAY,wCAAwC,KAAK;AAC7D;AACA,GAAG;AACH;AACA,IAAI,iCAAY,uCAAuC,KAAK;AAC5D;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA;;AAEA;AACA,qBAAqB,oDAAqB;AAC1C;AACA,IAAI,iCAAY,wCAAwC,KAAK;AAC7D,sCAAsC,YAAY;AAClD;;AAEA,2BAA2B,oDAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yCAAyC,QAAQ;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,kDAAoB;AAC3C,IAAI,iCAAY,eAAe,eAAe,kBAAkB,KAAK;AACrE;AACA,+DAA+D,WAAW;AAC1E,MAAM;AACN,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAqB;;AAEzC;AACA;AACA,IAAI,iCAAY,eAAe,eAAe,QAAQ,YAAY,MAAM,KAAK;AAC7E,8DAA8D,WAAW,SAAS,WAAW;AAC7F;AACA;AACA;;AAEA;AACA;AACA,EAAE,2EAAmC;AACrC;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAqB;AACzC;AACA,IAAI,iCAAY,uCAAuC,KAAK;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAqB;AAC5C;AACA,IAAI,iCAAY,gCAAgC,KAAK;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAqB;AACzC;AACA,IAAI,iCAAY,sDAAsD,KAAK;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,2EAAmC;AACvC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA;;AAEA;AACA;AACA,SAAS,kBAAkB;;AAE3B;;AAEA;AACA,EAAE,iCAAY,2BAA2B,iBAAiB;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEO;AACP;;AAEA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA,4BAA4B,oDAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA,oBAAoB,+CAAqB;AACzC;AACA;AACA;AACA;AACA,oBAAoB,gDAAuB;AAC3C;AACA;AACA;AACA;;AAEA;AACA,IAAI,iCAAY,IAAI,MAAM,SAAS,iBAAiB;AACpD;;AAEA;;;;;;;;;;;;;;;;ACl2CgC;AACE;;AAE3B;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP,EAAE,oEAAY,sBAAsB,MAAM,EAAE,SAAS;AACrD,2BAA2B,6EAAgB,uCAAuC,KAAK;;AAEvF;AACA;AACA,sBAAsB,6EAAgB,uCAAuC,KAAK;AAClF,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,iBAAiB;AACjB,cAAc;AACd;AACA,KAAK;AACL;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxDoD;AACkC;;AAE/E;AACP,eAAe,cAAc;AAC7B;AACA,MAAM,2FAA2F;AACjG,MAAM;AACN;;AAEA;AACA,0BAA0B;AAC1B,6BAA6B;AAC7B;AACA,8BAA8B,gCAAa;AAC3C,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;;AAEzC;AACA;AACA;;;ACpB4C;;AAErC;AACP,eAAe,kCAAc;AAC7B;AACA,MAAM,iHAAiH;AACvH;AACA;AACA;AACA;;;;ACToD;;AAE7C;AACP,eAAe,cAAc,cAAc,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxD8C;AACd;AACE;AACkB;AACO;AACJ;AACV;;AAEtC;AACP;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;AAEO;AACP;AACA,2BAA2B,0EAAgC;AAC3D,kCAAkC,0EAAgC;AAClE,oBAAoB,0EAAgC;AACpD,6BAA6B,0EAAgC;AAC7D,kBAAkB,0EAAgC;AAClD,uBAAuB,0EAAgC;AACvD,qCAAqC,0EAAgC;;AAErE,+BAA+B,0EAAgC;AAC/D,uBAAuB,0EAAgC;AACvD,8BAA8B,0EAAgC;AAC9D,8BAA8B,0EAAgC;AAC9D,kCAAkC,0EAAgC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;;AAEA;AACA;AACA;AACA,IAAI,+BAAW;AACf;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wCAAqB;AACtC;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd;AACO;AACP,2BAA2B,0EAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,mBAAmB,kCAAc,cAAc,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kCAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yBAAyB,kCAAc;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;AClPsD;;AAE/C;AACP,iBAAiB,eAAe,cAAc,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACvCsF;AAChC;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACnBsD;;AAE/C;AACP,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,6BAA6B,eAAe;AAC5C;AACA,MAAM,+FAA+F;AACrG,MAAM,uFAAuF;AAC7F,MAAM,mFAAmF;AACzF,MAAM;AACN;AACA;;AAEA;AACA;;;ACtBkF;;AAE3E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;;;ACRsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;;AAEzC,2BAA2B;AAC3B;AACA,0BAA0B;AAC1B;;AAEA;;AAEA;AACA;;;ACnBsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA,MAAM,qGAAqG;AAC3G,MAAM;AACN;AACA;;AAEA;AACA;;;ACXsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACbsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;ACbsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM;AACN;AACA;;AAEA;AACA;;;AChBkF;;AAE3E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;;;ACRsG;;AAE/F;AACP,eAAe,eAAe;AAC9B;AACA,MAAM,sGAAsG;AAC5G,MAAM;AACN;AACA;;AAEA,MAAM,kBAAkB;AACxB,wBAAwB,0BAA0B;AAClD;;AAEA;AACA;;;ACfsG;;AAE/F;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,kBAAkB;AACxB,wBAAwB,0BAA0B;AAClD;;AAEA;;AAEA;AACA;;;ACpBsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACnBsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;AACA;;AAEA;AACA;;;ACdkF;;AAE3E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;;;ACRiE;;AAE1D;AACP,8BAA8B,gCAAa;AAC3C,0CAA0C,qCAAkB;AAC5D;;AAEA;AACA;;;ACRsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACnBsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;;AAEA;AACA;;;ACPsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AChBsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACpBkF;AACI;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,sBAAsB,0BAA0B;AAChD;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;;;ACfkD;AACwB;AACY;;AAE/E;AACP,eAAe,eAAe;;AAE9B,MAAM,kBAAkB;AACxB,wBAAwB,qCAAiB;AACzC,wBAAwB,qCAAiB;AACzC;;AAEA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC,2BAA2B;AAC3B;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;;;ACvBsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;AACA;AACA,0BAA0B;;AAE1B;AACA;;;ACf6F;AACP;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,MAAM,kBAAkB;AACxB,wBAAwB,iBAAiB;AACzC,IAAI;AACJ;AACA,gCAAgC,gCAAa;AAC7C;AACA,iCAAiC,qCAAkB;AACnD,wBAAwB,sCAAmB;AAC3C;;AAEA;;AAEA;AACA;;;ACzBsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA,MAAM,6GAA6G;AACnH,MAAM;AACN;AACA;;AAEA;AACA;;;ACXsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACbkF;;AAE3E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;;;ACRkF;;AAE3E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;;;ACRkF;;AAE3E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;;;ACRsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACb0E;AACY;;AAE/E;AACP,OAAO,kBAAkB;;AAEzB,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACfkF;;AAE3E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;;;ACRsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD;AACA,sBAAsB,sCAAmB;AACzC;AACA;AACA;;AAEA;AACA;;;AChBsG;AAChB;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;;AAEzC,MAAM,kBAAkB;AACxB,wBAAwB,0BAA0B;AAClD;;AAEA;;AAEA;AACA;;;ACxBkF;;AAE3E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;;;ACRsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA,MAAM,qGAAqG;AAC3G,MAAM,qGAAqG;AAC3G,MAAM;AACN;AACA;;AAEA;AACA;;;ACZsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACbsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC,2BAA2B;AAC3B;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;;;ACjBkF;AACI;;AAE/E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD;AACA,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACfsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;ACbkF;;AAE3E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;;;ACRkF;;AAE3E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;;;ACRsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACbsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;ACtBsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACtBsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA,MAAM,mGAAmG;AACzG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM;AACN;AACA;;AAEA;AACA;;;ACjBsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,MAAM,oGAAoG;AAC1G,MAAM;AACN;AACA;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACjBsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACpBkF;AACI;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,IAAI,0BAA0B;AAC9B,IAAI,0BAA0B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,8BAA8B,gCAAa;AAC3C;;AAEA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;AC1BkF;;AAE3E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA,GAAG;AACH;;AAEA;AACA;;;ACdkF;;AAE3E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA,GAAG;AACH;;AAEA;AACA;;;ACd6F;;AAEtF;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,MAAM,kBAAkB;AACxB,wBAAwB,iBAAiB;AACzC,wBAAwB,iBAAiB;AACzC,wBAAwB,iBAAiB;AACzC,6BAA6B,8CAA8C;AAC3E,wBAAwB,iBAAiB;AACzC;;AAEA;;AAEA;AACA;;;AC9BsD;AACW;;AAEjE;AACA;AACO;AACP,eAAe,eAAe;;AAE9B;AACA,8BAA8B,gCAAa;AAC3C;;AAEA,0CAA0C,qCAAkB;AAC5D;AACA;;AAEA;;AAEA;AACA;;;ACnBkF;;AAE3E;AACP,qCAAqC,eAAe;AACpD,4CAA4C,0BAA0B;AACtE;;AAEA;AACA;;;ACRsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACbsD;AACgC;;AAE/E;AACP,eAAe,eAAe;;AAE9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;AClC6F;;AAEtF;AACP,eAAe,eAAe;;AAE9B,MAAM,kBAAkB;AACxB,wBAAwB,iBAAiB;AACzC,wBAAwB,iBAAiB;AACzC,wBAAwB,iBAAiB;AACzC,wBAAwB,iBAAiB;AACzC,6BAA6B,2CAA2C;AACxE,wBAAwB,iBAAiB;AACzC;;AAEA;;AAEA;AACA;;;ACjBsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA,MAAM,sGAAsG;AAC5G,MAAM,qGAAqG;AAC3G,MAAM,wGAAwG;AAC9G,MAAM,uGAAuG;AAC7G,MAAM;AACN;AACA;;AAEA;AACA;;;ACdsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;ACbsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACbkF;;AAE3E;AACP,eAAe,eAAe;AAC9B,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;;;ACRsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AChBsG;;AAE/F;AACP,eAAe,eAAe;;AAE9B,MAAM,kBAAkB;AACxB,wBAAwB,0BAA0B;AAClD;;AAEA;;AAEA;AACA;;;ACZsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACbsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;AACA,2BAA2B;AAC3B;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;;;ACnBsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AChBsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;ACdsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACbsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;ACbsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA,GAAG;AACH;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;ACnBsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;ACbsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;;AAEA;AACA;;;ACfsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;ACtBsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;ACtBsG;;AAE/F;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,MAAM,kBAAkB;AACxB,wBAAwB,0BAA0B;AAClD;;AAEA;;AAEA;AACA;;;ACnBsG;;AAE/F;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,MAAM,kBAAkB;AACxB,wBAAwB,0BAA0B;AAClD;;AAEA;;AAEA;AACA;;;AClBsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;;AAEzC,2BAA2B;AAC3B;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;;;AClBsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA,MAAM,mGAAmG;AACzG,MAAM,0GAA0G;AAChH,MAAM;AACN;AACA;;AAEA;AACA;;;ACZsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;ACb0E;AACY;;AAE/E;AACP;AACA,OAAO,kBAAkB;;AAEzB,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sCAAmB;;AAEzC;;AAEA,2BAA2B;AAC3B;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;;;AClDsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA,2BAA2B;AAC3B;AACA,0BAA0B;AAC1B;;AAEA;AACA;;;AClBsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;ACbkF;;AAE3E;AACP,6BAA6B,eAAe;AAC5C,oCAAoC,0BAA0B;AAC9D;;AAEA;AACA;;;ACRiE;;AAE1D;AACP,8BAA8B,gCAAa;AAC3C,0CAA0C,qCAAkB;AAC5D;;AAEA,2BAA2B;AAC3B;AACA;;;ACTsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;ACbsD;;AAE/C;AACP,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;ACbsD;AACgC;;AAE/E;AACP,eAAe,eAAe;AAC9B;AACA,MAAM,kGAAkG;AACxG,MAAM,+FAA+F;AACrG,MAAM;AACN;AACA;AACA,8BAA8B,gCAAa;AAC3C;AACA,+BAA+B,qCAAkB;AACjD,sBAAsB,sCAAmB;AACzC;;AAEA;AACA;;;AClBkF;;AAE3E;AACP,4BAA4B,eAAe;AAC3C,mCAAmC,0BAA0B;AAC7D;;AAEA;AACA;;;;;;;ACRkE;AACtB;AACY;AACc;AACV;AACd;AACY;AACJ;AACQ;AACI;AAClB;AACF;AAC0B;AACR;AACJ;AACE;AACJ;AACN;AACwB;AACpB;AACA;AACM;AACR;AACI;AACE;AACF;AACM;AACI;AACF;AACA;AACF;AACV;AACF;AACM;AACZ;AACY;AACA;AACA;AACI;AAClB;AACE;AACI;AAC0B;AACtB;AACM;AACZ;AACY;AACR;AACgB;AACR;AACF;AACJ;AACM;AACQ;AACN;AACU;AACxB;AACY;AACJ;AACI;AACM;AACV;AACI;AACJ;AACF;AACgB;AACA;AACQ;AACA;AACN;AACd;AACA;AACU;AACV;AACR;AACc;AACN;AACZ;AACc;AACQ;AACA;AACZ;AACJ;AACQ;AACF;AACQ;AACN;AAChB;;AAEZ;AACE;AAKZ;AAC8B;;AAEpD;;AAEO;AACP;AACA,2BAA2B,0EAAgC;AAC3D,kCAAkC,0EAAgC;AAClE,oBAAoB,0EAAgC;AACpD,6BAA6B,0EAAgC;AAC7D,kBAAkB,0EAAgC;AAClD,uBAAuB,0EAAgC;AACvD,qCAAqC,0EAAgC;;AAErE,+BAA+B,0EAAgC;AAC/D,uBAAuB,0EAAgC;AACvD,8BAA8B,0EAAgC;AAC9D,8BAA8B,0EAAgC;AAC9D,kCAAkC,0EAAgC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEO;AACP,SAAS,8CAA8B;AACvC;;AAEO;AACP,SAAS,8CAA8B;AACvC;;AAEO;AACP,SAAS,qCAAqB;AAC9B;;AAEA;;AAEA;AACA;AACA,WAAW,GAAG;AACd;AACA;AACO;AACP;;AAEA;AACA;AACA;AACA,IAAI,+BAAW;AACf;AACA;AACA;AACA,iBAAiB,wCAAqB;AACtC;;AAEA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACniBgC;AACE;;AAElC;;AAEA,wCAAwC,aAAa;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,oEAAY,6BAA6B,SAAS;AACpD,2BAA2B,6EAAgB;;AAE3C;AACA;AACA,sBAAsB,6EAAgB;AACtC,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,oEAAY,iCAAiC,KAAK;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,oEAAY,YAAY,KAAK;AACjC;AACA,GAAG;;AAEH;AACA;;AAEO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wDAAwD,WAAW,GAAG,UAAU;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;;;;;;;;;;;AC7JA;AACA;AACA;;AAEkC;;AAE3B;AACP,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,4EAA4E,wBAAwB;AACpG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,mBAAmB,GAAG,aAAa,IAAI,WAAW;AAC9D,YAAY,mBAAmB,IAAI,WAAW;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,kBAAkB;AACxC;AACA;AACA,+BAA+B,cAAc,GAAG,SAAS;AACzD;AACA;AACA,4EAA4E,cAAc,KAAK,2BAA2B;;AAE1H,UAAU;AACV,0EAA0E,oEAAY,iCAAiC,wBAAwB,KAAK,mBAAmB;AACvK;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;ACpKD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,aAAa,YAAY,IAAI,UAAU,IAAI,IAAI;AAC/C;AACA;AACA;AACA,yCAAyC;AACzC,UAAU;AACV,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,wCAAwC;AACxC,UAAU;AACV,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,wCAAwC;AACxC,UAAU;AACV,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,yCAAyC;AACzC,UAAU;AACV,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;ACrFU;AACE;AACQ;AACqB;AAClB;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,kEAAW,+BAA+B,WAAW;AAC3D;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kEAAW,+BAA+B,YAAY,KAAK,kBAAkB;AACnF;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAI,wGAA+B;AACnC;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAI,gHAAmC;AACvC;AACA,kEAAkE,SAAS;AAC3E;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,kEAAW,qBAAqB,UAAU;AAChD;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAI,wGAAgC;AACpC,yBAAyB,6EAAgB;AACzC,MAAM,kEAAW,qBAAqB,WAAW;AACjD;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,kEAAW,qBAAqB,WAAW;AACjD;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,kEAAW,0BAA0B,MAAM,cAAc,IAAI;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,kEAAW,+BAA+B,MAAM,cAAc,IAAI;AACtE;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,kEAAW,4BAA4B,MAAM,cAAc,IAAI;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,kEAAW,wCAAwC,WAAW;AAClE;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,IAAI,kEAAW,gCAAgC,WAAW;AAC1D;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,IAAI,kEAAW,0BAA0B,WAAW;AACpD;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,IAAI,kEAAW,8BAA8B,WAAW;AACxD;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;AACO;AACP,qCAAqC,6GAAgC;;AAErE;AACA;AACA;AACA;AACA;AACA,2BAA2B,uEAAkB;AAC7C;AACA,IAAI,oEAAY,6CAA6C,KAAK;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kGAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6EAAgB,CAAC,kGAA6B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM,EAAE,eAAe,YAAY,YAAY;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,8CAA8C,WAAW,QAAQ,SAAS;AAC1E;AACA;;AAEO;AACP,qCAAqC,6GAAgC;;AAErE;AACA;AACA,2BAA2B,uEAAkB;AAC7C,IAAI,oEAAY,aAAa,eAAe,KAAK,SAAS;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAW,WAAW,MAAM,EAAE,eAAe,YAAY,YAAY;AACjF;AACA,YAAY;AACZ,YAAY,oEAAY,2BAA2B,WAAW,QAAQ,SAAS,QAAQ,KAAK;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP,qCAAqC,6GAAgC;;AAErE;AACA,IAAI,kEAAW;AACf;AACA;AACA,KAAK;AACL;AACA;AACA,yBAAyB,uEAAkB;;AAE3C;AACA;AACA;;AAEA;;AAEA,EAAE,oEAAY;;AAEd,2BAA2B,kEAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,qBAAqB;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;;AC/pBA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;AACqB;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,8EAAwB;AAC1B;AACA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,GAAG;AACd;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,oEAAY,cAAc,sBAAsB;AAC1D;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,GAAG;AACd;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oEAAY,uBAAuB,iBAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,GAAG;AACd;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5KgC;AACE;AACQ;AACmD;AACnD;AACW;AACU;;AAE/D;AACA,IAAI,wCAAwC;AAC5C,IAAI,sCAAsC;AAC1C,IAAI,+CAA+C;AACnD,IAAI,oCAAoC;AACxC,IAAI,qCAAqC;AACzC,IAAI,+CAA+C;AACnD,IAAI,2CAA2C;AAC/C,IAAI,4CAA4C;AAChD,IAAI,8CAA8C;AAClD,IAAI,qCAAqC;AACzC,IAAI,yCAAyC;AAC7C,IAAI,mCAAmC;AACvC,IAAI,mCAAmC;AACvC,IAAI,uCAAuC;AAC3C,IAAI,qCAAqC;AACzC,IAAI,wCAAwC;AAC5C,IAAI,0CAA0C;AAC9C,IAAI,wDAAwD;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,kEAAa;AACrC;AACA,IAAI,oEAAY,2BAA2B,eAAe;AAC1D,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,oEAAY,YAAY,WAAW,MAAM,kBAAkB;AAC/D;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd;AACO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,oBAAoB,IAAI,aAAa;AAC5D;;AAEA;AACA;AACA;AACA,uBAAuB,mBAAmB,IAAI,YAAY;AAC1D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD;AACzD,wDAAwD;AACxD,qBAAqB,MAAM,wBAAwB;AACnD;;AAEA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,UAAU,0GAAiC;AAC3C,UAAU,8GAAmC;AAC7C;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,QAAQ,8GAAmC;AAC3C,QAAQ,8GAAmC;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,8DAAS,aAAa,UAAU;AACtC;AACA,wFAAwF,iBAAiB;AACzG,yFAAyF,iBAAiB;AAC1G;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,MAAM,8DAAS,aAAa,UAAU;AACtC,MAAM,oEAAY,YAAY,WAAW;AACzC;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,qCAAqC,6GAAgC;AACrE;AACA;AACA,IAAI,8DAAS,WAAW,eAAe;AACvC,IAAI,oEAAY,WAAW,eAAe;AAC1C,UAAU,sFAAqB;AAC/B;AACA;;AAEO;AACP,EAAE,oEAAY,qCAAqC,MAAM,sBAAsB,oBAAoB;AACnG,2BAA2B,sEAAiB;AAC5C,yBAAyB,eAAe;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,8DAAS,0BAA0B,wBAAwB,MAAM,MAAM;;AAE3E;AACA;AACA;;AAEA;AACA;AACA,IAAI,8DAAS;;AAEb;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,6EAAgB;;AAE9C;AACA;AACA,0BAA0B,6EAAgB;AAC1C;AACA,MAAM;AACN;AACA,0BAA0B,+EAAiB;AAC3C;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA,MAAM,oEAAY,aAAa,UAAU;AACzC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,kCAAkC,iCAAiC;AACnE;AACA;AACA,SAAS;AACT;AACA;;AAEA,KAAK;AACL;AACA,GAAG;AACH;;AAEO;AACP;AACA;AACA;AACA,QAAQ,oEAAY,uBAAuB,WAAW,KAAK,kCAAkC;AAC7F;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA,EAAE,8DAAS;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,8DAAS,gBAAgB,WAAW;AAC9C;AACA,UAAU,oEAAY,gBAAgB,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI,8DAAS;AACb;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,EAAE,8DAAS;AACX,kBAAkB,gFAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,EAAE,8DAAS;AACX;AACA;;AAEA;AACA,EAAE,8DAAS;AACX,kBAAkB,sGAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,EAAE,8DAAS;AACX;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,EAAE,8DAAS;AACX,oBAAoB,gGAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,EAAE,8DAAS;AACX;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEO;AACP,mEAAmE,8GAAmC;;AAEtG;AACA;AACA;AACA,QAAQ,8GAAmC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,oEAAY;AAClB;AACA;;AAEA;AACA,MAAM,oEAAY;AAClB,oBAAoB,0EAAgB;AACpC;;AAEA;AACA,MAAM,oEAAY;AAClB;AACA;;AAEA;AACA,MAAM,oEAAY;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,2EAAe;AAC9B,OAAO;AACP;AACA;;AAEA;;AAEA,mCAAmC,2EAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kEAAW,aAAa,MAAM,EAAE,UAAU;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB,EAAE,WAAW,MAAM,KAAK;AAC9F,YAAY;AACZ,YAAY,kEAAW,aAAa,MAAM,EAAE,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,UAAU;AAC1C,mGAAmG;;AAEnG,gCAAgC,wBAAwB;AACxD;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,KAAK;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mDAAmD,4BAA4B,GAAG,yBAAyB;AAC3G;AACA;AACA,EAAE,oEAAY,eAAe,MAAM;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,oEAAY,eAAe,MAAM;AACnC;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd;AACO;AACP;AACA,sBAAsB,uEAAkB;AACxC;AACA,2BAA2B,kEAAa;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM;AACN,iCAAiC;AACjC;AACA;AACA,GAAG;AACH,yBAAyB,MAAM;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,oEAAY,QAAQ,MAAM;;AAE5B;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd;AACO;AACP,EAAE,oEAAY;;AAEd;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA,GAAG;AACH;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEO;AACP;AACA;AACA;AACA,IAAI,oEAAY;AAChB;AACA;;AAEA;AACA;AACA,IAAI,oEAAY;AAChB,kBAAkB,0EAAgB;AAClC;;AAEA;AACA;AACA;AACA;AACA,IAAI,oEAAY;AAChB;AACA;;AAEA;AACA;AACA;AACA,IAAI,oEAAY;AAChB;AACA;;AAEA;AACA;AACA;AACA,IAAI,oEAAY;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA,IAAI,oEAAY;AAChB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI,oEAAY;AAChB;AACA;AACA;AACA,IAAI,oEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;;AAGO;AACP;AACA,oBAAoB,6GAAgC;AACpD,KAAK,6GAAgC,2BAA2B,6GAAgC;;AAEhG;AACA,WAAW,iEAAc;AACzB,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,oEAAY;;AAEd;AACA;AACA,IAAI,oEAAY;AAChB,IAAI,oEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,8CAA8C,WAAW;AACzD,UAAU;AACV,8CAA8C,UAAU,qBAAqB,WAAW;AACxF;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;;;;;;;;ACtsCgC;AACE;AACQ;AAC8G;AAC9F;AACZ;;AAE9C;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH,wBAAwB,qGAA4B;AACpD;;AAEA;AACA;;;AAGA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,sEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAsB;;AAEpC,gEAAgE,iBAAiB;AACjF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM,oEAAY,uBAAuB,cAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,uEAAiB;AAC3B,IAAI;AACJ,IAAI,oEAAY;AAChB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,kEAAY;AACnC,MAAM;AACN;AACA,uBAAuB,kEAAY;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,kEAAY;AACzC,MAAM;AACN;AACA,6BAA6B,kEAAY;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,oEAAY,wBAAwB,WAAW;AACnD;AACA;AACA;AACA;AACA,QAAQ,oEAAY;AACpB;AACA;AACA;AACA,oBAAoB,YAAY,GAAG,cAAc;AACjD,0DAA0D,cAAc,eAAe,4BAA4B;AACnH,2DAA2D,cAAc,eAAe,6BAA6B;;AAErH;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,oEAAY;AACd;AACA;AACA;AACA;;AAEA;AACA,IAAI,oEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,IAAI,oEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,IAAI,oEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR,IAAI,oEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oFAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI,oEAAY;AAChB;AACA,+BAA+B,wEAAkB;AACjD;AACA,MAAM,oEAAY,IAAI,WAAW,KAAK,wCAAwC;AAC9E,eAAe;AACf,KAAK;AACL,IAAI,oEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI,oEAAY,yBAAyB,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACO;AACP,EAAE,oEAAY;AACd;AACA,EAAE,oEAAY;AACd;AACA,EAAE,oEAAY;AACd;;AAEA;AACA,uBAAuB,6GAAgC;AACvD,KAAK,6GAAgC,2BAA2B,6GAAgC;AAChG;AACA;AACA,IAAI,8DAAS,2BAA2B,UAAU;AAClD;AACA,uBAAuB,qEAAkB;AACzC;;AAEA,EAAE,oEAAY;AACd;AACA,qBAAqB,iEAAW;AAChC;;AAEA;AACA;AACA,IAAI,oEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,iBAAiB;AACvE;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA,EAAE,oEAAY,iBAAiB,UAAU;AACzC;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,QAAQ,oEAAY,uBAAuB,OAAO,EAAE,UAAU;AAC9D,QAAQ,oEAAY;AACpB;AACA,OAAO;AACP,GAAG;AACH;;AAEO;AACP;;AAEA;AACA;AACA;AACA,iCAAiC,uEAAiB;AAClD,IAAI,8DAAS;AACb;;AAEA;AACA,MAAM,8DAAS,eAAe,aAAa;AAC3C;AACA,QAAQ,kEAAY;AACpB;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;ACnfO;AACP,IAAI,uCAAuC;AAC3C,IAAI,wCAAwC;AAC5C,IAAI,2CAA2C;AAC/C,IAAI,2CAA2C;AAC/C,IAAI,qCAAqC;AACzC,IAAI,uCAAuC;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;;AAGO;AACP;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;;;;;;;;;;;;;;ACzEqC;AACwB;AACG;;AAEhE;AACA;AACA;;AAEA;;AAEO;AACP;AACA;;AAEA;AACA;AACA,kBAAkB,uEAAkB;AACpC;AACA,gCAAgC,kEAAa;AAC7C;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,qDAAqD;;AAErD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,sBAAsB,WAAW,IAAI,WAAW;AAChD;AACA;AACA;AACA,4BAA4B,2BAA2B,UAAU,kBAAkB;AACnF;AACA,KAAK;AACL;;AAEA;AACA,+BAA+B,mFAA6B,0CAA0C,oBAAoB;AAC1H;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,oEAAY,IAAI,cAAc;AAChC;;AAEA;;;;;;;;;;;;;;;AC1GO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;;AAEG;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,6BAA6B,gBAAgB,IAAI,cAAc;AAC/D;AACA,MAAM;AACN,2BAA2B,gBAAgB,IAAI,cAAc;AAC7D;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;;;;;AC/F+B;;AAEnC;AACA,IAAI,mCAAmC;AACvC,IAAI,mCAAmC;AACvC,IAAI,qCAAqC;AACzC,IAAI,yCAAyC;AAC7C,IAAI,yCAAyC;AAC7C,IAAI,qCAAqC;AACzC,IAAI,+CAA+C;AACnD,IAAI,uCAAuC;AAC3C,IAAI,uCAAuC;AAC3C,IAAI,uCAAuC;AAC3C,IAAI,qCAAqC;AACzC,IAAI,+BAA+B;AACnC,IAAI,yCAAyC;AAC7C,IAAI,mCAAmC;AACvC,IAAI,2CAA2C;AAC/C,IAAI,qCAAqC;AACzC,IAAI,oCAAoC;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN,+BAA+B,0EAAgC;AAC/D;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;;;;;;;ACrIA;AACA,IAAI,iCAAiC;AACrC,IAAI,uCAAuC;AAC3C,IAAI,mCAAmC;AACvC,IAAI,+BAA+B;AACnC,IAAI,+BAA+B;AACnC,IAAI,uCAAuC;AAC3C,IAAI,oCAAoC;AACxC,IAAI,qCAAqC;AACzC,IAAI,mCAAmC;AACvC,IAAI,qCAAqC;AACzC,IAAI,iCAAiC;AACrC,IAAI,+BAA+B;AACnC,IAAI,6BAA6B;AACjC,IAAI,mCAAmC;AACvC,IAAI,iCAAiC;AACrC,IAAI,+BAA+B;AACnC,IAAI,qCAAqC;AACzC,IAAI,+BAA+B;AACnC,IAAI,qCAAqC;AACzC,IAAI,2BAA2B;AAC/B,IAAI,yCAAyC;AAC7C,IAAI,iCAAiC;AACrC,IAAI,iCAAiC;AACrC,IAAI,sCAAsC;AAC1C,IAAI,sCAAsC;AAC1C,IAAI,2CAA2C;AAC/C;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACG;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,6CAA6C,UAAU;AACvD;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGG;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AC5CA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACG;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA,wBAAwB,sBAAsB,MAAM,sBAAsB,GAAG,sBAAsB;AACnG;AACA,MAAM;AACN,uDAAuD,sBAAsB;AAC7E,iCAAiC,sBAAsB,KAAK,qBAAqB,EAAE,aAAa;AAChG;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;;;AAGA;;AAEqC;;AAErC;AACA,IAAI,wCAAwC;AAC5C,IAAI,uCAAuC;AAC3C,IAAI,uCAAuC;AAC3C,IAAI,qCAAqC;AACzC,IAAI,sCAAsC;AAC1C,IAAI,2CAA2C;AAC/C;;AAEO;AACP;AACA;;AAEA;AACA,IAAI,+BAAW;AACf,aAAa;AACb;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AClDO;AACP;AACA;AACA;AACA;AACA;AACA,mDAAmD,yBAAyB;AAC5E,oBAAoB,WAAW,EAAE,KAAK;AACtC;AACA;;;;ACRO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;ACTsC;;AAE/B;AACP;AACA;AACA;AACA,qBAAqB,4CAAiB;AACtC;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;;;;;ACfA;AACA;AACA,MAAM,iFAAiF,mCAAmC;AAC1H,MAAM,0EAA0E,mCAAmC;AACnH,MAAM,yEAAyE,mCAAmC;AAClH,MAAM,6EAA6E,aAAa;AAChG,MAAM,uEAAuE,aAAa;AAC1F,MAAM,4EAA4E,aAAa;AAC/F,MAAM,0EAA0E,wBAAwB;AACxG,MAAM,0EAA0E,aAAa;AAC7F,MAAM,+EAA+E,wBAAwB;AAC7G,MAAM,yEAAyE;AAC/E,MAAM,+EAA+E,aAAa;AAClG,MAAM,yEAAyE,aAAa;AAC5F,MAAM,wEAAwE,wBAAwB;AACtG,MAAM,iFAAiF,mCAAmC;AAC1H,MAAM,uEAAuE,wBAAwB;AACrG,MAAM,2EAA2E,wBAAwB;AACzG,MAAM,wEAAwE,aAAa;AAC3F,MAAM,6EAA6E,aAAa;AAChG,MAAM,2EAA2E;AACjF,MAAM,4EAA4E,wBAAwB;AAC1G,MAAM,8EAA8E,wBAAwB;AAC5G,MAAM,2EAA2E,mCAAmC;AACpH,MAAM,yEAAyE,wBAAwB;AACvG,MAAM,wEAAwE,wBAAwB;AACtG,MAAM,iFAAiF;AACvF,MAAM,wEAAwE,mCAAmC;AACjH,MAAM,0EAA0E,aAAa;AAC7F,MAAM,4EAA4E,wBAAwB;AAC1G,MAAM,8EAA8E,wBAAwB;AAC5G,MAAM,2EAA2E,wBAAwB;AACzG,MAAM,8EAA8E;AACpF,MAAM,6EAA6E,aAAa;AAChG,MAAM,wEAAwE,wBAAwB;AACtG,MAAM,2EAA2E,wBAAwB;AACzG,MAAM,kFAAkF,8CAA8C;AACtI,MAAM,2EAA2E,mCAAmC;AACpH,MAAM,uEAAuE,wBAAwB;AACrG,MAAM,4EAA4E,aAAa;AAC/F,MAAM,wEAAwE,aAAa;AAC3F,MAAM,0EAA0E,mCAAmC;AACnH,MAAM,0EAA0E,mCAAmC;AACnH,MAAM,yEAAyE;AAC/E,MAAM,yEAAyE;AAC/E,MAAM,yEAAyE;AAC/E,MAAM,yEAAyE;AAC/E,MAAM,yEAAyE;AAC/E,MAAM,yEAAyE;AAC/E,MAAM,yEAAyE;AAC/E,MAAM,8EAA8E;AACpF;AACA;AACA,MAAM,oBAAoB;AAC1B,MAAM,8BAA8B;AACpC,MAAM,0BAA0B;AAChC,MAAM,0BAA0B;AAChC,MAAM,oBAAoB;AAC1B,MAAM,6BAA6B;AACnC,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,0BAA0B;AAChC,MAAM,0BAA0B;AAChC,MAAM,oCAAoC;AAC1C,MAAM,+BAA+B;AACrC;AACA;AACA,2CAAe,UAAU,EAAC;;;;ACrES;AACa;AACX;AACF;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACO;AACP,sDAAsD,IAAI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D,WAAW;AACtE,oBAAoB,oDAAqB;AACzC;AACA;AACA;AACA;AACA,oBAAoB,gEAA2B;AAC/C;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,aAAa;AACb,8CAA8C,YAAY;AAC1D;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,oDAAqB;AACnD;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAsB;AAC3C;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAuB;AACxC;AACA;AACA;AACA,wBAAwB,IAAI,IAAI,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM,+BAAW,+BAA+B,mBAAmB,WAAW,cAAc,OAAO,YAAY;;AAE/G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM,iCAAY;AAClB,MAAM,iCAAY;AAClB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ,iCAAY;AACpB,QAAQ,+BAAW;AACnB;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,oBAAoB,4CAAc;;AAElC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;;;ACxjByC;AACM;AACA;AACD;;AAE9C,kHAAkH,6iBAA6iB,qBAAqB,6nCAA6nC,4DAA4D,4CAA4C,qOAAqO,qCAAqC;;AAEnqE;AACA,6CAA6C,cAAc,SAAS,YAAY;AAChF;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,eAAe;;AAEzC;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA,sBAAsB,OAAO;AAC7B;AACA,8BAA8B,SAAS;AACvC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA,GAAG;;AAEH;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,8CAA8C,8BAAa;;AAE3D;AACA;AACA;AACA;AACA;;;ACvHyC;AAC8E;AACxE;AACA;;AAE/C,SAAS,8BAAoB;AAC7B,6CAA6C,cAAc,WAAW,YAAY;AAClF;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA,aAAa,OAAO;AACpB,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,iBAAiB,OAAO;;AAExB;AACA;AACA,iBAAiB,gBAAgB;AACjC,iBAAiB,eAAe;AAChC,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,8BAAoB;AACjE;AACA,0CAA0C,8BAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;;AAEA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,iCAAiC,WAAW;AAC5C,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC,+BAA+B,SAAS;AACxC,+BAA+B,SAAS;AACxC;AACA;AACA,KAAK;;AAEL;AACA,qCAAqC,8BAAoB;AACzD;AACA,8CAA8C,8BAAa;;;AAG3D;;AAEA;AACA;AACA;AACA;AACA;;;ACpKyC;AACmD;AAC7C;AACA;;AAE/C,gsCAAgsC;;AAEhsC;AACA,uDAAuD,8BAA8B;AACrF;AACA,8CAA8C,cAAc,mBAAmB,YAAY;AAC3F,IAAI;AACJ,8CAA8C,cAAc,QAAQ,YAAY;AAChF,IAAI;AACJ,8CAA8C,cAAc,OAAO,aAAa;AAChF,IAAI;AACJ,8CAA8C,cAAc,OAAO,YAAY;AAC/E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,gCAAgC,SAAS;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO;AAC9B;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY,eAAe;;AAE3B;AACA;AACA,8DAA8D,gBAAgB;AAC9E;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA,GAAG;;AAEH,+BAA+B,MAAM;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8BAA8B,mCAAmC;AACjE,0BAA0B;AAC1B;AACA,iBAAiB,OAAO;AACxB,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE,4BAA4B;AAC5B;AACA,mBAAmB,OAAO;AAC1B,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,mBAAmB,OAAO;AAC1B,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,mBAAmB,OAAO;AAC1B,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU,EAAE,2BAA2B;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,8BAA8B,SAAS;AACvC,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA,gCAAgC,8BAAa;AAC7C;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;;ACnTA;AACA;;AAEyC;AACwF;AAClF;AACA;;AAE/C,SAAS,kCAAoB;AAC7B,6CAA6C,cAAc,OAAO,YAAY;AAC9E;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,eAAe;AACpC;AACA,8DAA8D,gBAAgB;AAC9E;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8BAA8B,mCAAmC;AACjE,0BAA0B;AAC1B;AACA,iBAAiB,OAAO;AACxB;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE,4BAA4B;AAC5B;AACA,mBAAmB,OAAO;AAC1B,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,iBAAiB,OAAO;AACxB,yBAAyB,SAAS;AAClC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6EAA6E;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kCAAoB;AAC7D;AACA,sCAAsC,8BAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,SAAS;AAC3C,2BAA2B,aAAa;AACxC;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA,uBAAuB,OAAO;AAC9B,2BAA2B,WAAW;AACtC,uBAAuB,WAAW;AAClC,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA,qCAAqC,kCAAoB;AACzD;AACA,8CAA8C,8BAAa;;AAE3D;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AChPgD;AACX;;;AAGrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAAc;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAA0D;AACxF,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAA0D;AACxF;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,yCAAyC;AACjD;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA,qEAAqE;;;AAG9D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yCAAyC;AACjD;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA,4EAA4E,aAAa;;AAEzF;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA,EAAE,iCAAY;;AAEd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;AChX0C;;AAE1C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;AC/CsC;;AAE/B;AACP;AACA;AACA;AACA,qBAAqB,4CAAiB;AACtC;AACA,eAAe;AACf,sBAAsB;AACtB;AACA,qBAAqB;AACrB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;;;;;ACzC0D;AACvB;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kCAAc,UAAU,UAAU;AACrD;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACO;AACP;AACA;AACA,uDAAuD,2CAA2C;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,2BAA2B,0EAAgC;AAC3D;AACA;AACA;AACA;AACA;;;;ACjDwD;AAM/B;AACqB;AACS;AACT;AACP;AACE;AACL;AACI;AACY;AACA;AACU;AACX;AACY;AACvB;AACJ;AACC;;AAEW;AACA;AACJ;;AAEP;;AAErC;AACA,+CAA+C,MAAM;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC,0CAAY,uCAAuC,2BAAU;;AAE7F;AACA;AACA,MAAM,4BAAS,oCAAoC,2BAAU;AAC7D,MAAM,gCAAa,oCAAoC,2BAAU;;AAEjE;AACA,wCAAwC,SAAS,UAAU,2BAAU;AACrE,uBAAuB,cAAc,8BAA8B,2BAAU;AAC7E;;AAEA;AACA,gCAAgC,mBAAmB,UAAU,2BAAU;AACvE,gCAAgC,oBAAoB,UAAU,2BAAU;AACxE,gCAAgC,wBAAwB,UAAU,2BAAU;AAC5E,gCAAgC,sBAAsB,UAAU,2BAAU;AAC1E,eAAe,OAAO,UAAU,2BAAU;AAC1C;AACA;AACA;AACA;;;AAGA;AACA,uCAAuC,YAAY,UAAU,2BAAU;;AAEvE;AACA,oCAAoC,YAAY;AAChD,mBAAmB,QAAQ,UAAU,2BAAU;AAC/C;;AAEA,sCAAsC,uEAAgC;;AAEtE;AACA,mBAAmB,gCAAU,UAAU,2BAAU;AACjD;AACA;AACA;;AAEA;AACA,aAAa,uEAAgC;AAC7C,mCAAmC,OAAO,UAAU,2BAAU;AAC9D,oBAAoB,2DAA0B;AAC9C;AACA;AACA,qCAAqC,SAAS,UAAU,2BAAU;AAClE;AACA;AACA;AACA,0CAA0C,eAAe,UAAU,2BAAU;AAC7E;;AAEA;AACA;;AAEA,0CAA0C,UAAU,UAAU,2BAAU;AACxE;;AAEA;AACA,kBAAkB,cAAc,UAAU,2BAAU;AACpD;AACA;AACA;;AAEA;AACA,uBAAuB,mBAAmB,UAAU,2BAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,gBAAgB,UAAU,2BAAU;AACxD;AACA;AACA;;AAEA,8CAA8C,UAAU,UAAU,2BAAU;AAC5E;AACA,mCAAmC,UAAU,UAAU,2BAAU;AACjE;AACA,oCAAoC,UAAU,UAAU,2BAAU;AAClE;;AAEA;AACA,IAAI,+BAAW,+BAA+B,aAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,SAAS,UAAU,2BAAU;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,iCAAY,IAAI,cAAc,IAAI,iBAAiB;AACvD;AACA;;AAEA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEO;;AAEP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,iCAAY,mBAAmB,aAAa;AAClD,MAAM,iCAAY;AAClB,MAAM,iCAAY;AAClB;AACA;;;AAGA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;AC5NO;AACP,IAAI,qFAAqF;AACzF,IAAI,gGAAgG;AACpG,IAAI,6EAA6E;AACjF,IAAI,mFAAmF;AACvF,IAAI,oFAAoF;AACxF,IAAI,+EAA+E;AACnF,IAAI,gFAAgF;AACpF,IAAI,0FAA0F;AAC9F,IAAI,2FAA2F;AAC/F,IAAI,kFAAkF;AACtF,IAAI,6EAA6E;AACjF,IAAI,sFAAsF;AAC1F,IAAI,wFAAwF;AAC5F,IAAI,sFAAsF;AAC1F,IAAI,kFAAkF;AACtF,IAAI,+FAA+F;AACnG,IAAI,+EAA+E;AACnF,IAAI,kFAAkF;AACtF;;AAEqC;AACM;;AAE3C;AACA,OAAO,6CAA6C;AACpD,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACG;AACP;;AAEA;AACA;AACA;AACA,oBAAoB,wEAAc;AAClC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,oEAAY,6BAA6B,aAAa;AAC5D,MAAM,oEAAY;AAClB,MAAM,oEAAY;AAClB,MAAM,oEAAY;AAClB;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,oBAAoB,wEAAc;AAClC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;;;;;;;;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA,wBAAwB,qBAAM,gBAAgB,qBAAM,IAAI,qBAAM,sBAAsB,qBAAM;;AAE1F;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA,IAAI,mBAAc;;AAElB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mBAAc;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mBAAc;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA,kDAAkD,mBAAc;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC73BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;;AAEzC;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,sCAAsC;AAClD;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,qCAAqC,sBAAsB;AAC3D,KAAK,IAAI;AACT;AACA;;AAEA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,YAAY,qBAAqB;AACjC;AACO;AACP;AACA;AACA;AACA,GAAG;;AAEH,qBAAqB,IAAI;AACzB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,YAAY,qBAAqB;AACjC;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACxGqE;AACrC;AACE;AACa;;AAE/C;AACA;AACA,uBAAuB,IAAI;AAC3B;AACA,uBAAuB,oDAAqB,eAAe,iBAAiB;AAC5E,cAAc,aAAa,OAAO,YAAY,IAAI,UAAU,IAAI,IAAI;AACpE,IAAI;AACJ,uBAAuB,oDAAqB;AAC5C,cAAc,aAAa,OAAO,YAAY,aAAa,IAAI;AAC/D,IAAI;AACJ,uBAAuB,oDAAqB;AAC5C,sBAAsB,aAAa,OAAO,WAAW,IAAI,cAAc,EAAE,cAAc,EAAE,aAAa;AACtG;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,IAAI,+BAAW,iCAAiC,WAAW;AAC3D;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,iCAAY,kCAAkC,WAAW;AAC/D,oFAAoF,oBAAoB,GAAG,WAAW,EAAE,iBAAiB,YAAY;AACrJ,KAAK;AACL;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA;AACA;AACA,mBAAmB,wCAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,MAAM,cAAc,KAAK;AACvF;AACA;;;AAGA;AACA;;AAEA;AACA,8CAA8C,SAAS;AACvD;AACA,IAAI,iCAAY,qBAAqB,SAAS;;AAE9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,+BAA+B,IAAI,MAAM,MAAM;AAC/C,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA,GAAG;;AAEH;AACA;;AAEA;;AAEO;AACP,mBAAmB,wCAAe;AAClC;AACA;AACA,wBAAwB,wCAAe;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA,wBAAwB,UAAU;AAClC,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW,IAAI,UAAU;AAClD;;AAEA,IAAI,iCAAY,kCAAkC,WAAW;AAC7D,IAAI,iCAAY,YAAY,UAAU;AACtC,IAAI,iCAAY,eAAe,oBAAoB;AACnD,IAAI,iCAAY,UAAU,gBAAgB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,0CAAgB,aAAa,qBAAqB;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;;;;;;;;;;;;;;;;;;;;;;AC1QkC;;AAE3B;;AAEA;AACP;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,uDAAuD;AAC3D,IAAI,sDAAsD;AAC1D,IAAI,qDAAqD;AACzD,IAAI,2DAA2D;AAC/D,IAAI,0DAA0D;AAC9D,IAAI,iDAAiD;AACrD,IAAI,wDAAwD;AAC5D,IAAI,sDAAsD;AAC1D,IAAI,qDAAqD;AACzD,IAAI,oDAAoD;AACxD,IAAI,uDAAuD;AAC3D,IAAI,sDAAsD;AAC1D,IAAI,sDAAsD;AAC1D,IAAI,2DAA2D;AAC/D,IAAI,0DAA0D;AAC9D,IAAI,0DAA0D;AAC9D,IAAI,4DAA4D;AAChE,IAAI,yDAAyD;AAC7D,IAAI,oDAAoD;AACxD,IAAI,qDAAqD;AACzD,IAAI,gDAAgD;AACpD,IAAI,oDAAoD;AACxD,IAAI,8CAA8C;AAClD,IAAI,8CAA8C;AAClD,IAAI,kDAAkD;AACtD,IAAI,gDAAgD;AACpD,IAAI,mDAAmD;AACvD,IAAI,sDAAsD;AAC1D,IAAI,uDAAuD;AAC3D;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA,MAAM,oEAAY,8BAA8B,MAAM;AACtD,8DAA8D,MAAM;AACpE,uDAAuD,MAAM;AAC7D;AACA;AACA;AACA;;AAEO;AACP;AACA,EAAE,oEAAY,uBAAuB,iBAAiB,gBAAgB,KAAK;AAC3E;AACA;AACA;AACA,IAAI;AACJ,IAAI,oEAAY,8BAA8B,iBAAiB,MAAM,MAAM;AAC3E,4DAA4D,gBAAgB;AAC5E;AACA,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA;;AAEO;AACP;;AAEA;AACA,iDAAiD,WAAW;AAC5D,IAAI,oEAAY,oCAAoC,WAAW;AAC/D;AACA,IAAI;AACJ,mFAAmF,WAAW;AAC9F,IAAI,oEAAY,sEAAsE,WAAW;AACjG;AACA;AACA;AACA;;AAEO;AACP;AACA,4BAA4B;AAC5B;AACA;AACA,iBAAiB;;AAEjB;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEO;AACP;AACA,4BAA4B;AAC5B;AACA,iBAAiB;;AAEjB;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrM6C;AACV;;AAEa;;AAEhD;AACA,oBAAoB,4GAAiC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAU;AAChC;AACA;;AAEA;AACA;;AAEO;AACP,4BAA4B,+FACJ;AACxB;AACA,eAAe;AACf,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,GAAG;AACH;;AAEA;AACA;;AAEO;AACP;AACA;;AAEA;AACA,yBAAyB,0HAAyC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA,6BAA6B,0HAClB;AACX;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;;AAEO;AACP;AACA;;AAEA;AACA,2BAA2B,0HAAyC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB,EAAE,yBAAyB;AAC/D;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,8GAAmC;AACtD;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,6EAAgB,gBAAgB;AAClE;AACA;;AAEO;AACP,oBAAoB,+FAAyB;;AAE7C;AACA;;;;;;;;;;;;;;;AClN6C;AACV;AACgC;;AAEnE;AACA,sBAAsB,kHACX;AACX;;AAEA;AACA,MAAM,uFAAqB,4CAA4C,YAAY;AACnF,MAAM,+FAAyB,uCAAuC,YAAY;AAClF;AACA;;AAEO;AACP;AACA;AACA,MAAM,uGAA6B;AACnC,MAAM,iFAAkB;AACxB,MAAM,iFAAkB;AACxB,MAAM,iFAAkB;AACxB,MAAM,qGAA4B;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4IAAkD;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8GAAmC;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;;AAGO;AACP;;AAEA,qBAAqB,6GAAgC;AACrD;AACA,uBAAuB,qFAAoB;;AAE3C;AACA,EAAE,8GAAmC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,+FACL;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR,0BAA0B,sFAAuB;AACjD;AACA;AACA;;AAEA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA,kBAAkB,cAAc;AAChC;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR,0BAA0B,sFAAuB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,2FAAuB;AAClC;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;;;;AC7LgC;AACE;;AAElC;;AAEO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI,oEAAY;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,cAAc,oBAAoB;AAClC;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,6GAAgC;AAChF;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,EAAE,cAAc,EAAE;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2FAAuB;AACzD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,oCAAoC,EAAE;AACtC;AACA;;AAEA;AACA;AACA,0CAA0C,GAAG;AAC7C;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,iGAA0B;AAClC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oEAAY;AACtB;AACA,QAAQ,oEAAY,sDAAsD,oBAAoB;AAC9F,QAAQ;AACR,0BAA0B,iGAA0B;AACpD;AACA;AACA,UAAU;AACV,UAAU,oEAAY,mEAAmE,wBAAwB,oBAAoB,oBAAoB;AACzJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,EAAE;AAC1C;AACA;;AAEA;AACA;AACA,8CAA8C,GAAG;AACjD;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,oEAAY,oBAAoB,MAAM;AAC5C,MAAM,kEAAW,yDAAyD,GAAG,aAAa,uBAAuB;AACjH;AACA;;AAEA;AACA,6BAA6B,OAAO,GAAG,mBAAmB;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kCAAkC,sBAAsB;AACxD;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,kEAAW,wBAAwB,MAAM;AAC7C;AACA;AACA;AACA;AACA,MAAM;AACN,kCAAkC,IAAI;AACtC;AACA;AACA,sCAAsC,aAAa,EAAE,EAAE,IAAI;AAC3D,IAAI;AACJ,IAAI,kEAAW,kDAAkD,MAAM;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,aAAa;AAChE,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,EAAE,sBAAsB;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR,mEAAmE,EAAE,QAAQ;AAC7E,QAAQ,kEAAW,oDAAoD,EAAE,QAAQ;AACjF,QAAQ,kEAAW;AACnB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7T2D;AAClB;AACR;AACW;AACsB;;AAElE;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW,EAAE,iCAAiC,EAAE,0BAA0B;AACrF;AACA,4DAA4D,WAAW;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,+CAA+C;AAC/C;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,GAAG;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4FACL;AACf;AACA;AACA,mDAAmD,mBAAmB;AACtE;AACA,oBAAoB,WAAW,EAAE,KAAK;AACtC,SAAS;AACT;AACA,MAAM;AACN;AACA,sBAAsB,4FACL;AACjB;AACA;AACA,QAAQ;AACR,sBAAsB,4FACL;AACjB;AACA;AACA,mBAAmB,aAAa;AAChC,mBAAmB,MAAM;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA,4CAA4C,gBAAgB;;AAE5D;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,wFAAwF,yFAA0B;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,MAAM,yFAA0B;AAChC;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yFAA0B;AAClC,QAAQ,yFAA0B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,GAAG;AAChB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8GAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6FAA6F,uBAAuB,GAAG,YAAY;AACnI;AACA;AACA,aAAa;AACb;AACA;AACA,2FAA2F,uBAAuB,GAAG,YAAY;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,oEAAY,YAAY,WAAW,eAAe,8BAA8B;AACtF;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,IAAI,oEAAY,sBAAsB,WAAW,cAAc,OAAO;;AAEtE;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,oEAAY,UAAU,uBAAuB,YAAY,WAAW,cAAc,OAAO;AAC/F,MAAM;AACN,MAAM,oEAAY,wBAAwB,UAAU;AACpD;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,8CAA8C,wBAAwB,EAAE,MAAM;AAC9E;AACA;AACA,0CAA0C,kBAAkB;AAC5D,SAAS,WAAW,MAAM,OAAO,EAAE,MAAM,GAAG,IAAI,EAAE,aAAa,EAAE,WAAW;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,mBAAmB,MAAM;;AAEzB;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,IAAI,oEAAY,0BAA0B,cAAc;AACxD,gBAAgB,yFAAqB;AACrC,2BAA2B,2FAAsB,kCAAkC,oBAAoB;AACvG;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,IAAI,oEAAY,iBAAiB,UAAU,KAAK,QAAQ;AACxD,gBAAgB,yFAAqB;AACrC,2BAA2B,2FAAsB,kCAAkC,oBAAoB;;AAEvG;AACA,MAAM,oEAAY,UAAU,QAAQ;AACpC;AACA;AACA,MAAM;AACN,MAAM,oEAAY,mBAAmB,QAAQ;AAC7C;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,0DAA0D,oBAAoB;AAC9E;AACA,YAAY;AACZ,oCAAoC,oBAAoB;AACxD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA,oDAAoD,iBAAiB;AACrE,+BAA+B,uGAA4B;AAC3D;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,YAAY,oEAAY;AACxB;AACA,WAAW;AACX,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI;AACnC;AACA;AACA,MAAM;AACN,MAAM,oEAAY;AAClB,0GAA0G,IAAI;AAC9G;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM,EAAE,YAAY,EAAE,WAAW;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,QAAQ;AACR;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oEAAoE,KAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY,GAAG,iBAAiB;AACxE;AACA,UAAU;AACV;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,gBAAgB,yFAAqB;AACrC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN,MAAM,oEAAY;AAClB;AACA;AACA;AACA;;AAEA,iEAAe,KAAK,EAAC;;;;;;;;;;;;ACloCrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAM,gBAAgB,qBAAM,IAAI,qBAAM,sBAAsB,qBAAM;;AAE1F;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC,QAAa;;AAE7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;UC9mDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCzBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA;;;;;WCVA;;;;;;;;;;;ACAA,6BAAe,SAAS,eAAG;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;;ACf6C;AACR;AACF;;AAEnC;AACA;AACA;;AAEA,4BAA4B,gEAAyB;;AAErD;AACA;AACA;AACA;AACA,sCAAsC,2EAAmC;AACzE;AACA;AACA,kCAAkC,4BAA4B;AAC9D,UAAU;AACV;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mCAAW,4BAA4B,YAAY;AAC3D;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4EAA4E,YAAY;AACxF,IAAI;AACJ,sBAAsB,YAAY;AAClC;AACA;AACA,wFAAwF,YAAY;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACO;AACP,2BAA2B,8EAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,gCAAgC;AAChC,UAAU;AACV,gCAAgC;AAChC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,UAAU;AACV,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;AACA;AACA,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,UAAU;AACV;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;;AChRO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClC6C;AACV;;;AAGnC;AACA,wBAAwB,sDAAoB;AAC5C,IAAI,uEAAiC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACvF6C;;AAE7C;AACA;AACA,WAAW,GAAG;AACd;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAsB;AACtC,IAAI;AACJ;AACA,gBAAgB,iDAAsB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AC3B6C;;AAE7C;AACA;AACA;AACO;AACP,yBAAyB,+EAAqC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AClB6C;;AAE7C;AACA;AACA,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAyB;AAC/C;AACA,KAAK;AACL,qBAAqB,mDAAuB;;AAE5C;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACtHA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AC9CO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AC1BmC;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,WAAW,EAAE,mBAAmB,EAAE,YAAY;AAC9F;AACA,uBAAuB,wDAAqB;AAC5C;AACA,KAAK;;AAEL;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;;AAEA;AACA;AACA;AACA,kFAAkF,gDAAgD;AAClI;AACA;AACA;AACA;AACA,gDAAgD,WAAW,EAAE,mBAAmB,EAAE,YAAY;AAC9F,mDAAmD,oBAAoB,EAAE,UAAU;AACnF;AACA,aAAa,WAAW,QAAQ,aAAa;AAC7C,aAAa,UAAU,EAAE,aAAa;AACtC;AACA,KAAK;AACL;AACA;AACA;AACA;;;AC9D6C;;AAEtC;AACP;AACA,wBAAwB,2EAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;;ACzBqC;;AAErC;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,mCAAW;AACjB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI,mCAAW,IAAI,MAAM;AACzB,8BAA8B;AAC9B;;AAEA;AACA;;AAEO;AACP;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,cAAc,mCAAW;AACzB;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzKA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;;AC5BmC;AACU;;AAE7C;AAC8D;AACJ;AACtB;AACY;AACJ;AACJ;AACF;AACM;AACJ;AACJ;AACW;AACQ;AACgB;AACnC;;AAE7B;AACP;AACA;AACA,qBAAqB,gDAAiB;AACtC,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;AACA,iBAAiB,+DAA6B;AAC9C;;AAEA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC,yBAAyB,YAAY;AACrC,2BAA2B,uBAAuB;;AAElD;AACA;AACA;AACA,gCAAgC,8BAAa;;AAE7C;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,gDAAiB;AACvC,0BAA0B,aAAa;AACvC,wBAAwB,WAAW;AACnC,sBAAsB,SAAS;AAC/B,qBAAqB,QAAQ;AAC7B,0BAA0B,aAAa;AACvC,sBAAsB,SAAS;AAC/B,oBAAoB,OAAO;AAC3B,uBAAuB,eAAe;AACtC,oBAAoB,OAAO;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM,8EAAgC;AACtC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,+CAAqB;AACzB;AACA;;AAEA;AACA;;;AClHA;AACyC;AACI;;AAEtC;AACP;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA,iBAAiB,UAAU;AAC3B,KAAK;;AAEL,aAAa,SAAS;;AAEtB;AACA;;;ACpCkC;;AAElC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEO;AACP,sFAAsF,WAAW;AACjG;;AAEO;AACP;AACA;AACA;;AAEA,EAAE,qCAAY,kCAAkC,WAAW,cAAc,aAAa,eAAe,gBAAgB;AACrH;AACA,uDAAuD,WAAW;AAClE,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE,qCAAY,kCAAkC,WAAW,cAAc,aAAa,eAAe,gBAAgB;AACrH;AACA,8CAA8C,WAAW;AACzD,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEO;AACP;;AAEA;AACA,iDAAiD,WAAW;AAC5D;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ,qCAAY;AACpB,QAAQ,qCAAY;AACpB,QAAQ,qCAAY;AACpB;AACA,OAAO;AACP,GAAG;AACH;;;;;AC7FA;AACyE;AACT;AACC;AACjC;AACE;AACY;AAC2B;;AAEzE;AACA,uBAAuB,SAAS;AAChC,qBAAqB,+BAAa;AAClC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU,0BAAQ;AAClB;AACA;AACA,UAAU,2BAAS,aAAa,aAAa;AAC7C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ,mCAAW;AACnB;AACA,OAAO;AACP,GAAG;AACH;;AAEO;AACP;AACA;;AAEA;AACA,QAAQ,kEAA0B;;AAElC;AACA,qCAAqC,8EAAgC;AACrE;AACA,IAAI,2BAAS;AACb,UAAU,6DAA+B;AACzC,IAAI,2BAAS;AACb;;AAEA,EAAE,2BAAS;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,2BAAS;;AAEX;AACA;AACA;;AAEA,oBAAoB,SAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,IAAI,2BAAS;AACb,IAAI,qCAAY;AAChB;;AAEA;AACA,0BAA0B,sCAAW;AACrC;AACA;AACA;AACA,4BAA4B,sCAAW;;AAEvC;AACA,EAAE,2BAAS,cAAc,YAAY;;AAErC;AACA,YAAY,0CAAgB,aAAa,qBAAqB;AAC9D,GAAG;AACH;;;;;ACxHmC;AACU;;;AAGtC;AACP,yBAAyB,sDAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AAGA;AACA;AACA,WAAW;AACX;AACO,SAAS,cAAO;AACvB;AACA,oBAAoB,iDAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,aAAa;AACb;AACA;;AAEO;AACP;AACA,eAAe,cAAO;AACtB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,QAAQ;AACnB,WAAW,OAAO,8DAA8D,yBAAyB;AACzG;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEO;AACP;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,8BAA8B,uFACjB;AACb;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;;AAGA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;;AC9J6C;AACV;AACuG;;AAE1I;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA,eAAe,uEAAiC;AAChD;AACA;AACA,gBAAgB,yEAAkC;AAClD;AACA;;AAEA;AACA,cAAc,WAAW,EAAE,YAAY;AACvC,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA,EAAE,6EAAoC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,SAAS,eAAQ;AACjB,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,gBAAgB,0BAA0B;AAC1C;AACA,SAAS,gBAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,gEAAyB;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAqB,yBAAyB,mBAAmB;AAC3E;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM,wDAAqB,oBAAoB,mBAAmB,MAAM,IAAI,EAAE,QAAQ;AACtF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8DAAwB;AACzD,6BAA6B,wDAAqB;AAClD,uBAAuB,aAAa;AACpC;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,+DAA+D,UAAU;AACzE;AACA,iCAAiC,8DAAwB;AACzD,6BAA6B,wDAAqB;;AAElD,YAAY,8EAAgC;AAC5C;AACA;AACA,yBAAyB,aAAa;AACtC,UAAU;AACV;AACA;AACA,oEAAoE,QAAQ;AAC5E,WAAW;AACX,gCAAgC,aAAa;AAC7C,2CAA2C,gBAAgB;AAC3D;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS,oBAAa;AACtB;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,8EAAgC;AACnD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,6BAA6B,mBAAmB;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAiB;AACxC,yBAAyB,WAAW;AACpC,uBAAuB,mBAAmB;AAC1C,yBAAyB,WAAW;AACpC,uBAAuB,aAAa;AACpC;AACA,6BAA6B;AAC7B;;AAEA,sBAAsB,eAAQ;AAC9B,qBAAqB,cAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,oBAAa;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,gBAAS;;;AAGf;AACA;;;ACtVmC;AACyE;;AAE5G;AACA;AACA;AACA,SAAS,mBAAQ;AACjB,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,gBAAgB,0BAA0B;AAC1C;AACA,IAAI,oBAAS;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,wDAAqB,yCAAyC,mBAAmB;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe;AACf;AACA;AACA;AACA,4BAA4B,gDAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAiB;AAC5C;AACA,6BAA6B,WAAW;AACxC,2BAA2B,mBAAmB;AAC9C,6BAA6B,WAAW;AACxC,2BAA2B,aAAa;AACxC;AACA,iCAAiC;AACjC,0BAA0B,mBAAQ;AAClC;AACA;AACA,gCAAgC,eAAe;AAC/C,2BAA2B,oBAAS,OAAO,eAAe;AAC1D;;AAEA;AACA;;;AC/F6C;AACV;AAC8F;;AAEjI;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA,SAAS,oBAAa;AACtB;AACA,eAAe,uEAAiC;AAChD,gBAAgB,yEAAkC;;AAElD;AACA,cAAc,WAAW,EAAE,YAAY;AACvC,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB;AACA,SAAS,oBAAa;AACtB;AACA;AACA,EAAE,6EAAoC;AACtC;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA,SAAS,eAAQ;AACjB,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA,SAAS,iBAAU;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,gBAAgB,0BAA0B;AAC1C;AACA,SAAS,gBAAS;AAClB;AACA;AACA;AACA,gBAAgB,wDAAqB,uBAAuB,mBAAmB;AAC/E,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM,wDAAqB,wCAAwC,mBAAmB;AACtF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,uBAAuB,UAAU;AACjC;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe;AACf,4BAA4B,gDAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA,0BAA0B,oBAAa;AACvC,0BAA0B,oBAAa;AACvC,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,gDAAiB;AACvC,wBAAwB,WAAW;AACnC,sBAAsB,mBAAmB;AACzC,wBAAwB,WAAW;AACnC,sBAAsB,aAAa;AACnC;AACA,4BAA4B;AAC5B,qBAAqB,eAAQ;AAC7B,uBAAuB,iBAAU;AACjC;AACA,2BAA2B,eAAe;AAC1C,sBAAsB,gBAAS,OAAO,eAAe;;AAErD;AACA;;;ACpK6C;AACV;AACiE;;AAEpG;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA,oBAAoB,2EAAmC;AACvD,kBAAkB,2EAAmC;;AAErD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,sDAAoB,CAAC,wDAAqB;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO,8DAA8D,yBAAyB;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,gDAAiB;AACvC,wBAAwB,WAAW;AACnC,sBAAsB,mBAAmB;AACzC,wBAAwB,WAAW;AACnC,sBAAsB,aAAa;AACnC;AACA,oBAAoB,cAAO;;AAE3B;AACA;;;AClHmC;AACiE;;AAErF;AACf;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gDAAiB;AACtC,uBAAuB,WAAW;AAClC,qBAAqB,mBAAmB;AACxC,uBAAuB,WAAW;AAClC,qBAAqB,aAAa;AAClC;AACA,mBAAmB,cAAO;;AAE1B;AACA;;;ACrDmC;AAC2E;;;AAG9G,SAAS,oBAAa;AACtB;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,SAAS,gBAAS;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,uBAAuB;AACrF,QAAQ;AACR,yDAAyD,uBAAuB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,kBAAW;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA,QAAQ,yDAAyD;AACjE,QAAQ,4DAA4D;AACpE,QAAQ,uEAAuE;AAC/E,QAAQ,kEAAkE;AAC1E,QAAQ,+DAA+D;AACvE,QAAQ,wDAAwD;AAChE,QAAQ,+DAA+D;AACvE,WAAW,iDAAiD;AAC5D,QAAQ,4DAA4D;AACpE,QAAQ,4DAA4D;AACpE;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGe;AACf;AACA;AACA;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAiB;AACxC,yBAAyB,WAAW;AACpC,uBAAuB,mBAAmB;AAC1C,yBAAyB,WAAW;AACpC,uBAAuB,aAAa;AACpC;AACA,6BAA6B;AAC7B,yBAAyB,kBAAW;AACpC,2BAA2B,oBAAa;AACxC,uBAAuB,gBAAS,OAAO,oBAAa;;AAEpD;AACA;;;ACxHmC;AAC2E;;;AAG/F;AACf;AACA;AACA;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,gDAAiB;AACxC,yBAAyB,WAAW;AACpC,uBAAuB,mBAAmB;AAC1C,yBAAyB,WAAW;AACpC,uBAAuB,aAAa;AACpC;AACA,6BAA6B;AAC7B;;AAEA;AACA;;;ACpC6C;AACV;AACiE;;AAEpG;AACA,sBAAsB,+EACX;AACX;AACA,kBAAkB,gEAAyB,uCAAuC,YAAY;AAC9F;AACA;;AAEA;AACA;AACA,IAAI,wEAA6B;AACjC,IAAI,kDAAkB;AACtB,IAAI,kDAAkB;AACtB,IAAI,kDAAkB;AACtB,IAAI,sEAA4B;AAChC;AACA;AACA;AACA;;AAEA;AACA,IAAI,wEAA6B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA,sBAAsB,uFACX;AACX;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,gDAAiB;AACtC,uBAAuB,WAAW;AAClC,qBAAqB,mBAAmB;AACxC,uBAAuB,WAAW;AAClC,qBAAqB,aAAa;AAClC;AACA,mBAAmB,cAAO;;AAE1B;AACA;;;AC/EmC;AAC2E;;AAE9G;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEe;AACf;;AAEA;AACA;AACA;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,qBAAqB,iBAAiB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gDAAiB;AACtC,uBAAuB,WAAW;AAClC,qBAAqB,mBAAmB;AACxC,uBAAuB,WAAW;AAClC,qBAAqB,aAAa;AAClC;;AAEA;AACA;;;ACtFmC;AACwD;;AAE5E;AACf;AACA;AACA;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,WAAW;AACxC,2BAA2B,mBAAmB;AAC9C;AACA,6BAA6B,WAAW;AACxC;AACA,2BAA2B,aAAa;;AAExC;AACA;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAC6C;AACV;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,mEAA+B;AAC3C,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,aAAa;AACb,cAAc;AACd;AACA;AACA,wBAAwB,8EAAgC;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B,eAAe;AAC7C,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA,IAAI;AACJ,8BAA8B,aAAa;AAC3C;;AAEA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,mCAAmC,qFAAwC;AAC3E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;;;AClSA;AACA;;AAEA;AACA;AACA,oDAAoD;AACpD,gDAAgD;AAChD,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACO;AACP;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA;AACA,2BAA2B;AAC3B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA,+BAA+B;AAC/B,2BAA2B;AAC3B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;ACjKmC;AACE;;AAEsB;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB,EAAE,gCAAgC;;AAE5E;AACA;;AAEA;AACA,4BAA4B,wDAAqB;AACjD,qBAAqB,sDAAoB;;AAEzC;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,sBAAsB;AAC7E,2BAA2B,SAAS,aAAa,oBAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA,EAAE,qCAAY;AACd,EAAE,qCAAY;AACd;AACA;;AAEO;AACP;AACA;AACA,kCAAkC;AAClC;AACA,IAAI,qCAAY,0BAA0B,iBAAiB;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,2CAAe;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+FAA+F,oBAAoB,aAAa,2BAA2B;AAC3J,8FAA8F,oBAAoB,aAAa,6EAA6E;;AAE5M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gEAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AC/K6C;AAC7C;AACsC;AACQ;AACT;;AAErC;AACoC;;AAEpC;AAC4C;;AAE5C;AACsC;AACA;;AAEtC;AACkC;;AAElC;AACkC;AACQ;AACP;;AAEnC;AAC+C;AACU;AACpB;;AAEG;;AAExC;AAC2D;AACW;AACvB;;AAE/C;AACuD;;AAEvD;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA,SAAS,gEAAyB;AAClC;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mGAA+C;AACvD;AACA;AACA;AACA;AACA;AACA,QAAQ,mGAA+C;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yFAA0C;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,wEAA6B;AACpD;AACA;AACA;;AAEA,qBAAqB,wEAA6B;AAClD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mCAAmC,gEAAyB;AAC5D,wBAAwB,gEAAyB;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,0EAA8B;AACtC;AACA;AACA;AACA,QAAQ,0EAA8B;AACtC;AACA;AACA;AACA,QAAQ,0EAA8B;AACtC;AACA;AACA,QAAQ,sDAAoB;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA,MAAM,mCAAW;AACjB;AACA;AACA;;AAEA,SAAS,yBAAe;AACxB;AACA;AACA,qBAAqB,sDAAoB;AACzC,sBAAsB,sDAAoB;AAC1C;AACA,uBAAuB,sDAAoB;AAC3C,yBAAyB,sDAAoB;AAC7C;AACA;AACA,mBAAmB,sDAAoB;AACvC;AACA,qBAAqB,sDAAoB;AACzC;AACA;;AAEA;AACA;AACA,0FAA0F,YAAY;AACtG,IAAI;AACJ,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,+CAAqB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,YAAY;AACZ,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,UAAU,mCAAW;AACrB;AACA;AACA,MAAM;AACN;AACA,aAAa,eAAe;AAC5B;AACA,yBAAyB,WAAW;AACpC,2BAA2B,aAAa;AACxC;;AAEA;;AAEA;AACA,IAAI;AACJ,IAAI,mCAAW;AACf,+BAA+B,qBAAqB,IAAI,qBAAqB,GAAG,2BAA2B,IAAI,YAAY;AAC3H;AACA;AACA,IAAI,qCAAY;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,8EAAgC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6EAAoC;AACzD;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,uBAAuB,8EAAgC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,wCAAa;AAC3C;;AAEA;AACA;AACA;AACA,qCAAqC,8BAAa;;AAElD,+BAA+B;AAC/B,IAAI,yBAAe;AACnB;;AAEA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;;AAEA,6CAA6C,2CAAe;AAC5D;AACA;AACA;AACA,iBAAiB,8CAAwB;AACzC;AACA,QAAQ;AACR;AACA,eAAe,8CAAwB;AACvC;;AAEA,kCAAkC,aAAa;AAC/C;AACA;AACA;;AAEA,EAAE,QAAQ;AACV;AACA;;;ACjdA;AACyE;AACT;AACR;AACxB;AACc;AACZ;AACuC;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,uBAAuB;AACvB,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,SAAS;AAChC,qBAAqB,+BAAa;AAClC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU,0BAAQ;AAClB;AACA;AACA,UAAU,2BAAS,aAAa,aAAa;AAC7C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEO;AACP;AACA,2BAA2B,0CAAgB,iBAAiB,oBAAoB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEO;AACP;AACA;AACA;;AAEA;AACA,EAAE,mCAAW;AACb,QAAQ,kEAA0B;AAClC,EAAE,mCAAW;;AAEb;AACA,qCAAqC,8EAAgC;AACrE;AACA,IAAI,2BAAS;AACb,UAAU,6DAA+B;AACzC;;AAEA,EAAE,2BAAS;;AAEX;AACA;AACA;AACA;;AAEA,EAAE,2BAAS;;AAEX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,sCAAW;AACpC;AACA;AACA;AACA,2BAA2B,sCAAW;;AAEtC;AACA,EAAE,2BAAS,cAAc,YAAY;;AAErC;AACA,YAAY,0CAAgB,gBAAgB,uBAAuB;AACnE,GAAG;AACH;;;;;;;;;AC3LA;AAC2E;AAC1B;AACf;AAC8E;AAC3D;AACrB;AACc;AAC2B;AACxB;;AAEjD;AACA,uBAAuB,SAAS;AAChC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,WAAW;AACpB,SAAS,WAAW;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU,2BAAS,iBAAiB,aAAa;AACjD;AACA;AACA;AACA,UAAU,0BAAQ;AAClB;AACA;AACA,OAAO;AACP;AACA,QAAQ,2BAAS,cAAc,kBAAkB;AACjD,QAAQ,mCAAW,cAAc,kBAAkB;AACnD,+BAA+B,gCAAa;AAC5C;AACA,OAAO;AACP;AACA,QAAQ,2BAAS;AACjB,oBAAoB,oBAAoB,mBAAmB,gCAAgC;AAC3F;AACA;AACA;AACA;AACA,UAAU,qCAAY,oBAAoB,wBAAwB;AAClE;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEO;AACP,EAAE,gDAAsB;AACxB,EAAE,4BAAc;AAChB;AACA;AACA;;AAEA;AACA,EAAE,mCAAW;AACb,QAAQ,kEAA0B;AAClC,EAAE,mCAAW;AACb;;AAEA;AACA,IAAI,2BAAS;AACb,mCAAmC,6CAAkB;AACrD;AACA;AACA,MAAM,qCAAY;AAClB,MAAM,qCAAY,YAAY,sBAAsB;AACpD,MAAM,2BAAS,aAAa,uBAAuB;AACnD,uBAAuB,sCAAW;AAClC;AACA;AACA,MAAM,qCAAY;AAClB,MAAM,2BAAS,uBAAuB,uBAAuB;AAC7D,iBAAiB,mDAAyB;AAC1C;AACA;AACA,EAAE,2BAAS;AACX,EAAE,2BAAS;AACX,8BAA8B,sCAAW;;AAEzC;AACA;AACA;AACA;AACA,gBAAgB,kFAAkF;AAClG;AACA,uBAAuB,iEAAiE;AACxF,MAAM;AACN,MAAM;AACN;AACA;AACA;;AAEA,EAAE,2BAAS;AACX,QAAQ,yCAAe;;;AAGvB;AACA,qCAAqC,8EAAgC;AACrE;AACA,IAAI,2BAAS;AACb,UAAU,6DAA+B;AACzC,IAAI,2BAAS;AACb;;AAEA;AACA;AACA;AACA,EAAE,2BAAS,cAAc,cAAc;AACvC;AACA,IAAI,2BAAS,cAAc,cAAc,GAAG,eAAe,GAAG,aAAa;AAC3E,IAAI,qCAAY,cAAc,aAAa;AAC3C;AACA,0BAA0B,gCAAM;AAChC;AACA;AACA;AACA,EAAE,2BAAS;AACX,EAAE,4BAAc;;AAEhB;AACA;AACA;AACA;AACA;;;;;AChKqC;AACF;AACwC;AACI;;AAE/E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC,iBAAiB;;AAEvD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,gDAAiB;;AAExC;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B,uCAAY;AAC1C;AACA;AACA;;AAEA;AACA,sBAAsB,uCAAY;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,uCAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,UAAU,0CAA0C,eAAe;AAC9G;AACA;;AAEA,0BAA0B,oCAAkB;;AAE5C;AACA;AACA;AACA,4CAA4C,aAAa,mBAAmB,gBAAgB,GAAG,iBAAiB,EAAE,EAAE,cAAc,iBAAiB,aAAa;AAChK,wCAAwC,MAAM,IAAI,oBAAoB;AACtE,GAAG;;AAEH;AACA;;AAEA;AACA,qBAAqB,mCAAiB;AACtC;AACA,8CAA8C,oDAAoD;AAClG;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,qCAAY;;AAEd;;AAEA;AACA,wCAAwC,aAAa,GAAG,SAAS;;AAEjE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,EAAE,qCAAY;AACd;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,qCAAY,IAAI,eAAe;AACnC;AACA,MAAM,qCAAY,IAAI,uBAAuB;AAC7C;AACA;AACA;AACA,uBAAuB,mDAAmD;AAC1E;AACA,KAAK;AACL,GAAG;;AAEH,sCAAsC,sCAAW;AACjD,EAAE,2BAAS,cAAc,8BAA8B;AACvD,QAAQ,0CAAgB,aAAa,+BAA+B;;AAEpE;;AAEA;AACA,IAAI,qCAAY,IAAI,eAAe;AACnC;AACA;AACA,GAAG;;AAEH,6BAA6B,sCAAW;AACxC,EAAE,2BAAS,cAAc,qBAAqB;;AAE9C,QAAQ,0CAAgB,YAAY,qBAAqB;;AAEzD;AACA;;;ACtLA;AACgE;AACpB;AACE;;AAE9C;AACA,uBAAuB,SAAS;AAChC,qBAAqB,+BAAa;AAClC;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU,0BAAQ;AAClB;AACA;AACA,UAAU,2BAAS,aAAa,aAAa;AAC7C;AACA;AACA;AACA,OAAO;AACP,sBAAsB,QAAQ;AAC9B;AACA;AACA,GAAG;AACH;;AAEO;AACP;;AAEA;;AAEA;AACA;;;;;AC5CqC;AACF;AACuC;AAClC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA,SAAS,eAAS;AAClB;;AAEA;AACA,sCAAsC,iBAAiB;AACvD,qCAAqC,aAAa;;AAElD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iEAAiE,0BAA0B;AAC3F;;AAEA,uBAAuB,gDAAiB;;AAExC;AACA;;;AAGA;AACA,eAAe,eAAS;;AAExB;AACA;;;AAGO;AACP,EAAE,qCAAY;AACd;;AAEA;;AAEA;AACA,IAAI,qCAAY,IAAI,WAAW;AAC/B;AACA;AACA,GAAG;;AAEH,6BAA6B,sCAAW;AACxC,2BAA2B,sCAAW;;AAEtC,EAAE,2BAAS,cAAc,mBAAmB;AAC5C,QAAQ,0CAAgB,YAAY,mBAAmB;;AAEvD;AACA;;;AC/EA;AACgE;AACpB;AACE;;AAE9C;AACA,uBAAuB,SAAS;AAChC,qBAAqB,+BAAa;AAClC;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU,0BAAQ;AAClB;AACA;AACA,UAAU,2BAAS,aAAa,aAAa;AAC7C;AACA;AACA;AACA,OAAO;AACP,sBAAsB,QAAQ;AAC9B;AACA;AACA,GAAG;AACH;;AAEO;AACP;;AAEA;AACA;;;;;AC1CmC;AACE;AACQ;AACD;AACA;AACK;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEO,MAAM,gBAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,MAAM,kBAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,gBAAS;AAClB;AACA;;AAEA;AACA,2BAA2B,8BAAa;AACxC,sCAAsC,iBAAiB;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,gDAAiB;;AAExC;AACA;AACO;AACP,EAAE,qCAAY;;AAEd,eAAe,gBAAS;AACxB;;AAEA,2BAA2B,kBAAW;AACtC,wCAAwC,cAAc,GAAG,WAAW;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,sBAAsB;AAC1E,gCAAgC,WAAW,EAAE,cAAc;;AAE3D;AACA;;AAEO;AACP,eAAe,gBAAS;AACxB,EAAE,qCAAY,YAAY,WAAW;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B,uCAAY;AAC1C;AACA;AACA;;AAEA;AACA,sBAAsB,uCAAY;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,uCAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAmE,UAAU,+CAA+C,eAAe;;AAE3I;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;;AAE1C;AACA;AACA,6BAA6B,uEAAiC;AAC9D;AACA,QAAQ,2EAAmC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,yBAAyB;AACpE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mEAA+B;AAClD,yBAAyB,mDAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,+CAA+C,qEAAgC;AAC/E;AACA,0BAA0B,qEAAgC;AAC1D;AACA,OAAO;AACP,yBAAyB,mDAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,0EAA0E,2BAA2B;AACrG;;AAEA;AACA;;AAEO;AACP,EAAE,qCAAY,YAAY,YAAY;AACtC;AACA;;AAEA,0BAA0B,oCAAkB;;AAE5C;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,aAAa,mBAAmB,gBAAgB,GAAG,iBAAiB,EAAE,EAAE,cAAc,iBAAiB,aAAa;;AAElK;AACA,wBAAwB,MAAM,IAAI,oBAAoB;AACtD;AACA;;AAEA,GAAG;;AAEH;AACA;;;ACtQqC;AACwD;AAChC;AACF;;;AAG3D;AACA,qBAAqB,cAAc;AACnC,yCAAyC,kBAAkB;AAC3D;AACA;;AAEO;AACP;AACA,EAAE,qCAAY;AACd;;AAEA;AACA;;AAEA;AACA,IAAI,qCAAY,IAAI,YAAY;AAChC;AACA;AACA,MAAM,qCAAY,IAAI,cAAc;AACpC,WAAW,yBAAkB;AAC7B,8BAA8B,eAAe;AAC7C;AACA,uBAAuB,wDAAwD;AAC/E;AACA,KAAK;AACL,GAAG;;AAEH,qCAAqC,sCAAW;AAChD,EAAE,2BAAS,cAAc,6BAA6B;AACtD,QAAQ,0CAAgB,eAAe,gCAAgC;;AAEvE,qBAAqB,mCAAiB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,IAAI,qCAAY,IAAI,YAAY;AAChC;AACA;AACA,GAAG;;AAEH,+BAA+B,sCAAW;AAC1C,EAAE,2BAAS,cAAc,uBAAuB;;AAEhD,QAAQ,0CAAgB,cAAc,yBAAyB;;AAE/D;AACA;AACA;;;;;AC5DqC;AACW;;AAE6C;AAClB;AAChB;;AAE3D;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B,uCAAY;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,uCAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,uCAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD,6CAA6C,eAAe;AAC5D;AACA;;AAEA;AACA,qBAAqB,cAAc;AACnC;AACA,yCAAyC,cAAc,SAAS,qBAAqB;;AAErF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,wBAAwB,cAAc;AACtC;AACA,yCAAyC,kBAAkB;AAC3D;AACA;;AAEO;AACP,EAAE,qCAAY;AACd;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,6EAAmC;AAC1D,IAAI,qCAAY,IAAI,eAAe;AACnC;AACA;AACA,MAAM,qCAAY,IAAI,cAAc;AACpC,WAAW,yBAAkB;AAC7B,8BAA8B,eAAe;AAC7C;AACA,uBAAuB,wEAAwE;AAC/F;AACA,KAAK;AACL,GAAG;;AAEH,qCAAqC,sCAAW;AAChD,EAAE,2BAAS,cAAc,6BAA6B;AACtD,QAAQ,0CAAgB,eAAe,gCAAgC;;AAEvE,qBAAqB,mCAAiB;AACtC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,0BAA0B,mCAAiB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH,+BAA+B,sCAAW;AAC1C,EAAE,2BAAS,cAAc,uBAAuB;;AAEhD,QAAQ,0CAAgB,cAAc,yBAAyB;;AAE/D;AACA;AACA;;;ACzIqC;AACW;;AAES;AACI;AACrB;;AAEjC;AACP,EAAE,qCAAY;AACd;AACA;;AAEA;AACA,qBAAqB,6EAAmC;;AAExD;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,qCAAY,IAAI,cAAc;AAClC,SAAS,yBAAkB;AAC3B,4BAA4B,eAAe;AAC3C;AACA,qBAAqB,uDAAuD;AAC5E;AACA,GAAG;;AAEH,qCAAqC,sCAAW;AAChD,EAAE,2BAAS,cAAc,6BAA6B;AACtD,QAAQ,0CAAgB,eAAe,gCAAgC;;AAEvE;AACA;AACA;;;ACpCA;AACkD;AACc;AACR;AACD;AACT;;AAE9C;AACA,uBAAuB,SAAS;AAChC,qBAAqB,+BAAa;AAClC;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU,0BAAQ,mCAAmC,UAAU;AAC/D;AACA;AACA,UAAU,2BAAS,aAAa,aAAa;AAC7C;AACA;AACA;AACA,OAAO;AACP,sBAAsB,aAAa;AACnC;AACA;AACA,GAAG;AACH;;AAEA;AACA,uBAAuB,SAAS;AAChC,qBAAqB,+BAAa;AAClC;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU,0BAAQ,mCAAmC,UAAU;AAC/D;AACA;AACA,UAAU,2BAAS,aAAa,aAAa;AAC7C;AACA;AACA;AACA,OAAO;AACP,sBAAsB,eAAe;AACrC;AACA;AACA,GAAG;AACH;;AAEA;AACA,uBAAuB,SAAS;AAChC,qBAAqB,+BAAa;AAClC;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU,0BAAQ;AAClB;AACA;AACA,UAAU,2BAAS,aAAa,aAAa;AAC7C;AACA;AACA;AACA,OAAO;AACP,sBAAsB,UAAU;AAChC;AACA;AACA,GAAG;AACH;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;;;ACpJA;AAC2C;AACM;AACf;AACY;;AAE9C;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU,2BAAS,iBAAiB,aAAa;AACjD;AACA;AACA;AACA,UAAU,0BAAQ;AAClB;AACA;AACA,OAAO;AACP;AACA,QAAQ,2BAAS,cAAc,kBAAkB;AACjD,QAAQ,mCAAW,cAAc,kBAAkB;AACnD;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEO;AACP;AACA,EAAE,qCAAY;;AAEd,EAAE,2BAAS;AACX;AACA,UAAU,uCAAY,uCAAuC,WAAW;AACxE,GAAG;;AAEH,EAAE,2BAAS;;AAEX;AACA;;;AC1DkC;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,MAAM,mCAAW,UAAU,YAAY;AACvC;AACA,uBAAuB,mBAAmB,IAAI,aAAa;AAC3D,iEAAiE,YAAY;AAC7E,OAAO;AACP;AACA;AACA;AACA,MAAM,mCAAW,UAAU,YAAY;AACvC,+BAA+B,YAAY;AAC3C;AACA,MAAM;AACN,MAAM,mCAAW,UAAU,YAAY;AACvC,MAAM,mCAAW;AACjB;AACA;AACA,GAAG;AACH,4BAA4B,mCAAW;AACvC;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;;AC3D6C;AACsD;AACrD;;AAE9C;AACA,uBAAuB,SAAS;AAChC,qBAAqB,+BAAa;AAClC;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU,0BAAQ;AAClB;AACA;AACA,UAAU,2BAAS,aAAa,aAAa;AAC7C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA,iCAAiC,oCAAkB;AACnD,kCAAkC,+BAAa;AAC/C;AACA,0DAA0D,wBAAwB;;AAElF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,sBAAsB;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD,qBAAqB;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEO;AACP;;AAEA;AACA,YAAY,SAAS;AACrB,gBAAgB,+BAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB,GAAG,iBAAiB,EAAE,EAAE;;AAE3D;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,+BAAa;AAC3C;;AAEA;AACA,0BAA0B,+DAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,0BAA0B,uDAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,8BAA8B,+DAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,2BAA2B,6DAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,oCAAoC,qEAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEO;AACP;AACA;AACA,EAAE,0BAAQ;AACV;AACA;;;ACxNqC;AACF;AAC4B;AACF;AACd;AACJ;AACF;AACwB;AACrB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;;;AAGf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kDAAqB;AACtD;AACA,WAAW,6BAA6B,GAAG,WAAW;AACtD,WAAW,6BAA6B,GAAG,cAAc,GAAG,WAAW;AACvE;AACA,WAAW,WAAW,GAAG,SAAS;AAClC,WAAW,cAAc,GAAG,WAAW,GAAG,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA,gBAAgB,4DAA0B,gCAAgC,iBAAiB;AAC3F,iEAAiE,gBAAgB;AACjF,+EAA+E,iBAAiB,eAAe,2CAA2C;AAC1J;AACA;AACA,UAAU;AACV,UAAU,qCAAY,0BAA0B,KAAK;AACrD;;AAEA,iCAAiC,8CAAgB;AACjD,kBAAkB,WAAW;AAC7B;AACA,MAAM;AACN,MAAM,qCAAY,+BAA+B,MAAM,IAAI,YAAY;AACvE;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA,gBAAgB,4DAA0B,gCAAgC,iBAAiB;AAC3F;AACA;AACA,+EAA+E,iBAAiB,eAAe,2CAA2C;AAC1J;AACA;AACA,UAAU;AACV,UAAU,qCAAY,0BAA0B,KAAK;AACrD;;AAEA,iCAAiC,8CAAgB;AACjD,kBAAkB,WAAW;AAC7B;AACA,MAAM;AACN,MAAM,qCAAY,+BAA+B,MAAM,IAAI,YAAY;AACvE;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,UAAU;AACxB;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,uCAAuC,2BAA2B,IAAI,cAAc;AACpF;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,UAAU;AACxB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA,sDAAsD,cAAc;AACpE,QAAQ,qCAAY,uBAAuB,oBAAoB;AAC/D;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD,0BAA0B;AAClF;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,yBAAyB,KAAK,GAAG,UAAU;;AAE3C;AACA;AACA;AACA;AACA,MAAM;AACN,eAAe;AACf;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA,uDAAuD;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,yDAAyD;AACzD;;AAEA,4DAA4D,2CAA2C;AACvG;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,qCAAY,sBAAsB,KAAK;AACnD,YAAY,4BAA4B,cAAc,eAAe,UAAU,KAAK;AACpF,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA,4BAA4B,iCAAe;AAC3C;AACA,gBAAgB,qCAAY,sBAAsB,KAAK;AACvD,gBAAgB,4BAA4B,cAAc,eAAe,UAAU,KAAK;AACxF,wBAAwB,aAAa;AACrC,gBAAgB;AAChB,gBAAgB,mCAAW,6BAA6B,KAAK;AAC7D,kEAAkE,KAAK,uDAAuD,iBAAiB;AAC/I;AACA;AACA,cAAc;AACd;AACA,qGAAqG,iBAAiB;AACtH,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qCAAY,sBAAsB,KAAK;AACnD,YAAY,4BAA4B;AACxC;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,yBAAyB,mCAAiB;AAC1C;AACA;AACA;;AAEA,oDAAoD,gBAAgB;AACpE;AACA,KAAK;AACL;;AAEA;AACA;AACA,uBAAuB,MAAM;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,yBAAyB,MAAM;AAC/B;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc,4CAAe;;AAE7B;;AAEA;AACA,qEAAqE,UAAU;AAC/E,MAAM,qCAAY,cAAc,WAAW;;AAE3C,+CAA+C,UAAU;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2FAA2F,uBAAuB,GAAG,YAAY,EAAE,EAAE,kBAAkB;AACvJ,YAAY;AACZ,YAAY,mCAAW,mCAAmC,eAAe;AACzE;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,gBAAgB;AAChF;AACA,UAAU;AACV,UAAU,mCAAW,gCAAgC,eAAe;AACpE;AACA,QAAQ;AACR,QAAQ,mCAAW,gCAAgC,eAAe;AAClE;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,qEAAqE,UAAU;AAC/E,MAAM,qCAAY,8BAA8B,WAAW;;AAE3D;AACA;AACA;AACA;AACA,QAAQ,mCAAW,4BAA4B,gBAAgB;;AAE/D,+DAA+D,QAAQ,GAAG,aAAa;AACvF;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B,gDAAsB;;AAEpD;;AAEA;AACA;AACA,iBAAiB;AACjB,OAAO;AACP;AACA;AACA;AACA,OAAO;;AAEP,IAAI,qCAAY;AAChB;AACA;AACA;AACA,QAAQ,mCAAW,oBAAoB,YAAY,cAAc,aAAa,OAAO,iCAAiC,UAAU,mBAAmB;AACnJ;AACA,uGAAuG,4CAA4C,IAAI,cAAc;AACrK,UAAU;AACV,UAAU,qCAAY;AACtB,UAAU,mCAAW,2BAA2B,YAAY,UAAU,oBAAoB;AAC1F,UAAU,qCAAY,oEAAoE,mBAAmB,KAAK,QAAQ,cAAc,cAAc,eAAe,GAAG,IAAI,cAAc,EAAE;AAC5L;AACA;AACA,KAAK;;AAEL,IAAI,qCAAY;;AAEhB;;AAEA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,yFAAyF,OAAO;AAChG,KAAK;;AAEL;AACA;;;AAGA;;;AC5qBkC;AACG;AACqB;AACK;;AAEhD;AACf;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA,2BAA2B,kDAAqB;AAChD;;AAEA;AACA;AACA,8DAA8D,SAAS;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,4DAA0B;AAChE;AACA,0BAA0B;AAC1B,qBAAqB,mBAAmB;AACxC;AACA;;AAEA,mBAAmB;AACnB,SAAS;AACT;AACA,MAAM;AACN,MAAM,qCAAY;AAClB,MAAM,mCAAW;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA,WAAW;;AAEX;AACA,YAAY,qCAAY,oBAAoB,gBAAgB,IAAI,WAAW;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,cAAc;AAC/B;;AAEA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA,YAAY,gCAAgC;AAC5C;AACA;;AAEA;AACA,QAAQ,oBAAoB;AAC5B,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA;AACA,QAAQ,oBAAoB;AAC5B,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA;AACA,QAAQ,oBAAoB;AAC5B,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA;AACA,QAAQ,oBAAoB;AAC5B,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA;AACA,QAAQ,oBAAoB;AAC5B,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA;AACA,QAAQ,oBAAoB;AAC5B,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA;AACA,QAAQ,oBAAoB;AAC5B,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA;AACA,QAAQ,oBAAoB;AAC5B,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,OAAO,eAAe;AACzC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc,oBAAoB;AAClC;AACA,YAAY,mCAAW;AACvB,yEAAyE,eAAe;AACxF;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAW,aAAa,WAAW,IAAI,qBAAqB;AAC5E;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qCAAY,IAAI,YAAY,oBAAoB,cAAc;AACpF,iFAAiF,cAAc;AAC/F,sBAAsB;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,kBAAkB,mCAAW,aAAa,YAAY;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,YAAY,mCAAW,yCAAyC,KAAK;AACrE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA,MAAM,mCAAW,6CAA6C,KAAK;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C,UAAU;AACV;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,UAAU,mCAAW;AACrB;;AAEA;AACA,iEAAiE,eAAe,aAAa,iBAAiB;AAC9G,0DAA0D,eAAe,aAAa,iBAAiB;AACvG;;AAEA;AACA,qBAAqB;AACrB,oBAAoB;AACpB,oBAAoB;AACpB,yBAAyB;AACzB;;AAEA;;AAEA;AACA,wDAAwD,uBAAuB;AAC/E,QAAQ,qCAAY;;AAEpB;AACA;;AAEA;;AAEA,qEAAqE,eAAe;;AAEpF;AACA;AACA;AACA,QAAQ;AACR;AACA,+DAA+D,eAAe;AAC9E,QAAQ,qCAAY,yBAAyB,eAAe;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC,IAAI,mCAAW,cAAc,gBAAgB,IAAI,UAAU,GAAG,kBAAkB;AAChF;;AAEA,UAAU,oBAAoB;AAC9B;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;;AAEA;AACA,YAAY,oBAAoB;AAChC;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD;;AAEA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA,WAAW;AACX;;AAEA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA,iCAAiC,mBAAmB;AACpD,aAAa;AACb,wCAAwC,iBAAiB;AACzD;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA,iCAAiC,mBAAmB;AACpD,aAAa;AACb,uCAAuC,iBAAiB;AACxD;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oDAAoD,sBAAsB,GAAG,mBAAmB,GAAG,wBAAwB;AAC3H;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,SAAS,4BAA4B;AACrC,YAAY,oBAAoB;AAChC;AACA,yCAAyC,mBAAmB;AAC5D,OAAO;;AAEP,YAAY,oBAAoB;AAChC;AACA,2BAA2B,mBAAmB;AAC9C,OAAO;;AAEP,YAAY,oBAAoB;AAChC;AACA,0BAA0B,mBAAmB;AAC7C,OAAO;;AAEP,YAAY,oBAAoB;AAChC;AACA,yBAAyB,mBAAmB;AAC5C,OAAO;;AAEP;AACA,+CAA+C,cAAc;AAC7D,yCAAyC,eAAe;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC,iDAAiD,cAAc;AAC/D,+BAA+B,wCAAwC;AACvE;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC,+CAA+C,cAAc;AAC7D;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC,0DAA0D,cAAc;AACxE;AACA,sDAAsD,iBAAiB;AACvE;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC,yDAAyD,cAAc;AACvE;AACA,mDAAmD,mBAAmB;AACtE;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC,yBAAyB,eAAe,GAAG,UAAU;AACrD,wCAAwC,cAAc;AACtD;AACA;AACA;AACA,aAAa,4BAA4B;AACzC,iDAAiD,cAAc;AAC/D;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,qBAAqB;AAC5C,sBAAsB,gBAAgB;;AAEtC,IAAI,mCAAW,aAAa,gBAAgB,IAAI,YAAY,GAAG,kBAAkB;;AAEjF;AACA;AACA;AACA;;AAEA,UAAU,oBAAoB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA,IAAI,mCAAW,6BAA6B,KAAK,IAAI,6BAA6B;;AAElF,uBAAuB,qBAAqB;AAC5C,sBAAsB,gBAAgB;;AAEtC,IAAI,mCAAW,cAAc,gBAAgB,IAAI,YAAY,GAAG,kBAAkB;;AAElF;;AAEA,UAAU,oBAAoB;AAC9B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;;AAEX;;AAEA,8BAA8B,6BAA6B,GAAG,cAAc,GAAG,eAAe;;AAE9F;AACA;;AAEA,kBAAkB,oBAAoB;AACtC,oBAAoB,mBAAmB;AACvC;AACA;AACA,aAAa;AACb;;AAEA,UAAU;AACV;AACA,iCAAiC,mBAAmB;AACpD;AACA;;AAEA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA,SAAS;AACT;;AAEA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA,QAAQ;AACR,cAAc,oBAAoB;AAClC;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA,SAAS;AACT,QAAQ;AACR,cAAc,oBAAoB;AAClC;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA,UAAU,qCAAY,2BAA2B,UAAU;AAC3D;AACA,sBAAsB,gCAAgC;AACtD,SAAS;AACT,QAAQ;AACR,8BAA8B,kBAAkB,wDAAwD;AACxG;AACA,gBAAgB,oBAAoB;AACpC,+BAA+B,mBAAmB;AAClD,8DAA8D,UAAU,IAAI,KAAK;AACjF,WAAW;AACX;AACA,QAAQ,qCAAY,2BAA2B,UAAU;AACzD,uBAAuB,gCAAgC;AACvD;;AAEA;AACA;;AAEA;AACA;AACA,UAAU,qCAAY,yCAAyC,YAAY,aAAa,qDAAqD;AAC7I;AACA,UAAU;AACV,UAAU,qCAAY,yCAAyC,YAAY,aAAa,gDAAgD;AACxI;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA,gDAAgD,KAAK;AACrD;AACA,gBAAgB,kCAAkC;AAClD,qBAAqB,kDAAkD,GAAG,kCAAkC;AAC5G;;AAEA;AACA;AACA,qBAAqB,kDAAkD,GAAG,KAAK;AAC/E;AACA;;;ACxtBqC;AACH;;AAElC;AACA,yJAAyJ,mCAAmC,iCAAiC,mBAAmB;AAChP;AACA;AACA,kCAAkC,eAAe,gBAAgB,qBAAqB;AACtF;AACA;AACA;AACA;AACA,yJAAyJ,mCAAmC,iCAAiC,mBAAmB;AAChP;AACA;AACA,kCAAkC,eAAe,gBAAgB,qBAAqB;AACtF;AACA;AACA;AACA;AACA,yJAAyJ,mCAAmC,iCAAiC,mBAAmB;AAChP;AACA;AACA,kCAAkC,eAAe,gBAAgB,qBAAqB;AACtF;AACA;AACA;AACA;AACA,yJAAyJ,mCAAmC,iCAAiC,mBAAmB;AAChP;AACA;AACA,kCAAkC,eAAe,gBAAgB,qBAAqB;AACtF;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA,+BAA+B,KAAK;AACpC,IAAI,mCAAW;AACf;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;;;ACpDkC;AACG;AACqB;AACvB;AACa;AACN;;AAE1C;AACA,0DAA0D,6BAA6B;AACvF,2BAA2B,aAAa;;AAEzB;AACf;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,SAAS;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,qCAAY,IAAI,IAAI,IAAI,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qCAAY;AAClB,MAAM;AACN,MAAM,qCAAY;AAClB,MAAM,mCAAW;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gBAAgB,8EAAgC;AAChD,OAAO;;AAEP;AACA;;;AAGA;AACA;AACA;AACA,0DAA0D,qBAAqB;AAC/E;;AAEA;AACA;AACA;AACA,UAAU,mCAAW,uBAAuB,KAAK;AACjD;AACA,UAAU;AACV,UAAU,mCAAW,yBAAyB,KAAK;AACnD;AACA;AACA,OAAO;;AAEP;AACA;AACA,8FAA8F,WAAW;AACzG;;AAEA;AACA,yCAAyC,kBAAkB;AAC3D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA,MAAM,qCAAY,IAAI,gBAAgB;AACtC;AACA,YAAY,gCAAgC;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,OAAO,eAAe;AACzC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,YAAY,mCAAW,wCAAwC,IAAI;AACnE;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA,MAAM,mCAAW,6CAA6C,KAAK;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,qCAAY,uBAAuB,oBAAoB;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,qDAAuB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,MAAM,GAAG,SAAS;AACrC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,mCAAW,aAAa,WAAW,IAAI,qBAAqB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,qCAAY,IAAI,YAAY,oBAAoB,cAAc;AACxE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA,UAAU,mCAAW,gBAAgB,WAAW,iCAAiC,eAAe,KAAK,iBAAiB;AACtH;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,UAAU,mCAAW,aAAa,YAAY,cAAc,WAAW,GAAG,WAAW;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,aAAa,QAAQ,gBAAgB;;AAEjE;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;;AAET;;AAEA,MAAM,qCAAY;;AAElB;AACA,mBAAmB;AACnB,kBAAkB;AAClB,kBAAkB;AAClB,uBAAuB;AACvB,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA,MAAM,qCAAY;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET,MAAM,qCAAY;;AAElB,MAAM,qCAAY;AAClB;AACA,YAAY,oBAAoB;AAChC,QAAQ,qCAAY,gCAAgC,WAAW;AAC/D,cAAc,2BAA2B;AACzC,QAAQ,qCAAY,8BAA8B,WAAW;AAC7D,OAAO;;AAEP;AACA;AACA;AACA,UAAU,qCAAY,8BAA8B,WAAW;AAC/D;AACA;AACA;AACA,SAAS;AACT;;AAEA,MAAM,qCAAY;;AAElB,sDAAsD,uBAAuB;AAC7E,MAAM,qCAAY;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY,mCAAW,aAAa,WAAW;AAC/C;AACA;AACA,YAAY;AACZ,gHAAgH,cAAc;AAC9H,YAAY,mCAAW,WAAW,YAAY;AAC9C,YAAY,qCAAY;AACxB;AACA;AACA,SAAS;;AAET;;AAEA;AACA,QAAQ,mCAAW;AACnB,yEAAyE,YAAY,KAAK,mBAAmB;AAC7G;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;;AAEA,oEAAoE,YAAY,KAAK,mBAAmB;;AAExG;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,KAAK;AACrD;AACA,gBAAgB,kCAAkC;AAClD,qBAAqB,kDAAkD,GAAG,kCAAkC;AAC5G;;AAEA;AACA;AACA,qBAAqB,kDAAkD,GAAG,KAAK;AAC/E;AACA;;;ACtiBA;AACgC;AACE;AACW;AACC;AACD;AACoB;;AAE1D;AACP;AACA;AACA,4EAA4E,4CAAkB;AAC9F,gFAAgF,4CAAkB;AAClG,6EAA6E,4CAAkB;AAC/F,iFAAiF,4CAAkB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,KAAK;AACzD,wEAAwE,KAAK;AAC7E,oDAAoD,KAAK;AACzD,wEAAwE,KAAK;AAC7E,oDAAoD,KAAK;AACzD,wEAAwE,KAAK;AAC7E,oDAAoD,KAAK;AACzD,wEAAwE,KAAK;AAC7E,oDAAoD,KAAK;AACzD,wEAAwE,KAAK;AAC7E,GAAG;AACH;;AAEA;AACA,SAAS,4CAAkB;AAC3B;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,sCAAsC,4CAAkB;AACxD;AACA,0BAA0B,8EAAgC;AAC1D,2BAA2B,8EAAgC;AAC3D;AACA,kFAAkF,iCAAiC,YAAY,qCAAqC,mBAAmB,4CAA4C,cAAc,uCAAuC,cAAc,8BAA8B,YAAY,4BAA4B,0BAA0B,gDAAgD,+CAA+C,yCAAyC,wBAAwB,iCAAiC,kBAAkB,wCAAwC,4BAA4B,4CAA4C;;AAEzsB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,iCAAe;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;;AAEA,EAAE,qCAAY,6BAA6B,WAAW,KAAK,QAAQ;AACnE;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mHAAmH,KAAK;AACxH,kGAAkG,KAAK;;AAEvG;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEO;AACP,iBAAiB,SAAS;AAC1B;AACA;AACA,gBAAgB,iCAAe;AAC/B,sCAAsC,4CAAkB;AACxD;AACA,0BAA0B,8EAAgC;AAC1D,2BAA2B,8EAAgC;AAC3D;AACA;AACA,qCAAqC,8EAAgC;AACrE;AACA;AACA;AACA,qEAAqE,iCAAiC,YAAY,qCAAqC,mBAAmB,4CAA4C,cAAc,uCAAuC,cAAc,8BAA8B,YAAY,4BAA4B,0BAA0B,gDAAgD,+CAA+C,yCAAyC,wBAAwB,iCAAiC,kBAAkB,wCAAwC,4BAA4B,4CAA4C;;;AAG5rB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA,0EAA0E,uBAAuB;;AAEjG;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEO;AACP;AACA;;AAEA,EAAE,qCAAY,6BAA6B,WAAW,KAAK,QAAQ;;AAEnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACn3BA;AACkC;AACM;AACE;AACI;AACN;AACA;AACI;AACF;AACc;AACX;AACC;AACM;AACK;AACH;AACE;AACkB;AACP;;;AAG5D;AACP,qBAAqB,yDACV;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAmE;AACzF;AACA;;AAEA;AACA,IAAI,2BAAS;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA,MAAM,2BAAS;AACf;AACA;AACA,KAAK;AACL;AACA,MAAM,2BAAS;AACf;AACA;AACA,KAAK;AACL;AACA,MAAM,2BAAS;AACf;AACA;AACA,KAAK;AACL;AACA,MAAM,2BAAS;AACf;AACA;AACA,KAAK;AACL;AACA,MAAM,2BAAS;AACf;AACA;AACA,KAAK;AACL;AACA,MAAM,2BAAS;AACf;AACA;AACA,KAAK;AACL;AACA,MAAM,2BAAS;AACf;AACA;AACA,KAAK;AACL;AACA,UAAU,cAAc;AACxB,KAAK;AACL;AACA,UAAU,eAAe;AACzB,KAAK;AACL;AACA,MAAM,2BAAS;AACf;AACA;AACA,KAAK;AACL;AACA,MAAM,2BAAS;AACf;AACA;AACA,KAAK;AACL;AACA,MAAM,2BAAS;AACf;AACA;AACA,KAAK;AACL;AACA,MAAM,2BAAS;AACf;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qBAAqB;AAC7B,OAAO;;;AAGP;AACA;AACA,yCAAyC;AACzC;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,mBAAmB,SAAS;AAC5B;AACA,kBAAkB,iCAAe;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM,mCAAW;AACjB,2BAA2B,aAAa;AACxC,MAAM,2BAAS,uBAAuB,QAAQ;AAC9C,MAAM,2BAAS;AACf;AACA,MAAM;AACN,MAAM,qCAAY;AAClB,MAAM,qCAAY;AAClB;;AAEA;;AAEA;AACA;AACA,MAAM,mCAAW;AACjB,YAAY,WAAW;AACvB,MAAM,2BAAS;AACf,MAAM,2BAAS;AACf;AACA,MAAM;AACN,MAAM,qCAAY;AAClB,MAAM,qCAAY;AAClB;AACA;;AAEA;AACA;AACA,MAAM,mCAAW;AACjB,YAAY,UAAU;AACtB,MAAM,2BAAS;AACf,MAAM,2BAAS;AACf;AACA,MAAM;AACN,MAAM,qCAAY;AAClB,MAAM,qCAAY;AAClB;AACA;;AAEA;AACA;AACA,MAAM,mCAAW;AACjB,2BAA2B,UAAU;AACrC,MAAM,2BAAS,uBAAuB,eAAe;AACrD,MAAM,2BAAS;AACf;AACA,MAAM;AACN,MAAM,qCAAY;AAClB,MAAM,qCAAY;AAClB;AACA;;AAEA;AACA;AACA,MAAM,mCAAW;AACjB,2BAA2B,UAAU;AACrC,MAAM,2BAAS,uBAAuB,eAAe;AACrD,MAAM,2BAAS;AACf;AACA,MAAM;AACN,MAAM,qCAAY;AAClB,MAAM,qCAAY;AAClB;AACA;;;AAGA;AACA;AACA,MAAM,mCAAW;AACjB,2BAA2B,YAAY;AACvC,MAAM,2BAAS,uBAAuB,eAAe;AACrD,MAAM,2BAAS;AACf;AACA,MAAM;AACN,MAAM,qCAAY;AAClB,MAAM,qCAAY;AAClB;AACA;;AAEA;AACA;AACA,MAAM,mCAAW;AACjB,2BAA2B,WAAW;AACtC,MAAM,2BAAS,uBAAuB,eAAe;AACrD,MAAM,2BAAS;AACf;AACA,MAAM;AACN,MAAM,qCAAY;AAClB,MAAM,qCAAY;AAClB;AACA;;AAEA;AACA;AACA,MAAM,mCAAW;AACjB,YAAY,uBAAuB;AACnC,MAAM,2BAAS;AACf,MAAM,2BAAS;AACf;AACA,MAAM;AACN,MAAM,qCAAY;AAClB,MAAM,qCAAY;AAClB;AACA;;AAEA;AACA,IAAI,mCAAW,cAAc,MAAM;AACnC,UAAU,uDAAyB;AACnC,IAAI,2BAAS;AACb;AACA;;AAEA;AACA,IAAI,mCAAW;AACf,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA,MAAM;AACN,qEAAqE,4BAA4B;AACjG,kEAAkE,0BAA0B;AAC5F;AACA,IAAI,2BAAS;AACb;AACA;;AAEA,cAAc;AACd,uBAAuB,kBAAkB;AACzC;AACA;AACA;;;ACpYuD;AAC4D;AACxE;AAC+D;AACxE;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,MAAM,UAAU,OAAO;AACxE;AACA;AACA;AACA;;AAEO;AACP;AACA,sBAAsB,wCAAiB;AACvC,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;;AAEA;AACA;AACA,4BAA4B,MAAM;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;;AAE7B;AACA,IAAI,qCAAY;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA,IAAI,mCAAW;AACf,IAAI,qCAAY;AAChB,gGAAgG,UAAU,gBAAgB,eAAe,SAAS,cAAc,SAAS,cAAc;AACvL,GAAG;;AAEH;AACA,IAAI,qCAAY;;AAEhB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,IAAI,qCAAY;AAChB;AACA,GAAG;AACH;;AAEA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA,iBAAiB;;AAEjB;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ,qCAAY;AACpB,QAAQ,qCAAY;AACpB,QAAQ,qCAAY;AACpB;AACA,OAAO;AACP,GAAG;;AAEH;;AAEA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,qBAAqB,+BAAa;AAClC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,QAAQ,SAAS;AACjB;AACA;AACA;AACA,IAAI,iBAAiB;AACrB,IAAI;AACJ,IAAI,oBAAoB;AACxB;;AAEA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAkB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,YAAY,gCAAc;AAC1B;;AAEA;;AAEA;AACA;AACA,UAAU,UAAU;AACpB;;AAEA;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA,IAAI;AACJ,wBAAwB,oCAAkB;AAC1C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,0CAA0C,gBAAgB,QAAQ,WAAW;AAC7E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,SAAS;;AAEnB,+BAA+B,WAAW;AAC1C;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;;;AAGA;AACA;AACA,EAAE,8DAA2B;AAC7B,CAAC;;AAED;AACA;AACA,EAAE,8DAA2B;AAC7B,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,mBAAmB,SAAS;AAC5B;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA,uBAAuB,+BAAa;AACpC;AACA;AACA;AACA;AACA,wBAAwB,wCAAiB,gBAAgB,wCAAiB;AAC1E;AACA,0CAA0C,oCAAkB;AAC5D;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY,IAAI,eAAe,GAAG,oBAAoB,MAAM,YAAY;AAClH,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,gCAAc;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yBAAyB,wCAAiB;AAC1C,8BAA8B,wCAAiB;;AAE/C;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,MAAM,4DAA0B,CAAC,kDAAqB;AACtD,MAAM,4DAA0B,CAAC,kDAAqB;AACtD,MAAM,4DAA0B,CAAC,kDAAqB;;AAEtD;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB,IAAI,oBAAoB;AACjE;AACA;AACA;AACA,KAAK,IAAI;;AAET;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA,kBAAkB,iCAAe;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,mCAAW;AACjB;AACA;AACA;AACA;;;;AC3tBqC;;AAErC;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA,2BAA2B,oBAAoB,GAAG,sBAAsB;AACxE;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,MAAM,QAAQ;AACd,MAAM,QAAQ;AACd,MAAM,SAAS;AACf,MAAM,UAAU;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB,GAAG,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,GAAG;AACd;AACO,SAAS,gCAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAoD,kBAAkB,gCAAgC;AACjH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEO;AACP;AACA;AACA,aAAa,gCAAgB;AAC7B,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,gCAAgC,GAAG,kCAAkC;AAC3G;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA,qBAAqB,gCAAgB;AACrC;AACA,GAAG;AACH;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA,oBAAoB,sDAAsD,QAAQ,UAAU,IAAI,UAAU;AAC1G;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;ACnL6C;AACR;AACF;AACgC;AACR;;AAE3D;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA,mBAAmB,2EAAmC;AACtD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B,kBAAkB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,iBAAiB;AAC5D;;AAEA;AACA,oBAAoB,2EAAmC;AACvD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,2EAAmC;AACvD;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,IAAI,wDAAqB;AACzB;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uCAAuC;AAC7D;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,yCAAyC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,2EAAmC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,gEAAyB;AACjE;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2CAAqB,sBAAsB,+CAA+C,aAAa,cAAc;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2CAAqB,sBAAsB,+CAA+C,uBAAuB,cAAc;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2CAAqB,IAAI,eAAe,6BAA6B,+CAA+C,eAAe,cAAc;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2CAAqB,sBAAsB,+CAA+C,WAAW,cAAc;AACpI;AACA;AACA;AACA,yCAAyC,gEAAyB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2CAAqB,IAAI,QAAQ,GAAG,sBAAsB,cAAc,WAAW,+CAA+C,YAAY,cAAc;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2CAAqB,IAAI,QAAQ,6BAA6B,+CAA+C,WAAW,cAAc;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2CAAqB,IAAI,QAAQ,6BAA6B,8CAA8C,IAAI,cAAc;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,qCAAY;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;;AAEA;AACA,2BAA2B,2CAAqB,mCAAmC,iBAAiB;AACpG;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEACH;AACxB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,wEAA6B;AACnC;AACA;AACA,MAAM,sEAA4B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA,+BAA+B,wEAA6B;AAC5D;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,IAAI,wEAA6B;AACjC;AACA;AACA;AACA;;AAEA,EAAE,wDAAqB;AACvB;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAE,qCAAY;AACd,EAAE,qCAAY;AACd,EAAE,qCAAY;AACd,EAAE,qCAAY;AACd,EAAE,qCAAY;AACd,EAAE,qCAAY;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,qCAAY;AACd;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,wBAAwB,mBAAmB;AAC3C,EAAE,qCAAY;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,sDAAoB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,EAAE,qCAAY;;AAEd;AACA;;;ACjhBmC;;AAE5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,gEAAyB;;AAEnD;AACA,+BAA+B,gEAAyB;;AAExD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;ACpG6C;AACV;;AAEnC;AACA;AACA,SAAS,2EAAmC;AAC5C;;AAEA;AACA;AACA,SAAS,2EAAmC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAuB;AACnD,oBAAoB,oDAAoD;AACxE;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,YAAY;AACZ,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gCAAgC,4DAAuB;AACvD;AACA;AACA,KAAK;;AAEL;AACA;;;ACzLmC;;AAE5B;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,gEAAyB;AACzD,2CAA2C,gEAAyB;;AAEpE;AACA;AACA,gBAAgB,kEAA0B;AAC1C;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA,gBAAgB,kEAA0B;AAC1C;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;;AC1D6C;AACV;AACC;;AAE7B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,qEAAgC;AACvD;AACA,oFAAoF,WAAW;AAC/F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,qBAAqB,gEACG;AACxB;;AAEA;AACA;AACA,sBAAsB,gEACI,yBAAyB,KAAK;AACxD;;AAEA;AACA;AACA;;AAEA;AACA,OAAO,SAAS;AAChB,IAAI,wEAA6B;AACjC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,uBAAuB,qEAAgC;AACvD;AACA,uBAAuB,gEACG,8BAA8B,WAAW;AACnE;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA;;;AAGA;AACA;AACA;AACA,mBAAmB,qEAAgC;AACnD;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,iBAAiB,8CAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AC1H6C;;AAEtC;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D,sBAAsB;AACrF,2DAA2D,oBAAoB;AAC/E,+DAA+D,sBAAsB;AACrF,6DAA6D,qBAAqB;AAClF,2DAA2D,oBAAoB;AAC/E,2DAA2D,oBAAoB;AAC/E,yDAAyD,mBAAmB;AAC5E,+DAA+D,sBAAsB;AACrF;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,6EAAoC,+CAA+C;AACrG;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,iCAAiC,QAAQ;AACzC,4CAA4C,QAAQ;AACpD;;AAEA;AACA,gCAAgC,eAAe;AAC/C,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA,mCAAmC,kCAAkC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kCAAkC;AACrE;AACA,mCAAmC,yCAAyC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,MAAM;AAC7E;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,8BAA8B,KAAK;AACnC;AACA,qBAAqB,QAAQ,OAAO,KAAK;AACzC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AC5SmC;;AAEnC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,yBAAyB,sDAAoB,CAAC,gEAAyB;AACvE;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACO;AACP;AACA;AACA,MAAM,iDAAiD;AACvD,MAAM,mCAAmC,KAAK,iBAAiB;AAC/D,MAAM,yDAAyD;AAC/D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACO;AACP;AACA;AACA;AACA;AACA,MAAM,mCAAmC,KAAK,WAAW;AACzD,MAAM,kDAAkD;AACxD,MAAM,mCAAmC,KAAK,kBAAkB;AAChE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACO;AACP;AACA;AACA,MAAM,iDAAiD;AACvD,MAAM,+CAA+C;AACrD,MAAM,+CAA+C;AACrD;;AAEA;AACA,kBAAkB,sDAAoB,CAAC,gEAAyB;AAChE,+CAA+C,MAAM;AACrD,GAAG;AACH;AACA;;AAEO;AACP;AACA;AACA,MAAM,6CAA6C;AACnD,MAAM,qDAAqD;AAC3D;;AAEA;AACA,yBAAyB,sDAAoB,CAAC,gEAAyB;AACvE,GAAG;;AAEH;AACA;;;;;ACnJ6C;AAC7C;AACmC;;AAEnC;AACA;AACA,EAAE,iFAAsC;AACxC;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA,yCAAyC,uBAAuB;;AAEhE;AACA,EAAE,iFAAsC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,iCAAiC,gEACP;AAC1B;AACA;AACA,kBAAkB,gEACQ,mBAAmB,aAAa;AAC1D;AACA;AACA,yBAAyB,gEACC,iBAAiB,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA,4CAA4C,0BAA0B;AACtE,wBAAwB,gEACE,mBAAmB,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,eAAe,4BAA4B,uBAAuB;AACzF,2BAA2B,KAAK;AAChC,4BAA4B,MAAM;AAClC,gCAAgC,UAAU;AAC1C,mCAAmC,aAAa;AAChD,2CAA2C,qBAAqB;AAChE,mCAAmC,aAAa;AAChD;AACA,kCAAkC,YAAY;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,WAAW;AAC5C,qCAAqC,eAAe;AACpD,sCAAsC,gBAAgB;AACtD,sCAAsC,gBAAgB;AACtD,qCAAqC,eAAe;;AAEpD;;AAEA;AACA;AACA,QAAQ,gEAAyB,yBAAyB,aAAa;AACvE;AACA;;AAEA;AACA;AACA,gCAAgC,4DAAuB;AACvD;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;;AAEA,EAAE,iFAAsC;;AAExC,gCAAgC,gEACN,mBAAmB,aAAa;AAC1D,uBAAuB,sDAAoB;AAC3C;AACA;AACA;;AAEA,+BAA+B,gEACL,mBAAmB,aAAa;AAC1D,+BAA+B,sDAAoB;AACnD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D,QAAQ;AACR,gDAAgD,mBAAmB;AACnE;AACA,MAAM;AACN;AACA,gDAAgD,oBAAoB,IAAI,gBAAgB;AACxF,QAAQ;AACR,gDAAgD,mBAAmB;AACnE;AACA,MAAM;AACN,8CAA8C,gBAAgB;AAC9D;;AAEA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChN6C;AACV;AACE;;AAE9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qEAAgC;AAClD;AACA;AACA,UAAU;AACV,+BAA+B,iBAAiB;AAChD;AACA,OAAO;AACP;;AAEA;AACA;AACA,IAAI,gEAAyB;AAC7B;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,EAAE,gEACsB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,EAAE,gEACsB;AACxB;AACA;AACA;AACA;AACA,QAAQ;AACR,8BAA8B,UAAU;AACxC;AACA,KAAK;;AAEL;;AAEA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,eAAe,GAAG,YAAY,GAAG,eAAe;AACrE;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,IAAI,qCAAY;AAChB,IAAI,qCAAY;AAChB;AACA;;AAEA;AACA;;AAEO;AACP;AACA;;;AC3F8C;AACT;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA,IAAI;AACJ,IAAI,qCAAY;AAChB,IAAI,qCAAY;AAChB;AACA;AACA;;;ACrC6C;AACV;;AAE5B;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,mFACX;AACX;;AAEA,eAAe,gEACS;AACxB;AACA;AACA;AACA,oBAAoB,+EAAqC;AACzD;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,sBAAsB,+EAAqC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;;AC7E6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,2EAAmC;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA,sBAAsB,oDAAoD;AAC1E;;AAEA;AACA;AACA,cAAc;AACd,kDAAkD;AAClD;AACA;AACA;AACA;AACA,sBAAsB,oDAAoD;AAC1E,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAoD;AAC1E,yEAAyE;AACzE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;;;AC1Q6C;;AAEtC;AACP,aAAa,6EAAoC;AACjD;AACA;AACA;AACA;;;ACPmC;;AAE5B;AACP,0BAA0B,sDAAoB,CAAC,gEAAyB;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACpBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACRmC;AACK;AACc;AACd;AAC0D;AAC/C;AACb;AAWpB;AACmG;AAOzF;AACkB;AACQ;AAChB;AAQhB;AACwB;AACV;AACY;AACJ;AAC5C,YAAY,qBAAqB;;AAElB;AACf;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0CAAgB;AACzC,yCAAyC,0CAAgB;AACzD;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,gBAAgB;;AAE1C;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;;AAEA;AACA,iCAAiC,UAAU;;AAE3C;AACA,oCAAoC,aAAa;;AAEjD;AACA,yCAAyC,aAAa;;AAEtD;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,YAAY;;AAE7C;AACA,mCAAmC,aAAa;;AAEhD;AACA,mBAAmB,QAAQ;AAC3B;AACA,qCAAqC,YAAY;;AAEjD;AACA,2CAA2C,eAAe;;AAE1D;AACA,sCAAsC,UAAU;;AAEhD;AACA,6BAA6B,YAAY;;AAEzC;AACA,sCAAsC,aAAa;;AAEnD;AACA,6CAA6C,iBAAiB;;AAE9D;AACA;;AAEA;AACA,iCAAiC,QAAQ;AACzC,iCAAiC,QAAQ;AACzC,gCAAgC,OAAO;AACvC,gCAAgC,OAAO;AACvC,sCAAsC,aAAa;;AAEnD,wCAAwC,cAAc;;AAEtD,qCAAqC,YAAY;;AAEjD;AACA,qCAAqC,YAAY;AACjD;;AAEA;AACA,qCAAqC,gDAAsB;AAC3D,oCAAoC,+CAAqB;AACzD,mCAAmC,8CAAoB;AACvD,+BAA+B,OAAO;AACtC,iCAAiC,SAAS;AAC1C,oCAAoC,sCAAY;AAChD,6BAA6B,mBAAmB;AAChD,6BAA6B,oBAAoB;AACjD,6BAA6B,wBAAwB;AACrD,6BAA6B,sBAAsB;;AAEnD,4BAA4B,WAAW;AACvC,0BAA0B,2BAAS;AACnC,0BAA0B,aAAa;;AAEvC;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA,gCAAgC,oBAAoB;AACpD,gCAAgC,oBAAoB;AACpD;AACA,iCAAiC,eAAe;AAChD;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA,gCAAgC,qBAAqB;;AAErD;AACA;;;;;;;ACvLA;AACA;AACmC;AACwB;AACW;AACf;AACc;;AAErE;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wEAA6B;AACjC,IAAI,kDAAkB;AACtB,IAAI,kDAAkB;AACtB,IAAI,kDAAkB;AACtB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEO;AACP;AACA,uBAAuB,8EAAgC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2CAAe;AAC1B;AACA;;AAEA,SAAS,8CAAwB;;AAEjC;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,gCAAgC;AAChC;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,iDAAiD,iDAAiD;AAClG;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,8BAAa;AAC1C;AACA;AACA,GAAG;AACH;;;AAGO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,6CAAoB;AACjC,KAAK;AACL;AACA,IAAI;AACJ;AACA;;AAEA;;;AC/U6C;AACR;AACF;AACqB;AAC+B;AACrB;;AAElE;AACA,oBAAoB,8EAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,kEAA0B;AACrD;AACA,mBAAmB,wCAAa;AAChC;AACA,KAAK;AACL;AACA;AACA,mBAAmB,wCAAa;AAChC;AACA,KAAK;AACL;AACA;AACA,mBAAmB,wCAAa;AAChC;AACA,KAAK;;AAEL;AACA;AACA,kBAAkB,kEAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA,6BAA6B,8EAAgC;AAC7D,oDAAoD,8EAAgC;AACpF;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,8EAAgC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,iBAAiB,GAAG,gBAAgB;AACjG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA,SAAS,wBAAgB;AACzB;AACA;;AAEA,SAAS,iBAAS;AAClB;AACA;AACA,MAAM,yEAAkC;AACxC;;AAEA;AACA;AACA;AACA,qDAAqD,uBAAuB;AAC5E;;AAEA;AACA;AACA,gEAAgE,WAAW;AAC3E,2BAA2B,wDAAqB;AAChD;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,yEAAkC;AACvD;;AAEA,oBAAoB,gEAAyB;AAC7C;AACA;AACA,IAAI;AACJ,wBAAwB,YAAY;AACpC;;AAEA;AACA,MAAM,wBAAgB;AACtB;AACA,uBAAuB,wBAAgB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;;AAEP,8DAA8D,WAAW;AACzE,yBAAyB,wDAAqB,SAAS,aAAa;;AAEpE;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,8DAA8D,WAAW;AACzE,yBAAyB,wDAAqB,4BAA4B,aAAa;AACvF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAsB;AAC5C;;AAEA;AACA,sBAAsB,2EAAmC;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,sBAAc;AACvB;AACA,iCAAiC,kCAAmB;AACpD,2CAA2C,kCAAmB;AAC9D,MAAM,SAAS;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,qBAAa;AACtB;AACA,uBAAuB,mFAAuC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,SAAS,qBAAa;AACtB,gBAAgB,2EAAmC;AACnD,gBAAgB,yEAAkC;AAClD,gDAAgD,YAAY;AAC5D;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,YAAY,mEAA+B;AAC3C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,iBAAS;;AAEhC;AACA,yEAAyE,2EAAmC;;AAE5G;AACA,MAAM,2EAAmC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAAmC;AAC7D;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,qBAAqB,2EAAmC;AACxD;AACA;AACA;AACA,IAAI;AACJ;AACA,8BAA8B,wBAAgB;AAC9C;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,8BAA8B,gEAAyB;AACvD,IAAI;AACJ,yBAAyB,iBAAS;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,wCAAa;AACvB;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA,EAAE,qCAAY,oBAAoB,cAAc,KAAK,WAAW;AAChE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,sBAAc;AAC7C;AACA;AACA;AACA,8BAA8B,qBAAa;AAC3C;AACA;AACA,8BAA8B,qBAAa;AAC3C;AACA;;AAEA;AACA,cAAc,cAAc;;AAE5B,IAAI;AACJ,IAAI,mCAAW;AACf,yCAAyC,YAAY,kCAAkC,YAAY;AACnG;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA,mDAAmD,kEAA0B;AAC7E;AACA;AACA;AACA,IAAI,qBAAqB;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA,mDAAmD,kEAA0B;AAC7E;AACA;AACA;AACA,IAAI,qBAAqB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qCAAY,yBAAyB,YAAY;AACvD;AACA,cAAc,wCAAa;AAC3B;AACA,yBAAyB,gDAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B,qBAAa;AAC1C,8BAA8B,sBAAc;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,qCAAY;AACpB;AACA;;AAEA;AACA,aAAa,cAAc;;AAE3B;AACA,KAAK;;AAEL;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN,4BAA4B,mFAAuC;AACnE;AACA;AACA,4BAA4B,mFAAuC;AACnE;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;;AAEH,EAAE,WAAW;AACb,wBAAwB,eAAe;AACvC;AACA;;;AC3qBqC;AACF;AACqB;AAC+B;AAC/B;;AAExD,SAAS,uBAAc;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,kCAAmB;AACjC,IAAI;AACJ,cAAc,kCAAmB;AACjC,IAAI;AACJ;AACA;;AAEA;AACA,kBAAkB,kCAAmB;AACrC,IAAI;AACJ,kBAAkB,kCAAmB;AACrC,IAAI;AACJ;AACA;;AAEA,MAAM,SAAS;;AAEf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA,EAAE,qCAAY,oBAAoB,UAAU;;AAE5C,sBAAsB,8EAAgC;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE,qCAAY,kBAAkB,MAAM;;AAEtC;AACA,gBAAgB,8CAAgB;;AAEhC;AACA,IAAI,qCAAY,qBAAqB,UAAU;AAC/C,IAAI,qCAAY,UAAU,sCAAsC;AAChE,4BAA4B,uBAAc;AAC1C;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,4CAA4C,aAAa;AACzD,KAAK;AACL;AACA;AACA,IAAI;AACJ,IAAI,qCAAY,UAAU,sCAAsC;AAChE;AACA,MAAM,qCAAY,kBAAkB,aAAa;AACjD;AACA;;AAEA;;AAEA,0CAA0C,gBAAgB,IAAI,aAAa;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uBAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA,KAAK;AACL,IAAI;AACJ,4BAA4B,uBAAc;AAC1C;AACA,WAAW,cAAc;;AAEzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU,UAAU,+CAA+C,OAAO,4BAA4B;AAC/I;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW,IAAI,8BAA8B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,aAAa,+CAA+C,OAAO,4BAA4B;AACvJ;AACA,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,aAAa,aAAa,+CAA+C,OAAO,4BAA4B;AACrJ;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;;AAEe;AACf;;AAEA;AACA;AACA;;AAEA;AACA,EAAE,qCAAY;AACd;AACA;AACA;AACA;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA;AACA;AACA,qFAAqF,4BAA4B;AACjH,UAAU;AACV;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA,EAAE,qCAAY;AACd;;AAEA;AACA,EAAE,qCAAY;AACd;AACA;AACA;AACA,QAAQ,qCAAY,6BAA6B,UAAU;AAC3D,uBAAuB,gDAAiB;AACxC;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA,EAAE,qCAAY;AACd;AACA;AACA;AACA;AACA;AACA,uCAAuC,uCAAuC,OAAO,4BAA4B;AACjH;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA,EAAE,qCAAY;AACd;AACA;AACA,qBAAqB,gDAAiB;AACtC;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL,EAAE,qCAAY;AACd,4BAA4B,iBAAiB;AAC7C,2BAA2B,gDAAiB;AAC5C;AACA;AACA;AACA,GAAG;;AAEH,EAAE,qCAAY;AACd,EAAE,WAAW;AACb,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;;;AChX6C;;AAE7C;AACO,SAAS,8BAAsB;AACtC,SAAS,2EAAmC;AAC5C;;AAEA;AACO,SAAS,oCAA4B;AAC5C,SAAS,2EAAmC;AAC5C;;AAEA;AACO,SAAS,8BAAsB;AACtC;AACA,MAAM,8BAAsB;AAC5B,0BAA0B,oCAA4B;AACtD,IAAI;AACJ;AACA,IAAI,8BAAsB;AAC1B;AACA;AACA,0BAA0B,oCAA4B;AACtD,IAAI;AACJ;AACA;AACA;AACA;AACA;;;AC5B6C;AACV;AAC2B;;AAE9D;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA,sBAAsB,oDAAmB;;AAEzC;AACA,4CAA4C,iBAAiB;;AAE7D;AACA,2BAA2B,oDAAmB;AAC9C;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;;AAEA;AACA;;AAEe,SAAS,oBAAY;AACpC;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,gDAAiB;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,kCAAkC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,6CAA6C;AAC1F;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,uBAAuB,GAAG,YAAY;AAC3H;AACA;AACA;AACA,0BAA0B,qEAAgC;AAC1D;AACA;AACA;AACA;AACA,QAAQ,qEAAgC;AACxC;AACA;AACA,QAAQ,qEAAgC;AACxC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,iFAAsC;AAC1C,mBAAmB,wEAA6B;AAChD,mBAAmB,wDAAqB,yBAAyB,aAAa;AAC9E;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,+BAA+B,uEAAiC;AAChE,kCAAkC,8BAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;;ACtKA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;;AC5EmC;;AAEnC;AAC2C;AACF;AACI;AAC+D;AACvE;;AAE9B;AACP;AACA;AACA,kBAAkB,UAAU;;AAE5B,EAAE,qCAAY;AACd;;AAEA,uBAAuB,gEAAyB;;AAEhD;AACA;AACA;AACA;AACA,gCAAgC,8BAAsB;AACtD,4BAA4B,4DAAuB;;AAEnD,IAAI,qCAAY;;AAEhB;AACA,MAAM,wEAA6B;AACnC;AACA;AACA,6BAA6B,wCAAwC;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,QAAQ;AACR;AACA;AACA,gCAAgC,UAAU;AAC1C,QAAQ;AACR;AACA,QAAQ,mCAAW,oBAAoB,uBAAuB,oBAAoB,0BAA0B;AAC5G;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,sBAAsB,0EAA8B;AACpD;;AAEA,IAAI,qCAAY;AAChB;AACA;AACA;AACA;AACA;AACA,MAAM,mCAAW,kBAAkB,sBAAsB;AACzD;AACA;AACA,gBAAgB,kEAA0B;;AAE1C,wBAAwB,kEAA0B;;AAElD,IAAI,qCAAY;;AAEhB,QAAQ,8BAAsB;AAC9B,4BAA4B,oCAA4B;AACxD,MAAM;AACN,4BAA4B,8BAAsB;AAClD;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,4BAA4B,4DAAuB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B,MAAM;AACN;AACA;AACA,8BAA8B,UAAU;AACxC,MAAM;AACN;AACA,MAAM,mCAAW,oBAAoB,uBAAuB,oBAAoB,eAAe;AAC/F;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8BAAsB;AAC9B,4BAA4B,oCAA4B;AACxD;;AAEA,4BAA4B,4DAAuB;;AAEnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;;AAEA,eAAe,UAAU;AACzB,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8BAAsB;AAC9B,4BAA4B,oCAA4B;AACxD;;AAEA,4BAA4B,4DAAuB;;AAEnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;;AAEA,eAAe,UAAU;AACzB,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8BAAsB;AAC9B,4BAA4B,oCAA4B;AACxD;;AAEA,4BAA4B,4DAAuB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;;AAEA,eAAe,UAAU;AACzB,GAAG;;AAEH,aAAa,SAAS;;AAEtB;AACA;;;;ACzUmC;;AAEnC;AAC2C;AACF;AACI;AACuC;;;AAG7E,SAAS,2BAAa;AAC7B;AACA;AACA,kBAAkB,UAAU;;AAE5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU,8BAAsB;AAChC,8BAA8B,oCAA4B;AAC1D;;AAEA,8BAA8B,4DAAuB;AACrD;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB,GAAG,cAAc;AACnE;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA,eAAe,UAAU;AACzB,GAAG;;AAEH,aAAa,SAAS;;AAEtB;AACA;;;ACpEA;AACmC;;AAEnC;AACA;AACA,gBAAgB,8EAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;;AAEA,wBAAwB,kDAAkB,GAAG,qCAAqC;AAClF,wBAAwB,wDAAqB;AAC7C,6BAA6B,kDAAkB,GAAG,iCAAiC;AACnF,sBAAsB,wDAAqB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kMAAkM;AAClM;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA,MAAM,8EAAgC;AACtC,sCAAsC,YAAY;AAClD,IAAI;AACJ,6BAA6B,eAAe,IAAI,YAAY;AAC5D,iDAAiD,0BAA0B;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnJgD;AACD;AACE;AACY;AACjB;AACwB;AACV;AACH;AACP;AACJ;AACV;AAC4B;;AAEvD;AACP;AACA,IAAI,qCAAY;AAChB,oBAAoB,YAAY;AAChC;AACA,MAAM,qCAAY;AAClB,wBAAwB,kBAAkB;AAC1C;AACA,IAAI,qCAAY;AAChB,qBAAqB,UAAU;AAC/B,IAAI,qCAAY;AAChB,mCAAmC,aAAW;AAC9C,IAAI,qCAAY;AAChB,kBAAkB,oBAAU;AAC5B,IAAI,qCAAY;AAChB,iBAAiB,kBAAkB;AACnC,IAAI,qCAAY;AAChB,wBAAwB,YAAU;AAClC,IAAI,qCAAY;AAChB,qBAAqB,2BAAa;AAClC,IAAI,qCAAY;AAChB,oBAAoB,YAAY;AAChC,IAAI,qCAAY;;AAEhB,0BAA0B,oBAAoB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI,OAAU;;AAEd;AACA,IAAI;AACJ,IAAI,qCAAY;AAChB,IAAI,qCAAY;AAChB;AACA;AACA;;;;;;;;;ACzDO;AACP;AACA,6BAA6B,SAAS,eAAe;AACrD;AACA;;AAEO;AACP;AACA,6BAA6B,SAAS,eAAe;AACrD;AACA;;AAEO;AACP;AACA,6BAA6B,SAAS,eAAe;AACrD;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,6BAA6B,SAAS,eAAe;AACrD;AACA;;;AC7BgC;AACE;;AAElC;AACA,IAAI,+FAA+F;AACnG,IAAI,+FAA+F;AACnG,IAAI,iGAAiG;AACrG,IAAI,sGAAsG;AAC1G,IAAI,sGAAsG;AAC1G,IAAI,sGAAsG;AAC1G,IAAI,sGAAsG;AAC1G,IAAI,sGAAsG;AAC1G,IAAI,sGAAsG;AAC1G,IAAI,qGAAqG;AACzG,IAAI,iGAAiG;AACrG,IAAI,2GAA2G;AAC/G,IAAI,mGAAmG;AACvG,IAAI,mGAAmG;AACvG,IAAI,oGAAoG;AACxG,IAAI,kGAAkG;AACtG,IAAI,4FAA4F;AAChG,IAAI,sGAAsG;AAC1G,IAAI,gGAAgG;AACpG,IAAI,wGAAwG;AAC5G;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACO;AACP,yBAAyB,8EAAgC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mCAAW,0BAA0B,OAAO,MAAM,iBAAiB,KAAK,YAAY,GAAG,WAAW;AAC1G,0EAA0E,qBAAqB;AAC/F,QAAQ;AACR;AACA,QAAQ,mCAAW,cAAc,iBAAiB,qBAAqB,MAAM,QAAQ,YAAY,GAAG,WAAW;AAC/G;AACA;AACA,KAAK;AACL;AACA;;;ACxFkC;AACF;AACe;AACW;AACa;AACb;AAChB;AACiB;AACqE;AACxD;;AAExE;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C,wCAAwC,WAAW;AACnD,iCAAiC,WAAW;AAC5C;AACA;;AAEO;AACP;AACA,2BAA2B,mCAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;;AAE/D;AACA;;AAEA;AACA;AACA,sBAAsB,6CAAkB;AACxC;AACA;;AAEA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA,qBAAqB,+BAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA,SAAS,WAAW,kBAAkB,KAAK;AAC3C,SAAS,WAAW,gBAAgB,KAAK;;AAEzC,EAAE,qCAAY;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU,mCAAW;AACrB;AACA;AACA,QAAQ,qCAAY,IAAI,MAAM;AAC9B;AACA,OAAO;AACP;AACA;AACA,QAAQ,qCAAY,YAAY,MAAM;AACtC,QAAQ,qCAAY;AACpB,QAAQ,qCAAY;AACpB;AACA,OAAO;AACP,GAAG;AACH;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,yCAAyC,kCAAkC;AAC3E;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,0BAA0B,cAAc;AACxC,oBAAoB,QAAQ;AAC5B,qDAAqD,EAAE;AACvD,0DAA0D,EAAE;AAC5D;AACA,yCAAyC,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,0BAA0B,cAAc;AACxC,oBAAoB,QAAQ;AAC5B,qDAAqD,EAAE;AACvD,+EAA+E,EAAE;AACjF;AACA,yCAAyC,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,0BAAO;;AAExB;AACA;AACA,MAAM;AACN;AACA;;AAEA,GAAG;AACH;;AAEA;AACA;AACA,+CAA+C,6CAA6C;AAC5F,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA,2BAA2B,8EAAgC;AAC3D;AACA,IAAI,uBAAuB;AAC3B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,iBAAiB,0BAAO;;AAExB;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,sDAAsD,wBAAwB;AAC9E,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,iBAAiB,0BAAO,GAAG;AAC3B;AACA,sDAAsD,wBAAwB;AAC9E;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,qCAAY;AAClB;AACA;AACA;AACA;AACA,QAAQ,qCAAY,WAAW,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE,qCAAY;;AAEd;AACA;AACA;;AAEA;AACA,EAAE,qCAAY;;AAEd;AACA;AACA,IAAI,qCAAY;AAChB,IAAI;AACJ,IAAI,qCAAY;AAChB,IAAI,qCAAY;AAChB,IAAI,qCAAY;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,MAAM,qCAAY;AAClB,MAAM,qCAAY;;AAElB;AACA;AACA;AACA,QAAQ;AACR,QAAQ,qCAAY;AACpB,QAAQ,qCAAY;AACpB,QAAQ,qCAAY;AACpB;;AAEA,MAAM;AACN,MAAM,qCAAY;AAClB,MAAM,qCAAY;AAClB,MAAM,qCAAY;AAClB,MAAM,qCAAY;AAClB,MAAM,qCAAY;AAClB,MAAM,qCAAY;AAClB;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,2EAAmC;AACvC;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,2EAAmC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM,qCAAY,kBAAkB,UAAU;AAC9C;AACA;AACA,QAAQ;AACR,uEAAuE,6CAA6C;AACpH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,2EAAmC;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uBAAuB;AACvB;AACA,GAAG;AACH;AACA,uBAAuB;AACvB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD,wBAAwB,aAAa;AACrC;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEO;AACP,4BAA4B,4BAA4B;AACxD,QAAQ,qBAAqB;;AAE7B,4BAA4B,WAAW;;AAEvC;AACA,IAAI,qCAAY;AAChB,IAAI;AACJ,IAAI,qCAAY;AAChB,IAAI,qCAAY;AAChB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;;AAEtC,EAAE,qCAAY;AACd,EAAE,qCAAY;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,uBAAuB;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,qCAAY;AACd,QAAQ,oBAAoB;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,QAAQ,qCAAY;AACpB;AACA;AACA;AACA,QAAQ,qCAAY;AACpB;AACA;AACA;AACA;AACA;AACA,UAAU,qCAAY;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU,qCAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qCAAY;AACpB;AACA;AACA;AACA,QAAQ,qCAAY;AACpB;AACA;AACA;AACA,QAAQ,qCAAY;AACpB;AACA;AACA;AACA,QAAQ,qCAAY;AACpB;AACA;AACA;AACA;;AAEA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,QAAQ,eAAe;AACvD;AACA;AACA;;AAEA;AACA,wBAAwB,0BAA0B;AAClD,UAAU,qCAAY,kBAAkB,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM,qCAAY;AAClB;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN,MAAM,mCAAW;AACjB;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,MAAM,qCAAY;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,2EAAmC;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,qCAAY;AACtB;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR,QAAQ,qCAAY;AACpB;AACA,QAAQ;AACR;AACA;AACA,QAAQ,qCAAY;AACpB;AACA,UAAU,qCAAY;AACtB;AACA,wBAAwB,uBAAuB;AAC/C;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM,qCAAY,iBAAiB,qBAAqB;AACxD;AACA;AACA,QAAQ,qCAAY,kBAAkB,qBAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM,qCAAY,iBAAiB,qBAAqB;AACxD;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA,QAAQ,qCAAY,kBAAkB,qBAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8EAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACnxC0C;AACY;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,qBAAqB;AACrB,KAAK;AACL;AACA;AACA;;;AAGO;AACP;;AAEA,EAAE,iFAAsC;AACxC;AACA,yBAAyB,kDAAsB,iDAAiD,cAAc;AAC9G,GAAG;;AAEH;AACA;;;ACvCgC;AACE;AACiB;AAYrB;AACmD;AAC9B;AACE;AACJ;AACH;AACJ;AACsC;AACjC;AACa;AACY;AAKxC;AACuE;AACvD;;AAEhD;;AAEA,MAAM,8BAAuB;AAC7B;AACA;AACA;AACA;;AAEA;AACA,MAAM,aAAM;AACZ;AACA;AACA;AACA,MAAM,kBAAW;AACjB,MAAM,aAAM,WAAW,aAAM;AAC7B,IAAI,aAAM;AACV,IAAI,aAAM;AACV,IAAI;AACJ;AACA;AACA;AACA,IAAI,aAAM;AACV;AACA;AACA,iDAAiD,MAAM,UAAU,OAAO;AACxE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA,kGAAkG,YAAY;AAC9G;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAA0B;AAC7D;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,mCAAmC,yDAA0B;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd;;AAEO;AACP;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,qBAAqB,+BAAa;AAClC;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,UAAU,uCAAY;;AAEtB,gCAAgC,YAAY,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,IAAI,qCAAY;AAChB,IAAI,qCAAY;AAChB;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ,0BAAQ,0BAA0B,oBAAoB;AAC9D;AACA;AACA;AACA,IAAI;AACJ,IAAI,qCAAY;AAChB,IAAI,qCAAY;AAChB,IAAI,qCAAY;AAChB;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAkE;;AAExF;AACA;;AAEA;AACA;AACA,wBAAwB,oCAAoC,GAAG,MAAM,OAAO,gBAAgB,QAAQ,WAAW;AAC/G;AACA;;AAEA;AACA;AACA,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAsB;AAC9B;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mCAAW,wBAAwB,kBAAkB;AACnE;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI,qCAAY;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,gDAAiB;AACzC;AACA;AACA,gCAAgC,gDAAiB,uDAAuD,SAAS;AACjH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,0BAA0B;;AAErD;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,aAAa;AACrC,yBAAyB,SAAS;AAClC;AACA,iCAAiC,mCAAiB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mBAAmB;AAC3B,OAAO;;AAEP;AACA;AACA;AACA;AACA,QAAQ,2CAA2C;AACnD,OAAO;;AAEP;AACA;AACA;AACA,6BAA6B,SAAS,eAAe,aAAa;AAClE;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,mCAAmC,SAAS,eAAe;AAC3D;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,qCAAY;AACtB;AACA;AACA,YAAY,0BAAQ,mCAAmC,YAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,cAAc,qCAAY;AAC1B,cAAc,qCAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA,YAAY,qCAAY;AACxB;AACA;AACA,WAAW;AACX,UAAU;AACV,UAAU,qCAAY;AACtB,UAAU,qCAAY;AACtB;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B;AACA,UAAU;AACV,UAAU,qCAAY;AACtB,UAAU,qCAAY;AACtB;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,cAAc,SAAS,GAAG;AAC1B;AACA,UAAU;AACV,UAAU,qCAAY;AACtB,UAAU,qCAAY;AACtB;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,qCAAY;AACtB;AACA;AACA,YAAY,0BAAQ,mCAAmC,YAAY;AACnE;AACA;AACA,kBAAkB,iCAAe;AACjC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,cAAc,qCAAY;AAC1B,cAAc,qCAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAW;AACrB,UAAU;AACV;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8EAAgC;AAC5D,6BAA6B,8EAAgC;AAC7D,yBAAyB,8EAAgC;AACzD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,+CAAoB;AAC1C;;AAEA;AACA;AACA,sBAAsB,iCAAgB;AACtC;;AAEA;AACA;AACA,sBAAsB,uCAAY;AAClC;;AAEA;AACA;AACA,sBAAsB,iDAAsB;AAC5C;;AAEA;AACA;AACA,sBAAsB,iDAAsB;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,8BAAc;AACpC;;AAEA;AACA,sBAAsB,6CAAkB;AACxC;;AAEA,oBAAoB,8CAAmB;AACvC;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,8CAA8C,8BAAuB;AACrE;;AAEA;AACA;AACA;AACA;;AAEA,IAAI,qCAAY,gDAAgD,QAAQ;AACxE;;AAEA,IAAI,qCAAY;AAChB,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;;AAEP,MAAM,qCAAY;AAClB;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,gCAAgC,8EAAgC;AAChE;AACA;;AAEA;AACA;AACA;AACA,YAAY,6CAAkB;AAC9B;;AAEA,IAAI,qCAAY;AAChB;AACA;;AAEA,IAAI,qCAAY;AAChB;;AAEA;AACA;;AAEA,IAAI,qCAAY;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mCAAW,sCAAsC,UAAU;AAClF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,mCAAW;AACjB,4CAA4C,6CAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,mCAAW;AACjB,2CAA2C,gDAAqB;AAChE,6CAA6C,gDAAqB;AAClE,yCAAyC,gDAAqB;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,mCAAW;AACjB,2CAA2C,6CAAkB;AAC7D,6CAA6C,6CAAkB;AAC/D,yCAAyC,6CAAkB;;AAE3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,qCAAY;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,mCAAW;AACjB;AACA;;AAEA;AACA;AACA,MAAM,mCAAW;AACjB;AACA;;AAEA;AACA;AACA,MAAM,mCAAW;AACjB;AACA;;AAEA,IAAI,qCAAY;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;;AAEA;AACA,0DAA0D,wDAAwD;AAClH;AACA,iCAAiC,cAAc;AAC/C;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAI,qCAAY;;AAEhB;AACA,8BAA8B,4BAA4B;AAC1D,UAAU,qBAAqB;;AAE/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI,qCAAY;AAChB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,4DAA4D,qCAAqC;AACjG,OAAO;AACP;;AAEA;;AAEA,UAAU,oBAAoB;AAC9B,UAAU,aAAa;AACvB;AACA;;AAEO;AACP;AACA,sBAAsB,4CAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,YAAY;AACrE,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,0BAAQ,mCAAmC,YAAY;AAC7D;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,qCAAY;AAClB;AACA;AACA,IAAI;AACJ;AACA;AACA,QAAQ,qCAAY;AACpB;AACA;AACA,QAAQ,qCAAY;AACpB,QAAQ,qCAAY;AACpB;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,sBAAsB,4CAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,qCAAY;AAChB;AACA;AACA,MAAM,0BAAQ,mCAAmC,YAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,mCAAW;AACjB;AACA,MAAM;AACN,MAAM,qCAAY;AAClB;AACA;AACA,IAAI;AACJ;AACA;AACA,QAAQ,qCAAY;AACpB;AACA;AACA,QAAQ,qCAAY;AACpB,QAAQ,qCAAY;AACpB;AACA;AACA;AACA;AACA;;;ACnxCA;AAC4D;AAC0B;AACpD;AACF;AACc;AACa;AACb;AAOvB;AACqB;AACiB;;AAE7D;AACA,IAAI,+CAA+C;AACnD,IAAI,qCAAqC;AACzC,IAAI,uCAAuC;AAC3C,IAAI,sCAAsC;AAC1C,IAAI,qCAAqC;AACzC;;AAEA;AACA,IAAI,kEAAkE;AACtE,IAAI,0EAA0E;AAC9E,IAAI,yEAAyE;AAC7E,IAAI,sEAAsE;AAC1E,IAAI,oEAAoE;AACxE,IAAI,sEAAsE;AAC1E,IAAI,oEAAoE;AACxE;;AAEA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU,2BAAS,iBAAiB,aAAa;AACjD;AACA;AACA;AACA,UAAU,0BAAQ;AAClB;AACA;AACA,OAAO;AACP;AACA,QAAQ,2BAAS,cAAc,kBAAkB;AACjD,QAAQ,mCAAW,cAAc,kBAAkB;AACnD;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEO;AACP;AACA,EAAE,qCAAY;AACd,EAAE,2BAAS;AACX;AACA,EAAE,2BAAS;AACX;AACA;;AAEA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;;AAEA,EAAE,qCAAY,IAAI,sBAAsB;AACxC,EAAE,qCAAY;AACd;AACA,EAAE,qCAAY,uBAAuB,WAAW;AAChD;AACA,EAAE,qCAAY,IAAI,2BAA2B;AAC7C;AACA;;AAEO;AACP,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAmE;AACzF;AACA;;AAEA;AACA,IAAI,qCAAY,2BAA2B,GAAG;AAC9C;AACA,wBAAwB,gDAAsB;AAC9C,iCAAiC,0CAA0C;;AAE3E;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI,qCAAY;AAChB;AACA;AACA;AACA;AACA,8BAA8B,wFAAwF;AACtH,QAAQ;AACR,iCAAiC,uCAAuC;AACxE;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yEAAyE;AAC5G,UAAU;AACV,sCAAsC,2CAA2C;AACjF;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,IAAI,qCAAY;;AAEhB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM,qCAAY;AAClB,YAAY,aAAa;AACzB,MAAM,qCAAY;AAClB;;AAEA,wBAAwB,gDAAsB;AAC9C,iCAAiC,0CAA0C;AAC3E,2BAA2B,oCAAkB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe,GAAG,mBAAmB,EAAE,EAAE,oBAAoB;AACnG;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,yCAAyC,4CAAe;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI,qCAAY;AAChB,UAAU,oBAAoB;AAC9B;AACA;AACA;AACA;AACA,QAAQ,mCAAW;AACnB,+BAA+B,YAAY,cAAc,aAAa,OAAO,2BAA2B,UAAU,SAAS;AAC3H;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV,UAAU,qCAAY;AACtB,UAAU,mCAAW,2BAA2B,YAAY,UAAU,UAAU;AAChF,UAAU,qCAAY;AACtB,+EAA+E,SAAS,KAAK,WAAW,0BAA0B,GAAG,EAAE;AACvI;AACA;AACA;AACA,6DAA6D,mBAAmB;AAChF,KAAK;;AAEL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,cAAc,mBAAmB;AACjC,OAAO;AACP;AACA;;AAEA;AACA,IAAI,qCAAY;AAChB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA,kCAAkC,4CAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB,GAAG,iBAAiB;AAChF,SAAS;AACT;AACA;AACA;AACA,kEAAkE,gCAAgC,IAAI,+BAA+B;AACrI;AACA;AACA,kDAAkD,2BAA2B;AAC7E;AACA;AACA,8CAA8C,uBAAuB;AACrE;;AAEA;AACA;AACA;AACA;AACA,QAAQ,mCAAW,sBAAsB,aAAa;AACtD;AACA;AACA,UAAU;AACV,UAAU,qCAAY;AACtB,UAAU,mCAAW,6BAA6B,aAAa;AAC/D;AACA,QAAQ;AACR,QAAQ,mCAAW,qBAAqB,aAAa;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;;AAGA;AACA,kCAAkC,4CAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM,qCAAY,kCAAkC,oBAAoB;AACxE;AACA,MAAM;AACN;AACA;AACA,QAAQ,qCAAY,0BAA0B,qBAAqB,mBAAmB,oBAAoB;AAC1G;AACA,QAAQ;AACR,QAAQ,mCAAW,yBAAyB,aAAa;AACzD,gDAAgD,aAAa;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mCAAW,qBAAqB,gBAAgB,MAAM,oBAAoB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,QAAQ,mCAAW,qBAAqB,sBAAsB,GAAG,kBAAkB,QAAQ,oBAAoB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,mCAAW,mBAAmB,eAAe;AACrD;AACA;AACA,UAAU,mCAAW,wBAAwB,eAAe;AAC5D;AACA,kEAAkE,iBAAiB;AACnF;AACA,UAAU;AACV,UAAU,mCAAW,4BAA4B,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ,mCAAW,oBAAoB,eAAe;AACtD;AACA;AACA;AACA,UAAU;AACV,UAAU,qCAAY;AACtB,UAAU,mCAAW,2BAA2B,eAAe;AAC/D;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yDAAyD,cAAc;;AAEvE;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,qCAAY,kCAAkC,oBAAoB;;AAEtE;AACA;;AAEA;AACA,wCAAwC,sBAAsB;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,qBAAqB;AAC7B,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mBAAmB;AAC3B,OAAO;;AAEP;AACA;AACA;AACA;AACA,QAAQ,2CAA2C;AACnD,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,IAAI,eAAe;AAC3E,uCAAuC,wBAAwB;AAC/D,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+EAA+E,eAAe;AAC9F,wEAAwE,aAAa;AACrF;AACA;AACA;AACA,SAAS,IAAI,6EAA6E;AAC1F;AACA;AACA;AACA;AACA,SAAS,cAAc,uEAAuE;AAC9F;;AAEA,4GAA4G,eAAe;AAC3H;AACA,+GAA+G,kBAAkB;AACjI;AACA;AACA,uDAAuD,kBAAkB,4BAA4B,eAAe,EAAE,qBAAqB;AAC3I;AACA;AACA,qDAAqD,gBAAgB,0BAA0B,aAAa,EAAE,mBAAmB;AACjI;AACA,uIAAuI,2BAA2B,IAAI,0BAA0B;AAChM;AACA,+GAA+G,kBAAkB;AACjI;;AAEA;AACA,6LAA6L,kBAAkB;AAC/M;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6FAA6F,oBAAoB;AACjH,uDAAuD,cAAc,wBAAwB,oBAAoB;AACjH,KAAK;AACL;;AAEA;AACA;AACA;AACA,kBAAkB,iCAAe;AACjC,qCAAqC,qBAAqB;AAC1D;;AAEA,8BAA8B,0BAA0B;AACxD,4BAA4B,kBAAkB;;AAE9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,8CAA8C,kBAAkB;AAChE;AACA,mBAAmB,WAAW,EAAE,WAAW;AAC3C;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,qCAAY;;AAEhB;AACA;AACA;;;AC33BqC;;AAErC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,mCAAW,gBAAgB,eAAe;AAC9C;AACA,IAAI;AACJ,IAAI,mCAAW,mBAAmB,gBAAgB;AAClD;AACA,wBAAwB,qBAAqB,GAAG,eAAe;AAC/D,4DAA4D,KAAK;AACjE;AACA,MAAM,mCAAW,+BAA+B,eAAe,8CAA8C,KAAK;AAClH,MAAM;AACN;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA,OAAO;AACP,oEAAoE,KAAK;AACzE;AACA;AACA;AACA;;AAEO;AACP,IAAI,gEAAgE;AACpE,IAAI,8DAA8D;AAClE,IAAI,qEAAqE;AACzE,IAAI,8DAA8D;AAClE,IAAI,0EAA0E;AAC9E,IAAI,iEAAiE;AACrE,IAAI,uEAAuE;AAC3E,IAAI,8DAA8D;AAClE,IAAI,qEAAqE;AACzE,IAAI,qEAAqE;AACzE;;AAEO;AACP;AACA;AACA,GAAG;AACH;;AAEA,6BAAe,eAAe,mBAAG;AACjC;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA,MAAM,mCAAW;AACjB;AACA;AACA;;AAEA;;;ACzEA;AACiE;AACX;AACF;AACM;AACsD;AAC/B;AACZ;AACN;AACkB;AACsB;AACpD;AACI;AACC;AACU;;AAElE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;;AAEO;AACP;AACA,iBAAiB;AACjB,iBAAiB;AACjB,eAAe;AACf,cAAc;AACd,mBAAmB;AACnB,2BAA2B;AAC3B;AACA;AACA;AACA,sBAAsB;AACtB,kBAAkB;AAClB,mBAAmB;AACnB,kBAAkB;AAClB,gBAAgB;AAChB,eAAe;AACf,qBAAqB;AACrB,kDAAkD,mDAAyB;AAC3E,mCAAmC;AACnC,mBAAmB;AACnB,uBAAuB;AACvB,gBAAgB,QAAQ;AACxB,iBAAiB,WAAW;AAC5B;AACA;;;AChEkC;;AAE3B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAM,qCAAY,aAAa,SAAS,kBAAkB,cAAc;AACxE;AACA,QAAQ,qCAAY;AACpB;AACA,oCAAoC,cAAc,GAAG,QAAQ;AAC7D;AACA,UAAU,mCAAW,oCAAoC,SAAS;AAClE;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA,MAAM,qCAAY,eAAe,UAAU;AAC3C;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,uFAAuF,eAAe,GAAG,WAAW;;AAEpH,IAAI,qCAAY;AAChB;AACA;;AAEA;;;AC3DwD;AACnB;AAC6B;AACF;;AAEhE;AACA;AACA,MAAM,qBAAM;AACZ;AACA;AACA;AACA,MAAM,0BAAW;AACjB,MAAM,qBAAM,WAAW,qBAAM;AAC7B,IAAI,qBAAM;AACV,IAAI,qBAAM;AACV,IAAI;AACJ;AACA;AACA;AACA,IAAI,qBAAM;AACV;AACA;AACA,iDAAiD,MAAM,UAAU,OAAO;AACxE;AACA;AACA;AACA;;AAEA,6BAAe,SAAS,iBAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kGAAkG,WAAW;AAC7G,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,iBAAiB,iBAAiB;AAChD,UAAU;AACV;AACA,iBAAiB,0BAAW;AAC5B,UAAU;AACV;AACA,iBAAiB,0BAAW;AAC5B,UAAU;AACV;AACA;AACA;AACA;AACA,mBAAmB,0BAAW;AAC9B;AACA,UAAU;AACV,gCAAgC,eAAe;;AAE/C;AACA,sCAAsC,eAAe,CAAC,8BAA8B;AACpF;AACA,YAAY;AACZ,gBAAgB,QAAQ;AACxB;;AAEA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gGAAgG,WAAW;AAC3G,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,iBAAiB,iBAAiB;AAChD,UAAU;AACV,UAAU,qCAAY,oBAAoB,IAAI;AAC9C,UAAU,0BAAW;AACrB;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;AC9J+D;AAC6B;AACvD;;AAErC;AACA;AACA;AACA,eAAe;AACf;;AAEA,6BAAe,SAAS,uBAAG;;AAE3B;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,UAAU,qBAAqB;AAC/B;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,UAAU,0DAAyB;AACnC;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,UAAU,0DAAyB;AACnC;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,4DAA0B,CAAC,kDAAqB;AACtD;AACA,IAAI,4DAA0B,CAAC,kDAAqB;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,0DAAyB;AACnC;AACA,GAAG;;AAEH;AACA;AACA,IAAI,4DAA0B,CAAC,kDAAqB;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0DAAyB;AACnC,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0DAAyB;AACnC,GAAG;;AAEH;;AAEA;AACA,wCAAwC,cAAc;AACtD,mBAAmB,kDAAqB;;AAExC;AACA,MAAM,oDAAsB,wCAAwC,uBAAuB;AAC3F;AACA,UAAU,mCAAW;AACrB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,UAAU,qCAAY;AACtB;AACA,OAAO;AACP;;AAEA,IAAI,4DAA0B,CAAC,kDAAqB;AACpD;;AAEA;AACA,SAAS,iBAAiB;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0DAAyB;AACnC,GAAG;;AAEH;AACA;AACA,IAAI,4DAA0B,CAAC,kDAAqB;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;ACj6CO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AC9EwD;AACQ;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,MAAM,mCAAmC,WAAW;AACjH;AACA;AACA,UAAU,iBAAiB,iBAAiB;AAC5C,MAAM;AACN,UAAU,aAAa,iBAAiB;AACxC;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEO;AACP;AACA;;;;ACxBmC;AACE;;AAErC;AACA;AACA;AACA,2DAA2D,cAAc,GAAG,YAAY;AACxF,wEAAwE,cAAc,GAAG,YAAY;AACrG;;AAEA;AACA;AACA;AACA,YAAY,sCAAsC;AAClD,aAAa;AACb,IAAI;AACJ,IAAI,qCAAY;AAChB;AACA;;AAEA;AACA;AACA;AACA,YAAY,4CAA4C;AACxD,aAAa;AACb,IAAI;AACJ,IAAI,qCAAY;AAChB;AACA;;AAEA,mDAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAA4C;AACxD,oCAAoC,sDAAoB;;AAExD;AACA,gCAAgC,cAAc,iCAAiC,oBAAoB,oDAAoD,iBAAiB;AACxK;;AAEA;AACA;AACA;;AAEA,YAAY,wCAAwC;;AAEpD,6BAA6B,sDAAoB;AACjD,2BAA2B,sDAAoB;AAC/C,kCAAkC,sDAAoB;;AAEtD;;AAEA,4DAA4D;AAC5D,4DAA4D;AAC5D,4DAA4D;;AAE5D,oBAAoB,qCAAY,kBAAkB,cAAc;;AAEhE;AACA;AACA,eAAe,cAAc,0BAA0B,YAAY,kDAAkD,cAAc;AACnI;AACA;AACA;AACA,IAAI;AACJ,IAAI,mCAAW;AACf,sEAAsE,aAAa;AACnF;AACA,CAAC,EAAC;;;ACxEK;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;;AC1C8C;AAC2C;AACtC;;;AAG5C;AACP;AACA;;AAEA;AACA;AACA,4BAA4B,eAAe;;AAE3C;AACA,mCAAmC,WAAW;AAC9C;AACA,+BAA+B,UAAU;AACzC;AACA,gBAAgB,UAAU;AAC1B;AACA,UAAU;AACV,cAAc,SAAS;AACvB;AACA,QAAQ;AACR;AACA,YAAY,QAAQ;AACpB;AACA,KAAK;;AAEL;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;;ACrCgE;AACyB;AACtC;AACM;AACpB;;;AAG9B;AACP;AACA,gBAAgB,iCAAe;AAC/B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe;;AAE7C;AACA,qCAAqC,WAAW;AAChD;AACA,iCAAiC,UAAU;AAC3C;AACA,kBAAkB,iBAAiB;AACnC;AACA,YAAY;AACZ;AACA,gBAAgB,SAAS;AACzB;AACA,UAAU;AACV;AACA,cAAc,QAAQ;AACtB;AACA,QAAQ;AACR,QAAQ,qCAAY;AACpB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA,KAAK;;AAEL;AACA;;;ACzDA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA,GAAG;AACH;;AAEA;AACA;AACA,8CAA8C,MAAM,OAAO,IAAI;AAC/D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;;AAEX,SAAS;AACT;AACA,KAAK;AACL;;;AC/DmC;;AAE5B;AACP;AACA;AACA,qBAAqB,8EAAgC;AACrD,IAAI,8EAAgC;AACpC,IAAI,8EAAgC;;AAEpC;;AAEA;AACA;AACA;AACA;AACA,iGAAiG;;AAEjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,KAAK,iEAAiE,OAAO,MAAM,EAAE,MAAM;AAClH;AACA;;AAEA;AACA;AACA,2FAA2F;AAC3F;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA,oEAAe,UAAU,EAAC;;;ACjHsC;AACvB;AACO;;AAEhD,MAAM,gBAAM;AACZ;AACA;AACA;AACA,MAAM,qBAAW;AACjB,MAAM,gBAAM,WAAW,gBAAM;AAC7B,IAAI,gBAAM;AACV,IAAI,gBAAM;AACV,IAAI;AACJ;AACA;AACA;AACA,IAAI,gBAAM;AACV;AACA;AACA,iDAAiD,MAAM,UAAU,OAAO;AACxE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kEAAkE,MAAM,mCAAmC,WAAW;AACtH;AACA;AACA,UAAU,iBAAiB,iBAAiB;AAC5C,MAAM;AACN;AACA;AACA,yBAAyB,qDAAuB;AAChD,aAAa,qBAAW,qCAAqC,qBAAqB,GAAG,WAAW;AAChG;AACA;AACA,GAAG;;AAEH;AACA;AACA,EAAE,6BAAU;AACZ;;;AAGA,gDAAe,cAAc,EAAC;;;ACnD9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,sDAAsD,gBAAgB,YAAY;;AAElF;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,wEAAwE;AACtF;AACA;AACA;AACA;AACA,YAAY,kFAAkF;AAC9F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA,mDAAe,qBAAqB,EAAC;;;ACrIJ;;AAEjC;AACwD;AACA;;AAExD;AAC6D;AACI;AACQ;AACrB;AACK;AACV;;AAE/C;AACkE;AACD;AACkB;;AAEnF;AACoE;;AAEpE;AACsE;AACA;AACD;;AAEX;;AAEE;;;AAG5D;AACO;AACP,EAAE,YAAY;AACd,EAAE,cAAc;AAChB,EAAE,mCAAW;AACb;;AAEA;AACO;AACP;AACA,EAAE,oBAAoB;;AAEtB;AACA,EAAE,gBAAgB;;AAElB;AACA,EAAE,YAAqB;;AAEvB;AACA;AACA;AACA,IAAI,cAAc;AAClB,IAAI,UAAU;AACd,IAAI,YAAY;AAChB,IAAI,kCAAa;AACjB,IAAI,mBAAmB;;AAEvB,GAAG;AACH;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,eAAe;AACnB,GAAG;AACH;;AAEO;AACP,EAAE,aAAa;AACf,EAAE,mBAAmB;AACrB,EAAE,UAAU;AACZ;;AAEO;AACP,EAAE,UAAU;AACZ,EAAE,UAAU;AACZ;;AAEO;AACP,EAAE,UAAU;AACZ,EAAE,UAAU;AACZ,EAAE,SAAc;AAChB;;;ACzFsC;AACO;AACA;AACX;;AAElC;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,6BAA6B,sBAAsB;AACnD,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;;AAGL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;;AAGA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,QAAQ,yDAAyB;AACjC;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qEAAqE;AAC3F;AACA;;AAEA;AACA,oDAAoD,gBAAgB;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU,GAAG,SAAS,GAAG,WAAW;AAC7E,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;;AAGA,uCAAuC;AACvC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,8BAA8B,mBAAmB;;AAEjD;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,IAAI,qCAAY;AAChB;AACA,2CAA2C,KAAK;AAChD,IAAI,0BAAQ,wCAAwC,SAAS;;AAE7D;AACA;AACA;;;;ACldA;AACkD;AACqC;;AAEvF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAAe,SAAS,6BAAC;AACzB;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,0BAA0B,8BAA8B,GAAG,2BAA2B;AACtF,4DAA4D,8BAA8B;AAC1F,4DAA4D,8BAA8B;AAC1F,wEAAwE,oCAAoC;AAC5G;AACA,0BAA0B,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,eAAe,GAAG,KAAK;AAClF,aAAa,0BAAQ,mCAAmC,SAAS;AACjE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,UAAU,mBAAmB;AAC7B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;;AC1CoB;AACiF;;AAErG;AACA,mBAAmB,IAAI;AACvB,oBAAoB,SAAS;AAC7B,kBAAkB,OAAO;AACzB,6BAA6B,gBAAgB;AAC7C,+BAA+B,kBAAkB;AACjD,4BAA4B,eAAe;AAC3C,sCAAsC,4BAA4B;AAClE,0CAA0C,4BAA4B","sources":["webpack://ddb-importer/./src/character/extras.js","webpack://ddb-importer/./src/ddbConfig.js","webpack://ddb-importer/./src/dictionary.js","webpack://ddb-importer/./src/effects/acEffects.js","webpack://ddb-importer/./src/effects/specialEquipment.js","webpack://ddb-importer/./src/effects/specialInfusions.js","webpack://ddb-importer/./src/effects/effects.js","webpack://ddb-importer/./src/effects/macros.js","webpack://ddb-importer/./src/effects/feats/kiEmptyBody.js","webpack://ddb-importer/./src/effects/feats/warCaster.js","webpack://ddb-importer/./src/effects/feats/rage.js","webpack://ddb-importer/./src/effects/specialFeats.js","webpack://ddb-importer/./src/effects/spells/absorbElements.js","webpack://ddb-importer/./src/effects/spells/aid.js","webpack://ddb-importer/./src/effects/spells/alterSelf.js","webpack://ddb-importer/./src/effects/spells/animalFriendship.js","webpack://ddb-importer/./src/effects/spells/arcaneSword.js","webpack://ddb-importer/./src/effects/spells/bane.js","webpack://ddb-importer/./src/effects/spells/banishment.js","webpack://ddb-importer/./src/effects/spells/barkskin.js","webpack://ddb-importer/./src/effects/spells/beaconofHope.js","webpack://ddb-importer/./src/effects/spells/blackTentacles.js","webpack://ddb-importer/./src/effects/spells/bless.js","webpack://ddb-importer/./src/effects/spells/blur.js","webpack://ddb-importer/./src/effects/spells/blindnessDeafness.js","webpack://ddb-importer/./src/effects/spells/callLightning.js","webpack://ddb-importer/./src/effects/spells/charmPerson.js","webpack://ddb-importer/./src/effects/spells/chromaticOrb.js","webpack://ddb-importer/./src/effects/spells/chillTouch.js","webpack://ddb-importer/./src/effects/spells/command.js","webpack://ddb-importer/./src/effects/spells/comprehendLanguages.js","webpack://ddb-importer/./src/effects/spells/confusion.js","webpack://ddb-importer/./src/effects/spells/contagion.js","webpack://ddb-importer/./src/effects/spells/crownofStars.js","webpack://ddb-importer/./src/effects/spells/darkness.js","webpack://ddb-importer/./src/effects/spells/darkvision.js","webpack://ddb-importer/./src/effects/spells/divineFavor.js","webpack://ddb-importer/./src/effects/spells/divineWord.js","webpack://ddb-importer/./src/effects/spells/dominateBeast.js","webpack://ddb-importer/./src/effects/spells/dominateMonster.js","webpack://ddb-importer/./src/effects/spells/dominatePerson.js","webpack://ddb-importer/./src/effects/spells/enhanceAbility.js","webpack://ddb-importer/./src/effects/spells/enlargeReduce.js","webpack://ddb-importer/./src/effects/spells/entangle.js","webpack://ddb-importer/./src/effects/spells/eyebite.js","webpack://ddb-importer/./src/effects/spells/faerieFire.js","webpack://ddb-importer/./src/effects/spells/fear.js","webpack://ddb-importer/./src/effects/spells/feeblemind.js","webpack://ddb-importer/./src/effects/spells/fireShield.js","webpack://ddb-importer/./src/effects/spells/flameBlade.js","webpack://ddb-importer/./src/effects/spells/fleshtoStone.js","webpack://ddb-importer/./src/effects/spells/fly.js","webpack://ddb-importer/./src/effects/spells/geas.js","webpack://ddb-importer/./src/effects/spells/grease.js","webpack://ddb-importer/./src/effects/spells/greaterInvisibility.js","webpack://ddb-importer/./src/effects/spells/guidance.js","webpack://ddb-importer/./src/effects/spells/guidingBolt.js","webpack://ddb-importer/./src/effects/spells/haste.js","webpack://ddb-importer/./src/effects/spells/heroesFeast.js","webpack://ddb-importer/./src/effects/spells/heroism.js","webpack://ddb-importer/./src/effects/spells/hideousLaughter.js","webpack://ddb-importer/./src/effects/spells/holdMonster.js","webpack://ddb-importer/./src/effects/spells/holdPerson.js","webpack://ddb-importer/./src/effects/spells/holyAura.js","webpack://ddb-importer/./src/effects/spells/huntersMark.js","webpack://ddb-importer/./src/effects/spells/hypnoticPattern.js","webpack://ddb-importer/./src/effects/spells/invisibility.js","webpack://ddb-importer/./src/effects/spells/irresistibleDance.js","webpack://ddb-importer/./src/effects/spells/light.js","webpack://ddb-importer/./src/effects/spells/longstrider.js","webpack://ddb-importer/./src/effects/spells/mageArmor.js","webpack://ddb-importer/./src/effects/spells/magicWeapon.js","webpack://ddb-importer/./src/effects/spells/massSuggestion.js","webpack://ddb-importer/./src/effects/spells/mindBlank.js","webpack://ddb-importer/./src/effects/spells/mirrorImage.js","webpack://ddb-importer/./src/effects/spells/mistyStep.js","webpack://ddb-importer/./src/effects/spells/moonbeam.js","webpack://ddb-importer/./src/effects/spells/passWithoutTrace.js","webpack://ddb-importer/./src/effects/spells/phantasmalKiller.js","webpack://ddb-importer/./src/effects/spells/protectionfromEnergy.js","webpack://ddb-importer/./src/effects/spells/protectionfromPoison.js","webpack://ddb-importer/./src/effects/spells/rayofEnfeeblement.js","webpack://ddb-importer/./src/effects/spells/rayofFrost.js","webpack://ddb-importer/./src/effects/spells/regenerate.js","webpack://ddb-importer/./src/effects/spells/resilientSphere.js","webpack://ddb-importer/./src/effects/spells/resistance.js","webpack://ddb-importer/./src/effects/spells/shield.js","webpack://ddb-importer/./src/effects/spells/shieldofFaith.js","webpack://ddb-importer/./src/effects/spells/shillelagh.js","webpack://ddb-importer/./src/effects/spells/slow.js","webpack://ddb-importer/./src/effects/spells/spiderClimb.js","webpack://ddb-importer/./src/effects/spells/spiritGuardians.js","webpack://ddb-importer/./src/effects/spells/spiritualWeapon.js","webpack://ddb-importer/./src/effects/spells/stoneskin.js","webpack://ddb-importer/./src/effects/spells/sunbeam.js","webpack://ddb-importer/./src/effects/spells/tolltheDead.js","webpack://ddb-importer/./src/effects/spells/trueStrike.js","webpack://ddb-importer/./src/effects/spells/viciousMockery.js","webpack://ddb-importer/./src/effects/spells/wardingBond.js","webpack://ddb-importer/./src/effects/spells/web.js","webpack://ddb-importer/./src/effects/specialSpells.js","webpack://ddb-importer/./src/icons/index.js","webpack://ddb-importer/./src/lib/DirectoryPicker.js","webpack://ddb-importer/./src/logger.js","webpack://ddb-importer/./src/muncher/compendiumFolders.js","webpack://ddb-importer/./src/muncher/dae.js","webpack://ddb-importer/./src/muncher/import.js","webpack://ddb-importer/./src/muncher/importMonster.js","webpack://ddb-importer/./src/muncher/monster/abilities.js","webpack://ddb-importer/./src/muncher/monster/ac.js","webpack://ddb-importer/./src/muncher/monster/senses.js","webpack://ddb-importer/./src/muncher/monster/conditions.js","webpack://ddb-importer/./src/muncher/monster/languages.js","webpack://ddb-importer/./src/muncher/monster/hp.js","webpack://ddb-importer/./src/muncher/monster/movement.js","webpack://ddb-importer/./src/muncher/monster/size.js","webpack://ddb-importer/./src/muncher/monster/source.js","webpack://ddb-importer/./src/muncher/monster/environments.js","webpack://ddb-importer/./src/muncher/monster/templates/feat.js","webpack://ddb-importer/./src/muncher/monster/dict.js","webpack://ddb-importer/./src/muncher/monster/utils.js","webpack://ddb-importer/./src/muncher/monster/features/lair.js","webpack://ddb-importer/./src/muncher/monster/features/legendary.js","webpack://ddb-importer/./src/muncher/monster/features/actions.js","webpack://ddb-importer/./src/muncher/monster/features/specialtraits.js","webpack://ddb-importer/./src/muncher/monster/spells.js","webpack://ddb-importer/./src/muncher/monster/type.js","webpack://ddb-importer/./src/muncher/monster/templates/monster.js","webpack://ddb-importer/./src/muncher/monster/special.js","webpack://ddb-importer/./src/muncher/monster/monster.js","webpack://ddb-importer/./src/muncher/monster/skills.js","webpack://ddb-importer/./vendor/lowdash/uniq.js","webpack://ddb-importer/./vendor/parseTable.js","webpack://ddb-importer/./src/muncher/table.js","webpack://ddb-importer/./src/muncher/utils.js","webpack://ddb-importer/./src/parser/character/proficiencies.js","webpack://ddb-importer/./src/parser/character/skills.js","webpack://ddb-importer/./src/parser/templateStrings.js","webpack://ddb-importer/./src/utils.js","webpack://ddb-importer/./vendor/lowdash/isequal.js","webpack://ddb-importer/webpack/bootstrap","webpack://ddb-importer/webpack/runtime/define property getters","webpack://ddb-importer/webpack/runtime/global","webpack://ddb-importer/webpack/runtime/harmony module decorator","webpack://ddb-importer/webpack/runtime/hasOwnProperty shorthand","webpack://ddb-importer/./src/hooks/init/setupLogging.js","webpack://ddb-importer/./src/parser/spells/special.js","webpack://ddb-importer/./src/parser/spells/components.js","webpack://ddb-importer/./src/parser/spells/prepartion.js","webpack://ddb-importer/./src/parser/spells/uses.js","webpack://ddb-importer/./src/parser/spells/activation.js","webpack://ddb-importer/./src/parser/spells/duration.js","webpack://ddb-importer/./src/parser/spells/target.js","webpack://ddb-importer/./src/parser/spells/range.js","webpack://ddb-importer/./src/parser/spells/action.js","webpack://ddb-importer/./src/parser/spells/damage.js","webpack://ddb-importer/./src/parser/spells/save.js","webpack://ddb-importer/./src/parser/spells/scaling.js","webpack://ddb-importer/./src/parser/spells/name.js","webpack://ddb-importer/./src/parser/spells/parseSpell.js","webpack://ddb-importer/./src/parser/spells/getGenericSpells.js","webpack://ddb-importer/./src/lib/Secrets.js","webpack://ddb-importer/./src/muncher/spells.js","webpack://ddb-importer/./src/parser/inventory/common.js","webpack://ddb-importer/./src/parser/inventory/weapon.js","webpack://ddb-importer/./src/parser/inventory/ammunition.js","webpack://ddb-importer/./src/parser/inventory/staves.js","webpack://ddb-importer/./src/parser/inventory/armor.js","webpack://ddb-importer/./src/parser/inventory/wonderous.js","webpack://ddb-importer/./src/parser/inventory/potion.js","webpack://ddb-importer/./src/parser/inventory/scroll.js","webpack://ddb-importer/./src/parser/inventory/tool.js","webpack://ddb-importer/./src/parser/inventory/loot.js","webpack://ddb-importer/./src/parser/inventory/custom.js","webpack://ddb-importer/./src/parser/inventory/magicify.js","webpack://ddb-importer/./src/parser/inventory/special.js","webpack://ddb-importer/./src/parser/inventory/infusions.js","webpack://ddb-importer/./src/parser/inventory/index.js","webpack://ddb-importer/./src/muncher/items.js","webpack://ddb-importer/./src/muncher/monsters.js","webpack://ddb-importer/./src/muncher/races/races.js","webpack://ddb-importer/./src/muncher/races.js","webpack://ddb-importer/./src/muncher/feats/feats.js","webpack://ddb-importer/./src/muncher/feats.js","webpack://ddb-importer/./src/muncher/classes/shared.js","webpack://ddb-importer/./src/muncher/classes/classes.js","webpack://ddb-importer/./src/muncher/classes/subclasses.js","webpack://ddb-importer/./src/muncher/classes/options.js","webpack://ddb-importer/./src/muncher/classes.js","webpack://ddb-importer/./src/muncher/frames.js","webpack://ddb-importer/./src/lib/Base64Check.js","webpack://ddb-importer/./src/muncher/adventure.js","webpack://ddb-importer/./src/muncher/adventure/common.js","webpack://ddb-importer/./src/muncher/adventure/adventure.js","webpack://ddb-importer/./src/muncher/adventure/icons.js","webpack://ddb-importer/./src/muncher/adventure/thirdParty.js","webpack://ddb-importer/./src/muncher/settings.js","webpack://ddb-importer/./src/muncher/ddb.js","webpack://ddb-importer/./src/lib/Settings.js","webpack://ddb-importer/./src/parser/character/filterModifiers.js","webpack://ddb-importer/./src/parser/character/ac.js","webpack://ddb-importer/./src/parser/character/specialTraits.js","webpack://ddb-importer/./src/parser/character/spellCasting.js","webpack://ddb-importer/./src/parser/character/hp.js","webpack://ddb-importer/./src/parser/character/speed.js","webpack://ddb-importer/./src/parser/character/bio.js","webpack://ddb-importer/./src/parser/character/globalBonuses.js","webpack://ddb-importer/./src/parser/character/abilities.js","webpack://ddb-importer/./src/parser/character/senses.js","webpack://ddb-importer/./src/parser/character/token.js","webpack://ddb-importer/./src/parser/character/effects.js","webpack://ddb-importer/./src/parser/character/resources.js","webpack://ddb-importer/./src/parser/character/size.js","webpack://ddb-importer/./src/parser/character/initiative.js","webpack://ddb-importer/./src/parser/character/currency.js","webpack://ddb-importer/./src/parser/character/index.js","webpack://ddb-importer/./src/parser/features/special.js","webpack://ddb-importer/./src/parser/features/actions.js","webpack://ddb-importer/./src/parser/features/features.js","webpack://ddb-importer/./src/parser/spells/ability.js","webpack://ddb-importer/./src/parser/classes/index.js","webpack://ddb-importer/./src/parser/spells/metadata.js","webpack://ddb-importer/./src/parser/spells/getCharacterSpells.js","webpack://ddb-importer/./src/parser/spells/getItemSpells.js","webpack://ddb-importer/./src/parser/special/index.js","webpack://ddb-importer/./src/parser/character.js","webpack://ddb-importer/./src/character/utils.js","webpack://ddb-importer/./src/character/conditions.js","webpack://ddb-importer/./src/character/update.js","webpack://ddb-importer/./src/effects/abilityOverrides.js","webpack://ddb-importer/./src/character/import.js","webpack://ddb-importer/./src/muncher/encounters.js","webpack://ddb-importer/./src/hooks/ready/checkCompendiums.js","webpack://ddb-importer/./src/hooks/init/window.js","webpack://ddb-importer/./src/lib/adventureFlags.js","webpack://ddb-importer/./src/hooks/ready/registerSheets.js","webpack://ddb-importer/./src/hooks/ready/registerGameSettings.js","webpack://ddb-importer/./src/lib/itemConfig.js","webpack://ddb-importer/./src/hooks/ready/items.js","webpack://ddb-importer/./src/hooks/ready/checkVersion.js","webpack://ddb-importer/./src/hooks/renderMuncher/settings.js","webpack://ddb-importer/./src/hooks/renderMuncher/addMuncher.js","webpack://ddb-importer/./src/hooks/renderMuncher/addEncounterMuncher.js","webpack://ddb-importer/./src/hooks/socket/onSocketMessage.js","webpack://ddb-importer/./src/hooks/renderJournalSheet/linkTables.js","webpack://ddb-importer/./src/hooks/renderJournalSheet/linkImages.js","webpack://ddb-importer/./src/hooks/renderJournalSheet/buildNotes.js","webpack://ddb-importer/./src/hooks/renderJournalSheet/adventure.js","webpack://ddb-importer/./src/lib/Notification.js","webpack://ddb-importer/./src/hooks.js","webpack://ddb-importer/./src/muncher/sceneEnhancer.js","webpack://ddb-importer/./src/hooks/navigationContext/extendSceneNavigationContext.js","webpack://ddb-importer/./src/index.js"],"sourcesContent":["import logger from \"../logger.js\";\nimport utils from \"../utils.js\";\nimport { parseMonsters } from \"../muncher/monster/monster.js\";\nimport { copySupportedItemFlags, srdFiddling } from \"../muncher/import.js\";\nimport { buildNPC, generateIconMap, copyExistingMonsterImages } from \"../muncher/importMonster.js\";\nimport { DDB_CONFIG } from \"../ddbConfig.js\";\nimport { ABILITIES, getAbilityMods } from \"../muncher/monster/abilities.js\";\nimport { SKILLS } from \"../muncher/monster/skills.js\";\n\nconst MUNCH_DEFAULTS = [\n  { name: \"munching-policy-update-existing\", needed: true },\n  { name: \"munching-policy-use-srd\", needed: false },\n  { name: \"munching-policy-use-inbuilt-icons\", needed: true },\n  { name: \"munching-policy-use-srd-icons\", needed: false },\n  { name: \"munching-policy-download-images\", needed: true },\n  { name: \"munching-policy-remote-images\", needed: false },\n  { name: \"munching-policy-use-dae-effects\", needed: false },\n  { name: \"munching-policy-hide-description\", needed: false },\n  { name: \"munching-policy-monster-items\", needed: false },\n  { name: \"munching-policy-update-images\", needed: false },\n  { name: \"munching-policy-dae-copy\", needed: false },\n];\n\nfunction getCustomValue(ddbCharacter, typeId, valueId, valueTypeId) {\n  const characterValues = ddbCharacter.characterValues;\n  const customValue = characterValues.find(\n    (value) => value.valueId == valueId && value.valueTypeId == valueTypeId && value.typeId == typeId\n  );\n\n  if (customValue) {\n    return customValue.value;\n  }\n  return null;\n}\n\nasync function updateExtras(extras, existingExtras) {\n  return Promise.all(\n    extras\n      .filter((extra) =>\n        existingExtras.some(\n          (exist) =>\n            exist.flags?.ddbimporter?.id === extra.flags.ddbimporter.id &&\n            extra.flags?.ddbimporter?.entityTypeId === extra.flags.ddbimporter.entityTypeId\n        )\n      )\n      .map(async (extra) => {\n        const existingExtra = await existingExtras.find(\n          (exist) =>\n            exist.flags?.ddbimporter?.id === extra.flags.ddbimporter.id &&\n            extra.flags?.ddbimporter?.entityTypeId === extra.flags.ddbimporter.entityTypeId\n        );\n        extra._id = existingExtra._id;\n        logger.info(`Updating extra ${extra.name}`);\n        await copySupportedItemFlags(existingExtra, extra);\n        // await Actor.update(extra);\n        await buildNPC(extra, false, true, true);\n        return extra;\n      })\n  );\n}\n\nasync function createExtras(extras, existingExtras, folderId) {\n  return Promise.all(\n    extras\n      .filter(\n        (extra) =>\n          !existingExtras.some(\n            (exist) =>\n              exist.flags?.ddbimporter?.id === extra.flags.ddbimporter.id &&\n              extra.flags?.ddbimporter?.entityTypeId === extra.flags.ddbimporter.entityTypeId\n          )\n      )\n      .map(async (extra) => {\n        if (!game.user.can(\"ITEM_CREATE\")) {\n          ui.notifications.warn(`Cannot create Extra ${extra.name}`);\n        } else {\n          logger.info(`Creating Extra ${extra.name}`);\n          extra.folder = folderId;\n          const importedExtra = await buildNPC(extra, false, false, true);\n          return importedExtra;\n        }\n        return extra;\n      })\n  );\n}\n\nfunction generateBeastCompanionEffects(extra, characterProficiencyBonus) {\n  // beast master get to add proficiency bonus to current attacks, damage, ac\n  // and saving throws and skills it is proficient in.\n  // extra.data.details.cr = actor.data.flags.ddbimporter.dndbeyond.totalLevels;\n\n  let effect = {\n    changes: [\n      {\n        key: \"data.bonuses.rwak.attack\",\n        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n        value: `+${characterProficiencyBonus}`,\n        priority: 20,\n      },\n      {\n        key: \"data.bonuses.rwak.damage\",\n        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n        value: `+${characterProficiencyBonus}`,\n        priority: 20,\n      },\n      {\n        key: \"data.bonuses.mwak.attack\",\n        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n        value: `+${characterProficiencyBonus}`,\n        priority: 20,\n      },\n      {\n        key: \"data.bonuses.mwak.damage\",\n        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n        value: `+${characterProficiencyBonus}`,\n        priority: 20,\n      },\n    ],\n    duration: {\n      seconds: null,\n      startTime: null,\n      rounds: null,\n      turns: null,\n      startRound: null,\n      startTurn: null,\n    },\n    label: \"Beast Companion Effects\",\n    tint: \"\",\n    disabled: false,\n    selectedKey: [],\n  };\n  ABILITIES.filter((ability) => extra.data.abilities[ability.value].proficient >= 1).forEach((ability) => {\n    const boost = {\n      key: `data.abilities.${ability.value}.save`,\n      mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n      value: characterProficiencyBonus,\n      priority: 20,\n    };\n    effect.selectedKey.push(`data.abilities.${ability.value}.save`);\n    effect.changes.push(boost);\n  });\n  SKILLS.filter((skill) => extra.data.skills[skill.name].prof >= 1).forEach((skill) => {\n    const boost = {\n      key: `data.skills.${skill.name}.mod`,\n      mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n      value: characterProficiencyBonus,\n      priority: 20,\n    };\n    effect.selectedKey.push(`data.skills.${skill.name}.mod`);\n    effect.changes.push(boost);\n  });\n  extra.effects = [effect];\n  return extra;\n}\n\nfunction generateArtificerEffects(actor, extra, characterProficiencyBonus) {\n  // artificer uses the actors spell attack bonus, so is a bit trickier\n  // we remove damage bonus later, and will also have to calculate additional attack bonus for each attack\n  extra.data.details.cr = actor.data.flags.ddbimporter.dndbeyond.totalLevels;\n\n  let effect = {\n    changes: [\n      {\n        key: \"data.bonuses.rwak.damage\",\n        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n        value: `+${characterProficiencyBonus}`,\n        priority: 20,\n      },\n      {\n        key: \"data.bonuses.mwak.damage\",\n        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n        value: `+${characterProficiencyBonus}`,\n        priority: 20,\n      },\n    ],\n    duration: {\n      seconds: null,\n      startTime: null,\n      rounds: null,\n      turns: null,\n      startRound: null,\n      startTurn: null,\n    },\n    label: \"Artificer Extra Effects\",\n    tint: \"\",\n    disabled: false,\n    selectedKey: [],\n  };\n  extra.effects = [effect];\n  return extra;\n}\n\nconst creatureGroupMatrix = [\n  {\n    id: 1,\n    name: \"Wildshape\",\n    animation: \"fourelements\",\n  },\n  {\n    id: 2,\n    name: \"Familiar\",\n    animation: \"magic1\",\n  },\n  {\n    id: 3,\n    name: \"Beast Companion\",\n    animation: \"fourelements\",\n  },\n  {\n    id: 4,\n    name: \"Mount\",\n    animation: \"heart\",\n  },\n  {\n    id: 5,\n    name: \"Pet\",\n    animation: \"heart\",\n  },\n  {\n    id: 6,\n    name: \"Summoned\",\n    animation: \"magic1\",\n  },\n  {\n    id: 7,\n    name: \"Misc\",\n    animation: \"magic1\",\n  },\n  {\n    id: 10,\n    name: \"Battle Smith Defender\",\n    animation: \"energy1\",\n  },\n  {\n    id: 11,\n    name: \"Sidekick\",\n    animation: \"energy1\",\n  },\n  {\n    id: 12,\n    name: \"Infusion\",\n    animation: \"energy1\",\n  },\n];\n\nfunction getCreatureAnimationType(name, creatureGroup) {\n  // \"fire\":\n  // \"air\":\n  // \"lightning\":\n  // \"water\":\n  // \"energy1\":\n  // \"magic1\":\n  // \"heart\":\n  // \"music\":\n  // \"fourelements\":\n  const checkName = name.toLowerCase();\n  let animation = \"magic1\";\n  switch (name) {\n    case checkName.includes(\"flame\"):\n    case checkName.includes(\"fire\"):\n      animation = \"fire\";\n      break;\n    case checkName.includes(\"air\"):\n    case checkName.includes(\"wind\"):\n      animation = \"air\";\n      break;\n    case checkName.includes(\"lightning\"):\n    case checkName.includes(\"thunder\"):\n      animation = \"lightning\";\n      break;\n    case checkName.includes(\"water\"):\n    case checkName.includes(\"aqua\"):\n      animation = \"water\";\n      break;\n    case checkName.includes(\"energy\"):\n    case checkName.includes(\"construct\"):\n      animation = \"energy1\";\n      break;\n    case checkName.includes(\"magic\"):\n    case checkName.includes(\"arcane\"):\n      animation = \"magic1\";\n      break;\n    default: {\n      const match = creatureGroupMatrix.find((group) => group.id === creatureGroup.id);\n      if (match) {\n        animation = match.animation;\n      }\n    }\n  }\n\n  return animation;\n}\n\nexport async function characterExtras(html, characterData, actor) {\n  let munchSettings = [];\n  let ddbCharacter = characterData.ddb.character;\n\n  MUNCH_DEFAULTS.forEach((setting) => {\n    logger.debug(`Loading extras munch settings ${setting.name}`);\n    setting[\"chosen\"] = game.settings.get(\"ddb-importer\", setting.name);\n    munchSettings.push(setting);\n  });\n\n  munchSettings.forEach((setting) => {\n    game.settings.set(\"ddb-importer\", setting.name, setting.needed);\n  });\n\n  try {\n    logger.debug(characterData);\n    if (ddbCharacter.creatures.length === 0) return;\n\n    const folder = await utils.getOrCreateFolder(actor.folder, \"Actor\", `[Extras] ${actor.name}`);\n\n    // eslint-disable-next-line complexity\n    let creatures = ddbCharacter.creatures.map((creature) => {\n      logger.debug(\"Extra data\", creature);\n      let mock = JSON.parse(JSON.stringify(creature.definition));\n      const proficiencyBonus = DDB_CONFIG.challengeRatings.find(\n        (cr) => cr.id == mock.challengeRatingId\n      ).proficiencyBonus;\n      const creatureGroup = DDB_CONFIG.creatureGroups.find((group) => group.id == creature.groupId);\n      let creatureFlags = creatureGroup.flags;\n\n      mock.id = creature.id;\n      mock.entityTypeId = creature.entityTypeId;\n\n      if (creature.definition.name === \"Homunculus Servant\") {\n        creatureFlags = creatureFlags.concat([\"MHPAMCM\", \"MHPAIM\", \"MHPBAL\", \"ARPB\", \"PSPB\"]);\n      }\n      mock.creatureFlags = creatureFlags;\n      mock.removedHitPoints = creature.removedHitPoints;\n      mock.temporaryHitPoints = creature.temporaryHitPoints;\n      mock.creatureGroup = creature.groupId;\n\n      if (creature.name) mock.name = creature.name;\n\n      // creature group\n      mock.automatedEvcoationAnimation = getCreatureAnimationType(mock.name, creatureGroup);\n\n      // size\n      const sizeChange = getCustomValue(ddbCharacter, 46, creature.id, creature.entityTypeId);\n      if (sizeChange) mock.sizeId = sizeChange;\n\n      // hp\n      const hpMaxChange = getCustomValue(ddbCharacter, 43, creature.id, creature.entityTypeId);\n      if (hpMaxChange) mock.averageHitPoints = hpMaxChange;\n\n      // creature type\n      const typeChange = getCustomValue(ddbCharacter, 44, creature.id, creature.entityTypeId);\n      if (typeChange) mock.typeId = typeChange;\n\n      // ac\n      const acChange = getCustomValue(ddbCharacter, 42, creature.id, creature.entityTypeId);\n      if (acChange) mock.armorClass = acChange;\n\n      // alignment\n      const alignmentChange = getCustomValue(ddbCharacter, 45, creature.id, creature.entityTypeId);\n      if (alignmentChange) mock.alignmentId = alignmentChange;\n\n      // notes\n      const extraNotes = getCustomValue(ddbCharacter, 47, creature.id, creature.entityTypeId);\n      if (extraNotes) mock.characteristicsDescription += `\\n\\n${extraNotes}`;\n\n      const creatureStats = mock.stats.filter((stat) => !creatureGroup.ownerStats.includes(stat.statId));\n      const characterStats = mock.stats\n        .filter((stat) => creatureGroup.ownerStats.includes(stat.statId))\n        .map((stat) => {\n          const value = actor.data.data.abilities[ABILITIES.find((a) => a.id === stat.statId).value].value;\n          return { name: null, statId: stat.statId, value: value };\n        });\n\n      mock.stats = creatureStats.concat(characterStats);\n\n      // permissions the same as\n      mock.permission = actor.data.permission;\n      mock.folder = folder.id;\n\n      if (creatureGroup.description !== \"\") {\n        mock.characteristicsDescription = `${creatureGroup.description}\\n\\n${mock.characteristicsDescription}`;\n      }\n\n      if (creatureGroup.specialQualityTitle) {\n        mock.specialTraitsDescription = `${mock.specialTraitsDescription} <p><em><strong>${creatureGroup.specialQualityTitle}.</strong></em> ${creatureGroup.specialQualityText}</p>`;\n      }\n\n      if (creatureFlags.includes(\"ACPB\")) {\n        mock.armorClass += actor.data.data.attributes.prof;\n      }\n\n      // assume this is beast master\n      if (creatureFlags.includes(\"HPLM\")) {\n        const ranger = ddbCharacter.classes.find((klass) => klass.definition.id === 5);\n        const level = ranger ? ranger.level : 0;\n        mock.averageHitPoints = Math.max(mock.averageHitPoints, 4 * level);\n      }\n\n      // homunculus servant\n      if (creatureFlags.includes(\"MHPBAL\")) {\n        const artificer = ddbCharacter.classes.find((klass) => klass.definition.name === \"Artificer\");\n        mock.averageHitPoints = parseInt(artificer.level);\n      }\n\n      if (creatureFlags.includes(\"AHM\")) {\n        const artificer = ddbCharacter.classes.find((klass) => klass.definition.name === \"Artificer\");\n        mock.averageHitPoints = parseInt(5 * artificer.level);\n      }\n\n      if (creatureFlags.includes(\"MHPAIM\")) {\n        mock.averageHitPoints += parseInt(actor.data.data.abilities.int.mod);\n      }\n\n      if (creatureFlags.includes(\"MHPAMCM\")) {\n        const monsterConModifier = getAbilityMods(mock, DDB_CONFIG);\n        mock.averageHitPoints += parseInt(monsterConModifier.con);\n      }\n\n      // add owner skill profs\n      if (creatureFlags.includes(\"EOSKP\")) {\n        let newSkills = [];\n\n        SKILLS.forEach((skill) => {\n          const existingSkill = mock.skills.find((mockSkill) => skill.valueId === mockSkill.skillId);\n          const characterProficient = characterData.character.character.data.skills[skill.name].value;\n\n          const ability = ABILITIES.find((ab) => ab.value === skill.ability);\n          const stat = mock.stats.find((stat) => stat.statId === ability.id).value || 10;\n          const mod = DDB_CONFIG.statModifiers.find((s) => s.value == stat).modifier;\n\n          if (existingSkill && characterProficient === 2) {\n            const doubleProf = proficiencyBonus * 2;\n            newSkills.push({\n              skillId: skill.valueId,\n              value: mod + doubleProf,\n              additionalBonus: null,\n            });\n          } else if (existingSkill) {\n            newSkills.push(existingSkill);\n          } else if (characterProficient === 1) {\n            newSkills.push({\n              skillId: skill.valueId,\n              value: mod + proficiencyBonus,\n              additionalBonus: null,\n            });\n          }\n        });\n        mock.skills = newSkills;\n      }\n\n      // add owner save profs\n      if (creatureFlags.includes(\"EOSVP\")) {\n        let newSaves = [];\n        ABILITIES.forEach((ability) => {\n          const existingProficient = mock.savingThrows.find((stat) => stat.statId === ability.id) ? 1 : 0;\n          const characterProficient = characterData.character.character.data.abilities[ability.value].proficient;\n\n          if (existingProficient || characterProficient) {\n            const bonus = {\n              bonusModifier: null,\n              statId: ability.id,\n            };\n            newSaves.push(bonus);\n          }\n        });\n        mock.savingThrows = newSaves;\n      }\n\n      if (creatureFlags.includes(\"CULGA\")) {\n        mock.isLegendary = false;\n        mock.legendaryActionsDescription = \"\";\n      }\n\n      if (creatureFlags.includes(\"CULRA\")) {\n        mock.hasLair = false;\n        mock.lairDescription = \"\";\n      }\n\n      logger.debug(mock);\n      return mock;\n    });\n    let parsedExtras = await parseMonsters(creatures, true);\n    parsedExtras = parsedExtras.actors;\n    logger.debug(parsedExtras);\n\n    const damageDiceExpression = /(\\d*d\\d+\\s*\\+*\\s*)+/;\n    const characterProficiencyBonus = actor.data.data.attributes.prof;\n    const artificerBonusGroup = [10, 12];\n\n    parsedExtras = parsedExtras.map((extra) => {\n      if (\n        extra.flags?.ddbimporter?.creatureFlags?.includes(\"ARPB\") &&\n        extra.flags?.ddbimporter?.creatureFlags?.includes(\"PSPB\")\n      ) {\n        if (extra.flags?.ddbimporter?.creatureGroup === 3) {\n          extra = generateBeastCompanionEffects(extra, characterProficiencyBonus);\n        } else if (artificerBonusGroup.includes(extra.flags?.ddbimporter?.creatureGroup)) {\n          // artificer uses the actors spell attack bonus, so is a bit trickier\n          // we remove damage bonus later, and will also have to calculate additional attack bonus for each attack\n          extra = generateArtificerEffects(actor, extra, characterProficiencyBonus);\n        } else {\n          // who knows!\n          extra.data.details.cr = actor.data.flags.ddbimporter.dndbeyond.totalLevels;\n        }\n      }\n\n      if (\n        (extra.flags?.ddbimporter?.creatureFlags?.includes(\"DRPB\") && extra.flags?.ddbimporter?.creatureGroup !== 3) ||\n        // is this a artificer infusion? the infusion call actually adds this creature group, but we don't fetch that yet.\n        extra.flags?.ddbimporter?.creatureGroup === 12\n      ) {\n        extra.items = extra.items.map((item) => {\n          if (item.type === \"weapon\") {\n            let characterAbility;\n\n            item.data.damage.parts = item.data.damage.parts.map((part) => {\n              const match = part[0].match(damageDiceExpression);\n              if (match) {\n                let dice = match[0];\n                // the artificer creatures have the initial prof built in, lets replace it\n                if (artificerBonusGroup.includes(extra.flags?.ddbimporter?.creatureGroup)) {\n                  characterAbility = \"int\";\n                  dice = match[1].trim().endsWith(\"+\") ? match[1].trim().slice(0, -1) : match[1];\n                }\n                part[0] = `${dice.trim()}`;\n              }\n\n              return part;\n            });\n\n            if (characterAbility) {\n              const ability = item.data.ability;\n              const mod = parseInt(extra.data.abilities[ability].mod);\n              const characterMod = parseInt(actor.data.data.abilities[characterAbility].mod);\n              // eslint-disable-next-line no-eval\n              const globalMod = parseInt(eval(actor.data.data.bonuses.rsak.attack || 0));\n              item.data.attackBonus = characterMod + globalMod - mod;\n            }\n          }\n          return item;\n        });\n      }\n\n      return extra;\n    });\n\n    logger.debug(\"Parsed Extras:\", parsedExtras);\n\n    const updateBool = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n    const updateImages = game.settings.get(\"ddb-importer\", \"munching-policy-update-images\");\n    // const uploadDirectory = game.settings.get(\"ddb-importer\", \"image-upload-directory\").replace(/^\\/|\\/$/g, \"\");\n\n    const existingExtras = await game.actors.contents\n      .filter((extra) => extra.data.folder === folder.id)\n      .map((extra) => extra.data);\n\n    if (!updateBool || !updateImages) {\n      if (!updateImages) {\n        logger.debug(\"Copying monster images across...\");\n        parsedExtras = copyExistingMonsterImages(parsedExtras, existingExtras);\n      }\n    }\n\n    let finalExtras = await srdFiddling(parsedExtras, \"monsters\");\n    await generateIconMap(finalExtras);\n\n    if (updateBool) await updateExtras(finalExtras, existingExtras);\n    const importedExtras = await createExtras(finalExtras, existingExtras, folder.id);\n\n    const currentAutomatedEvocationSettings = {\n      isLocal: actor.getFlag(\"automated-evocations\", \"isLocal\"),\n      companions: actor.getFlag(\"automated-evocations\", \"isLocal\"),\n    };\n\n    const companions = existingExtras.concat(importedExtras).map((extra) => {\n      return {\n        id: extra.id ? extra.id : extra._id,\n        number: 1,\n        animation: extra.data.flags?.ddbimporter?.automatedEvcoationAnimation\n          ? extra.data.flags?.ddbimporter?.automatedEvcoationAnimation\n          : \"magic1\",\n      };\n    });\n    const newAutomatedEvocationSettings = {\n      isLocal: true,\n      companions,\n    };\n    const mergedSettings = mergeObject(currentAutomatedEvocationSettings, newAutomatedEvocationSettings);\n\n    actor.setFlag(\"automated-evocations\", \"isLocal\", mergedSettings.isLocal);\n    actor.setFlag(\"automated-evocations\", \"companions\", mergedSettings.companions);\n  } catch (err) {\n    logger.error(\"Failure parsing extra\", err);\n    logger.error(err.stack);\n  } finally {\n    munchSettings.forEach((setting) => {\n      logger.debug(`Returning ${setting.name} to ${setting.chosen}`);\n      game.settings.set(\"ddb-importer\", setting.name, setting.chosen);\n    });\n  }\n}\n","export var DDB_CONFIG;\n\nasync function getDDBConfig() {\n  DDB_CONFIG = await $.getJSON(\"https://www.dndbeyond.com/api/config/json\");\n}\n\nexport function loadDDBConfig() {\n  if (!DDB_CONFIG) {\n    getDDBConfig();\n  }\n}\n\n","const DICTIONARY = {\n  types: {\n    equipment: [\"equipment\", \"consumable\", \"tool\", \"loot\", \"backpack\"],\n    inventory: [\"equipment\", \"consumable\", \"tool\", \"loot\", \"backpack\", \"weapon\"],\n    monster: [\"equipment\", \"consumable\", \"tool\", \"loot\", \"backpack\", \"weapon\", \"feat\"],\n  },\n  numbers: [\n    { num: 1, natural: \"a\" },\n    { num: 1, natural: \"one\" },\n    { num: 2, natural: \"two\" },\n    { num: 3, natural: \"three\" },\n    { num: 4, natural: \"four\" },\n    { num: 5, natural: \"five\" },\n    { num: 6, natural: \"six\" },\n    { num: 7, natural: \"seven\" },\n    { num: 8, natural: \"eight\" },\n    { num: 9, natural: \"nine\" },\n    { num: 10, natural: \"ten\" },\n    { num: 11, natural: \"eleven\" },\n    { num: 12, natural: \"twelve\" },\n    { num: 13, natural: \"thirteen\" },\n    { num: 14, natural: \"fourteen\" },\n    { num: 15, natural: \"fifteen\" },\n    { num: 16, natural: \"sixteen\" },\n    { num: 17, natural: \"seventeen\" },\n    { num: 18, natural: \"eighteen\" },\n    { num: 19, natural: \"nineteen\" },\n    { num: 20, natural: \"twenty\" },\n  ],\n  magicitems: {\n    rechargeUnits: [\n      { id: 1, value: \"r4\" },\n      { id: \"ShortRest\", value: \"r4\" },\n      { id: 2, value: \"r5\" },\n      { id: \"LongRest\", value: \"r5\" },\n      { id: \"Dawn\", value: \"r2\" },\n      { id: \"Dusk\", value: \"r3\" },\n      { id: \"Sunset\", value: \"r3\" },\n      { id: \"Consumable\", value: \"\" },\n      { id: \"Other\", value: \"\" },\n      { id: \"Daily\", value: \"r1\" },\n      { id: \"sr\", value: \"r4\" },\n      { id: \"lr\", value: \"r5\" },\n    ],\n    nums: [\n      { id: \"once\", value: 1 },\n      { id: \"twice\", value: 2 },\n      { id: \"thrice\", value: 3 },\n      { id: \"one\", value: 1 },\n      { id: \"two\", value: 2 },\n      { id: \"three\", value: 3 },\n    ],\n  },\n  resets: [\n    { id: 1, value: \"sr\" },\n    { id: \"ShortRest\", value: \"sr\" },\n    { id: \"Short\", value: \"sr\" },\n    { id: \"short\", value: \"sr\" },\n    { id: 2, value: \"lr\" },\n    { id: \"LongRest\", value: \"lr\" },\n    { id: \"Long\", value: \"lr\" },\n    { id: \"long\", value: \"lr\" },\n    { id: \"Day\", value: \"day\" },\n    { id: \"day\", value: \"day\" },\n    { id: \"Dawn\", value: \"day\" },\n    { id: \"dusk\", value: \"day\" },\n    { id: \"Consumable\", value: \"charges\" },\n    { id: \"Other\", value: \"charges\" },\n    { id: \"\", value: \"\" },\n    { id: null, value: \"\" },\n    { id: 3, value: \"day\" },\n    { id: 4, value: \"charges\" },\n  ],\n  character: {\n    abilities: [\n      { id: 1, value: \"str\", long: \"strength\" },\n      { id: 2, value: \"dex\", long: \"dexterity\" },\n      { id: 3, value: \"con\", long: \"constitution\" },\n      { id: 4, value: \"int\", long: \"intelligence\" },\n      { id: 5, value: \"wis\", long: \"wisdom\" },\n      { id: 6, value: \"cha\", long: \"charisma\" },\n    ],\n    skills: [\n      { name: \"acr\", label: \"Acrobatics\", ability: \"dex\", subType: \"acrobatics\", valueId: 3 },\n      { name: \"ani\", label: \"Animal Handling\", ability: \"wis\", subType: \"animal-handling\", valueId: 11 },\n      { name: \"arc\", label: \"Arcana\", ability: \"int\", subType: \"arcana\", valueId: 6 },\n      { name: \"ath\", label: \"Athletics\", ability: \"str\", subType: \"athletics\", valueId: 2 },\n      { name: \"dec\", label: \"Deception\", ability: \"cha\", subType: \"deception\", valueId: 16 },\n      { name: \"his\", label: \"History\", ability: \"int\", subType: \"history\", valueId: 7 },\n      { name: \"ins\", label: \"Insight\", ability: \"wis\", subType: \"insight\", valueId: 12 },\n      { name: \"itm\", label: \"Intimidation\", ability: \"cha\", subType: \"intimidation\", valueId: 17 },\n      { name: \"inv\", label: \"Investigation\", ability: \"int\", subType: \"investigation\", valueId: 8 },\n      { name: \"med\", label: \"Medicine\", ability: \"wis\", subType: \"medicine\", valueId: 13 },\n      { name: \"nat\", label: \"Nature\", ability: \"int\", subType: \"nature\", valueId: 9 },\n      { name: \"prc\", label: \"Perception\", ability: \"wis\", subType: \"perception\", valueId: 14 },\n      { name: \"prf\", label: \"Performance\", ability: \"cha\", subType: \"performance\", valueId: 18 },\n      { name: \"per\", label: \"Persuasion\", ability: \"cha\", subType: \"persuasion\", valueId: 19 },\n      { name: \"rel\", label: \"Religion\", ability: \"int\", subType: \"religion\", valueId: 10 },\n      { name: \"slt\", label: \"Sleight of Hand\", ability: \"dex\", subType: \"sleight-of-hand\", valueId: 4 },\n      { name: \"ste\", label: \"Stealth\", ability: \"dex\", subType: \"stealth\", valueId: 5 },\n      { name: \"sur\", label: \"Survival\", ability: \"wis\", subType: \"survival\", valueId: 15 },\n    ],\n    customSkillProficiencies: [\n      // typeId:26\n      // value not: 1, half 2, prof: 3, expertise 4\n      { value: 1, proficient: 0 },\n      { value: 2, proficient: 0.5 },\n      { value: 3, proficient: 1 },\n      { value: 4, proficient: 2 },\n    ],\n    alignments: [\n      { id: 1, name: \"Lawful Good\", value: \"lg\" },\n      { id: 2, name: \"Neutral Good\", value: \"ng\" },\n      { id: 3, name: \"Chaotic Good\", value: \"cg\" },\n      { id: 4, name: \"Lawful Neutral\", value: \"ln\" },\n      { id: 5, name: \"True Neutral\", value: \"tn\" },\n      { id: 6, name: \"Chaotic Neutral\", value: \"cn\" },\n      { id: 7, name: \"Lawful Evil\", value: \"le\" },\n      { id: 8, name: \"Neutral Evil\", value: \"ne\" },\n      { id: 9, name: \"Chaotic Evil\", value: \"ce\" },\n    ],\n    actorSizes: [\n      { id: 2, name: \"Tiny\", value: \"tiny\" }, // wild guess\n      { id: 3, name: \"Small\", value: \"sm\" }, // consistent\n      { id: 4, name: \"Medium\", value: \"med\" }, // consistent\n      { id: 5, name: \"Large\", value: \"lg\" }, // wild guess\n      { id: 6, name: \"Huge\", value: \"huge\" }, // wild guess\n      { id: 7, name: \"Gargantuan\", value: \"grg\" }, // wild guess\n    ],\n    senses: [\n      { id: 1, name: \"Blindsight\" },\n      { id: 2, name: \"Darkvision\" },\n      { id: 3, name: \"Tremorsense\" },\n      { id: 4, name: \"Truesight\" },\n    ],\n    speeds: [\n      { id: 1, type: \"walk\", innate: \"walking\" },\n      { id: 2, type: \"burrow\", innate: \"burrowing\" },\n      { id: 3, type: \"climb\", innate: \"climbing\" },\n      { id: 4, type: \"fly\", innate: \"flying\" },\n      { id: 5, type: \"swim\", innate: \"swimming\" },\n    ],\n    languages: [\n      { name: \"Common\", value: \"common\" },\n      { name: \"Aarakocra\", value: \"aarakocra\" },\n      { name: \"Abyssal\", value: \"abyssal\" },\n      { name: \"Aquan\", value: \"aquan\" },\n      { name: \"Auran\", value: \"auran\" },\n      { name: \"Celestial\", value: \"celestial\" },\n      { name: \"Deep Speech\", value: \"deep\" },\n      { name: \"Draconic\", value: \"draconic\" },\n      { name: \"Druidic\", value: \"druidic\" },\n      { name: \"Dwarvish\", value: \"dwarvish\" },\n      { name: \"Elvish\", value: \"elvish\" },\n      { name: \"Giant\", value: \"giant\" },\n      { name: \"Gith\", value: \"gith\" },\n      { name: \"Gnomish\", value: \"gnomish\" },\n      { name: \"Goblin\", value: \"goblin\" },\n      { name: \"Gnoll\", value: \"gnoll\" },\n      { name: \"Halfling\", value: \"halfling\" },\n      { name: \"Ignan\", value: \"ignan\" },\n      { name: \"Infernal\", value: \"infernal\" },\n      { name: \"Orc\", value: \"orc\" },\n      { name: \"Primordial\", value: \"primordial\" },\n      { name: \"Terran\", value: \"terran\" },\n      { name: \"Sylvan\", value: \"sylvan\" },\n      { name: \"Thieves' Cant\", value: \"cant\" },\n      { name: \"Thieves Cant\", value: \"cant\" },\n      { name: \"Undercommon\", value: \"undercommon\" },\n    ],\n    armorTypes: [\n      { name: \"Clothing\", value: \"clothing\" },\n      { name: \"Light Armor\", value: \"light\" },\n      { name: \"Medium Armor\", value: \"medium\" },\n      { name: \"Heavy Armor\", value: \"heavy\" },\n      { name: \"Magical Bonus\", value: \"bonus\" },\n      { name: \"Natural Armor\", value: \"natural\" },\n      { name: \"Shield\", value: \"shield\" },\n    ],\n    damageTypes: [\n      { id: 1, type: 2, kind: \"resistance\", name: \"Bludgeoning\", value: \"bludgeoning\" },\n      { id: 2, type: 2, kind: \"resistance\", name: \"Piercing\", value: \"piercing\" },\n      { id: 3, type: 2, kind: \"resistance\", name: \"Slashing\", value: \"slashing\" },\n      { id: 4, type: 2, kind: \"resistance\", name: \"Lightning\", value: \"lightning\" },\n      { id: 5, type: 2, kind: \"resistance\", name: \"Thunder\", value: \"thunder\" },\n      { id: 6, type: 2, kind: \"resistance\", name: \"Poison\", value: \"poison\" },\n      { id: 7, type: 2, kind: \"resistance\", name: \"Cold\", value: \"cold\" },\n      { id: 8, type: 2, kind: \"resistance\", name: \"Radiant\", value: \"radiant\" },\n      { id: 9, type: 2, kind: \"resistance\", name: \"Fire\", value: \"fire\" },\n      { id: 10, type: 2, kind: \"resistance\", name: \"Necrotic\", value: \"necrotic\" },\n      { id: 11, type: 2, kind: \"resistance\", name: \"Acid\", value: \"acid\" },\n      { id: 12, type: 2, kind: \"resistance\", name: \"Psychic\", value: \"psychic\" },\n      { id: 13, type: 2, kind: \"resistance\", name: \"Physical\", value: \"bludgeoning-piercing-and-slashing-from-nonmagical-weapons\", foundryValue: \"physical\" },\n      { id: 14, type: 2, kind: \"resistance\", name: \"Physical\", value: \"bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-silvered\", foundryValue: \"physical\" },\n      { id: 15, type: 2, kind: \"resistance\", name: \"Physical\", value: \"bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine\", foundryValue: \"physical\" },\n      // { id: 16, type: 2, kind: \"resistance\", name: \"Physical\", value: \"piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine\", foundryValue: \"physical\" },\n      { id: 17, type: 2, kind: \"immunity\", name: \"Bludgeoning\", value: \"bludgeoning\" },\n      { id: 18, type: 2, kind: \"immunity\", name: \"Piercing\", value: \"piercing\" },\n      { id: 19, type: 2, kind: \"immunity\", name: \"Slashing\", value: \"slashing\" },\n      { id: 20, type: 2, kind: \"immunity\", name: \"Lightning\", value: \"lightning\" },\n      { id: 21, type: 2, kind: \"immunity\", name: \"Thunder\", value: \"thunder\" },\n      { id: 22, type: 2, kind: \"immunity\", name: \"Poison\", value: \"poison\" },\n      { id: 23, type: 2, kind: \"immunity\", name: \"Cold\", value: \"cold\" },\n      { id: 24, type: 2, kind: \"immunity\", name: \"Radiant\", value: \"radiant\" },\n      { id: 25, type: 2, kind: \"immunity\", name: \"Fire\", value: \"fire\" },\n      { id: 26, type: 2, kind: \"immunity\", name: \"Necrotic\", value: \"necrotic\" },\n      { id: 27, type: 2, kind: \"immunity\", name: \"Acid\", value: \"acid\" },\n      { id: 28, type: 2, kind: \"immunity\", name: \"Psychic\", value: \"psychic\" },\n      { id: 29, type: 2, kind: \"immunity\", name: \"Physical\", value: \"bludgeoning-piercing-and-slashing-from-nonmagical-weapons\", foundryValue: \"physical\" },\n      { id: 30, type: 2, kind: \"immunity\", name: \"Physical\", value: \"bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-silvered\", foundryValue: \"physical\" },\n      { id: 31, type: 2, kind: \"immunity\", name: \"Physical\", value: \"bludgeoning-piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine\", foundryValue: \"physical\" },\n      // { id: 32, type: 2, kind: \"immunity\", name: \"Physical\", value: \"piercing-and-slashing-from-nonmagical-attacks-that-arent-adamantine\", foundryValue: \"physical\" },\n      { id: 33, type: 2, kind: \"vulnerability\", name: \"Bludgeoning\", value: \"bludgeoning\" },\n      { id: 34, type: 2, kind: \"vulnerability\", name: \"Piercing\", value: \"piercing\" },\n      { id: 35, type: 2, kind: \"vulnerability\", name: \"Slashing\", value: \"slashing\" },\n      { id: 36, type: 2, kind: \"vulnerability\", name: \"Lightning\", value: \"lightning\" },\n      { id: 37, type: 2, kind: \"vulnerability\", name: \"Thunder\", value: \"thunder\" },\n      { id: 38, type: 2, kind: \"vulnerability\", name: \"Poison\", value: \"poison\" },\n      { id: 39, type: 2, kind: \"vulnerability\", name: \"Cold\", value: \"cold\" },\n      { id: 40, type: 2, kind: \"vulnerability\", name: \"Radiant\", value: \"radiant\" },\n      { id: 41, type: 2, kind: \"vulnerability\", name: \"Fire\", value: \"fire\" },\n      { id: 42, type: 2, kind: \"vulnerability\", name: \"Necrotic\", value: \"necrotic\" },\n      { id: 43, type: 2, kind: \"vulnerability\", name: \"Acid\", value: \"acid\" },\n      { id: 44, type: 2, kind: \"vulnerability\", name: \"Psychic\", value: \"psychic\" },\n\n      { id: 47, type: 2, kind: \"resistance\", name: \"Force\", value: \"force\" },\n      { id: 48, type: 2, kind: \"immunity\", name: \"Force\", value: \"force\" },\n      { id: 49, type: 2, kind: \"vulnerability\", name: \"Force\", value: \"force\" },\n      { id: 51, type: 2, kind: \"resistance\", name: \"Ranged attacks\" },\n      { id: 52, type: 2, kind: \"resistance\", name: \"Damage dealt by traps\" },\n      { id: 54, type: 2, kind: \"resistance\", name: \"Bludgeoning from non magical attacks\" },\n\n      { id: 1, type: 1, kind: \"immunity\", name: \"Blinded\", value: \"blinded\" },\n      { id: 2, type: 1, kind: \"immunity\", name: \"Charmed\", value: \"charmed\" },\n      { id: 3, type: 1, kind: \"immunity\", name: \"Deafened\", value: \"deafened\" },\n      { id: 4, type: 1, kind: \"immunity\", name: \"Exhaustion\", value: \"exhaustion\" },\n      { id: 5, type: 1, kind: \"immunity\", name: \"Frightened\", value: \"frightened\" },\n      { id: 6, type: 1, kind: \"immunity\", name: \"Grappled\", value: \"grappled\" },\n      { id: 7, type: 1, kind: \"immunity\", name: \"Incapacitated\", value: \"incapacitated\" },\n      { id: 8, type: 1, kind: \"immunity\", name: \"Invisible\", value: \"invisible\" },\n      { id: 9, type: 1, kind: \"immunity\", name: \"Paralyzed\", value: \"paralyzed\" },\n      { id: 10, type: 1, kind: \"immunity\", name: \"Petrified\", value: \"petrified\" },\n      { id: 11, type: 1, kind: \"immunity\", name: \"Poisoned\", value: \"poisoned\" },\n      { id: 12, type: 1, kind: \"immunity\", name: \"Prone\", value: \"prone\" },\n      { id: 13, type: 1, kind: \"immunity\", name: \"Restrained\", value: \"restrained\" },\n      { id: 14, type: 1, kind: \"immunity\", name: \"Stunned\", value: \"stunned\" },\n      { id: 15, type: 1, kind: \"immunity\", name: \"Unconscious\", value: \"unconscious\" },\n      // In DDB it is disease, but in FVTT ut is diseased\n      { id: 16, type: 1, kind: \"immunity\", name: \"Diseased\", value: \"disease\", foundryValue: \"diseased\" },\n    ],\n    proficiencies: [\n      // Armor\n      { name: \"Studded Leather\", type: \"Armor\", subType: \"Light Armor\" },\n      { name: \"Scale Mail\", type: \"Armor\", subType: \"Medium Armor\" },\n      { name: \"Shield\", type: \"Armor\", subType: \"Shield\" },\n      { name: \"Padded\", type: \"Armor\", subType: \"Light Armor\" },\n      { name: \"Leather\", type: \"Armor\", subType: \"Light Armor\" },\n      { name: \"Hide\", type: \"Armor\", subType: \"Medium Armor\" },\n      { name: \"Chain Shirt\", type: \"Armor\", subType: \"Medium Armor\" },\n      { name: \"Breastplate\", type: \"Armor\", subType: \"Medium Armor\" },\n      { name: \"Half Plate\", type: \"Armor\", subType: \"Medium Armor\" },\n      { name: \"Ring Mail\", type: \"Armor\", subType: \"Heavy Armor\" },\n      { name: \"Chain Mail\", type: \"Armor\", subType: \"Heavy Armor\" },\n      { name: \"Splint\", type: \"Armor\", subType: \"Heavy Armor\" },\n      { name: \"Plate\", type: \"Armor\", subType: \"Heavy Armor\" },\n      { name: \"Spiked Armor\", type: \"Armor\", subType: \"Medium Armor\" },\n\n      // Weapons\n      { name: \"Crossbow, Hand\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Glaive\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Dagger\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Longsword\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Club\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Greatclub\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Handaxe\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Javelin\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Light Hammer\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Mace\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Quarterstaff\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Sickle\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Spear\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Crossbow, Light\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Dart\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Shortbow\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Sling\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Battleaxe\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Flail\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Greataxe\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Greatsword\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Halberd\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Lance\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Maul\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Morningstar\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Pike\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Rapier\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Scimitar\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Shortsword\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Trident\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"War Pick\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Warhammer\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Whip\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Blowgun\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Crossbow, Heavy\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Longbow\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Net\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Boomerang\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Yklwa\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n      { name: \"Pistol\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Musket\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Pistol, Automatic\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Revolver\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Rifle, Hunting\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Rifle, Automatic\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Shotgun\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Laser Pistol\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Antimatter Rifle\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Laser Rifle\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Double-Bladed Scimitar\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Revenant Double-Bladed Scimitar\", type: \"Weapon\", subType: \"Martial Weapon\", foundryValue: \"\" },\n      { name: \"Ammunition\", type: \"Weapon\", subType: \"Simple Weapon\", foundryValue: \"\" },\n\n      // Tools and Instruments and Stuff\n      { name: \"Carpenter's Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"dex\", baseTool: \"carpenter\" },\n      { name: \"Cartographer's Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"dex\", baseTool: \"cartographer\" },\n      { name: \"Cobbler's Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"dex\", baseTool: \"cobbler\" },\n      { name: \"Cook's Utensils\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"wis\", baseTool: \"cook\" },\n      { name: \"Glassblower's Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"dex\", baseTool: \"glassblower\" },\n      { name: \"Jeweler's Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"dex\", baseTool: \"jeweler\" },\n      { name: \"Leatherworker's Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"dex\", baseTool: \"leatherworker\" },\n      { name: \"Mason's Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"dex\", baseTool: \"mason\" },\n      { name: \"Navigator's Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"int\", baseTool: \"navg\" },\n      { name: \"Potter's Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"dex\", baseTool: \"potter\" },\n      { name: \"Smith's Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"dex\", baseTool: \"smith\" },\n      { name: \"Thieves' Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"dex\", baseTool: \"thief\" },\n      { name: \"Tinker's Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"dex\", baseTool: \"tinker\" },\n      { name: \"Weaver's Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"dex\", baseTool: \"weaver\" },\n      { name: \"Woodcarver's Tools\", type: \"Tool\", subType: \"Artisan's Tools\", ability: \"dex\", baseTool: \"woodcarver\" },\n      { name: \"Dice Set\", type: \"Tool\", subType: \"Gaming Set\", ability: \"int\", baseTool: \"dice\" },\n      { name: \"Dragonchess Set\", type: \"Tool\", subType: \"Gaming Set\", ability: \"int\", baseTool: \"chess\" },\n      { name: \"Playing Card Set\", type: \"Tool\", subType: \"Gaming Set\", ability: \"int\", baseTool: \"card\" },\n      { name: \"Three-Dragon Ante Set\", type: \"Tool\", subType: \"Gaming Set\", ability: \"int\", baseTool: \"\" },\n      { name: \"Disguise Kit\", type: \"Tool\", subType: \"Kit\", ability: \"int\", baseTool: \"disg\" },\n      { name: \"Forgery Kit\", type: \"Tool\", subType: \"Kit\", ability: \"int\", baseTool: \"forge\" },\n      { name: \"Herbalism Kit\", type: \"Tool\", subType: \"Kit\", ability: \"int\", baseTool: \"herb\" },\n      { name: \"Poisoner's Kit\", type: \"Tool\", subType: \"Kit\", ability: \"int\", baseTool: \"pois\" },\n      { name: \"Bagpipes\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"con\", baseTool: \"bagpipes\" },\n      { name: \"Birdpipes\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"con\", baseTool: \"\" },\n      { name: \"Drum\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"drum\" },\n      { name: \"Dulcimer\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"dulcimer\" },\n      { name: \"Flute\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"flute\" },\n      { name: \"Glaur\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"\" },\n      { name: \"Hand Drum\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"\" },\n      { name: \"Horn\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"horn\" },\n      { name: \"Longhorn\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"\" },\n      { name: \"Lute\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"lute\" },\n      { name: \"Lyre\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"lyre\" },\n      { name: \"Pan Flute\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"\" },\n      { name: \"Shawm\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"\" },\n      { name: \"Songhorn\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"\" },\n      { name: \"Tantan\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"\" },\n      { name: \"Thelarr\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"\" },\n      { name: \"Tocken\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"\" },\n      { name: \"Viol\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"viol\" },\n      { name: \"Wargong\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"\" },\n      { name: \"Yarting\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"\" },\n      { name: \"Zulkoon\", type: \"Tool\", subType: \"Musical Instrument\", ability: \"dex\", baseTool: \"\" },\n      { name: \"Alchemist's Supplies\", type: \"Tool\", subType: \"Supplies\", ability: \"int\", baseTool: \"alchemist\" },\n      { name: \"Brewer's Supplies\", type: \"Tool\", subType: \"Supplies\", ability: \"int\", baseTool: \"brewer\" },\n      { name: \"Calligrapher's Supplies\", type: \"Tool\", subType: \"Supplies\", ability: \"dex\", baseTool: \"calligrapher\" },\n      { name: \"Painter's Supplies\", type: \"Tool\", subType: \"Supplies\", ability: \"dex\", baseTool: \"\" },\n      { name: \"Vehicles (Land)\", type: \"Tool\", subType: \"Vehicles\", ability: \"dex\", baseTool: \"land\" },\n      { name: \"Vehicles (Air)\", type: \"Tool\", subType: \"Vehicles\", ability: \"dex\", baseTool: \"air\" },\n      { name: \"Vehicles (Water)\", type: \"Tool\", subType: \"Vehicles\", ability: \"dex\", baseTool: \"water\" },\n    ],\n    characterValuesLookup: [\n      { name: \"pactWeapon\", typeId: 28 },\n      { name: \"hexWarrior\", typeId: 29 },\n    ],\n    // Supported Warlock Pact Weapon options\n    pactFeatures: [\"Improved Pact Weapon\", \"Lifedrinker\"],\n  },\n  item: {\n    characterValues: [\n      { typeId: 8, value: \"name\" },\n      //   { typeId: 9, value: 'notes'},  // note: Not supported by Foundry right now, skipping\n      { typeId: 19, value: \"price\" },\n      { typeId: 22, value: \"weight\" },\n    ],\n  },\n  items: [\n    { filterType: \"Armor\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/armor.jpg\" },\n    { filterType: \"Potion\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/potion.jpg\" },\n    { filterType: \"Ring\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/ring.jpg\" },\n    { filterType: \"Rod\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/rod.jpg\" },\n    { filterType: \"Scroll\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/scroll.jpg\" },\n    { filterType: \"Staff\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/staff.jpg\" },\n    { filterType: \"Wand\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/wand.jpg\" },\n    { filterType: \"Weapon\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/weapon.jpg\" },\n    { filterType: \"Wondrous item\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/item_types/wondrousitem.jpg\" },\n  ],\n  genericItemIcons: [\n    { name: \"Adventuring Gear\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/adventuring-gear.jpg\" },\n    { name: \"Tool\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/tool.jpg\" },\n    { name: \"Gemstone\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/gemstone.jpg\" },\n    { name: \"Holy Symbol\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/holy-symbol.jpg\" },\n    { name: \"Weapon\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/weapon.jpg\" },\n    { name: \"Arcane Focus\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/arcane-focus.jpg\" },\n    { name: \"Druidic Focus\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/druidic-focus.jpg\" },\n    { name: \"Ammunition\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/ammunition.jpg\" },\n    { name: \"Poison\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/poison.jpg\" },\n    { name: \"Mount\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/mount.jpg\" },\n    { name: \"Potion\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/potion.jpg\" },\n    { name: \"Equipment Pack\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/pack.jpg\" },\n    // Vehicle (Land)/(Water)\n    { name: \"Vehicle\", img: \"https://www.dndbeyond.com/content/1-0-1358-0/skins/waterdeep/images/icons/equipment/vehicle.jpg\" },\n  ],\n  equipment: {\n    armorType: [\n      { name: \"Light Armor\", id: 1, value: \"light\" },\n      { name: \"Medium Armor\", id: 2, value: \"medium\" },\n      { name: \"Heavy Armor\", id: 3, value: \"heavy\" },\n      { name: \"Shield\", id: 4, value: \"shield\" },\n      { name: \"Unarmored\", id: 0, value: null },\n      { name: \"Unarmored Defense\", id: -1, value: null },\n      { name: \"Natural Armor\", id: -2, value: \"natural\" },\n      { name: \"Magical Bonus\", id: -3, value: \"bonus\" },\n      { name: \"Clothing\", id: -4, value: \"clothing\" },\n    ],\n  },\n  weapon: {\n    weaponRange: [\n      { attackType: 1, value: \"M\" },\n      { attackType: 2, value: \"R\" },\n      { attackType: null, value: \"R\" },\n    ],\n    weaponType: [\n      { categoryId: 1, value: \"simple\" },\n      { categoryId: 2, value: \"martial\" },\n      { categoryId: 3, value: \"martial\" }, // this is not 100% correct. a martialF for \"Martial Firearms\" would be better\n      { categoryId: 0, value: \"simple\" }, // this is totally incorrect, this is of type ammunition\n    ],\n    properties: [\n      { name: \"Ammunition\", value: \"amm\" },\n      { name: \"Ammunition (Firearms)\", value: \"fir\" },\n      { name: \"Finesse\", value: \"fin\" },\n      { name: \"Heavy\", value: \"hvy\" },\n      { name: \"Light\", value: \"lgt\" },\n      { name: \"Loading\", value: \"lod\" },\n      { name: \"Range\", value: \"fir\" },\n      { name: \"Reach\", value: \"rch\" },\n      { name: \"Reload\", value: \"rel\" },\n      { name: \"Special\", value: \"spc\" },\n      { name: \"Thrown\", value: \"thr\" },\n      { name: \"Two-Handed\", value: \"two\" },\n      { name: \"Versatile\", value: \"ver\" },\n      { name: \"Returning\", value: \"ret\" },\n      { name: \"Focus\", value: \"foc\" },\n      { name: \"Adamantine\", value: \"ada\" },\n      { name: \"Magical\", value: \"mgc\" },\n      { name: \"Silvered\", value: \"sil\" },\n    ],\n  },\n  actions: {\n    activationTypes: [\n      { id: 0, value: \"none\" },\n      { id: 1, value: \"action\" },\n      { id: 2, value: \"action\" },\n      { id: 3, value: \"bonus\" },\n      { id: 4, value: \"reaction\" },\n      { id: 5, value: \"action\" },\n      { id: 6, value: \"minute\" },\n      { id: 7, value: \"hour\" },\n      { id: 8, value: \"special\" },\n    ],\n    attackTypes: [\n      //  natural improv\n      // { attackSubtype: 1, value: \"\" },\n      { attackSubtype: 2, value: \"natural\" },\n      { attackSubtype: 3, value: \"simpleM\" }, // unarmed\n    ],\n    damageType: [\n      { name: \"bludgeoning\", id: 1 },\n      { name: \"piercing\", id: 2 },\n      { name: \"slashing\", id: 3 },\n      { name: \"necrotic\", id: 4 },\n      { name: \"acid\", id: 5 },\n      { name: \"cold\", id: 6 },\n      { name: \"fire\", id: 7 },\n      { name: \"lightning\", id: 8 },\n      { name: \"thunder\", id: 9 },\n      { name: \"poison\", id: 10 },\n      { name: \"psychic\", id: 11 },\n      { name: \"radiant\", id: 12 },\n      { name: \"force\", id: 13 },\n      { name: null, id: null },\n    ],\n    aoeType: [\n      { id: 1, value: \"cone\" },\n      { id: 2, value: \"\" },\n      { id: 3, value: \"\" },\n      { id: 4, value: \"line\" },\n      // presumably others here too! add when found\n    ],\n  },\n  spell: {\n    schools: [\n      { id: \"abj\", name: \"abjuration\", img: \"https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/abjuration.png\" },\n      { id: \"con\", name: \"conjuration\", img: \"https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/conjuration.png\" },\n      { id: \"div\", name: \"divination\", img: \"https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/divination.png\" },\n      { id: \"enc\", name: \"enchantment\", img: \"https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/enchantment.png\" },\n      { id: \"evo\", name: \"evocation\", img: \"https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/evocation.png\" },\n      { id: \"ill\", name: \"illusion\", img: \"https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/illusion.png\" },\n      { id: \"nec\", name: \"necromancy\", img: \"https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/necromancy.png\" },\n      { id: \"trs\", name: \"transmutation\", img: \"https://www.dndbeyond.com/content/1-0-1337-0/skins/waterdeep/images/spell-schools/35/transmutation.png\" },\n    ],\n    progression: [\n      { name: \"Artificer\", value: \"artificer\" },\n      { name: \"Artificer (UA)\", value: \"artificer\" },\n      { name: \"Bard\", value: \"full\" },\n      { name: \"Barbarian\", value: \"none\" },\n      { name: \"Blood Hunter\", value: \"pact\" },\n      { name: \"Blood Hunter (archived)\", value: \"pact\" },\n      { name: \"Cleric\", value: \"full\" },\n      { name: \"Druid\", value: \"full\" },\n      { name: \"Fighter\", value: \"third\" },\n      { name: \"Hunter\", value: \"half\" },\n      { name: \"Paladin\", value: \"half\" },\n      { name: \"Ranger\", value: \"half\" },\n      { name: \"Rogue\", value: \"third\" },\n      { name: \"Sorcerer\", value: \"full\" },\n      { name: \"Warlock\", value: \"pact\" },\n      { name: \"Wizard\", value: \"full\" },\n      { name: \"Monk\", value: \"none\" },\n    ],\n    preparationModes: [\n      { name: \"Artificer\", value: \"prepared\" },\n      { name: \"Artificer (UA)\", value: \"prepared\" },\n      { name: \"Bard\", value: \"always\" },\n      { name: \"Blood Hunter\", value: \"pact\" },\n      { name: \"Blood Hunter (archived)\", value: \"pact\" },\n      { name: \"Cleric\", value: \"prepared\" },\n      { name: \"Druid\", value: \"prepared\" },\n      { name: \"Fighter\", value: \"always\" },\n      { name: \"Hunter\", value: \"always\" },\n      { name: \"Paladin\", value: \"prepared\" },\n      { name: \"Ranger\", value: \"always\" },\n      { name: \"Rogue\", value: \"always\" },\n      { name: \"Sorcerer\", value: \"always\" },\n      { name: \"Warlock\", value: \"pact\" },\n      { name: \"Wizard\", value: \"prepared\" },\n      { name: \"Monk\", value: \"always\" },\n    ],\n    activationTypes: [\n      { activationType: 0, value: \"none\", name: \"No Action\" }, // doesn't exist an more\n      { activationType: 1, value: \"action\", name: \"Action\", }, // action\n      { activationType: 2, value: \"none\", name: \"No Action\" }, // no action\n      { activationType: 3, value: \"bonus\", name: \"Bonus Action\" }, // bonus action\n      { activationType: 4, value: \"reaction\", name: \"Reaction\", }, // reaction\n      { activationType: 5, value: \"special\", name: \"Unknown\" }, // no longer exists\n      { activationType: 6, value: \"minute\", name: \"Minute\" }, // minute\n      { activationType: 7, value: \"hour\", name: \"Hour\" }, // hour\n      { activationType: 8, value: \"special\", name: \"Special\" }, // special\n    ],\n  },\n};\n\nexport default DICTIONARY;\n","import utils from \"../utils.js\";\nimport logger from \"../logger.js\";\nimport DICTIONARY from \"../dictionary.js\";\nimport { baseItemEffect, generateUpgradeChange, generateAddChange } from \"./effects.js\";\n\n// // ac -\n// { type: \"bonus\", subType: \"armor-class\" },\n// // e.g. robe of the archm\n// { type: \"set\", subType: \"unarmored-armor-class\" },\n// // bracers of defence\n// { type: \"bonus\", subType: \"unarmored-armor-class\" },\n\n/**\n *\n * @param {*} label\n */\nfunction buildBaseACEffect(label) {\n  let effect = {\n    changes: [],\n    duration: {\n      seconds: null,\n      startTime: null,\n      rounds: null,\n      turns: null,\n      startRound: null,\n      startTurn: null,\n    },\n    origin: null,\n    label,\n    tint: \"\",\n    disabled: true,\n    transfer: true,\n    selectedKey: [],\n    icon: \"icons/svg/shield.svg\",\n  };\n  return effect;\n}\n\n/**\n *\n * Generate an effect given inputs for AC\n * This is a high priority set effect that will typically override all other AE.\n * @param {*} formula\n * @param {*} label\n * @param {*} alwaysActive\n * @param {*} priority\n * @param {*} mode\n */\nexport function generateFixedACEffect(formula, label, alwaysActive = false, priority = 30, mode = CONST.ACTIVE_EFFECT_MODES.OVERRIDE) {\n  let effect = buildBaseACEffect(label);\n\n  effect.flags = {\n    dae: { transfer: true, armorEffect: true },\n    ddbimporter: { disabled: !alwaysActive, itemId: null, entityTypeId: null, characterEffect: true },\n  };\n  // effect.disabled = !alwaysActive;\n  effect.disabled = false;\n  effect.origin = \"AC\";\n\n  const change = {\n    key: \"data.attributes.ac.value\",\n    value: formula,\n    mode,\n    priority,\n  };\n\n  effect.changes.push(change);\n\n  return effect;\n}\n\n/**\n * Generate stat sets\n *\n * @param {*} modifiers\n * @param {*} name\n * @param {*} subType\n */\nfunction addACSetEffect(modifiers, name, subType) {\n  let bonuses;\n\n  if (modifiers.some((mod) => mod.statId !== null && mod.type === \"set\" && mod.subType === subType)) {\n    modifiers.filter((mod) => mod.statId !== null && mod.type === \"set\" && mod.subType === subType)\n      .forEach((mod) => {\n        const ability = DICTIONARY.character.abilities.find((ability) => ability.id === mod.statId);\n        if (bonuses) {\n          bonuses += \" \";\n        } else {\n          bonuses = \"\";\n        }\n        bonuses += `@abilities.${ability.value}.mod`;\n      });\n  } else {\n    // others are picked up here e.g. Draconic Resilience\n    const fixedValues = modifiers.filter((mod) => mod.type === \"set\" && mod.subType === subType).map((mod) => mod.value);\n    bonuses = Math.max(fixedValues);\n  }\n\n  let effects = [];\n  const maxDexTypes = [\"ac-max-dex-unarmored-modifier\", \"ac-max-dex-modifier\"];\n\n  if (bonuses && bonuses != 0) {\n    let effectString = \"\";\n    switch (subType) {\n      case \"unarmored-armor-class\": {\n        let maxDexMod = 99;\n        const ignoreDexMod = modifiers.some((mod) => mod.type === \"ignore\" && mod.subType === \"unarmored-dex-ac-bonus\");\n        const maxDexArray = modifiers\n          .filter((mod) => mod.type === \"set\" && maxDexTypes.includes(mod.subType))\n          .map((mod) => mod.value);\n        if (maxDexArray.length > 0) maxDexMod = Math.min(maxDexArray);\n        if (ignoreDexMod) {\n          effectString = `10 + ${bonuses}`;\n        } else {\n          effectString = `@abilities.dex.mod > ${maxDexMod} ? 10 + ${bonuses} + ${maxDexMod} : 10 + ${bonuses} + @abilities.dex.mod`;\n        }\n        break;\n      }\n      default: {\n        effectString = `10 + ${bonuses} + @abilities.dex.mod`;\n      }\n    }\n\n    logger.debug(`Generating ${subType} AC set for ${name}: ${effectString}`);\n    effects.push(\n      generateUpgradeChange(\n        effectString,\n        15,\n        \"data.attributes.ac.value\"\n      )\n    );\n  }\n  return effects;\n}\n\n/**\n *\n * @param {*} modifiers\n * @param {*} name\n */\nfunction addACSets(modifiers, name) {\n  let changes = [];\n  const stats = [\"unarmored-armor-class\"];\n  stats.forEach((set) => {\n    const result = addACSetEffect(modifiers, name, set);\n    changes = changes.concat(result);\n  });\n\n  return changes;\n}\n\n/**\n * Generates an AC bonus for an item\n *\n * @param {*} modifiers\n * @param {*} name\n * @param {*} type\n */\nfunction addACBonusEffect(modifiers, name, type) {\n  let changes = [];\n  const restrictions = [\n    \"while wearing heavy armor\",\n    \"\",\n    null,\n  ];\n  const bonus = utils.filterModifiers(modifiers, \"bonus\", type, restrictions).reduce((a, b) => a + b.value, 0);\n  if (bonus !== 0) {\n    logger.debug(`Generating ${type} bonus for ${name}`);\n    const AUTO_AC = utils.versionCompare(game.data.system.data.version, \"1.4.0\") >= 0;\n    if (AUTO_AC) {\n      const daeInstalled = utils.isModuleInstalledAndActive(\"dae\");\n      // using bonus here adds them to the bonus field, but then items that add a bonsu don't get applied\n      // (e.g. bracers of defense) if wearing something like robi of archmage.\n      // this is set to value, and show up as separate line in ac calculation.\n      // we set this to bonus if dae is not installed as itherwise it is not applied.\n      if (daeInstalled) {\n        changes.push(generateAddChange(bonus, 18, \"data.attributes.ac.value\"));\n      } else {\n        changes.push(generateAddChange(bonus, 18, \"data.attributes.ac.bonus\"));\n      }\n    } else {\n      changes.push(generateAddChange(bonus, 18, \"data.attributes.ac.value\"));\n    }\n  }\n  return changes;\n}\n\n\nfunction addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem) {\n  if (\n    isCompendiumItem ||\n    foundryItem.type === \"feat\" ||\n    (ddbItem.isAttuned && ddbItem.equipped) || // if it is attuned and equipped\n    (ddbItem.isAttuned && !ddbItem.definition.canEquip) || // if it is attuned but can't equip\n    (!ddbItem.definition.canAttune && ddbItem.equipped) // can't attune but is equipped\n  ) {\n    setProperty(foundryItem, \"flags.dae.alwaysActive\", false);\n    setProperty(effect, \"flags.ddbimporter.disabled\", false);\n    effect.disabled = false;\n  } else {\n    effect.disabled = true;\n    setProperty(effect, \"flags.ddbimporter.disabled\", true);\n    setProperty(foundryItem, \"flags.dae.alwaysActive\", false);\n  }\n\n  setProperty(effect, \"flags.ddbimporter.itemId\", ddbItem.id);\n  setProperty(effect, \"flags.ddbimporter.itemEntityTypeId\", ddbItem.entityTypeId);\n  // set dae flag for active equipped\n  if (ddbItem.definition?.canEquip || ddbItem.definition?.canAttune) {\n    setProperty(foundryItem, \"flags.dae.activeEquipped\", true);\n  } else {\n    setProperty(foundryItem, \"flags.dae.activeEquipped\", false);\n  }\n\n  return [foundryItem, effect];\n}\n\nfunction generateBaseACEffectChanges(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect) {\n  const noModifiers = !ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0;\n  const noACValue = !foundryItem.data?.armor?.value;\n  const daeInstalled = utils.isModuleInstalledAndActive(\"dae\");\n  const daeBonusField = daeInstalled ? \"data.attributes.ac.value\" : \"data.attributes.ac.bonus\";\n\n  if (noModifiers && noACValue) return [];\n  // console.error(`Item: ${foundryItem.name}`, ddbItem);\n  logger.debug(`Generating supported AC changes for ${foundryItem.name} for effect ${effect.label}`);\n\n  // base ac from modifiers\n  const acSets = daeInstalled ? addACSets(ddbItem.definition.grantedModifiers, foundryItem.name) : [];\n\n  // ac bonus effects\n  const acBonus = addACBonusEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"armor-class\",\n    daeBonusField\n  );\n  const unarmoredACBonus = addACBonusEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"unarmored-armor-class\",\n    daeBonusField\n  );\n  const armoredACBonus = addACBonusEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"armored-armor-class\",\n    daeBonusField\n  );\n  const dualWieldACBonus = addACBonusEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"dual-wield-armor-class\",\n    daeBonusField\n  );\n\n  const acChanges = [\n    ...acSets,\n    ...acBonus,\n    ...unarmoredACBonus,\n    ...armoredACBonus,\n    ...dualWieldACBonus,\n  ];\n\n  return acChanges;\n\n}\n\n// generates changes and adds to effect for item\nexport function generateACEffectChangesForItem(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect) {\n  const noModifiers = !ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0;\n\n  if (noModifiers) return [foundryItem, effect];\n\n  const acChanges = generateBaseACEffectChanges(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect);\n\n  if (acChanges.length === 0) return [foundryItem, effect]; ;\n\n  effect.changes = effect.changes.concat(acChanges);\n\n  // generate flags for effect (e.g. checking attunement and equipped status)\n  [foundryItem, effect] = addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem);\n\n  return [foundryItem, effect];\n\n}\n\n/**\n *\n * @param {*} ddb\n * @param {*} character\n * @param {*} ddbItem\n * @param {*} foundryItem\n * @param {*} isCompendiumItem\n */\nexport function generateBaseACItemEffect(ddb, character, ddbItem, foundryItem, isCompendiumItem) {\n  const noModifiers = !ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0;\n  const noACValue = !foundryItem.data?.armor?.value;\n\n  if (noModifiers && noACValue) return foundryItem;\n  // console.error(`Item: ${foundryItem.name}`, ddbItem);\n  logger.debug(`Generating supported AC effects for ${foundryItem.name}`);\n\n  let effect = baseItemEffect(foundryItem, `AC: ${foundryItem.name}`);\n\n  // generate flags for effect (e.g. checking attunement and equipped status)\n  [foundryItem, effect] = generateACEffectChangesForItem(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect);\n\n  if (effect.changes?.length > 0) {\n    if (!foundryItem.effects) foundryItem.effects = [];\n    foundryItem.effects.push(effect);\n  }\n  return foundryItem;\n}\n","import {\n  baseItemEffect,\n  generateUpgradeChange,\n  generateAddChange,\n  generateMultiplyChange,\n  generateCustomChange,\n} from \"./effects.js\";\n\n/**\n * This function is mainly for effects that can't be dynamically generated\n * @param {*} document\n */\nexport function equipmentEffectAdjustment(document) {\n  const name = document.flags.ddbimporter.originalName || document.name;\n  switch (name) {\n    case \"Armor of Invulnerability\": {\n      // this effect is 1/day, we have to add it\n      let effect = baseItemEffect(document, `${document.name} - Invulnerability`);\n      effect.changes.push(generateAddChange(\"physical\", 20, \"data.traits.di.value\"));\n      effect.duration = {\n        startTime: null,\n        seconds: 600,\n        rounds: null,\n        turns: null,\n        startRound: null,\n        startTurn: null,\n      };\n      effect.transfer = false;\n      effect.disabled = false;\n      effect.flags.dae.transfer = false;\n      effect.flags.dae.stackable = false;\n      effect.flags.dae.specialDuration = \"None\";\n      document.data.uses = {\n        value: 1,\n        max: \"1\",\n        per: \"day\",\n      };\n      document.data.target = {\n        value: null,\n        width: null,\n        units: \"\",\n        type: \"self\",\n      };\n      document.data.range = {\n        value: null,\n        long: null,\n        units: \"self\",\n      };\n      document.effects.push(effect);\n      break;\n    }\n    case \"Bracers of Archery\": {\n      // +2 damage to longbows/shortbows translates to +2 ranged weapon damage\n      document.effects[0].changes.push({\n        key: \"data.bonuses.rwak.damage\",\n        value: \"+2\",\n        mode: 0,\n        priority: 20,\n      });\n      break;\n    }\n    case \"Demon Armor\": {\n      // Unarmed strikes bonus/weapons\n      document.effects[0].changes.push(\n        {\n          key: \"items.Unarmed Strike.data.attackBonus\",\n          value: \"1\",\n          mode: 2,\n          priority: 20,\n        },\n        {\n          key: \"items.Unarmed Strike.data.damage.parts.0.0\",\n          value: \"1d8+@mod+1\",\n          mode: 5,\n          priority: 20,\n        },\n        {\n          key: \"items.Unarmed Strike.data.properties.mgc\",\n          value: \"true\",\n          mode: 5,\n          priority: 20,\n        }\n      );\n      break;\n    }\n    case \"Belashyrras Beholder Crown\": {\n      let effect = baseItemEffect(document, `${document.name} - Constant Effects`);\n      effect.changes.push(generateUpgradeChange(120, 10, \"data.attributes.senses.darkvision\"));\n      document.effects.push(effect);\n      break;\n    }\n    case \"Boots of Speed\": {\n      let effect = baseItemEffect(document, `${document.name} - Invulnerability`);\n      effect.changes.push(generateMultiplyChange(2, 20, \"data.attributes.movement.walk\"));\n      effect.duration = {\n        startTime: null,\n        seconds: 600,\n        rounds: null,\n        turns: null,\n        startRound: null,\n        startTurn: null,\n      };\n      effect.transfer = true;\n      effect.disabled = true;\n      effect.flags.dae.transfer = true;\n      effect.flags.dae.stackable = true;\n      effect.flags.dae.specialDuration = \"None\";\n      document.data.target = {\n        value: null,\n        width: null,\n        units: \"\",\n        type: \"self\",\n      };\n      document.data.range = {\n        value: null,\n        long: null,\n        units: \"self\",\n      };\n      document.data.activation.type = \"bonus\";\n      document.effects.push(effect);\n      break;\n    }\n    case \"Cloak of Displacement\": {\n      let effect = baseItemEffect(document, `${document.name} - Constant Effects`);\n      effect.flags.dae.specialDuration = [\"isDamaged\"];\n      break;\n    }\n    case \"Spellguard Shield\": {\n      document.effects[0].changes.push(\n        generateCustomChange(1, 20, \"flags.midi-qol.grants.disadvantage.attack.msak\"),\n        generateCustomChange(1, 20, \"flags.midi-qol.grants.disadvantage.attack.rsak\")\n      );\n      break;\n    }\n    // no default\n  }\n\n  return document;\n}\n","// import {\n//   baseItemEffect,\n//   generateUpgradeChange,\n//   generateAddChange,\n//   generateMultiplyChange,\n//   generateCustomChange,\n// } from \"./effects.js\";\n\n/**\n * This function is mainly for effects that can't be dynamically generated\n * @param {*} document\n */\nexport function infusionEffectAdjustment(document) {\n\n  return document;\n}\n","import utils from \"../utils.js\";\nimport logger from \"../logger.js\";\nimport DICTIONARY from \"../dictionary.js\";\nimport {\n  getWeaponProficiencies,\n  getArmorProficiencies,\n  getToolProficiencies,\n  getLanguagesFromModifiers,\n} from \"../parser/character/proficiencies.js\";\nimport { getSkillProficiency } from \"../parser/character/skills.js\";\nimport { equipmentEffectAdjustment } from \"./specialEquipment.js\";\nimport { spellEffectAdjustment } from \"./specialSpells.js\";\nimport { featureEffectAdjustment } from \"./specialFeats.js\";\nimport { infusionEffectAdjustment } from \"./specialInfusions.js\";\nimport { generateACEffectChangesForItem } from \"./acEffects.js\";\n\n/**\n * Add supported effects here to exclude them from calculations.\n */\nconst EFFECT_EXCLUDED_COMMON_MODIFIERS = [\n  { type: \"bonus\", subType: \"saving-throws\" },\n  { type: \"bonus\", subType: \"ability-checks\" },\n  { type: \"bonus\", subType: \"skill-checks\" },\n  { type: \"bonus\", subType: \"proficiency-bonus\" },\n\n  { type: \"set\", subType: \"strength-score\" },\n  { type: \"set\", subType: \"dexterity-score\" },\n  { type: \"set\", subType: \"constitution-score\" },\n  { type: \"set\", subType: \"wisdom-score\" },\n  { type: \"set\", subType: \"intelligence-score\" },\n  { type: \"set\", subType: \"charisma-score\" },\n\n  // skills\n  { type: \"bonus\", subType: \"acrobatics\" },\n  { type: \"bonus\", subType: \"animal-handling\" },\n  { type: \"bonus\", subType: \"arcana\" },\n  { type: \"bonus\", subType: \"athletics\" },\n  { type: \"bonus\", subType: \"deception\" },\n  { type: \"bonus\", subType: \"history\" },\n  { type: \"bonus\", subType: \"insight\" },\n  { type: \"bonus\", subType: \"intimidation\" },\n  { type: \"bonus\", subType: \"investigation\" },\n  { type: \"bonus\", subType: \"medicine\" },\n  { type: \"bonus\", subType: \"nature\" },\n  { type: \"bonus\", subType: \"perception\" },\n  { type: \"bonus\", subType: \"performance\" },\n  { type: \"bonus\", subType: \"persuasion\" },\n  { type: \"bonus\", subType: \"religion\" },\n  { type: \"bonus\", subType: \"sleight-of-hand\" },\n  { type: \"bonus\", subType: \"stealth\" },\n  { type: \"bonus\", subType: \"survival\" },\n  // advantage on skills - not added here as not used elsewhere in importer.\n  // { type: \"advantage\", subType: \"acrobatics\" },\n\n  // initiative\n  { type: \"advantage\", subType: \"initiative\" },\n\n  { type: \"bonus\", subType: \"strength-ability-checks\" },\n  { type: \"bonus\", subType: \"dexterity-ability-checks\" },\n  { type: \"bonus\", subType: \"constitution-ability-checks\" },\n  { type: \"bonus\", subType: \"wisdom-ability-checks\" },\n  { type: \"bonus\", subType: \"intelligence-ability-checks\" },\n  { type: \"bonus\", subType: \"charisma-ability-checks\" },\n\n  { type: \"bonus\", subType: \"strength-saving-throws\" },\n  { type: \"bonus\", subType: \"dexterity-saving-throws\" },\n  { type: \"bonus\", subType: \"constitution-saving-throws\" },\n  { type: \"bonus\", subType: \"wisdom-saving-throws\" },\n  { type: \"bonus\", subType: \"intelligence-saving-throws\" },\n  { type: \"bonus\", subType: \"charisma-saving-throws\" },\n\n  // attack modifiers\n  { type: \"bonus\", subType: \"weapon-attacks\" },\n  { type: \"bonus\", subType: \"melee-attacks\" },\n  { type: \"bonus\", subType: \"ranged-attacks\" },\n  { type: \"bonus\", subType: \"melee-weapon-attacks\" },\n  { type: \"bonus\", subType: \"ranged-weapon-attacks\" },\n  { type: \"damage\", subType: null },\n];\n\nconst EFFECT_EXCLUDED_SPELL_MODIFIERS = [\n  { type: \"bonus\", subType: \"spell-save-dc\" },\n  { type: \"bonus\", subType: \"spell-attacks\" },\n  { type: \"bonus\", subType: \"warlock-spell-save-dc\" },\n  { type: \"bonus\", subType: \"warlock-spell-attacks\" },\n  { type: \"bonus\", subType: \"spell-group-healing\" } // data.bonuses.heal.damage\n];\n\nconst EFFECT_EXCLUDED_HP_MODIFIERS = [\n  { type: \"bonus\", subType: \"hit-points-per-level\" },\n  { type: \"bonus\", subType: \"hit-points\" },\n];\n\nconst EFFECT_EXCLUDED_SENSE_MODIFIERS = [\n  // senses\n  { type: \"set-base\", subType: \"darkvision\" },\n  { type: \"sense\", subType: \"darkvision\" },\n  { type: \"set-base\", subType: \"blindsight\" },\n  { type: \"sense\", subType: \"blindsight\" },\n  { type: \"set-base\", subType: \"tremorsense\" },\n  { type: \"sense\", subType: \"tremorsense\" },\n  { type: \"set-base\", subType: \"truesight\" },\n  { type: \"sense\", subType: \"truesight\" },\n];\n\nconst EFFECT_EXCLUDED_SPEED_SET_MODIFIERS = [\n  // speeds\n  { type: \"set\", subType: \"innate-speed-walking\" },\n  { type: \"set\", subType: \"innate-speed-climbing\" },\n  { type: \"set\", subType: \"innate-speed-swimming\" },\n  { type: \"set\", subType: \"innate-speed-flying\" },\n];\n\nconst EFFECT_EXCLUDED_SPEED_BONUS_MODIFIERS = [\n  { type: \"bonus\", subType: \"speed\" },\n  { type: \"bonus\", subType: \"speed-walking\" },\n  { type: \"bonus\", subType: \"speed-climbing\" },\n  { type: \"bonus\", subType: \"speed-swimming\" },\n  { type: \"bonus\", subType: \"speed-flying\" },\n];\n\nconst EFFECT_EXCLUDED_GENERAL_SPEED_MODIFIERS = EFFECT_EXCLUDED_SPEED_SET_MODIFIERS.concat(EFFECT_EXCLUDED_SPEED_BONUS_MODIFIERS);\n\nconst EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS = [\n  { type: \"bonus\", subType: \"unarmored-movement\" },\n];\n\nconst EFFECT_EXCLUDED_ALL_SPEED_MODIFIERS = EFFECT_EXCLUDED_GENERAL_SPEED_MODIFIERS.concat(EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS);\n\nconst EFFECT_EXCLUDED_ABILITY_BONUSES = [\n  { type: \"bonus\", subType: \"strength-score\" },\n  { type: \"bonus\", subType: \"dexterity-score\" },\n  { type: \"bonus\", subType: \"constitution-score\" },\n  { type: \"bonus\", subType: \"wisdom-score\" },\n  { type: \"bonus\", subType: \"intelligence-score\" },\n  { type: \"bonus\", subType: \"charisma-score\" },\n];\n\nconst EFFECT_EXCLUDED_PROFICIENCY_BONUSES = [\n  // profs\n  { type: \"proficiency\", subType: null },\n];\n\nconst EFFECT_EXCLUDED_LANGUAGES_MODIFIERS = [\n  // languages - e.g. dwarvish -- lookup from DICTIONARY\n  { type: \"language\", subType: null },\n];\n\nconst EFFECT_EXCLUDED_DAMAGE_CONDITION_MODIFIERS = [\n  // resistances - subType - e.g. poison - lookup from DICTIONARY\n  { type: \"resistance\", subType: null },\n  { type: \"immunity\", subType: null },\n  { type: \"vulnerability\", subType: null },\n];\n\nconst AC_BONUS_MODIFIERS = [\n  { type: \"bonus\", subType: \"unarmored-armor-class\" },\n  { type: \"bonus\", subType: \"armor-class\" },\n  { type: \"bonus\", subType: \"armored-armor-class\" },\n  { type: \"bonus\", subType: \"dual-wield-armor-class\" },\n];\n\nconst AC_EFFECTS = [\n  { type: \"set\", subType: \"unarmored-armor-class\" },\n  { type: \"ignore\", subType: \"unarmored-dex-ac-bonus\" },\n  { type: \"set\", subType: \"ac-max-dex-modifier\" },\n];\n\nexport function getEffectExcludedModifiers(type, features, ac) {\n  let modifiers = [];\n\n  if (type !== \"item\") {\n    // these are the effect tweaks, and mostly excessive\n    const speedEffect = game.settings.get(\"ddb-importer\", `character-update-policy-effect-${type}-speed`);\n    const senseEffect = game.settings.get(\"ddb-importer\", `character-update-policy-effect-${type}-senses`);\n    const hpEffect = game.settings.get(\"ddb-importer\", `character-update-policy-effect-${type}-hp`);\n    const spellBonusEffect = game.settings.get(\"ddb-importer\", `character-update-policy-effect-${type}-spell-bonus`);\n    const damageEffect = game.settings.get(\"ddb-importer\", `character-update-policy-effect-${type}-damages`);\n\n    // features represent core non ac features\n    if (features) {\n      modifiers = modifiers.concat(EFFECT_EXCLUDED_COMMON_MODIFIERS);\n      if ([\"feat\", \"background\", \"race\", \"class\"].includes(type)) {\n        if (speedEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_GENERAL_SPEED_MODIFIERS);\n        if (senseEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_SENSE_MODIFIERS);\n        if (hpEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_HP_MODIFIERS);\n        if (spellBonusEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_SPELL_MODIFIERS);\n        if (damageEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_DAMAGE_CONDITION_MODIFIERS);\n      }\n      if ([\"class\"].includes(type)) {\n        modifiers = modifiers.concat(EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS);\n      } else if ([\"feat\", \"background\", \"race\"].includes(type)) {\n        if (speedEffect) modifiers = modifiers.concat(EFFECT_EXCLUDED_MONK_SPEED_MODIFIERS);\n      }\n    }\n    // here ac represents the more exotic ac effects that set limits and change base\n    modifiers = modifiers.concat(AC_BONUS_MODIFIERS);\n    if (ac) {\n      modifiers = modifiers.concat(AC_EFFECTS);\n    }\n  }\n\n  // items are basically their own thing, all or nuffin\n  if (type === \"item\") {\n    modifiers = modifiers.concat(\n      EFFECT_EXCLUDED_COMMON_MODIFIERS,\n      EFFECT_EXCLUDED_ABILITY_BONUSES,\n      EFFECT_EXCLUDED_DAMAGE_CONDITION_MODIFIERS,\n      EFFECT_EXCLUDED_LANGUAGES_MODIFIERS,\n      EFFECT_EXCLUDED_PROFICIENCY_BONUSES,\n      EFFECT_EXCLUDED_ALL_SPEED_MODIFIERS,\n      EFFECT_EXCLUDED_SENSE_MODIFIERS,\n      EFFECT_EXCLUDED_HP_MODIFIERS,\n      EFFECT_EXCLUDED_SPELL_MODIFIERS,\n      AC_EFFECTS,\n      AC_BONUS_MODIFIERS,\n    );\n  }\n  return modifiers;\n}\n\n/**\n *\n * Generate a base effect for an Item\n *\n * @param {*} formula\n * @param {*} mode\n * @param {*} itemData\n * @param {*} label\n * @param {*} origin\n */\n\nexport function baseItemEffect(foundryItem, label) {\n  return {\n    label,\n    icon: foundryItem.img,\n    changes: [],\n    duration: {},\n    // duration: {\n    //   seconds: null,\n    //   startTime: null,\n    //   rounds: null,\n    //   turns: null,\n    //   startRound: null,\n    //   startTurn: null,\n    // },\n    tint: \"\",\n    transfer: true,\n    disabled: false,\n    // origin: origin,\n    flags: {\n      dae: {\n        transfer: true,\n        stackable: false,\n        // armorEffect: true\n      },\n      ddbimporter: {\n        disabled: false,\n      },\n    },\n  };\n}\n\n// *\n// CONST.ACTIVE_EFFECT_MODES.\n// ADD: 2\n// CUSTOM: 0\n// DOWNGRADE: 3\n// MULTIPLY: 1\n// OVERRIDE: 5\n// UPGRADE: 4\n//\n\nexport function generateBaseSkillEffect(id, label) {\n  const mockItem = {\n    img: \"icons/svg/up.svg\",\n  };\n  let skillEffect = baseItemEffect(mockItem, label);\n  skillEffect.flags.dae = {};\n  skillEffect.flags.ddbimporter.characterEffect = true;\n  skillEffect.origin = `Actor.${id}`;\n  delete skillEffect.transfer;\n  return skillEffect;\n}\n\n\nexport function generateStatusEffectChange(statusName, priority = 20) {\n  return {\n    key: \"macro.CE\",\n    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n    value: statusName,\n    priority: priority,\n  };\n}\n\nexport function generateTokenMagicFXChange(macroValue, priority = 20) {\n  return {\n    key: 'macro.tokenMagic',\n    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n    value: macroValue,\n    priority: priority,\n  };\n}\n\nexport function generateATLChange(atlKey, mode, value, priority = 20) {\n  let key = atlKey;\n  const version = (game.version ?? game.data.version);\n  const v9 = utils.versionCompare(version, \"9.0\") >= 0;\n\n  if (v9) {\n    switch (atlKey) {\n      case 'ATL.dimLight':\n        key = 'ATL.light.dim';\n        break;\n      case 'ATL.brightLight':\n        key = 'ATL.light.bright';\n        break;\n      case 'ATL.lightAnimation':\n        key = 'ATL.light.animation';\n        break;\n      case 'ATL.lightColor':\n        key = 'ATL.light.color';\n        break;\n      case 'ATL.lightAlpha':\n        key = 'ATL.light.alpha';\n        break;\n      case 'ATL.lightAngle':\n        key = 'ATL.light.angle';\n        break;\n      // no default\n    }\n  }\n  return {\n    key,\n    mode,\n    value,\n    priority,\n  };\n}\n\nexport function generateChange(bonus, priority, key, mode) {\n  return {\n    key: key,\n    value: bonus,\n    mode: mode,\n    priority: priority,\n  };\n}\n\nexport function generateAddChange(bonus, priority, key) {\n  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.ADD);\n}\n\nexport function generateCustomChange(bonus, priority, key) {\n  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.CUSTOM);\n}\n\nexport function generateCustomBonusChange(bonus, priority, key) {\n  return generateChange(`+${bonus}`, priority, key, CONST.ACTIVE_EFFECT_MODES.CUSTOM);\n}\n\nexport function generateUpgradeChange(bonus, priority, key) {\n  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.UPGRADE);\n}\n\nexport function generateOverrideChange(bonus, priority, key) {\n  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.OVERRIDE);\n}\n\nexport function generateMultiplyChange(bonus, priority, key) {\n  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.MULTIPLY);\n}\n\nexport function generateDowngradeChange(bonus, priority, key) {\n  return generateChange(bonus, priority, key, CONST.ACTIVE_EFFECT_MODES.DOWNGRADE);\n}\n\n\n// special effect functions\nfunction attunedItemsBonus(actor, change) {\n  // actor is the actor being processed and change a key/value pair\n  if (change.key === \"data.bonuses.abilities.save\" && change.value === \"ATTUNED_ITEM_BONUS\") {\n    // If your active effect spec was\n    const bonus = actor.data.items.filter((item) => item.data.data.attunement == 2).length;\n    // actor.data.data.bonuses.abilities.save += bonus;\n    logger.debug(`Setting attuned items saving throw bonus for ${actor.name} to ${bonus}`);\n    // setProperty(actor, \"data.flags.ddbimporter.attundedItems\", bonus);\n    // this updates the effect value\n    change.value = bonus;\n    // console.warn(actor);\n    // console.warn(change);\n    // console.warn(bonus);\n  }\n}\n\nHooks.on(\"applyActiveEffect\", attunedItemsBonus);\n\n\n//\nfunction extractModifierValue(modifier) {\n  let value = \"\";\n  let modBonus = \"\";\n\n  let statBonus = (modifier.statId)\n    ? modifier.statId\n    : modifier.abilityModifierStatId\n      ? modifier.abilityModifierStatId\n      : null;\n\n  if (statBonus) {\n    const ability = DICTIONARY.character.abilities.find((ability) => ability.id === modifier.statId).value;\n    modBonus = modBonus === \"\" ? `@abilities.${ability}.mod` : `+ @abilities.${ability}.mod`;\n  }\n\n  const fixedBonus = modifier.dice?.fixedValue ? ` + ${modifier.dice.fixedValue}` : \"\";\n\n  if (modifier.dice) {\n    if (modifier.dice.diceString) {\n      value = modifier.dice.diceString + modBonus + fixedBonus;\n    } else if (fixedBonus) {\n      value = fixedBonus + modBonus;\n    }\n  } else if (modifier.fixedValue) {\n    value = modifier.fixedValue;\n  } else if (modifier.value) {\n    value = modifier.value;\n  } else if (modBonus) {\n    value = modBonus;\n  }\n\n  if (value === \"\" && modifier.subType == \"saving-throws\" && modifier.bonusTypes.includes(2)) {\n    // we set the value to zero and when the saving throw is calculated it will\n    // be updated by the attunedItemsBonus function above\n    value = \"ATTUNED_ITEM_BONUS\";\n  }\n\n  return value;\n}\n\n\nfunction getValueFromModifiers(modifiers, name, modifierSubType, modifierType = \"bonus\") {\n  let bonuses;\n  const bonusEffects = utils.filterModifiers(modifiers, modifierType, modifierSubType);\n\n  if (bonusEffects.length > 0) {\n    logger.debug(`Generating ${modifierSubType} ${modifierType} for ${name}`);\n    bonuses = \"\";\n    bonusEffects.forEach((modifier) => {\n      let bonusParse = extractModifierValue(modifier);\n      if (bonuses !== \"\") bonuses += \" + \";\n      bonuses += bonusParse;\n    });\n    if (bonuses === \"\") {\n      bonuses = undefined;\n      logger.debug(`Modifier value 0 for ${modifierSubType} ${modifierType} for ${name}. Reset to undefined`);\n    } else {\n      logger.debug(`Modifier value string for ${modifierSubType} ${modifierType} for ${name}`, bonuses);\n    }\n  }\n\n  return bonuses;\n}\n\n/**\n * Generates a global custom bonus for an item with a +\n */\nfunction addCustomBonusEffect(modifiers, name, type, key) {\n  let changes = [];\n  const bonuses = getValueFromModifiers(modifiers, name, type, \"bonus\");\n\n  if (bonuses) {\n    changes.push(generateCustomChange(`${bonuses}`, 18, key));\n    logger.debug(`Changes for ${type} bonus for ${name}`, changes);\n  }\n\n  return changes;\n}\n\n//\n// Generate saving throw bonuses\n//\nfunction addGlobalSavingBonusEffect(modifiers, name) {\n  const type = \"saving-throws\";\n  const key = \"data.bonuses.abilities.save\";\n  let changes = [];\n  const regularBonuses = modifiers.filter((mod) => !mod.bonusTypes?.includes(2));\n  const customBonuses = modifiers.filter((mod) => mod.bonusTypes?.includes(2));\n\n  if (customBonuses.length > 0) {\n    let customEffects = addCustomBonusEffect(customBonuses, name, type, key);\n    changes = changes.concat(customEffects);\n  }\n\n  const regularModifiers = utils.filterModifiers(regularBonuses, \"bonus\", type);\n\n  if (regularModifiers.length > 0) {\n    logger.debug(`Generating ${type} bonus for ${name}`);\n    let bonuses = \"\";\n    regularModifiers.forEach((modifier) => {\n      let bonusParse = extractModifierValue(modifier);\n      if (bonuses !== \"\") bonuses += \" + \";\n      bonuses += bonusParse;\n    });\n    if (bonuses === \"\") bonuses = 0;\n    changes.push(generateAddChange(`+ ${bonuses}`, 20, key));\n    logger.debug(`Changes for ${type} bonus for ${name}`, changes);\n  }\n\n  return changes;\n}\n\n/**\n * Generates a global custom bonus for an item\n */\nfunction addCustomEffect(modifiers, name, type, key, extra = \"\") {\n  let changes = [];\n  const bonus = utils.filterModifiers(modifiers, \"bonus\", type).reduce((a, b) => a + b.value, 0);\n  if (bonus !== 0) {\n    logger.debug(`Generating ${type} bonus for ${name}`);\n    changes.push(generateCustomChange(`${bonus}${(extra) ? extra : \"\"}`, 18, key));\n  }\n  return changes;\n}\n\n/**\n * Generates a global add for an item\n */\nfunction addAddEffect(modifiers, name, type, key) {\n  let changes = [];\n  // const bonus = utils.filterModifiers(modifiers, \"bonus\", type).reduce((a, b) => a + b.value, 0);\n  const bonus = getValueFromModifiers(modifiers, name, type, \"bonus\");\n  if (bonus) {\n    logger.debug(`Generating ${type} bonus for ${name}`, bonus);\n    changes.push(generateAddChange(bonus, 18, key));\n  }\n  return changes;\n}\n\n/**\n * Adds languages, can't handle custom languages\n */\nfunction addLanguages(modifiers, name) {\n  let changes = [];\n\n  const languages = getLanguagesFromModifiers(null, modifiers);\n\n  languages.value.forEach((prof) => {\n    logger.debug(`Generating language ${prof} for ${name}`);\n    changes.push(generateCustomChange(prof, 0, \"data.traits.languages.value\"));\n  });\n  if (languages?.custom != \"\") {\n    logger.debug(`Generating language ${languages.custom} for ${name}`);\n    changes.push(generateCustomChange(languages.custom, 0, \"data.traits.languages.custom\"));\n  }\n\n  return changes;\n}\n\n\n/**\n * Generate global damage bonuses\n*/\nfunction addGlobalDamageBonus(modifiers, name) {\n  const meleeRestrictions = [\"Melee Weapon Attacks\"];\n  let changes = [];\n  const meleeBonus = utils.filterModifiers(modifiers, \"damage\", null, meleeRestrictions)\n    .filter((mod) => mod.dice || mod.value)\n    .map((mod) => {\n      if (mod.dice) {\n        return utils.parseDiceString(mod.dice.diceString, null, mod.subType ? `[${mod.subType}]` : null).diceString;\n      } else {\n        return utils.parseDiceString(mod.value, null, mod.subType ? `[${mod.subType}]` : null).diceString;\n      }\n    });\n  if (meleeBonus && meleeBonus.length > 0) {\n    logger.debug(`Generating melee damage for ${name}`);\n    changes.push(generateCustomChange(`${meleeBonus.join(\" + \")}`, 18, \"data.bonuses.mwak.damage\"));\n  }\n  const rangedRestrictions = [\"Ranged Weapon Attacks\"];\n  const rangedBonus = utils.filterModifiers(modifiers, \"damage\", null, rangedRestrictions)\n    .filter((mod) => mod.dice || mod.value)\n    .map((mod) => {\n      if (mod.dice) {\n        return utils.parseDiceString(mod.dice.diceString, null, mod.subType ? `[${mod.subType}]` : null).diceString;\n      } else {\n        return utils.parseDiceString(mod.value, null, mod.subType ? `[${mod.subType}]` : null).diceString;\n      }\n    });\n  if (rangedBonus && rangedBonus.length > 0) {\n    logger.debug(`Generating ranged damage for ${name}`);\n    changes.push(generateCustomChange(`${rangedBonus.join(\" + \")}`, 18, \"data.bonuses.rwak.damage\"));\n  }\n  const bonus = utils.filterModifiers(modifiers, \"damage\", null)\n    .filter((mod) => mod.dice || mod.value)\n    .map((mod) => {\n      if (mod.dice) {\n        return utils.parseDiceString(mod.dice.diceString, null, mod.subType ? `[${mod.subType}]` : null).diceString;\n      } else {\n        return utils.parseDiceString(mod.value, null, mod.subType ? `[${mod.subType}]` : null).diceString;\n      }\n    });\n  if (bonus && bonus.length > 0) {\n    logger.debug(`Generating all damage for ${name}`);\n    changes.push(generateCustomChange(`${bonus.join(\" + \")}`, 18, \"data.bonuses.mwak.damage\"));\n    changes.push(generateCustomChange(`${bonus.join(\" + \")}`, 18, \"data.bonuses.rwak.damage\"));\n  }\n  return changes;\n}\n\n// *\n// Get list of generic conditions/damages\n//\nfunction getGenericConditionAffect(modifiers, condition, typeId) {\n  const damageTypes = DICTIONARY.character.damageTypes\n    .filter((type) => type.kind === condition && type.type === typeId)\n    .map((type) => type.value);\n\n  let restrictions = [\n    \"\",\n    null,\n    \"While within 20 feet\",\n    \"Dwarf Only\",\n    \"While Not Incapacitated\",\n    // \"As an Action\", this is a timed/limited effect, dealt with elsewhere\n    \"While Staff is Held\",\n    \"Helm has at least one ruby remaining\",\n    \"while holding\",\n    \"While Held\",\n  ];\n  let result = utils\n    .filterModifiers(modifiers, condition, null, restrictions)\n    .filter((modifier) => modifier.isGranted && damageTypes.includes(modifier.subType))\n    .map((modifier) => {\n      const entry = DICTIONARY.character.damageTypes.find(\n        (type) => type.type === typeId && type.kind === modifier.type && type.value === modifier.subType\n      );\n      return entry ? entry.foundryValue || entry.value : undefined;\n    });\n\n  return result;\n}\n\n/**\n * Get  Damage Conditions, and Condition Immunities\n * @param {*} ddbItem\n */\nfunction addDamageConditions(modifiers) {\n  let charges = [];\n\n  const damageImmunities = getGenericConditionAffect(modifiers, \"immunity\", 2);\n  const damageResistances = getGenericConditionAffect(modifiers, \"resistance\", 2);\n  const damageVulnerability = getGenericConditionAffect(modifiers, \"vulnerability\", 2);\n\n  damageImmunities.forEach((type) => {\n    charges.push(generateCustomChange(type, 1, \"data.traits.di.value\"));\n  });\n  damageResistances.forEach((type) => {\n    charges.push(generateCustomChange(type, 1, \"data.traits.dr.value\"));\n  });\n  damageVulnerability.forEach((type) => {\n    charges.push(generateCustomChange(type, 1, \"data.traits.dv.value\"));\n  });\n\n  const conditionImmunities = getGenericConditionAffect(modifiers, \"immunity\", 1);\n\n  conditionImmunities.forEach((type) => {\n    charges.push(generateCustomChange(type, 1, \"data.traits.ci.value\"));\n  });\n\n  // data.traits.di.all\n  const allDamageImmunity = utils.filterModifiers(modifiers, \"immunity\", \"all\");\n  if (allDamageImmunity?.length > 0) {\n    charges.push(generateCustomChange(1, 1, \"data.traits.di.all\"));\n  }\n\n  return charges;\n}\n\n// *\n// Generate stat bonuses\n//\nfunction addStatBonusEffect(modifiers, name, subType) {\n  const bonuses = modifiers.filter((modifier) => modifier.type === \"bonus\" && modifier.subType === subType);\n\n  let effects = [];\n  if (bonuses.length > 0) {\n    bonuses.forEach((bonus) => {\n      const maxMatch = /Maximum of (\\d*)/;\n      const match = bonus.restriction ? bonus.restriction.match(maxMatch) : false;\n      logger.debug(`Generating ${subType} stat bonus for ${name}`);\n      const ability = DICTIONARY.character.abilities.find((ability) => ability.long === subType.split(\"-\")[0]);\n      const abilityScoreMaxBonus = modifiers\n        .filter((modifier) => modifier.type === \"bonus\" && modifier.subType === \"ability-score-maximum\")\n        .filter((mod) => mod.statId === ability.id)\n        .reduce((prev, cur) => prev + cur.value, 0);\n      const max = match ? match[1] : 20 + abilityScoreMaxBonus;\n\n      const bonusString = `@abilities.${ability.value}.value + ${bonus.value} > ${max} ? ${max} : @abilities.${ability.value}.value + ${bonus.value}`;\n      effects.push(generateOverrideChange(bonusString, 5, `data.abilities.${ability.value}.value`));\n    });\n  }\n  return effects;\n}\n\nfunction addStatBonuses(modifiers, name) {\n  let changes = [];\n  const stats = [\n    \"strength-score\",\n    \"dexterity-score\",\n    \"constitution-score\",\n    \"wisdom-score\",\n    \"intelligence-score\",\n    \"charisma-score\",\n  ];\n  stats.forEach((stat) => {\n    const result = addStatBonusEffect(modifiers, name, stat);\n    changes = changes.concat(result);\n  });\n\n  return changes;\n}\n\n// *\n// Generate stat sets\n//\nfunction addStatSetEffect(modifiers, name, subType) {\n  const bonuses = modifiers.filter((modifier) => modifier.type === \"set\" && modifier.subType === subType);\n\n  let effects = [];\n  // dwarfen \"Maximum of 20\"\n  if (bonuses.length > 0) {\n    bonuses.forEach((bonus) => {\n      logger.debug(`Generating ${subType} stat set for ${name}`);\n      const ability = DICTIONARY.character.abilities.find((ability) => ability.long === subType.split(\"-\")[0]).value;\n      effects.push(generateUpgradeChange(bonus.value, 3, `data.abilities.${ability}.value`));\n    });\n  }\n  return effects;\n}\n\n// requires midi\n// does not add advantages with restrictions - which is most of them\nfunction addAbilityAdvantageEffect(modifiers, name, subType, type) {\n  const bonuses = utils.filterModifiers(modifiers, \"advantage\", subType);\n\n  let effects = [];\n  if (bonuses.length > 0) {\n    logger.debug(`Generating ${subType} saving throw advantage for ${name}`);\n    const ability = DICTIONARY.character.abilities.find((ability) => ability.long === subType.split(\"-\")[0]).value;\n    effects.push(generateCustomChange(1, 4, `flags.midi-qol.advantage.ability.${type}.${ability}`));\n  }\n  return effects;\n}\n\nfunction addStatChanges(modifiers, name) {\n  let changes = [];\n  const stats = [\"strength\", \"dexterity\", \"constitution\", \"wisdom\", \"intelligence\", \"charisma\"];\n  stats.forEach((stat) => {\n    const ability = DICTIONARY.character.abilities.find((ab) => ab.long === stat);\n    const statEffect = addStatSetEffect(modifiers, name, `${stat}-score`);\n    const savingThrowAdvantage = addAbilityAdvantageEffect(modifiers, name, `${stat}-saving-throw`, \"save\");\n    const abilityCheckAdvantage = addAbilityAdvantageEffect(modifiers, name, `${stat}-ability-checks`, \"check\");\n    const abilityBonusesSave = addAddEffect(modifiers, name, `${stat}-saving-throws`, `data.abilities.${ability.value}.bonuses.save`);\n    const abilityBonusesCheck = addAddEffect(modifiers, name, `${stat}-ability-checks`, `data.abilities.${ability.value}.bonuses.check`);\n    changes = changes.concat(statEffect, savingThrowAdvantage, abilityCheckAdvantage, abilityBonusesSave, abilityBonusesCheck);\n  });\n\n  return changes;\n}\n\n// *\n// Senses\n//\nfunction addSenseBonus(modifiers, name) {\n  let changes = [];\n\n  const senses = [\"darkvision\", \"blindsight\", \"tremorsense\", \"truesight\"];\n\n  senses.forEach((sense) => {\n    const base = modifiers\n      .filter((modifier) => modifier.type === \"set-base\" && modifier.subType === sense)\n      .map((mod) => mod.value);\n    if (base.length > 0) {\n      logger.debug(`Generating ${sense} base for ${name}`);\n      changes.push(generateUpgradeChange(Math.max(base), 10, `data.attributes.senses.${sense}`));\n    }\n    const bonus = modifiers\n      .filter((modifier) => modifier.type === \"sense\" && modifier.subType === sense)\n      .reduce((a, b) => a + b.value, 0);\n    if (bonus > 0) {\n      logger.debug(`Generating ${sense} bonus for ${name}`);\n      changes.push(generateAddChange(Math.max(bonus), 15, `data.attributes.senses.${sense}`));\n    }\n  });\n  return changes;\n}\n\n/**\n * Proficiency bonus\n */\n\nfunction addProficiencyBonus(modifiers, name) {\n  let changes = [];\n  const bonus = utils.filterModifiers(modifiers, \"bonus\", \"proficiency-bonus\").reduce((a, b) => a + b.value, 0);\n  if (bonus) {\n    logger.debug(`Generating proficiency bonus for ${name}`);\n    changes.push(generateAddChange(bonus, 0, \"data.attributes.prof\"));\n  }\n  return changes;\n}\n\n// *\n// Generate set speeds\n//\nfunction addSetSpeedEffect(modifiers, name, subType) {\n  const bonuses = modifiers.filter((modifier) => modifier.type === \"set\" && modifier.subType === subType);\n\n  let effects = [];\n  // \"Equal to Walking Speed\"\n  if (bonuses.length > 0) {\n    bonuses.forEach((bonus) => {\n      logger.debug(`Generating ${subType} speed set for ${name}`);\n      const innate = subType.split(\"-\").slice(-1)[0];\n      const speedType = DICTIONARY.character.speeds.find((s) => s.innate === innate).type;\n      // current assumption if no speed provided, set to walking speed\n      const speed = bonus.value ? bonus.value : \"@attributes.movement.walk\";\n      effects.push(generateUpgradeChange(speed, 5, `data.attributes.movement.${speedType}`));\n    });\n  }\n  return effects;\n}\n\n/**\n * Innate Speeds\n */\nfunction addSetSpeeds(modifiers, name) {\n  let changes = [];\n  const speedSets = [\n    \"innate-speed-walking\",\n    \"innate-speed-climbing\",\n    \"innate-speed-swimming\",\n    \"innate-speed-flying\",\n    \"innate-speed-burrowing\",\n  ];\n  speedSets.forEach((speedSet) => {\n    const result = addSetSpeedEffect(modifiers, name, speedSet);\n    changes = changes.concat(result);\n  });\n\n  return changes;\n}\n\n// *\n// Generate speed bonus speeds\n//\nfunction addBonusSpeedEffect(modifiers, name, subType, speedType = null) {\n  const bonuses = modifiers.filter((modifier) => modifier.type === \"bonus\" && modifier.subType === subType);\n\n  let effects = [];\n  // \"Equal to Walking Speed\"\n  // max(10+(ceil(((@classes.monk.levels)-5)/4))*5,10)\n  if (bonuses.length > 0) {\n    logger.debug(`Generating ${subType} speed bonus for ${name}`);\n    if (!speedType) {\n      const innate = subType.split(\"-\").slice(-1)[0];\n      speedType = DICTIONARY.character.speeds.find((s) => s.innate === innate).type;\n    }\n    const bonusValue = bonuses.reduce((speed, mod) => speed + mod.value, 0);\n    if (speedType === \"all\") {\n      effects.push(generateCustomChange(`+ ${bonusValue}`, 9, `data.attributes.movement.${speedType}`));\n    } else {\n      effects.push(generateAddChange(bonusValue, 9, `data.attributes.movement.${speedType}`));\n    }\n  }\n  return effects;\n}\n\n/**\n * Bonus Speeds\n */\nfunction addBonusSpeeds(modifiers, name) {\n  let changes = [];\n  const speedBonuses = [\"speed-walking\", \"speed-climbing\", \"speed-swimming\", \"speed-flying\", \"speed-burrowing\"];\n  speedBonuses.forEach((speed) => {\n    const result = addBonusSpeedEffect(modifiers, name, speed);\n    changes = changes.concat(result);\n  });\n\n  changes = changes.concat(addBonusSpeedEffect(modifiers, name, \"unarmored-movement\", \"walk\"));\n  changes = changes.concat(addBonusSpeedEffect(modifiers, name, \"speed\", \"walk\")); // probably all, but doesn't handle cases of where no base speed set, so say fly gets set to 10.\n\n  return changes;\n}\n\nfunction addSkillProficiencies(modifiers) {\n  let changes = [];\n  DICTIONARY.character.skills.forEach((skill) => {\n    const prof = getSkillProficiency(null, skill, modifiers);\n    if (prof != 0) {\n      changes.push(generateUpgradeChange(prof, 9, `data.skills.${skill.name}.value`));\n    }\n  });\n  return changes;\n}\n\nfunction addProficiencies(modifiers, name) {\n  let changes = [];\n\n  const proficiencies = modifiers\n    .filter((mod) => mod.type === \"proficiency\")\n    .map((mod) => {\n      return { name: mod.friendlySubtypeName };\n    });\n\n  changes = changes.concat(addSkillProficiencies(modifiers));\n  const toolProf = getToolProficiencies(null, proficiencies);\n  const weaponProf = getWeaponProficiencies(null, proficiencies);\n  const armorProf = getArmorProficiencies(null, proficiencies);\n\n  toolProf.value.forEach((prof) => {\n    logger.debug(`Generating tool proficiencies for ${name}`);\n    changes.push(generateCustomChange(prof, 8, \"data.traits.toolProf.value\"));\n  });\n  weaponProf.value.forEach((prof) => {\n    logger.debug(`Generating weapon proficiencies for ${name}`);\n    changes.push(generateCustomChange(prof, 8, \"data.traits.weaponProf.value\"));\n  });\n  armorProf.value.forEach((prof) => {\n    logger.debug(`Generating armor proficiencies for ${name}`);\n    changes.push(generateCustomChange(prof, 8, \"data.traits.armorProf.value\"));\n  });\n  if (toolProf?.custom != \"\") changes.push(generateCustomChange(toolProf.custom, 8, \"data.traits.toolProf.custom\"));\n  if (weaponProf?.custom != \"\")\n    changes.push(generateCustomChange(weaponProf.custom, 8, \"data.traits.weaponProf.custom\"));\n  if (armorProf?.custom != \"\") changes.push(generateCustomChange(armorProf.custom, 8, \"data.traits.armorProf.custom\"));\n\n  return changes;\n}\n\n/**\n * Add HP effects\n * @param {*} modifiers\n * @param {*} name\n */\nfunction addHPEffect(modifiers, name, consumable) {\n  let changes = [];\n\n  // HP per level\n  const hpPerLevel = utils.filterModifiers(modifiers, \"bonus\", \"hit-points-per-level\").reduce((a, b) => a + b.value, 0);\n  if (hpPerLevel && hpPerLevel > 0) {\n    logger.debug(`Generating HP Per Level effects for ${name}`);\n    changes.push(generateAddChange(`${hpPerLevel} * @details.level`, 14, \"data.attributes.hp.max\"));\n  }\n\n  const hpBonusModifiers = utils.filterModifiers(modifiers, \"bonus\", \"hit-points\");\n  if (hpBonusModifiers.length > 0 && !consumable) {\n    let hpBonus = \"\";\n    hpBonusModifiers.forEach((modifier) => {\n      let hpParse = extractModifierValue(modifier);\n      if (hpBonus !== \"\") hpBonus += \" + \";\n      hpBonus += hpParse;\n    });\n    changes.push(generateCustomChange(`${hpBonus}`, 14, \"data.attributes.hp.max\"));\n  }\n\n  return changes;\n}\n\n//\n// Generate skill bonuses\n//\nfunction addSkillBonusEffect(modifiers, name, skill) {\n  const bonus = getValueFromModifiers(modifiers, name, skill.subType, \"bonus\");\n\n  let changes = [];\n  if (bonus) {\n    const SAVE_BONUS = utils.versionCompare(game.data.system.data.version, \"1.5.0\") >= 0;\n    logger.debug(`Generating ${skill.subType} skill bonus for ${name}`, bonus);\n    if (SAVE_BONUS) {\n      changes.push(generateAddChange(bonus, 12, `data.skills.${skill.name}.bonuses.check`));\n    } else {\n      changes.push(generateAddChange(bonus, 12, `data.skills.${skill.name}.mod`));\n    }\n  }\n  return changes;\n}\n\n//\n// generate skill advantages\n// requires midi\n//\nfunction addSkillMidiEffect(modifiers, name, skill, midiEffect = \"advantage\") {\n  const allowedRestrictions = [\n    \"\",\n    null,\n    \"Sound Only\",\n    \"Sight Only\",\n    \"that rely on smell\",\n    \"While the hood is up, checks made to Hide \",\n  ];\n  const advantage = utils.filterModifiers(modifiers, midiEffect, skill.subType, allowedRestrictions);\n\n  let effects = [];\n  if (advantage.length > 0) {\n    logger.debug(`Generating ${skill.subType} skill ${midiEffect} for ${name}`);\n    effects.push(generateCustomChange(1, 5, `flags.midi-qol.${midiEffect}.skill.${skill.name}`));\n  }\n  return effects;\n}\n\nfunction addSkillBonuses(modifiers, name) {\n  let changes = [];\n  DICTIONARY.character.skills.forEach((skill) => {\n    const skillBonuses = addSkillBonusEffect(modifiers, name, skill);\n    const skillAdvantages = addSkillMidiEffect(modifiers, name, skill, \"advantage\");\n    changes = changes.concat(skillBonuses, skillAdvantages);\n  });\n\n  return changes;\n}\n\n//\n// initiative\n//\nfunction addInitiativeBonuses(modifiers, name) {\n  let changes = [];\n  const advantage = utils.filterModifiers(modifiers, \"advantage\", \"initiative\");\n  if (advantage.length > 0) {\n    logger.debug(`Generating Intiative advantage for ${name}`);\n    changes.push(generateCustomChange(1, 20, \"flags.dnd5e.initiativeAdv\"));\n  }\n  return changes;\n}\n\n//\n// attack rolls against you\n// midi only\n//\nfunction addAttackRollDisadvantage(modifiers, name) {\n  let changes = [];\n  const disadvantage = utils.filterModifiers(modifiers, \"disadvantage\", \"attack-rolls-against-you\", false);\n  if (disadvantage.length > 0) {\n    logger.debug(`Generating disadvantage for ${name}`);\n    changes.push(generateCustomChange(1, 5, \"flags.midi-qol.grants.disadvantage.attack.all\"));\n  }\n  return changes;\n}\n\n// midi advantages on saving throws against spells and magical effects\nfunction addMagicalAdvantage(modifiers, name) {\n  let changes = [];\n  const restrictions = [\n    \"against spells and magical effects\",\n    \"Against Spells and Magical Effects\",\n    \"Against Spells\",\n    \"against spells\",\n    \"Against spells\",\n    \"Against spells and magical effects within 10 ft. (or 30 ft. at level 17+) while holding the Holy Avenger\",\n  ];\n  const advantage = utils.filterModifiers(modifiers, \"advantage\", \"saving-throws\", restrictions);\n  if (advantage.length > 0) {\n    logger.debug(`Generating magical advantage on saving throws for ${name}`);\n    changes.push(generateCustomChange(\"magic-resistant\", 5, \"data.traits.dr.custom\"));\n  }\n  return changes;\n}\n\nfunction generateEffectDuration(foundryItem) {\n  let duration = {\n    seconds: null,\n    startTime: null,\n    rounds: null,\n    turns: null,\n    startRound: null,\n    startTurn: null,\n  };\n  switch (foundryItem.data.duration.units) {\n    case \"turn\":\n      duration.turns = foundryItem.data.duration.value;\n      break;\n    case \"round\":\n      duration.rounds = foundryItem.data.duration.value;\n      break;\n    case \"hour\":\n      duration.seconds = foundryItem.data.duration.value * 60 * 60;\n      break;\n    case \"minute\":\n      duration.rounds = foundryItem.data.duration.value * 10;\n      break;\n    // no default\n  }\n  return duration;\n}\n\nfunction consumableEffect(effect, ddbItem, foundryItem) {\n  effect.label = `${foundryItem.name} - Consumable Effects`;\n  effect.disabled = false;\n  effect.transfer = false;\n  setProperty(effect, \"flags.ddbimporter.disabled\", false);\n  setProperty(foundryItem, \"flags.dae.transfer\", false);\n  effect.duration = generateEffectDuration(foundryItem);\n  if (!foundryItem.data.target?.value) {\n    foundryItem.data.target = {\n      value: 1,\n      width: null,\n      units: \"\",\n      type: \"creature\",\n    };\n  }\n  if (!foundryItem.data.range?.units) {\n    foundryItem.data.range = {\n      value: null,\n      long: null,\n      units: \"touch\",\n    };\n  }\n  if (foundryItem.data.uses) {\n    foundryItem.data.uses.autoDestroy = true;\n    foundryItem.data.uses.autoUse = true;\n  }\n\n  return effect;\n}\n\n/**\n * This checks attunement status and similar to determine effect state\n * set disabled flags etc\n * @param {*} foundryItem\n * @param {*} effect\n * @param {*} ddbItem\n * @param {*} isCompendiumItem\n */\nfunction addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem) {\n  // check attunement status etc\n\n  if (\n    !ddbItem.definition?.canEquip &&\n    !ddbItem.definition?.canAttune &&\n    !ddbItem.definition?.isConsumable &&\n    DICTIONARY.types.inventory.includes(foundryItem.type)\n  ) {\n    // if item just gives a thing and not potion/scroll\n    effect.disabled = false;\n    setProperty(effect, \"flags.ddbimporter.disabled\", false);\n    setProperty(foundryItem, \"flags.dae.alwaysActive\", true);\n  } else if (\n    isCompendiumItem ||\n    foundryItem.type === \"feat\" ||\n    (ddbItem.isAttuned && ddbItem.equipped) || // if it is attuned and equipped\n    (ddbItem.isAttuned && !ddbItem.definition?.canEquip) || // if it is attuned but can't equip\n    (!ddbItem.definition?.canAttune && ddbItem.equipped) // can't attune but is equipped\n  ) {\n    setProperty(foundryItem, \"flags.dae.alwaysActive\", false);\n    setProperty(effect, \"flags.ddbimporter.disabled\", false);\n    effect.disabled = false;\n  } else {\n    effect.disabled = true;\n    setProperty(effect, \"flags.ddbimporter.disabled\", true);\n    setProperty(foundryItem, \"flags.dae.alwaysActive\", false);\n  }\n\n  setProperty(effect, \"flags.ddbimporter.itemId\", ddbItem.id);\n  setProperty(effect, \"flags.ddbimporter.itemEntityTypeId\", ddbItem.entityTypeId);\n  // set dae flag for active equipped\n  if (ddbItem.definition?.canEquip || ddbItem.definitio?.canAttune) {\n    setProperty(foundryItem, \"flags.dae.activeEquipped\", true);\n  } else {\n    setProperty(foundryItem, \"flags.dae.activeEquipped\", false);\n  }\n\n  if (ddbItem.definition?.filterType === \"Potion\") {\n    effect = consumableEffect(effect, ddbItem, foundryItem);\n  }\n\n  return [foundryItem, effect];\n}\n\n/**\n * Generate supported effects for items\n * @param {*} ddb\n * @param {*} character\n * @param {*} ddbItem\n * @param {*} foundryItem\n */\nfunction generateGenericEffects(ddb, character, ddbItem, foundryItem, isCompendiumItem, labelOverride) {\n  if (!foundryItem.effects) foundryItem.effects = [];\n\n  const label = labelOverride\n    ? labelOverride\n    : `${foundryItem.name} - Constant Effects`;\n\n  let effect = baseItemEffect(foundryItem, label);\n\n  if (!ddbItem.definition?.grantedModifiers || ddbItem.definition.grantedModifiers.length === 0) return [foundryItem, effect];\n  logger.debug(`Generating Effects for ${foundryItem.name}`, ddbItem);\n\n  const globalSaveBonus = addGlobalSavingBonusEffect(ddbItem.definition.grantedModifiers, foundryItem.name);\n  const globalAbilityBonus = addCustomBonusEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"ability-checks\",\n    \"data.bonuses.abilities.check\",\n  );\n  const globalSkillBonus = addCustomBonusEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"skill-checks\",\n    \"data.bonuses.abilities.skill\",\n  );\n  const languages = addLanguages(ddbItem.definition.grantedModifiers, foundryItem.name);\n  const conditions = addDamageConditions(ddbItem.definition.grantedModifiers, foundryItem.name);\n  const statSets = addStatChanges(ddbItem.definition.grantedModifiers, foundryItem.name);\n  const statBonuses = addStatBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);\n  const senses = addSenseBonus(ddbItem.definition.grantedModifiers, foundryItem.name);\n  const proficiencyBonus = addProficiencyBonus(ddbItem.definition.grantedModifiers, foundryItem.name);\n  const speedSets = addSetSpeeds(ddbItem.definition.grantedModifiers, foundryItem.name);\n  const spellAttackBonus = addCustomEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"spell-attacks\",\n    \"data.bonuses.spell.attack\"\n  );\n  const spellDCBonus = addAddEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"spell-save-dc\",\n    \"data.bonuses.spell.dc\"\n  );\n  const warlockSpellAttackBonus = addCustomEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"warlock-spell-attacks\",\n    \"data.bonuses.spell.attack\"\n  );\n  const warlockSpellDCBonus = addAddEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"warlock-spell-save-dc\",\n    \"data.bonuses.spell.dc\"\n  );\n  const healingSpellBonus = addCustomEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"spell-group-healing\",\n    \"data.bonuses.heal.damage\",\n    \" + @item.level\"\n  );\n\n  const profs = addProficiencies(ddbItem.definition.grantedModifiers, foundryItem.name);\n  const hp = addHPEffect(ddbItem.definition.grantedModifiers, foundryItem.name, ddbItem.definition.isConsumable);\n  const skillBonus = addSkillBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);\n  const initiative = addInitiativeBonuses(ddbItem.definition.grantedModifiers, foundryItem.name);\n  const disadvantageAgainst = addAttackRollDisadvantage(ddbItem.definition.grantedModifiers, foundryItem.name);\n  const magicalAdvantage = addMagicalAdvantage(ddbItem.definition.grantedModifiers, foundryItem.name);\n  const bonusSpeeds = addBonusSpeeds(ddbItem.definition.grantedModifiers, foundryItem.name);\n\n  const meleeAttackBonus = addCustomEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"melee-attacks\",\n    \"data.bonuses.mwak.attack\"\n  );\n  const rangedAttackBonus = addCustomEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"ranged-attacks\",\n    \"data.bonuses.rwak.attack\"\n  );\n  const meleeWeaponAttackBonus = addCustomEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"melee-weapon-attacks\",\n    \"data.bonuses.mwak.attack\"\n  );\n  const rangedWeaponAttackBonus = addCustomEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"ranged-weapon-attacks\",\n    \"data.bonuses.rwak.attack\"\n  );\n  const weaponAttackMeleeBonus = addCustomEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"weapon-attacks\",\n    \"data.bonuses.mwak.attack\"\n  );\n  const weaponAttackRangedBonus = addCustomEffect(\n    ddbItem.definition.grantedModifiers,\n    foundryItem.name,\n    \"weapon-attacks\",\n    \"data.bonuses.rwak.attack\"\n  );\n\n  const globalDamageBonus = addGlobalDamageBonus(ddbItem.definition.grantedModifiers, foundryItem.name);\n\n  effect.changes = [\n    ...globalSaveBonus,\n    ...globalAbilityBonus,\n    ...globalSkillBonus,\n    ...languages,\n    ...conditions,\n    ...statSets,\n    ...statBonuses,\n    ...senses,\n    ...proficiencyBonus,\n    ...speedSets,\n    ...spellAttackBonus,\n    ...warlockSpellAttackBonus,\n    ...spellDCBonus,\n    ...warlockSpellDCBonus,\n    ...profs,\n    ...hp,\n    ...skillBonus,\n    ...initiative,\n    ...disadvantageAgainst,\n    ...magicalAdvantage,\n    ...bonusSpeeds,\n    ...healingSpellBonus,\n    ...meleeAttackBonus,\n    ...rangedAttackBonus,\n    ...meleeWeaponAttackBonus,\n    ...rangedWeaponAttackBonus,\n    ...weaponAttackMeleeBonus,\n    ...weaponAttackRangedBonus,\n    ...globalDamageBonus,\n  ];\n\n  // if we don't have effects, lets return the item\n  if (effect.changes?.length === 0) {\n    return [foundryItem, effect];\n  }\n\n  // generate flags for effect (e.g. checking attunement and equipped status)\n  [foundryItem, effect] = addEffectFlags(foundryItem, effect, ddbItem, isCompendiumItem);\n\n  return [foundryItem, effect];\n}\n\nexport function generateEffects(ddb, character, ddbItem, foundryItem, isCompendiumItem, type) {\n  let label;\n\n  if (type == \"infusion\") {\n    label = `${foundryItem.name} - Infusion Effects`;\n  }\n  let effect;\n  [foundryItem, effect] = generateGenericEffects(ddb, character, ddbItem, foundryItem, isCompendiumItem, label);\n  if (type == \"infusion\") {\n    [foundryItem, effect] = generateACEffectChangesForItem(ddb, character, ddbItem, foundryItem, isCompendiumItem, effect);\n  }\n  if (effect.changes?.length > 0) {\n    foundryItem.effects.push(effect);\n  }\n  switch (type) {\n    case \"infusion\": {\n      foundryItem = infusionEffectAdjustment(foundryItem);\n      break;\n    }\n    case \"equipment\":\n    case \"item\": {\n      foundryItem = equipmentEffectAdjustment(foundryItem);\n      break;\n    }\n    case \"spell\": {\n      foundryItem = spellEffectAdjustment(foundryItem);\n      break;\n    }\n    case \"feature\":\n    case \"feat\": {\n      foundryItem = featureEffectAdjustment(foundryItem);\n      break;\n    }\n    // no default\n  }\n\n  if (foundryItem.effects?.length > 0)\n    logger.debug(`${type} effect ${foundryItem.name}:`, JSON.parse(JSON.stringify(foundryItem)));\n  return foundryItem;\n\n}\n","import utils from \"../utils.js\";\nimport logger from \"../logger.js\";\n\nexport function configureDependencies() {\n  // allow item use macros on items\n  let midiQOLSettings = game.settings.get(\"midi-qol\", \"ConfigSettings\");\n  if (!midiQOLSettings.allowUseMacro) {\n    midiQOLSettings.allowUseMacro = true;\n    game.settings.set(\"midi-qol\", \"ConfigSettings\", midiQOLSettings);\n  }\n\n  // if dfreds status effects not added, add them\n  let convenientEffectStatusSettings = game.settings.get(\"dfreds-convenient-effects\", \"modifyStatusEffects\");\n  if (!convenientEffectStatusSettings || convenientEffectStatusSettings === \"none\") {\n    game.settings.set(\"dfreds-convenient-effects\", \"modifyStatusEffects\", \"add\");\n  }\n\n  return true;\n}\n\nexport async function loadMacroFile(type, fileName) {\n  logger.debug(`Getting macro for ${type} ${fileName}`);\n  const fileExists = await utils.fileExists(`[data] modules/ddb-importer/macros/${type}s`, fileName);\n\n  let data;\n  if (fileExists) {\n    const url = await utils.getFileUrl(`[data] modules/ddb-importer/macros/${type}s`, fileName);\n    const response = await fetch(url, { method: \"GET\" });\n    data = await response.text();\n  }\n  return data;\n}\n\nexport function generateMacroFlags(document, macroText) {\n  return {\n    macro: {\n      data: {\n        name: document.name,\n        type: \"script\",\n        scope: \"global\",\n        command: macroText,\n      },\n      options: {},\n      apps: {},\n      compendium: null,\n    },\n  };\n}\n\nexport function generateMacroChange(macroValues, priority = 20) {\n  return {\n    key: \"macro.itemMacro\",\n    value: macroValues,\n    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n    priority: priority,\n  };\n}\n","import { baseFeatEffect } from \"../specialFeats.js\";\nimport { generateMacroChange, generateMacroFlags, loadMacroFile } from \"../macros.js\";\n\nexport async function kiEmptyBodyEffect(document) {\n  let effect = baseFeatEffect(document, document.name);\n  effect.changes.push(\n    { key: \"data.traits.dr.all\", value: \"\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },\n    { key: \"data.traits.dv.value\", value: \"force\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 }\n  );\n\n  document.data[\"target\"][\"type\"] = \"self\";\n  document.data.range = { value: null, units: \"self\", long: null };\n  document.data.duration = { value: 1, units: \"min\" };\n  document.data.actionType = null;\n  const itemMacroText = await loadMacroFile(\"spell\", \"invisibility.js\");\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\", 0));\n\n  document.effects.push(effect);\n  return document;\n}\n","import { baseItemEffect } from \"../effects\";\n\nexport function warCasterEffect(document) {\n  let effect = baseItemEffect(document, document.name);\n  effect.changes.push(\n    { key: \"flags.midi-qol.advantage.concentration\", value: \"1\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 10 },\n  );\n  document.effects.push(effect);\n  return document;\n}\n\n","import { baseFeatEffect } from \"../specialFeats.js\";\n\nexport function rageEffect(document) {\n  let effect = baseFeatEffect(document, `${document.name}`);\n\n  const extraDamage = document.flags?.ddbimporter?.dndbeyond?.levelScale?.fixedValue\n    ? document.flags.ddbimporter.dndbeyond.levelScale.fixedValue\n    : 2;\n  effect.changes.push(\n    {\n      key: \"data.bonuses.mwak.damage\",\n      value: `${extraDamage}`,\n      mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n      priority: 0,\n    },\n    {\n      key: \"data.traits.dr.value\",\n      value: \"piercing\",\n      mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n      priority: 0,\n    },\n    {\n      key: \"data.traits.dr.value\",\n      value: \"slashing\",\n      mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n      priority: 20,\n    },\n    {\n      key: \"data.traits.dr.value\",\n      value: \"bludgeoning\",\n      mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n      priority: 20,\n    },\n    {\n      key: \"flags.midi-qol.advantage.ability.save.str\",\n      value: \"1\",\n      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n      priority: 20,\n    },\n    {\n      key: \"flags.midi-qol.advantage.ability.check.str\",\n      value: \"1\",\n      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n      priority: 20,\n    }\n  );\n  effect.duration = {\n    startTime: null,\n    seconds: 60,\n    rounds: null,\n    turns: null,\n    startRound: null,\n    startTurn: null,\n  };\n  document.effects.push(effect);\n  return document;\n}\n","import { baseItemEffect } from \"./effects.js\";\nimport utils from \"../utils.js\";\nimport logger from \"../logger.js\";\nimport { configureDependencies } from \"./macros.js\";\nimport { kiEmptyBodyEffect } from \"./feats/kiEmptyBody.js\";\nimport { warCasterEffect } from \"./feats/warCaster.js\";\nimport { rageEffect } from \"./feats/rage.js\";\n\nexport function baseFeatEffect(document, label) {\n  return {\n    label,\n    icon: document.img,\n    changes: [],\n    duration: {},\n    tint: \"\",\n    transfer: false,\n    disabled: false,\n    flags: {\n      dae: {\n        transfer: false,\n        stackable: false,\n      },\n      ddbimporter: {\n        disabled: false,\n      },\n    },\n  };\n}\n\nvar installedModules;\n\nexport function featEffectModules() {\n  if (installedModules) return installedModules;\n  const midiQolInstalled = utils.isModuleInstalledAndActive(\"midi-qol\");\n  const advancedMacrosInstalled = utils.isModuleInstalledAndActive(\"advanced-macros\");\n  const aboutTime = utils.isModuleInstalledAndActive(\"about-time\");\n  const itemMacroInstalled = utils.isModuleInstalledAndActive(\"itemacro\");\n  const timesUp = utils.isModuleInstalledAndActive(\"times-up\");\n  const daeInstalled = utils.isModuleInstalledAndActive(\"dae\");\n  const convinientEffectsInstalled = utils.isModuleInstalledAndActive(\"dfreds-convenient-effects\");\n\n  const activeAurasInstalled = utils.isModuleInstalledAndActive(\"ActiveAuras\");\n  const atlInstalled = utils.isModuleInstalledAndActive(\"ATL\");\n  const tokenAurasInstalled = utils.isModuleInstalledAndActive(\"token-auras\");\n  const tokenMagicInstalled = utils.isModuleInstalledAndActive(\"tokenmagic\");\n  const autoAnimationsInstalled = utils.isModuleInstalledAndActive(\"autoanimations\");\n  installedModules = {\n    hasCore:\n      itemMacroInstalled &&\n      midiQolInstalled &&\n      advancedMacrosInstalled &&\n      aboutTime &&\n      timesUp &&\n      daeInstalled &&\n      convinientEffectsInstalled,\n    midiQolInstalled,\n    itemMacroInstalled,\n    advancedMacrosInstalled,\n    aboutTime,\n    timesUp,\n    daeInstalled,\n    convinientEffectsInstalled,\n    atlInstalled,\n    tokenAurasInstalled,\n    tokenMagicInstalled,\n    activeAurasInstalled,\n    autoAnimationsInstalled,\n  };\n  return installedModules;\n}\n\nvar configured;\n/**\n * These are effects that can't be generated dynamically and have extra requirements\n */\nexport async function generateExtraEffects(document) {\n  if (!document.effects) document.effects = [];\n\n  // check that we can gen effects\n  const deps = featEffectModules();\n  if (!deps.hasCore) {\n    logger.warn(\n      \"Sorry, you're missing some required modules for spell effects. Please install them and try again.\",\n      deps\n    );\n    return document;\n  }\n  if (!configured) {\n    configured = configureDependencies();\n  }\n\n  const name = document.flags.ddbimporter.originalName || document.name;\n  switch (name) {\n    case \"Empty Body\":\n    case \"Ki: Empty Body\": {\n      document = await kiEmptyBodyEffect(document);\n      break;\n    }\n    case \"Rage\": {\n      document = rageEffect(document);\n      break;\n    }\n    case \"War Caster\":\n    case \"Warcaster\": {\n      document = warCasterEffect(document);\n      break;\n    }\n    // no default\n  }\n  return document;\n}\n\n/**\n * This function is mainly for effects that can't be dynamically generated\n * @param {*} document\n */\nexport function featureEffectAdjustment(document) {\n  const midiQolInstalled = utils.isModuleInstalledAndActive(\"midi-qol\");\n  switch (document.name) {\n    // if using active auras add the aura effect\n    case \"Aura of Courage\":\n    case \"Aura of Protection\": {\n      document.effects.forEach((effect) => {\n        if (effect.label.includes(\"Constant Effects\")) {\n          effect.flags.ActiveAuras = {\n            aura: \"Allies\",\n            radius: 10,\n            isAura: true,\n            inactive: false,\n            hidden: false,\n          };\n        }\n      });\n      break;\n    }\n    case \"Unarmored Movement\": {\n      document.effects.forEach((effect) => {\n        if (effect.label.includes(\"Constant Effects\")) {\n          effect.changes = [\n            {\n              key: \"data.attributes.movement.walk\",\n              value: \"max(10+(ceil(((@classes.monk.levels)-5)/4))*5,10)\",\n              mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n              priority: 20,\n            },\n          ];\n        }\n      });\n      break;\n    }\n    case \"Potent Cantrip\": {\n      let effect = baseItemEffect(document, `${document.name}`);\n      effect.changes.push({\n        key: \"flags.midi-qol.potentCantrip\",\n        value: \"1\",\n        mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n        priority: 20,\n      });\n      document.effects.push(effect);\n      break;\n    }\n    case \"Bardic Inspiration\": {\n      if (midiQolInstalled) {\n        document.data.damage.parts = [];\n        let inspiredEffect = baseItemEffect(document, \"Inspired\");\n        inspiredEffect.changes.push(\n          {\n            key: \"flags.midi-qol.optional.bardicInspiration.attack\",\n            mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n            value: \"1d@flags.dae.BardicInspirationDice\",\n            priority: \"20\",\n          },\n          {\n            key: \"flags.midi-qol.optional.bardicInspiration.save\",\n            mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n            value: \"1d@flags.dae.BardicInspirationDice\",\n            priority: \"20\",\n          },\n          {\n            key: \"flags.midi-qol.optional.bardicInspiration.check\",\n            mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n            value: \"1d@flags.dae.BardicInspirationDice\",\n            priority: \"20\",\n          },\n          {\n            key: \"flags.midi-qol.optional.bardicInspiration.label\",\n            mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n            value: \"Bardic Inspiration\",\n            priority: \"20\",\n          }\n        );\n        inspiredEffect.transfer = false;\n        inspiredEffect.disabled = false;\n        setProperty(inspiredEffect, \"flags.dae.transfer\", false);\n        setProperty(inspiredEffect, \"flags.dae.stackable\", false);\n        setProperty(inspiredEffect, \"flags.dae.macroRepeat\", \"none\");\n        setProperty(inspiredEffect, \"flags.dae.specialDuration\", []);\n\n        if (document.flags.ddbimporter.subclass === \"College of Valor\") {\n          inspiredEffect.changes.push(\n            {\n              key: \"flags.midi-qol.optional.bardicInspiration.damage\",\n              mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n              value: \"1d@flags.dae.BardicInspirationDice\",\n              priority: \"20\",\n            },\n            {\n              key: \"flags.midi-qol.optional.bardicInspiration.ac\",\n              mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n              value: \"1d@flags.dae.BardicInspirationDice\",\n              priority: \"20\",\n            }\n          );\n        }\n\n        document.effects.push(inspiredEffect);\n\n        let diceEffect = baseItemEffect(document, \"Bardic Inspiration Dice\");\n        diceEffect.changes.push({\n          key: \"flags.dae\",\n          mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n          value: \"BardicInspirationDice (floor(@classes.bard.levels/5)+3) * 2\",\n          priority: \"20\",\n        });\n        diceEffect.transfer = true;\n        diceEffect.disabled = false;\n        setProperty(diceEffect, \"flags.dae.transfer\", true);\n        setProperty(diceEffect, \"flags.dae.stackable\", false);\n        setProperty(diceEffect, \"flags.dae.macroRepeat\", \"none\");\n        setProperty(diceEffect, \"flags.dae.specialDuration\", []);\n        document.effects.push(diceEffect);\n        document.flags[\"midi-qol\"] = {\n          onUseMacroName: \"\",\n          effectActivation: false,\n          forceCEOff: false,\n        };\n      }\n      break;\n    }\n    // no default\n  }\n\n  return document;\n}\n","\nimport { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function absorbElementsEffect(document) {\n  const effect = baseSpellEffect(document, `${document.name} - Extra Damage`);\n  effect.changes.push({\n    key: \"data.bonuses.mwak.damage\",\n    value: `(@item.level)d6`,\n    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n    priority: 0,\n  });\n  effect.flags.dae.specialDuration = \"1Hit\";\n  effect.duration = {\n    startTime: null,\n    seconds: null,\n    rounds: 1,\n    turns: null,\n    startRound: null,\n    startTurn: null,\n  };\n  document.data.damage = {\n    parts: [[\"\", \"\"]],\n    versatile: \"\",\n    value: \"\",\n  };\n  document.data.target = {\n    value: null,\n    width: null,\n    units: \"\",\n    type: \"self\",\n  };\n  document.data.range = {\n    value: null,\n    long: null,\n    units: \"self\",\n  };\n  document.effects.push(effect);\n\n  return document;\n}\n\n\n","import { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\nimport { baseSpellEffect } from \"../specialSpells.js\";\n\nexport async function aidEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"data.attributes.hp.max\",\n    value: \"5 * (@spellLevel - 1)\",\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n    priority: 20,\n  });\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"aid.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"@spellLevel\", 0));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function alterSelfEffect(document) {\n  let effectAquaticAdaptation = baseSpellEffect(document, document.name);\n  effectAquaticAdaptation.changes.push({\n    key: \"data.attributes.movement.swim\",\n    value: \"@attributes.movement.walk\",\n    mode: 4,\n    priority: 20,\n  });\n  document.effects.push(effectAquaticAdaptation);\n\n  let effectNaturalWeapons = baseSpellEffect(document, document.name);\n  effectNaturalWeapons.changes.push(\n    { key: \"items.Unarmed Strike.data.damage.parts.0.0\", value: \"1d6+@mod+1\", mode: 5, priority: 20 },\n    { key: \"items.Unarmed Strike.data.properties.mgc\", value: \"true\", mode: 5, priority: 20 },\n    { key: \"items.Unarmed Strike.data.proficient\", value: \"true\", mode: 5, priority: 20 },\n    { key: \"items.Unarmed Strike.data.attackBonus\", value: \"1\", mode: 2, priority: 20 }\n  );\n  document.effects.push(effectNaturalWeapons);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function animalFriendshipEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Charmed\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function arcaneSwordEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"arcaneSword.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\"));\n\n  document.data.damage = { parts: [], versatile: \"\", value: \"\" };\n  document.data['target']['type'] = \"self\";\n  document.data.range = { value: null, units: \"self\", long: null };\n  document.data.actionType = \"other\";\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function baneEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    { key: \"data.bonuses.All-Attacks\", value: \"-1d4\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },\n    { key: \"data.bonuses.abilities.save\", value: \"-1d4\", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 }\n  );\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function banishmentEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"banishment.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\", 0));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function barkskinEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"data.attributes.ac.value\",\n    mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,\n    value: \"16\",\n    priority: \"100\",\n  });\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function beaconofHopeEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    {\n      key: \"flags.midi-qol.advantage.ability.save.wis\",\n      value: \"1\",\n      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n      priority: 20,\n    },\n    { key: \"flags.midi-qol.advantage.deathSave\", value: \"1\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, priority: 20 }\n  );\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function blackTentaclesEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Restrained\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateTokenMagicFXChange, spellEffectModules } from \"../specialSpells.js\";\n\nexport function blessEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    { key: \"data.bonuses.abilities.save\", value: \"+1d4\", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },\n    { key: \"data.bonuses.All-Attacks\", value: \"+1d4\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 }\n  );\n  document.effects.push(effect);\n\n  if (spellEffectModules().tokenMagicInstalled) {\n    effect.changes.push(generateTokenMagicFXChange(\"bloom\"));\n  }\n\n  return document;\n}\n","import { baseSpellEffect, generateTokenMagicFXChange, spellEffectModules } from \"../specialSpells.js\";\n\nexport function blurEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    {\n      key: 'flags.midi-qol.grants.disadvantage.attack.all',\n      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n      value: '1',\n      priority: \"20\",\n    }\n  );\n\n  if (spellEffectModules().tokenMagicInstalled) {\n    effect.changes.push(generateTokenMagicFXChange(\"blur\"));\n  }\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function blindnessDeafnessEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"flags.midi-qol.OverTime\",\n    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n    value: \"label=Blindness/Deafness,turn=end,saveDC=@attributes.spelldc,saveAbility=con,savingThrow=true,saveMagic=true\",\n    priority: \"20\",\n  });\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"blindnessDeafness.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function callLightningEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"callLightning.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"@spellLevel\"));\n  document.effects.push(effect);\n  setProperty(document, \"data.actionType\", \"other\");\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function charmPersonEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Charmed\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { loadMacroFile, generateMacroFlags } from \"../macros.js\";\n\nexport async function chromaticOrbEffect(document) {\n  const itemMacroText = await loadMacroFile(\"spell\", \"chromaticOrb.js\");\n  setProperty(document, \"flags.itemacro\", generateMacroFlags(document, itemMacroText));\n  setProperty(document, \"flags.midi-qol.onUseMacroName\", \"[postActiveEffects]ItemMacro\");\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function chillTouchEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"data.traits.di.value\",\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n    value: \"healing\",\n    priority: \"30\",\n  });\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"chillTouch.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function commandEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function comprehendLanguagesEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    {\n      key: 'data.traits.languages.all',\n      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n      value: '1',\n      priority: \"20\",\n    }\n  );\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function confusionEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"flags.midi-qol.OverTime\",\n    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n    value: \"label=Confusion,turn=end,saveAbility=wis,saveDC=@attributes.spelldc,saveMagic=true\",\n    priority: \"20\",\n  });\n  effect.flags.dae.macroRepeat = \"startEveryTurn\";\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"confusion.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function contagionEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.flags.dae.macroRepeat = \"endEveryTurn\";\n  effect.changes.push(generateStatusEffectChange(\"Poisoned\"));\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"contagion.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { generateATLChange } from \"../effects.js\";\nimport { baseSpellEffect, spellEffectModules } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function crownofStarsEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n\n  if (spellEffectModules().atlInstalled) {\n    effect.changes.push(generateATLChange(\"ATL.dimLight\", CONST.ACTIVE_EFFECT_MODES.UPGRADE, '60'));\n    effect.changes.push(generateATLChange(\"ATL.brightLight\", CONST.ACTIVE_EFFECT_MODES.UPGRADE, '30'));\n  }\n\n  const itemMacroText = await loadMacroFile(\"spell\", \"crownofStars.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"@spellLevel\"));\n  document.data.damage = { parts: [], versatile: \"\", value: \"\" };\n  document.data['target']['type'] = \"self\";\n  document.data.range = { value: null, units: \"self\", long: null };\n  document.data.actionType = \"other\";\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function darknessEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"darkness.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\"));\n  document.effects.push(effect);\n  document.data['target']['type'] = \"self\";\n  document.data.range = { value: null, units: \"self\", long: null };\n\n  return document;\n}\n","import { baseSpellEffect, generateATLChange, spellEffectModules } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function darkvisionEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"data.attributes.senses.darkvision\",\n    value: \"60\",\n    mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,\n    priority: 20,\n  });\n\n  if (spellEffectModules().atlInstalled) {\n    effect.changes.push(generateATLChange(\"ATL.dimSight\", CONST.ACTIVE_EFFECT_MODES.UPGRADE, 60, 5));\n  } else {\n    // MACRO START\n    const itemMacroText = await loadMacroFile(\"spell\", \"darkvision.js\");\n    // MACRO STOP\n    document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n    effect.changes.push(generateMacroChange(\"\"));\n  }\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function divineFavorEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    { key: \"data.bonuses.mwak.damage\", value: \"1d4[Radiant]\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 },\n    { key: \"data.bonuses.rwak.damage\", value: \"1d4[Radiant]\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 0 }\n  );\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function divineWordEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"divineWord.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function dominateBeastEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Charmed\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function dominateMonsterEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Charmed\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function dominatePersonEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Charmed\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function enhanceAbilityEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"enhanceAbility.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, spellEffectModules } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function enlargeReduceEffect(document) {\n  if (!spellEffectModules().atlInstalled) return document;\n\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"enlargeReduce.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\", 0));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function entangleEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Restrained\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function eyebiteEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"eyebite.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.flags.dae.macroRepeat = \"startEveryTurn\";\n  effect.changes.push(generateMacroChange(\"\"));\n  document.effects.push(effect);\n  setProperty(document, \"data.actionType\", \"other\");\n  setProperty(document, \"data.save.ability\", \"\");\n\n  return document;\n}\n","import { baseSpellEffect, generateTokenMagicFXChange, spellEffectModules } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function faerieFireEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"flags.midi-qol.grants.advantage.attack.all\",\n    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n    value: \"1\",\n    priority: \"20\",\n  });\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"faerieFire.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\"));\n\n  if (spellEffectModules().tokenMagicInstalled) {\n    effect.changes.push(generateTokenMagicFXChange(\"glow\"));\n  }\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function fearEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Frightened\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function feeblemindEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    { key: \"data.abilities.cha.value\", value: \"1\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, priority: 50 },\n    { key: \"data.abilities.int.value\", value: \"1\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, priority: 50 },\n    { key: \"flags.midi-qol.fail.spell.all\", value: \"1\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, priority: 20 }\n  );\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function fireShieldEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"fireShield.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\", 0));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function flameBladeEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"flameBlade.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"@spellLevel\"));\n  document.data.damage = { parts: [], versatile: \"\", value: \"\" };\n  document.data['target']['type'] = \"self\";\n  document.data.range = { value: null, units: \"self\", long: null };\n  document.data.actionType = \"other\";\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function fleshtoStoneEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Restrained\"));\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"fleshtoStone.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.flags.dae.macroRepeat = \"endEveryTurn\";\n  effect.changes.push(generateMacroChange(\"\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function flyEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"data.attributes.movement.fly\",\n    value: \"60\",\n    mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,\n    priority: 20,\n  });\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function geasEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Charmed\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function greaseEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Prone\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function greaterInvisibilityEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"greaterInvisibility.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"@target\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function guidanceEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    {\n      key: 'flags.midi-qol.optional.guidance.label',\n      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n      value: 'Guidance',\n      priority: \"20\",\n    },\n    {\n      key: 'flags.midi-qol.optional.guidance.check',\n      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n      value: '+ 1d4',\n      priority: \"20\",\n    },\n  );\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function guidingBoltEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"flags.midi-qol.grants.advantage.attack.all\",\n    value: \"1\",\n    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n    priority: 20,\n  });\n  effect.flags.dae.specialDuration = \"isAttacked\";\n  effect.duration = {\n    startTime: null,\n    seconds: null,\n    rounds: 1,\n    turns: 1,\n    startRound: null,\n    startTurn: null,\n  };\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function hasteEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    { key: \"data.attributes.ac.bonus\", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: \"+2\", priority: \"20\" },\n    {\n      key: \"flags.midi-qol.advantage.ability.save.dex\",\n      mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n      value: \"1\",\n      priority: \"20\",\n    },\n    { key: \"data.attributes.movement.all\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: \"*2\", priority: \"30\" }\n  );\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function heroesFeastEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    { key: \"data.traits.di.value\", value: \"poison\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 20 },\n    { key: \"data.traits.ci.value\", value: \"frightened\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, priority: 20 }\n  );\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"heroesFeast.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"@damage\", 0));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function heroismEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"data.traits.ci.value\",\n    value: \"frightened\",\n    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n    priority: 20,\n  });\n  effect.flags.dae.macroRepeat = \"startEveryTurn\";\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"heroism.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"@damage\", 0));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function hideousLaughterEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    generateStatusEffectChange(\"Incapacitated\"),\n    generateStatusEffectChange(\"Prone\"),\n  );\n\n  effect.changes.push({\n    key: \"flags.midi-qol.OverTime\",\n    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n    value: \"label=Hideous Laughter,turn=end,saveDc=@attributes.spelldc,saveAbility=wis,saveMagic=true\",\n    priority: \"20\",\n  });\n\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"hideousLaughter.js\");\n  // MACRO STOP\n\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function holdMonsterEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Paralyzed\"));\n  effect.changes.push({\n    key: \"flags.midi-qol.OverTime\",\n    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n    value: `label=${document.name},turn=end,saveDC=@attributes.spelldc,saveAbility=wis,savingThrow=true,saveMagic=true`,\n    priority: \"20\",\n  });\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function holdPersonEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Paralyzed\"));\n  effect.changes.push({\n    key: \"flags.midi-qol.OverTime\",\n    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n    value: `label=${document.name},turn=end,saveDC=@attributes.spelldc,saveAbility=wis,savingThrow=true,saveMagic=true`,\n    priority: \"20\",\n  });\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateATLChange, spellEffectModules } from \"../specialSpells.js\";\n\nexport function holyAuraEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    {\n      key: \"flags.midi-qol.advantage.ability.save.all\",\n      mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n      value: \"1\",\n      priority: \"20\",\n    },\n    {\n      key: \"flags.midi-qol.grants.disadvantage.attack.all\",\n      mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n      value: \"1\",\n      priority: \"20\",\n    },\n  );\n\n  if (spellEffectModules().atlInstalled) {\n    effect.changes.push(generateATLChange(\"ATL.dimLight\", CONST.ACTIVE_EFFECT_MODES.UPGRADE, '5'));\n    effect.changes.push(generateATLChange(\"ATL.lightColor\", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '#ffffff'));\n    effect.changes.push(generateATLChange(\"ATL.lightAlpha\", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '0.25'));\n    const lightAnimation = '{\"type\": \"sunburst\", \"speed\": 2,\"intensity\": 4}';\n    effect.changes.push(generateATLChange(\"ATL.lightAnimation\", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, lightAnimation));\n  }\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroFlags } from \"../macros.js\";\n\n// this one is a bit different, the macro is triggered by midi-qol and applies effects to the actor\n// the Marked effect gets applied to the target\nexport async function huntersMarkEffect(document) {\n  let effect = baseSpellEffect(document, \"Marked\");\n\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"huntersMark.js\");\n  // MACRO STOP\n\n  setProperty(document, \"flags.itemacro\", generateMacroFlags(document, itemMacroText));\n  setProperty(document, \"flags.midi-qol.onUseMacroName\", \"[postActiveEffects]ItemMacro\");\n  setProperty(document, \"data.actionType\", \"util\");\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function hypnoticPatternEffect(document) {\n  let effectHypnoticPatternCharmed = baseSpellEffect(document, document.name);\n  effectHypnoticPatternCharmed.changes.push(generateStatusEffectChange(\"Charmed\"));\n  document.effects.push(effectHypnoticPatternCharmed);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function invisibilityEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"invisibility.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"@target\", 0));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function irresistibleDanceEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n\n  effect.changes.push({\n    key: \"flags.midi-qol.disadvantage.ability.save.str\",\n    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n    value: \"1\",\n    priority: \"20\",\n  });\n  effect.changes.push({\n    key: \"flags.midi-qol.disadvantage.attack.all\",\n    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n    value: \"1\",\n    priority: \"20\",\n  });\n  effect.changes.push({\n    key: \"flags.midi-qol.grants.advantage.attack.all \",\n    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n    value: \"1\",\n    priority: \"20\",\n  });\n\n  effect.flags.dae.macroRepeat = \"startEveryTurn\";\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"irresistibleDance.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateATLChange, spellEffectModules } from \"../specialSpells.js\";\n\nexport function lightEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n\n  if (spellEffectModules().atlInstalled) {\n    effect.changes.push(generateATLChange(\"ATL.dimLight\", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '40'));\n    effect.changes.push(generateATLChange(\"ATL.brightLight\", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '20'));\n    effect.changes.push(generateATLChange(\"ATL.lightColor\", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '#ffffff'));\n    effect.changes.push(generateATLChange(\"ATL.lightAlpha\", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, '0.25'));\n    const lightAnimation = '{\"type\": \"pulse\", \"speed\": 3,\"intensity\": 1}';\n    effect.changes.push(generateATLChange(\"ATL.lightAnimation\", CONST.ACTIVE_EFFECT_MODES.OVERRIDE, lightAnimation));\n  }\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function longstriderEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    { key: \"data.attributes.movement.walk\", value: \"10\", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },\n    { key: \"data.attributes.movement.fly\", value: \"10\", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },\n    { key: \"data.attributes.movement.burrow\", value: \"10\", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },\n    { key: \"data.attributes.movement.climb\", value: \"10\", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 },\n    { key: \"data.attributes.movement.swim\", value: \"10\", mode: CONST.ACTIVE_EFFECT_MODES.ADD, priority: 20 }\n  );\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function mageArmorEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"data.attributes.ac.base\",\n    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n    value: \"13\",\n    priority: \"5\",\n  });\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function magicWeaponEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"magicWeapon.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"@item.level\", 0));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function massSuggestionEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(generateStatusEffectChange(\"Charmed\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function mindBlankEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    {\n      key: 'data.traits.di.value',\n      mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n      value: 'psychic',\n      priority: \"20\",\n    }\n  );\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateTokenMagicFXChange, spellEffectModules } from \"../specialSpells.js\";\n\nexport function mirrorImageEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n\n  if (spellEffectModules().tokenMagicInstalled) {\n    effect.changes.push(generateTokenMagicFXChange(\"images\"));\n  }\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function mistyStepEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"mistyStep.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"@target\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function moonbeamEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.flags.dae.macroRepeat = \"startEveryTurn\";\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"moonbeam.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"@spellLevel\"));\n  document.effects.push(effect);\n  document.data.damage = { parts: [], versatile: \"\", value: \"\" };\n  document.data['target']['type'] = \"self\";\n  document.data.range = { value: null, units: \"self\", long: null };\n  document.data.actionType = \"other\";\n  document.data.save.ability = \"\";\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function passWithoutTraceEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    {\n      key: 'data.skills.ste.bonuses.check',\n      mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n      value: '+ 10',\n      priority: \"20\",\n    }\n  );\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function phantasmalKillerEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"flags.midi-qol.OverTime\",\n    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n    value:\n      \"label=Phantasmal Killer,turn=start,saveAbility=wis,saveDC=@attributes.spelldc,saveMagic=true,damageRoll=(@item.level)d10,damageType=psychic,savingThrow=true,damageBeforeSave=false\",\n    priority: \"20\",\n  });\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function protectionfromEnergyEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"protectionfromEnergy.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\", 0));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function protectionfromPoisonEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"data.traits.dr.value\",\n    value: \"poison\",\n    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n    priority: 0,\n  });\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function rayofEnfeeblementEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"flags.midi-qol.OverTime\",\n    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n    value: `label=${document.name},turn=end,saveDC=@attributes.spelldc,saveAbility=con,savingThrow=true,saveMagic=true`,\n    priority: \"20\",\n  });\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"rayofEnfeeblement.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function rayofFrostEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"data.attributes.movement.walk\",\n    value: \"-10\",\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n    priority: 20,\n  });\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function regenerateEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    {\n      key: \"flags.midi-qol.OverTime\",\n      mode: 5,\n      value: `label=${document.name},turn=start,damageRoll=1,damageType=healing,condition=@attributes.hp.value > 0 && @attributes.hp.value < @attributes.hp.max`,\n      priority: \"20\",\n    }\n  );\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function resilientSphereEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    {\n      key: 'data.attributes.movement.all',\n      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n      value: '* 0.5',\n      priority: \"20\",\n    },\n    {\n      key: 'data.traits.di.all',\n      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n      value: '1',\n      priority: \"20\",\n    },\n  );\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function resistanceEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    {\n      key: 'flags.midi-qol.optional.resistance.label',\n      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n      value: 'Resistance',\n      priority: \"20\",\n    },\n    {\n      key: 'flags.midi-qol.optional.resistance.save',\n      mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n      value: '+ 1d4',\n      priority: \"20\",\n    },\n  );\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateTokenMagicFXChange, spellEffectModules } from \"../specialSpells.js\";\n\nexport function shieldEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"data.attributes.ac.bonus\",\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n    value: \"+5\",\n    priority: \"20\",\n  });\n  effect.flags.dae.specialDuration = \"turnStart\";\n\n  if (spellEffectModules().tokenMagicInstalled) {\n    effect.changes.push(generateTokenMagicFXChange(\"water-field\"));\n  }\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateTokenMagicFXChange, spellEffectModules } from \"../specialSpells.js\";\n\nexport function shieldofFaithEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"data.attributes.ac.bonus\",\n    mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n    value: \"+2\",\n    priority: \"20\",\n  });\n\n  if (spellEffectModules().tokenMagicInstalled) {\n    effect.changes.push(generateTokenMagicFXChange(\"bloom\"));\n  }\n\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function shillelaghEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"shillelagh.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\", 0));\n\n  document.data.damage = { parts: [], versatile: \"\", value: \"\" };\n  document.data['target']['type'] = \"self\";\n  document.data.range = { value: null, units: \"self\", long: null };\n  document.data.actionType = \"other\";\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function slowEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    { key: \"data.attributes.ac.bonus\", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: \"-2\", priority: \"20\" },\n    { key: \"data.attributes.movement.all\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: \"/2\", priority: \"20\" },\n    { key: \"data.abilities.dex.save\", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: \"-2\", priority: \"20\" }\n  );\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function spiderClimbEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"data.attributes.movement.climb\",\n    value: \"@attributes.movement.walk\",\n    mode: CONST.ACTIVE_EFFECT_MODES.UPGRADE,\n    priority: 20,\n  });\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, spellEffectModules } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function spiritGuardiansEffect(document) {\n  // we require active auras for this effect\n  if (!spellEffectModules().activeAurasInstalled) return document;\n\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    {\n      key: \"data.attributes.movement.all\",\n      mode: 0,\n      value: \"/2\",\n      priority: \"20\",\n    },\n    {\n      key: \"flags.midi-qol.OverTime\",\n      mode: 5,\n      value:\n        \"turn=start,label=Spirit Guardians,damageRoll=(@spellLevel)d8,damageType=radiant,saveRemove=false,saveDC=@attributes.spelldc,saveAbility=wis,saveDamage=halfdamage,killAnim=true\",\n      priority: \"20\",\n    }\n  );\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"spiritGuardians.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.flags[\"ActiveAuras\"] = {\n    isAura: true,\n    aura: \"Enemy\",\n    radius: 15,\n    alignment: \"\",\n    type: \"\",\n    ignoreSelf: true,\n    height: false,\n    hidden: false,\n    hostile: false,\n    onlyOnce: false,\n  };\n  effect.changes.push(generateMacroChange(\"@token @spellLevel @attributes.spelldc\"));\n\n  document.effects.push(effect);\n\n  document.data.damage = { parts: [], versatile: \"\", value: \"\" };\n  document.data['target']['type'] = \"self\";\n  document.data.range = { value: null, units: \"self\", long: null };\n  document.data.actionType = \"\";\n  document.data.save.ability = \"\";\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function spiritualWeaponEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"spiritualWeapon.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"@item.level\"));\n  document.effects.push(effect);\n\n  document.data.damage = { parts: [], versatile: \"\", value: \"\" };\n  document.data['target']['type'] = \"self\";\n  document.data.range = { value: null, units: \"self\", long: null };\n  document.data.actionType = \"other\";\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function stoneskinEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"data.traits.dr.value\",\n    value: \"physical\",\n    mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n    priority: 0,\n  });\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function sunbeamEffect(document) {\n  let effectSunbeamBlinded = baseSpellEffect(document, document.name);\n  effectSunbeamBlinded.changes.push(generateStatusEffectChange(\"Blinded\"));\n  document.effects.push(effectSunbeamBlinded);\n\n  return document;\n}\n","import { loadMacroFile, generateMacroFlags } from \"../macros.js\";\n\nexport async function tolltheDeadEffect(document) {\n  const itemMacroText = await loadMacroFile(\"spell\", \"tolltheDead.js\");\n  setProperty(document, \"flags.itemacro\", generateMacroFlags(document, itemMacroText));\n  setProperty(document, \"flags.midi-qol.onUseMacroName\", \"[postActiveEffects]ItemMacro\");\n\n  document.data.damage = { parts: [], versatile: \"\", value: \"\" };\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function trueStrikeEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"flags.midi-qol.advantage.attack.all\",\n    value: \"1\",\n    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n    priority: 20,\n  });\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\n\nexport function viciousMockeryEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push({\n    key: \"flags.midi-qol.disadvantage.attack.all\",\n    value: \"1\",\n    mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n    priority: 20,\n  });\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect } from \"../specialSpells.js\";\nimport { loadMacroFile, generateMacroChange, generateMacroFlags } from \"../macros.js\";\n\nexport async function wardingBondEffect(document) {\n  let effect = baseSpellEffect(document, document.name);\n  effect.changes.push(\n    { key: \"data.attributes.ac.bonus\", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: \"1\", priority: \"20\" },\n    { key: \"data.traits.dr.all\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: \"1\", priority: \"20\" },\n    { key: \"data.bonuses.abilities.save\", mode: CONST.ACTIVE_EFFECT_MODES.ADD, value: \"1\", priority: \"20\" }\n  );\n  // MACRO START\n  const itemMacroText = await loadMacroFile(\"spell\", \"wardingBond.js\");\n  // MACRO STOP\n  document.flags[\"itemacro\"] = generateMacroFlags(document, itemMacroText);\n  effect.changes.push(generateMacroChange(\"\"));\n  document.effects.push(effect);\n\n  return document;\n}\n","import { baseSpellEffect, generateStatusEffectChange } from \"../specialSpells.js\";\n\nexport function webEffect(document) {\n  let effectWebRestrained = baseSpellEffect(document, document.name);\n  effectWebRestrained.changes.push(generateStatusEffectChange(\"Restrained\"));\n  document.effects.push(effectWebRestrained);\n\n  return document;\n}\n","import { absorbElementsEffect } from \"./spells/absorbElements.js\";\nimport { aidEffect } from \"./spells/aid.js\";\nimport { alterSelfEffect } from \"./spells/alterSelf.js\";\nimport { animalFriendshipEffect } from \"./spells/animalFriendship.js\";\nimport { arcaneSwordEffect } from \"./spells/arcaneSword.js\";\nimport { baneEffect } from \"./spells/bane.js\";\nimport { banishmentEffect } from \"./spells/banishment.js\";\nimport { barkskinEffect } from \"./spells/barkskin.js\";\nimport { beaconofHopeEffect } from \"./spells/beaconofHope.js\";\nimport { blackTentaclesEffect } from \"./spells/blackTentacles.js\";\nimport { blessEffect } from \"./spells/bless.js\";\nimport { blurEffect } from \"./spells/blur.js\";\nimport { blindnessDeafnessEffect } from \"./spells/blindnessDeafness.js\";\nimport { callLightningEffect } from \"./spells/callLightning.js\";\nimport { charmPersonEffect } from \"./spells/charmPerson.js\";\nimport { chromaticOrbEffect } from \"./spells/chromaticOrb.js\";\nimport { chillTouchEffect } from \"./spells/chillTouch.js\";\nimport { commandEffect } from \"./spells/command.js\";\nimport { comprehendLanguagesEffect } from \"./spells/comprehendLanguages.js\";\nimport { confusionEffect } from \"./spells/confusion.js\";\nimport { contagionEffect } from \"./spells/contagion.js\";\nimport { crownofStarsEffect } from \"./spells/crownofStars.js\";\nimport { darknessEffect } from \"./spells/darkness.js\";\nimport { darkvisionEffect } from \"./spells/darkvision.js\";\nimport { divineFavorEffect } from \"./spells/divineFavor.js\";\nimport { divineWordEffect } from \"./spells/divineWord.js\";\nimport { dominateBeastEffect } from \"./spells/dominateBeast.js\";\nimport { dominateMonsterEffect } from \"./spells/dominateMonster.js\";\nimport { dominatePersonEffect } from \"./spells/dominatePerson.js\";\nimport { enhanceAbilityEffect } from \"./spells/enhanceAbility.js\";\nimport { enlargeReduceEffect } from \"./spells/enlargeReduce.js\";\nimport { entangleEffect } from \"./spells/entangle.js\";\nimport { eyebiteEffect } from \"./spells/eyebite.js\";\nimport { faerieFireEffect } from \"./spells/faerieFire.js\";\nimport { fearEffect } from \"./spells/fear.js\";\nimport { feeblemindEffect } from \"./spells/feeblemind.js\";\nimport { fireShieldEffect } from \"./spells/fireShield.js\";\nimport { flameBladeEffect } from \"./spells/flameBlade.js\";\nimport { fleshtoStoneEffect } from \"./spells/fleshtoStone.js\";\nimport { flyEffect } from \"./spells/fly.js\";\nimport { geasEffect } from \"./spells/geas.js\";\nimport { greaseEffect } from \"./spells/grease.js\";\nimport { greaterInvisibilityEffect } from \"./spells/greaterInvisibility.js\";\nimport { guidanceEffect } from \"./spells/guidance.js\";\nimport { guidingBoltEffect } from \"./spells/guidingBolt.js\";\nimport { hasteEffect } from \"./spells/haste.js\";\nimport { heroesFeastEffect } from \"./spells/heroesFeast.js\";\nimport { heroismEffect } from \"./spells/heroism.js\";\nimport { hideousLaughterEffect } from \"./spells/hideousLaughter.js\";\nimport { holdMonsterEffect } from \"./spells/holdMonster.js\";\nimport { holdPersonEffect } from \"./spells/holdPerson.js\";\nimport { holyAuraEffect } from \"./spells/holyAura.js\";\nimport { huntersMarkEffect } from \"./spells/huntersMark.js\";\nimport { hypnoticPatternEffect } from \"./spells/hypnoticPattern.js\";\nimport { invisibilityEffect } from \"./spells/invisibility.js\";\nimport { irresistibleDanceEffect } from \"./spells/irresistibleDance.js\";\nimport { lightEffect } from \"./spells/light.js\";\nimport { longstriderEffect } from \"./spells/longstrider.js\";\nimport { mageArmorEffect } from \"./spells/mageArmor.js\";\nimport { magicWeaponEffect } from \"./spells/magicWeapon.js\";\nimport { massSuggestionEffect } from \"./spells/massSuggestion.js\";\nimport { mindBlankEffect } from \"./spells/mindBlank.js\";\nimport { mirrorImageEffect } from \"./spells/mirrorImage.js\";\nimport { mistyStepEffect } from \"./spells/mistyStep.js\";\nimport { moonbeamEffect } from \"./spells/moonbeam.js\";\nimport { passWithoutTraceEffect } from \"./spells/passWithoutTrace.js\";\nimport { phantasmalKillerEffect } from \"./spells/phantasmalKiller.js\";\nimport { protectionfromEnergyEffect } from \"./spells/protectionfromEnergy.js\";\nimport { protectionfromPoisonEffect } from \"./spells/protectionfromPoison.js\";\nimport { rayofEnfeeblementEffect } from \"./spells/rayofEnfeeblement.js\";\nimport { rayofFrostEffect } from \"./spells/rayofFrost.js\";\nimport { regenerateEffect } from \"./spells/regenerate.js\";\nimport { resilientSphereEffect } from \"./spells/resilientSphere.js\";\nimport { resistanceEffect } from \"./spells/resistance.js\";\nimport { shieldEffect } from \"./spells/shield.js\";\nimport { shieldofFaithEffect } from \"./spells/shieldofFaith.js\";\nimport { shillelaghEffect } from \"./spells/shillelagh.js\";\nimport { slowEffect } from \"./spells/slow.js\";\nimport { spiderClimbEffect } from \"./spells/spiderClimb.js\";\nimport { spiritGuardiansEffect } from \"./spells/spiritGuardians.js\";\nimport { spiritualWeaponEffect } from \"./spells/spiritualWeapon.js\";\nimport { stoneskinEffect } from \"./spells/stoneskin.js\";\nimport { sunbeamEffect } from \"./spells/sunbeam.js\";\nimport { tolltheDeadEffect } from \"./spells/tolltheDead.js\";\nimport { trueStrikeEffect } from \"./spells/trueStrike.js\";\nimport { viciousMockeryEffect } from \"./spells/viciousMockery.js\";\nimport { wardingBondEffect } from \"./spells/wardingBond.js\";\nimport { webEffect } from \"./spells/web.js\";\n\nimport utils from \"../utils.js\";\nimport logger from \"../logger.js\";\nimport {\n  generateStatusEffectChange as baseGenerateStatusEffectChange,\n  generateTokenMagicFXChange as baseGenerateTokenMagicFXChange,\n  generateATLChange as baseGenerateATLChange,\n} from \"./effects.js\";\nimport { configureDependencies } from \"./macros.js\";\n\nvar installedModules;\n\nexport function spellEffectModules() {\n  if (installedModules) return installedModules;\n  const midiQolInstalled = utils.isModuleInstalledAndActive(\"midi-qol\");\n  const advancedMacrosInstalled = utils.isModuleInstalledAndActive(\"advanced-macros\");\n  const aboutTime = utils.isModuleInstalledAndActive(\"about-time\");\n  const itemMacroInstalled = utils.isModuleInstalledAndActive(\"itemacro\");\n  const timesUp = utils.isModuleInstalledAndActive(\"times-up\");\n  const daeInstalled = utils.isModuleInstalledAndActive(\"dae\");\n  const convinientEffectsInstalled = utils.isModuleInstalledAndActive(\"dfreds-convenient-effects\");\n\n  const activeAurasInstalled = utils.isModuleInstalledAndActive(\"ActiveAuras\");\n  const atlInstalled = utils.isModuleInstalledAndActive(\"ATL\");\n  const tokenAurasInstalled = utils.isModuleInstalledAndActive(\"token-auras\");\n  const tokenMagicInstalled = utils.isModuleInstalledAndActive(\"tokenmagic\");\n  const autoAnimationsInstalled = utils.isModuleInstalledAndActive(\"autoanimations\");\n  installedModules = {\n    hasCore: itemMacroInstalled && midiQolInstalled && advancedMacrosInstalled && aboutTime && timesUp && daeInstalled && convinientEffectsInstalled,\n    midiQolInstalled,\n    itemMacroInstalled,\n    advancedMacrosInstalled,\n    aboutTime,\n    timesUp,\n    daeInstalled,\n    convinientEffectsInstalled,\n    atlInstalled,\n    tokenAurasInstalled,\n    tokenMagicInstalled,\n    activeAurasInstalled,\n    autoAnimationsInstalled,\n  };\n  return installedModules;\n}\n\nexport function baseSpellEffect(document, label) {\n  return {\n    label,\n    icon: document.img,\n    changes: [],\n    duration: {},\n    tint: \"\",\n    transfer: false,\n    disabled: false,\n    flags: {\n      dae: {\n        transfer: false,\n        stackable: false,\n      },\n      ddbimporter: {\n        disabled: false,\n      },\n    },\n  };\n}\n\nexport function generateStatusEffectChange(statusName, priority = 20) {\n  return baseGenerateStatusEffectChange(statusName, priority);\n}\n\nexport function generateTokenMagicFXChange(macroValue, priority = 20) {\n  return baseGenerateTokenMagicFXChange(macroValue, priority);\n}\n\nexport function generateATLChange(atlKey, mode, value, priority = 20) {\n  return baseGenerateATLChange(atlKey, mode, value, priority);\n}\n\nvar configured = false;\n\n/**\n * This function is mainly for effects that can't be dynamically generated\n * @param {*} document\n */\n// eslint-disable-next-line complexity\nexport async function spellEffectAdjustment(document) {\n  if (!document.effects) document.effects = [];\n\n  // check that we can gen effects\n  const deps = spellEffectModules();\n  if (!deps.hasCore) {\n    logger.warn(\"Sorry, you're missing some required modules for spell effects. Please install them and try again.\", deps);\n    return document;\n  }\n  if (!configured) {\n    configured = configureDependencies();\n  }\n\n  const name = document.flags.ddbimporter.originalName || document.name;\n  switch (name) {\n    case \"Absorb Elements\": {\n      document = absorbElementsEffect(document);\n      break;\n    }\n    case \"Aid\": {\n      document = await aidEffect(document);\n      break;\n    }\n    case \"Alter Self\": {\n      document = alterSelfEffect(document);\n      break;\n    }\n    case \"Animal Friendship\": {\n      document = animalFriendshipEffect(document);\n      break;\n    }\n    case \"Mordenkainen's Sword\":\n    case \"Arcane Sword\": {\n      document = await arcaneSwordEffect(document);\n      break;\n    }\n    case \"Bane\": {\n      document = baneEffect(document);\n      break;\n    }\n    case \"Banishment\": {\n      document = await banishmentEffect(document);\n      break;\n    }\n    case \"Barkskin\": {\n      document = barkskinEffect(document);\n      break;\n    }\n    case \"Beacon of Hope\": {\n      document = beaconofHopeEffect(document);\n      break;\n    }\n    case \"Black Tentacles\": {\n      document = blackTentaclesEffect(document);\n      break;\n    }\n    case \"Bless\": {\n      document = blessEffect(document);\n      break;\n    }\n    case \"Blur\": {\n      document = blurEffect(document);\n      break;\n    }\n    case \"Blindness/Deafness\": {\n      document = await blindnessDeafnessEffect(document);\n      break;\n    }\n    case \"Call Lightning\": {\n      document = await callLightningEffect(document);\n      break;\n    }\n    case \"Charm Person\": {\n      document = charmPersonEffect(document);\n      break;\n    }\n    case \"Chill Touch\": {\n      document = await chillTouchEffect(document);\n      break;\n    }\n    case \"Chromatic Orb\": {\n      document = await chromaticOrbEffect(document);\n      break;\n    }\n    case \"Command\": {\n      document = commandEffect(document);\n      break;\n    }\n    case \"Comprehend Languages\": {\n      document = comprehendLanguagesEffect(document);\n      break;\n    }\n    case \"Confusion\": {\n      document = await confusionEffect(document);\n      break;\n    }\n    case \"Contagion\": {\n      document = await contagionEffect(document);\n      break;\n    }\n    case \"Crown of Stars\": {\n      document = await crownofStarsEffect(document);\n      break;\n    }\n    case \"Darkness\": {\n      document = await darknessEffect(document);\n      break;\n    }\n    case \"Darkvision\": {\n      document = await darkvisionEffect(document);\n      break;\n    }\n    case \"Divine Favor\": {\n      document = divineFavorEffect(document);\n      break;\n    }\n    case \"Divine Word\": {\n      document = await divineWordEffect(document);\n      break;\n    }\n    case \"Dominate Beast\": {\n      document = dominateBeastEffect(document);\n      break;\n    }\n    case \"Dominate Monster\": {\n      document = dominateMonsterEffect(document);\n      break;\n    }\n    case \"Dominate Person\": {\n      document = dominatePersonEffect(document);\n      break;\n    }\n    case \"Enhance Ability\": {\n      document = await enhanceAbilityEffect(document);\n      break;\n    }\n    case \"Enlarge/Reduce\": {\n      document = await enlargeReduceEffect(document);\n      break;\n    }\n    case \"Entangle\": {\n      document = entangleEffect(document);\n      break;\n    }\n    case \"Eyebite\": {\n      document = await eyebiteEffect(document);\n      break;\n    }\n    case \"Faerie Fire\": {\n      document = faerieFireEffect(document);\n      break;\n    }\n    case \"Fear\": {\n      document = fearEffect(document);\n      break;\n    }\n    case \"Feeblemind\": {\n      document = feeblemindEffect(document);\n      break;\n    }\n    case \"Fire Shield\": {\n      document = await fireShieldEffect(document);\n      break;\n    }\n    case \"Flame Blade\": {\n      document = await flameBladeEffect(document);\n      break;\n    }\n    case \"Flesh to Stone\": {\n      document = await fleshtoStoneEffect(document);\n      break;\n    }\n    case \"Fly\": {\n      document = flyEffect(document);\n      break;\n    }\n    case \"Geas\": {\n      document = geasEffect(document);\n      break;\n    }\n    case \"Grease\": {\n      document = greaseEffect(document);\n      break;\n    }\n    case \"Greater Invisibility\": {\n      document = await greaterInvisibilityEffect(document);\n      break;\n    }\n    case \"Guidance\": {\n      document = guidanceEffect(document);\n      break;\n    }\n    case \"Guiding Bolt\": {\n      document = guidingBoltEffect(document);\n      break;\n    }\n    case \"Haste\": {\n      document = hasteEffect(document);\n      break;\n    }\n    case \"Heroes' Feast\": {\n      document = await heroesFeastEffect(document);\n      break;\n    }\n    case \"Heroism\": {\n      document = await heroismEffect(document);\n      break;\n    }\n    case \"Tasha's Hideous Laughter\":\n    case \"Hideous Laughter\": {\n      document = await hideousLaughterEffect(document);\n      break;\n    }\n    case \"Hold Monster\": {\n      document = holdMonsterEffect(document);\n      break;\n    }\n    case \"Hold Person\": {\n      document = holdPersonEffect(document);\n      break;\n    }\n    case \"Holy Aura\": {\n      document = holyAuraEffect(document);\n      break;\n    }\n    case \"Hunter's Mark\": {\n      document = await huntersMarkEffect(document);\n      break;\n    }\n    case \"Hypnotic Pattern\": {\n      document = hypnoticPatternEffect(document);\n      break;\n    }\n    case \"Invisibility\": {\n      document = await invisibilityEffect(document);\n      break;\n    }\n    case \"Otto's Irresistible Dance\":\n    case \"Irresistible Dance\": {\n      document = await irresistibleDanceEffect(document);\n      break;\n    }\n    case \"Light\": {\n      document = lightEffect(document);\n      break;\n    }\n    case \"Longstrider\": {\n      document = longstriderEffect(document);\n      break;\n    }\n    case \"Mage Armor\": {\n      document = mageArmorEffect(document);\n      break;\n    }\n    case \"Magic Weapon\": {\n      document = await magicWeaponEffect(document);\n      break;\n    }\n    case \"Mass Suggestion\": {\n      document = massSuggestionEffect(document);\n      break;\n    }\n    case \"Mind Blank\": {\n      document = mindBlankEffect(document);\n      break;\n    }\n    case \"Mirror Image\": {\n      document = mirrorImageEffect(document);\n      break;\n    }\n    case \"Misty Step\": {\n      document = await mistyStepEffect(document);\n      break;\n    }\n    case \"Moonbeam\": {\n      document = await moonbeamEffect(document);\n      break;\n    }\n    case \"Pass Without Trace\": {\n      document = passWithoutTraceEffect(document);\n      break;\n    }\n    case \"Phantasmal Killer\": {\n      document = phantasmalKillerEffect(document);\n      break;\n    }\n    case \"Protection from Energy\": {\n      document = await protectionfromEnergyEffect(document);\n      break;\n    }\n    case \"Protection from Poison\": {\n      document = protectionfromPoisonEffect(document);\n      break;\n    }\n    case \"Ray of Enfeeblement\": {\n      document = await rayofEnfeeblementEffect(document);\n      break;\n    }\n    case \"Ray of Frost\": {\n      document = rayofFrostEffect(document);\n      break;\n    }\n    case \"Regenerate\": {\n      document = regenerateEffect(document);\n      break;\n    }\n    case \"Otiluke's Resilient Sphere\":\n    case \"Resilient Sphere\": {\n      document = resilientSphereEffect(document);\n      break;\n    }\n    case \"Resistance\": {\n      document = resistanceEffect(document);\n      break;\n    }\n    case \"Shield\": {\n      document = shieldEffect(document);\n      break;\n    }\n    case \"Shield of Faith\": {\n      document = shieldofFaithEffect(document);\n      break;\n    }\n    case \"Shillelagh\": {\n      document = await shillelaghEffect(document);\n      break;\n    }\n    case \"Slow\": {\n      document = slowEffect(document);\n      break;\n    }\n    case \"Spider Climb\": {\n      document = spiderClimbEffect(document);\n      break;\n    }\n    case \"Spirit Guardians\": {\n      document = await spiritGuardiansEffect(document);\n      break;\n    }\n    case \"Spiritual Weapon\": {\n      document = await spiritualWeaponEffect(document);\n      break;\n    }\n    case \"Stoneskin\": {\n      document = stoneskinEffect(document);\n      break;\n    }\n    case \"Sunbeam\": {\n      document = sunbeamEffect(document);\n      break;\n    }\n    case \"Toll the Dead\": {\n      document = await tolltheDeadEffect(document);\n      break;\n    }\n    case \"True Strike\": {\n      document = trueStrikeEffect(document);\n      break;\n    }\n    case \"Vicious Mockery\": {\n      document = viciousMockeryEffect(document);\n      break;\n    }\n    case \"Warding Bond\": {\n      document = await wardingBondEffect(document);\n      break;\n    }\n    case \"Web\": {\n      document = webEffect(document);\n      break;\n    }\n    // no default\n  }\n  return document;\n}\n","import utils from \"../utils.js\";\nimport logger from \"../logger.js\";\n\nvar iconMap = {};\n\n// const BASE_PATH = ROUTE_PREFIX ? `/${ROUTE_PREFIX}` : \"\";\n\nconst TYPE_MAP = {\n  items: \"items\",\n  weapons: \"items\",\n  weapon: \"items\",\n  item: \"items\",\n  equipment: \"items\",\n  consumable: \"items\",\n  tool: \"items\",\n  loot: \"items\",\n  backpack: \"items\",\n  inventory: \"items\",\n  spells: \"spells\",\n  spell: \"spells\",\n  feats: \"feats\",\n  feat: \"feats\",\n  classes: \"classes\",\n  class: \"classes\",\n  monster: \"monster\",\n};\n\nconst FILE_MAP = {\n  items: [\"items.json\", \"class-features.json\"],\n  spells: [\"spells.json\"],\n  feats: [\"feats.json\", \"class-features.json\", \"races.json\", \"general.json\"],\n  classes: [\"classes.json\"],\n  monster: [\"monster-features.json\"],\n};\n\nasync function loadDataFile(fileName) {\n  logger.debug(`Getting icon mapping for ${fileName}`);\n  const fileExists = await utils.fileExists(\"[data] modules/ddb-importer/data\", fileName);\n\n  let data = [];\n  if (fileExists) {\n    const url = await utils.getFileUrl(\"[data] modules/ddb-importer/data\", fileName);\n    const response = await fetch(url, { method: \"GET\" });\n    // eslint-disable-next-line require-atomic-updates\n    data = await response.json();\n  }\n  return data;\n}\n\nasync function loadIconMap(type) {\n  // check to see if dictionary is loaded\n  logger.debug(`Loading Inbuilt Icon Map for ${type}`);\n  if (iconMap[type]) return;\n\n  let data = [];\n  for (const fileName of FILE_MAP[type]) {\n    // eslint-disable-next-line no-await-in-loop\n    const dataLoad = await loadDataFile(fileName);\n    data = data.concat(dataLoad);\n  }\n\n  iconMap[type] = data;\n  // console.warn(iconMap);\n}\n\nfunction looseMatch(item, typeValue) {\n  const originalName = item.flags?.ddbimporter?.originalName;\n  if (originalName) {\n    const originalMatch = iconMap[typeValue].find((entry) => entry.name === originalName);\n    if (originalMatch) return originalMatch.path;\n  }\n\n  if (item.name.includes(\":\")) {\n    const nameArray = item.name.split(\":\");\n    const postMatch = iconMap[typeValue].find((entry) => entry.name === nameArray[1].trim());\n    if (postMatch) return postMatch.path;\n    const subMatch = iconMap[typeValue].find((entry) => entry.name === nameArray[0].trim());\n    if (subMatch) return subMatch.path;\n  }\n\n  const startsMatchEntry = iconMap[typeValue].find((entry) => item.name.split(\":\")[0].trim().startsWith(entry.name.split(\":\")[0].trim()));\n  if (startsMatchEntry) return startsMatchEntry.path;\n  const startsMatchItem = iconMap[typeValue].find((entry) => entry.name.split(\":\")[0].trim().startsWith(item.name.split(\":\")[0].trim()));\n  if (startsMatchItem) return startsMatchItem.path;\n\n  return null;\n}\n\nfunction getIconPath(item, type, monsterName) {\n  // check to see if we are able to load a dic for that type\n  const typeValue = TYPE_MAP[type];\n  if (!typeValue || !iconMap[typeValue]) return null;\n\n  const iconMatch = iconMap[typeValue].find((entry) => {\n    if (type === \"monster\") {\n      return entry.name === item.name.split(\"(\")[0].trim() && entry.monster == monsterName;\n    }\n    return entry.name === item.name;\n  });\n  if (iconMatch) {\n    return iconMatch.path;\n  } else {\n    return looseMatch(item, typeValue);\n  }\n}\n\n\nasync function loadIconMaps(types) {\n  let promises = [];\n\n  const mapTypes = types\n    .filter((type) => TYPE_MAP[type])\n    .map((type) => TYPE_MAP[type]).filter((type, i, ar) => ar.indexOf(type) === i);\n\n  mapTypes.forEach((type) => {\n    logger.debug(`Loading ${type}`);\n    promises.push(loadIconMap(type));\n  });\n\n  return Promise.all(promises);\n}\n\nexport async function copyInbuiltIcons(items, monster = false, monsterName = \"\") {\n  // eslint-disable-next-line require-atomic-updates\n\n  // get unique array of item types to be matching\n  const itemTypes = items.map((item) => item.type).filter((item, i, ar) => ar.indexOf(item) === i);\n\n  if (monster) itemTypes.push(\"monster\");\n  await loadIconMaps(itemTypes);\n\n  return new Promise((resolve) => {\n    const iconItems = items.map((item) => {\n      // logger.debug(`Inbuilt icon match started for ${item.name} [${item.type}]`);\n      // if we have a monster lets check the monster dict first\n      if (monster) {\n        const monsterPath = getIconPath(item, \"monster\", monsterName);\n        if (monsterPath) {\n          item.img = monsterPath;\n          return item;\n        }\n      }\n      const pathMatched = getIconPath(item, item.type);\n      if (pathMatched) {\n        item.img = pathMatched;\n        if (item.effects) {\n          item.effects.forEach((effect) => {\n            if (!effect.icon || effect.icon === \"\") {\n              effect.icon = pathMatched;\n            }\n          });\n        }\n      }\n      return item;\n    });\n    resolve(iconItems);\n  });\n}\n","/**\n * Game Settings: Directory\n */\n\nimport logger from \"../logger.js\";\n\nexport class DirectoryPicker extends FilePicker {\n  constructor(options = {}) {\n    super(options);\n  }\n\n  _onSubmit(event) {\n    event.preventDefault();\n    const path = event.target.target.value;\n    const activeSource = this.activeSource;\n    const bucket = event.target.bucket ? event.target.bucket.value : null;\n    this.field.value = DirectoryPicker.format({\n      activeSource,\n      bucket,\n      path,\n    });\n    this.close();\n  }\n\n  static async uploadToPath(path, file) {\n    const options = DirectoryPicker.parse(path);\n    return FilePicker.upload(options.activeSource, options.current, file, { bucket: options.bucket });\n  }\n\n  // returns the type \"Directory\" for rendering the SettingsConfig\n  static Directory(val) {\n    return val;\n  }\n\n  // formats the data into a string for saving it as a GameSetting\n  static format(value) {\n    return value.bucket !== null\n      ? `[${value.activeSource}:${value.bucket}] ${value.path}`\n      : `[${value.activeSource}] ${value.path}`;\n  }\n\n  // parses the string back to something the FilePicker can understand as an option\n  static parse(str) {\n    let matches = str.match(/\\[(.+)\\]\\s*(.+)/);\n    if (matches) {\n      let source = matches[1];\n      const current = matches[2].trim();\n      const [s3, bucket] = source.split(\":\");\n      if (bucket !== undefined) {\n        return {\n          activeSource: s3,\n          bucket: bucket,\n          current: current,\n        };\n      } else {\n        return {\n          activeSource: s3,\n          bucket: null,\n          current: current,\n        };\n      }\n    }\n    // failsave, try it at least\n    return {\n      activeSource: \"data\",\n      bucket: null,\n      current: str,\n    };\n  }\n\n  // Adds a FilePicker-Simulator-Button next to the input fields\n  static processHtml(html) {\n    $(html)\n      .find(`input[data-dtype=\"Directory\"]`)\n      .each((index, element) => {\n        // disable the input field raw editing\n        $(element).prop(\"readonly\", true);\n\n        // if there is no button next to this input element yet, we add it\n        if (!$(element).next().length) {\n          let picker = new DirectoryPicker({\n            field: $(element)[0],\n            ...DirectoryPicker.parse($(element).val()),\n          });\n          let pickerButton = $(\n            '<button type=\"button\" class=\"file-picker\" data-type=\"imagevideo\" data-target=\"img\" title=\"Pick directory\"><i class=\"fas fa-file-import fa-fw\"></i></button>'\n          );\n          pickerButton.on(\"click\", () => {\n            picker.render(true);\n          });\n          $(element).parent().append(pickerButton);\n        }\n      });\n  }\n\n  /** @override */\n  activateListeners(html) {\n    super.activateListeners(html);\n\n    // remove unnecessary elements\n    $(html).find(\"ol.files-list\").remove();\n    $(html).find(\"footer div\").remove();\n    $(html).find(\"footer button\").text(\"Select Directory\");\n  }\n\n  static async forgeCreateDirectory(target) {\n    if (!target) return;\n    const response = await ForgeAPI.call('assets/new-folder', { path: target });\n    if (!response || response.error) {\n      throw new Error(response ? response.error : \"Unknown error while creating directory.\");\n    }\n  }\n\n  /**\n   * @param  {string} source\n   * @param  {string} target\n   * @param  {object} options={}\n   */\n  static async createDirectory(source, target, options = {}) {\n    if (!target) {\n      throw new Error(\"No directory name provided\");\n    }\n    if (typeof ForgeVTT !== \"undefined\" && ForgeVTT?.usingTheForge) {\n      return DirectoryPicker.forgeCreateDirectory(target);\n    }\n    return FilePicker.createDirectory(source, target, options);\n  }\n\n  /**\n   * Verifies server path exists, and if it doesn't creates it.\n   *\n   * @param  {object} parsedPath - output from DirectoryPicker,parse\n   * @param  {string} targetPath - if set will check this path, else check parsedPath.current\n   * @returns {boolean} - true if verfied, false if unable to create/verify\n   */\n  static async verifyPath(parsedPath, targetPath = null) {\n    try {\n      const paths = (targetPath) ? targetPath.split(\"/\") : parsedPath.current.split(\"/\");\n      let currentSource = paths[0];\n\n      for (let i = 0; i < paths.length; i += 1) {\n        try {\n          if (currentSource !== paths[i]) {\n            currentSource = `${currentSource}/${paths[i]}`;\n          }\n          // eslint-disable-next-line no-await-in-loop\n          await DirectoryPicker.createDirectory(parsedPath.activeSource, `${currentSource}`, { bucket: parsedPath.bucket });\n\n        } catch (err) {\n          if (!err.startsWith(\"EEXIST\") && !err.startsWith(\"The S3 key\")) logger.error(`Error trying to verify path [${parsedPath.activeSource}], ${parsedPath.current}`, err);\n        }\n      }\n    } catch (err) {\n      return false;\n    }\n\n    return true;\n  }\n}\n\n// this s hooked in, we don't use all the data, so lets stop eslint complaining\n// eslint-disable-next-line no-unused-vars\nHooks.on(\"renderSettingsConfig\", (app, html, user) => {\n  DirectoryPicker.processHtml(html);\n});\n","const logger = {\n  _showMessage: (logLevel, data) => {\n    if (!logLevel || !data || typeof (logLevel) !== 'string') {\n      return false;\n    }\n\n    const setting = game.settings.get(\"ddb-importer\", \"log-level\");\n    const logLevels = [\"DEBUG\", \"INFO\", \"WARN\", \"ERR\", \"OFF\"];\n    const logLevelIndex = logLevels.indexOf(logLevel.toUpperCase());\n    if (setting == \"OFF\" ||\n            logLevelIndex === -1 ||\n            logLevelIndex < logLevels.indexOf(setting)) {\n      return false;\n    }\n    return true;\n  },\n  log: (logLevel, ...data) => {\n    if (!logger._showMessage) {\n      return;\n    }\n\n    logLevel = logLevel.toUpperCase();\n\n    const LOG_PREFIX = \"DDB Importer\";\n    let msg = \"No logging message provided.  Please see the payload for more information.\";\n    let payload = data.slice();\n    if (data[0] && typeof (data[0] == 'string')) {\n      msg = data[0];\n      if (data.length > 1) {\n        payload = data.slice(1);\n      } else {\n        payload = null;\n      }\n    }\n    msg = `${LOG_PREFIX} | ${logLevel} > ${msg}`;\n    switch (logLevel) {\n      case \"DEBUG\":\n        if (payload) {\n          console.debug(msg, ...payload);// eslint-disable-line no-console\n        } else {\n          console.debug(msg);// eslint-disable-line no-console\n        }\n        break;\n      case \"INFO\":\n        if (payload) {\n          console.info(msg, ...payload);// eslint-disable-line no-console\n        } else {\n          console.info(msg);// eslint-disable-line no-console\n        }\n        break;\n      case \"WARN\":\n        if (payload) {\n          console.warn(msg, ...payload);// eslint-disable-line no-console\n        } else {\n          console.warn(msg);// eslint-disable-line no-console\n        }\n        break;\n      case \"ERR\":\n        if (payload) {\n          console.error(msg, ...payload);// eslint-disable-line no-console\n        } else {\n          console.error(msg);// eslint-disable-line no-console\n        }\n        break;\n      default: break;\n    }\n  },\n\n  debug: (...data) => {\n    logger.log(\"DEBUG\", ...data);\n  },\n\n  info: (...data) => {\n    logger.log(\"INFO\", ...data);\n  },\n\n  warn: (...data) => {\n    logger.log(\"WARN\", ...data);\n  },\n\n  error: (...data) => {\n    logger.log(\"ERR\", ...data);\n  },\n\n};\nexport default logger;\n","import utils from \"../utils.js\";\nimport logger from \"../logger.js\";\nimport DICTIONARY from \"../dictionary.js\";\nimport { getCompendium, getCompendiumLabel } from \"./utils.js\";\nimport { DDB_CONFIG } from \"../ddbConfig.js\";\n\nvar compendiumFolderTypeMonster;\nvar compendiumFolderTypeSpell;\nvar compendiumFolderTypeItem;\n\nvar rootItemFolders = {};\nvar equipmentFolders = {};\nvar weaponFolders = {};\nvar trinketFolders = {};\nvar consumableFolders = {};\nvar lootFolders = {};\nvar backpackFolders = {};\n\nconst spellLevelFolderNames = [\n  \"0th Level (Cantrip)\",\n  \"1st Level\",\n  \"2nd Level\",\n  \"3rd Level\",\n  \"4th Level\",\n  \"5th Level\",\n  \"6th Level\",\n  \"7th Level\",\n  \"8th Level\",\n  \"9th Level\",\n];\n\nconst itemRarityNames = [\n  \"Common\",\n  \"Uncommon\",\n  \"Rare\",\n  \"Very Rare\",\n  \"Legendary\",\n  \"Artifact\",\n  \"Varies\",\n  \"Unknown\",\n];\n\nconst rootItemFolderNames = {\n  equipment: \"Equipment\",\n  tool: \"Tools\",\n  loot: \"Loot\",\n  weapon: \"Weapon\",\n  backpack: \"Backpack\",\n  consumable: \"Consumable\",\n};\n\nconst equipmentFolderNames = {\n  heavy: \"Heavy Armor\",\n  medium: \"Medium Armor\",\n  light: \"Light Armor\",\n  trinket: \"Trinket\",\n  shield: \"Shield\",\n};\nconst weaponFolderNames = {\n  simpleM: \"Simple Melee\",\n  simpleR: \"Simple Ranged\",\n  martialM: \"Martial Melee\",\n  martialR: \"Martial Ranged\",\n};\nconst trinketFolderNames = [\"Wand\", \"Wondrous item\", \"Ring\", \"Rod\"];\nconst consumableFolderNames = [\"Ammunition\", \"Potion\", \"Scroll\", \"Poison\", \"Adventuring Gear\"];\nconst lootFolderNames = [\n  \"Adventuring Gear\",\n  \"Vehicle\",\n  \"Gemstone\",\n  \"Mount\",\n  \"Arcane Focus\",\n  \"Holy Symbol\",\n  \"Druidic Focus\",\n];\nconst backpackFolderNames = [\"Equipment Pack\", \"Adventuring Gear\"];\n\nasync function createCompendiumFolder(packName, folderName, color = \"#6f0006\") {\n  const existingFolder = game.customFolders.fic.folders.find((f) => f.packCode === packName && f.name == folderName);\n  return new Promise((resolve) => {\n    if (!existingFolder) {\n      logger.info(`Creating compendium folder ${folderName}`);\n      // createFolderAtRoot(packCode,name,color,fontColor)\n      resolve(game.CF.FICFolderAPI.createFolderAtRoot(packName, folderName, color));\n    } else {\n      resolve(existingFolder);\n    }\n  });\n}\n\nasync function createCompendiumFolderWithParent(packName, folderName, parentFolder, color = \"#6f0006\") {\n  const existingFolder = game.customFolders.fic.folders.find(\n    (f) => f.packCode === packName && f.name == folderName && f.parentId == parentFolder.id\n  );\n  return new Promise((resolve) => {\n    if (!existingFolder) {\n      logger.info(`Creating compendium folder ${folderName} in ${parentFolder.name}`);\n      resolve(game.CF.FICFolderAPI.createFolderWithParent(parentFolder, folderName, color));\n    } else {\n      resolve(existingFolder);\n    }\n  });\n}\n\n// assume type is monster compendium\nasync function createCreatureTypeCompendiumFolders(packName) {\n  return new Promise((resolve) => {\n    let promises = [];\n    DDB_CONFIG.monsterTypes.forEach(async (monsterType) => {\n      const folder = await createCompendiumFolder(packName, monsterType.name, \"#6f0006\");\n      promises.push(folder);\n    });\n    resolve(promises);\n  });\n}\n\n// challenge rating\nasync function createChallengeRatingCompendiumFolders(packName) {\n  return new Promise((resolve) => {\n    let promises = [];\n    DDB_CONFIG.challengeRatings.forEach(async (cr) => {\n      const paddedCR = String(cr.value).padStart(2, \"0\");\n      const folder = await createCompendiumFolder(packName, `CR ${paddedCR}`, \"#6f0006\");\n      promises.push(folder);\n    });\n    resolve(promises);\n  });\n}\n\n// alphabetical\nasync function createAlphabeticalCompendiumFolders(packName) {\n  return new Promise((resolve) => {\n    let promises = [];\n    for (let i = 9; ++i < 36;) {\n      const folderName = i.toString(36).toUpperCase();\n      // eslint-disable-next-line no-await-in-loop\n      createCompendiumFolder(packName, folderName, \"#6f0006\").then((folder) => {\n        promises.push(folder);\n      });\n    }\n    resolve(promises);\n  });\n}\n\n// spell level\nasync function createSpellLevelCompendiumFolders(packName) {\n  return new Promise((resolve) => {\n    let promises = [];\n    spellLevelFolderNames.forEach(async (levelName) => {\n      logger.info(`Creating folder '${levelName}'`);\n      const newFolder = await createCompendiumFolder(packName, levelName);\n      promises.push(newFolder);\n    });\n    resolve(promises);\n  });\n}\n\n// spell school\nasync function createSpellSchoolCompendiumFolders(packName) {\n  return new Promise((resolve) => {\n    let promises = [];\n    DICTIONARY.spell.schools.forEach(async (school) => {\n      const schoolName = utils.capitalize(school.name);\n      logger.info(`Creating folder '${schoolName}'`);\n      const newFolder = await createCompendiumFolder(packName, schoolName);\n      promises.push(newFolder);\n    });\n    resolve(promises);\n  });\n}\n\n// item rarity folder\nasync function createItemRarityCompendiumFolders(packName) {\n  return new Promise((resolve) => {\n    let promises = [];\n    itemRarityNames.forEach(async (rarityName) => {\n      logger.info(`Creating folder '${rarityName}'`);\n      const newFolder = await createCompendiumFolder(packName, rarityName);\n      promises.push(newFolder);\n    });\n    resolve(promises);\n  });\n}\n\n// item type folder\nasync function createItemTypeCompendiumFolders(packName) {\n  let promises = [];\n\n  for (const [key, value] of Object.entries(rootItemFolderNames)) {\n    logger.info(`Creating root folder '${value}' with key '${key}'`);\n    // eslint-disable-next-line no-await-in-loop\n    const folder = await createCompendiumFolder(packName, value);\n    rootItemFolders[key] = folder;\n    promises.push(folder);\n  }\n\n  for (const [key, value] of Object.entries(equipmentFolderNames)) {\n    logger.info(`Creating Equipment folder '${value}' with key '${key}'`);\n    // eslint-disable-next-line no-await-in-loop\n    const folder = await createCompendiumFolderWithParent(packName, value, rootItemFolders[\"equipment\"], \"#222222\");\n    equipmentFolders[key] = folder;\n    promises.push(folder);\n  }\n\n  for (const [key, value] of Object.entries(weaponFolderNames)) {\n    logger.info(`Creating Weapon folder '${value}' with key '${key}'`);\n    // eslint-disable-next-line no-await-in-loop\n    const folder = await createCompendiumFolderWithParent(packName, value, rootItemFolders[\"weapon\"], \"#222222\");\n    weaponFolders[key] = folder;\n    promises.push(folder);\n  }\n\n  trinketFolderNames.forEach((folderName) => {\n    logger.info(`Creating Equipment\\\\Trinket folder '${folderName}'`);\n    createCompendiumFolderWithParent(packName, folderName, equipmentFolders[\"trinket\"], \"#444444\").then((folder) => {\n      trinketFolders[folderName] = folder;\n      promises.push(folder);\n    });\n  });\n\n  consumableFolderNames.forEach((folderName) => {\n    logger.info(`Creating Consumable folder '${folderName}'`);\n    createCompendiumFolderWithParent(packName, folderName, rootItemFolders[\"consumable\"], \"#222222\").then((folder) => {\n      consumableFolders[folderName] = folder;\n      promises.push(folder);\n    });\n  });\n\n  lootFolderNames.forEach((folderName) => {\n    logger.info(`Creating Loot folder '${folderName}'`);\n    createCompendiumFolderWithParent(packName, folderName, rootItemFolders[\"loot\"], \"#222222\").then((folder) => {\n      lootFolders[folderName] = folder;\n      promises.push(folder);\n    });\n  });\n\n  backpackFolderNames.forEach((folderName) => {\n    logger.info(`Creating Backpack folder '${folderName}'`);\n    createCompendiumFolderWithParent(packName, folderName, rootItemFolders[\"backpack\"], \"#222222\").then((folder) => {\n      backpackFolders[folderName] = folder;\n      promises.push(folder);\n    });\n  });\n\n  return new Promise((resolve) => {\n    resolve(promises);\n  });\n}\n\n// create compendium folder structure\nexport async function createCompendiumFolderStructure(type) {\n  const compendiumFoldersInstalled = utils.isModuleInstalledAndActive(\"compendium-folders\");\n\n  if (compendiumFoldersInstalled) {\n    compendiumFolderTypeMonster = game.settings.get(\"ddb-importer\", \"munching-selection-compendium-folders-monster\");\n    compendiumFolderTypeSpell = game.settings.get(\"ddb-importer\", \"munching-selection-compendium-folders-spell\");\n    compendiumFolderTypeItem = game.settings.get(\"ddb-importer\", \"munching-selection-compendium-folders-item\");\n    // generate compendium folders for type\n    const packName = await getCompendiumLabel(type);\n    await game.CF.FICFolderAPI.loadFolders(packName);\n    logger.debug(`Creating Compendium folder structure for ${type}`);\n\n    switch (type) {\n      case \"monsters\":\n      case \"npc\":\n      case \"monster\": {\n        switch (compendiumFolderTypeMonster) {\n          case \"TYPE\": {\n            await createCreatureTypeCompendiumFolders(packName);\n            break;\n          }\n          case \"ALPHA\": {\n            await createAlphabeticalCompendiumFolders(packName);\n            break;\n          }\n          case \"CR\": {\n            await createChallengeRatingCompendiumFolders(packName);\n            break;\n          }\n          // no default\n        }\n        break;\n      }\n      case \"spell\":\n      case \"spells\": {\n        switch (compendiumFolderTypeSpell) {\n          case \"SCHOOL\":\n            await createSpellSchoolCompendiumFolders(packName);\n            break;\n          case \"LEVEL\":\n            await createSpellLevelCompendiumFolders(packName);\n            break;\n          // no default\n        }\n        break;\n      }\n      case \"inventory\":\n      case \"item\":\n      case \"items\": {\n        rootItemFolders = {};\n        equipmentFolders = {};\n        weaponFolders = {};\n        trinketFolders = {};\n        consumableFolders = {};\n        lootFolders = {};\n        backpackFolders = {};\n        switch (compendiumFolderTypeItem) {\n          case \"TYPE\":\n            await createItemTypeCompendiumFolders(packName);\n            break;\n          case \"RARITY\":\n            await createItemRarityCompendiumFolders(packName);\n            break;\n          // no default\n        }\n        break;\n      }\n      // no default\n    }\n    // reload folders\n    return game.CF.FICFolderAPI.loadFolders(packName);\n  }\n\n  return undefined;\n}\n\nfunction getItemCompendiumFolderNameForRarity(document) {\n  let name;\n  const rarity = document.data.data.rarity;\n\n  if (rarity && rarity != \"\") {\n    switch (rarity.toLowerCase().trim()) {\n      case \"common\":\n        name = \"Common\";\n        break;\n      case \"uncommon\":\n        name = \"Uncommon\";\n        break;\n      case \"rare\":\n        name = \"Rare\";\n        break;\n      case \"very rare\":\n      case \"veryrare\":\n        name = \"Very Rare\";\n        break;\n      case \"legendary\":\n        name = \"Legendary\";\n        break;\n      case \"artifact\":\n        name = \"Artifact\";\n        break;\n      case \"varies\":\n        name = \"Varies\";\n        break;\n      case \"unknown\":\n      default:\n        name = \"Unknown\";\n        break;\n    }\n  } else {\n    name = \"Unknown\";\n  }\n  return name;\n}\n\nfunction getItemCompendiumFolderNameForType(document) {\n  let name;\n\n  switch (document.data.type) {\n    case \"equipment\": {\n      switch (document.data.data?.armor?.type) {\n        case \"trinket\": {\n          const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;\n          if (ddbType) {\n            name = trinketFolders[ddbType].name;\n          }\n          break;\n        }\n        default: {\n          name = equipmentFolders[document.data.data.armor.type].name;\n          break;\n        }\n      }\n      break;\n    }\n    case \"weapon\": {\n      name = weaponFolders[document.data.data.weaponType].name;\n      break;\n    }\n    case \"consumable\": {\n      const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;\n      if (ddbType) {\n        name = consumableFolders[ddbType].name;\n      }\n      break;\n    }\n    case \"loot\": {\n      const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;\n      if (ddbType) {\n        name = lootFolders[ddbType].name;\n      }\n      break;\n    }\n    case \"backpack\": {\n      const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;\n      if (ddbType) {\n        name = backpackFolders[ddbType].name;\n      }\n      break;\n    }\n    default: {\n      name = rootItemFolders[document.data.type].name;\n      break;\n    }\n  }\n\n  return name;\n}\n\nfunction getItemCompendiumFolderName(document) {\n  let name;\n  switch (compendiumFolderTypeItem) {\n    case \"RARITY\": {\n      name = getItemCompendiumFolderNameForRarity(document);\n      break;\n    }\n    case \"TYPE\": {\n      name = getItemCompendiumFolderNameForType(document);\n      break;\n    }\n    // no default\n  }\n  return name;\n}\n\nfunction getCompendiumFolderName(type, document) {\n  let name;\n  switch (type) {\n    case \"monsters\":\n    case \"npc\":\n    case \"monster\": {\n      switch (compendiumFolderTypeMonster) {\n        case \"TYPE\": {\n          const creatureType = document.data.data?.details?.type?.value\n            ? document.data.data?.details?.type?.value\n            : \"Unknown\";\n          const ddbType = DDB_CONFIG.monsterTypes.find((c) => creatureType.toLowerCase() == c.name.toLowerCase());\n          if (ddbType) name = ddbType.name;\n          break;\n        }\n        case \"ALPHA\": {\n          name = document.name\n            .replace(/[^a-z]/gi, \"\")\n            .charAt(0)\n            .toUpperCase();\n          break;\n        }\n        case \"CR\": {\n          if (document.data.data.details.cr !== undefined || document.data.data.details.cr !== \"\") {\n            const paddedCR = String(document.data.data.details.cr).padStart(2, \"0\");\n            name = `CR ${paddedCR}`;\n          }\n        }\n        // no default\n      }\n      break;\n    }\n    case \"spell\":\n    case \"spells\": {\n      switch (compendiumFolderTypeSpell) {\n        case \"SCHOOL\": {\n          const school = document.data.data?.school;\n          if (school) {\n            name = utils.capitalize(DICTIONARY.spell.schools.find((sch) => school == sch.id).name);\n          }\n          break;\n        }\n        case \"LEVEL\": {\n          const levelFolder = spellLevelFolderNames[document.data.data?.level];\n          if (levelFolder) {\n            name = levelFolder;\n          }\n          break;\n        }\n        // no default\n      }\n      break;\n    }\n    case \"inventory\":\n    case \"item\":\n    case \"items\": {\n      name = getItemCompendiumFolderName(document);\n    }\n    // no default\n  }\n  return name;\n}\n\n// function addItemToCompendiumFolder(packName, document, folders) {\n//   const folderName = getCompendiumFolderName(\"item\", document);\n//   if (folderName) {\n//     switch (compendiumFolderTypeItems) {\n//       case \"TYPE\": {\n//         switch (document.data.type) {\n//           case \"equipment\": {\n//             switch (document.data.data?.armor?.type) {\n//               case \"trinket\": {\n//                 const folder = trinketFolders[document.data.flags?.ddbimporter?.dndbeyond?.type];\n//                 const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;\n//                 if (ddbType) {\n//                   name = trinketFolders[ddbType].name;\n//                   logger.info(`Moving ${type} ${document.name} to folder ${folder.name}`);\n//                   await game.CF.FICFolderAPI.moveDocumentToFolder(packName, document, folder);\n//                 }\n//                 break;\n//               }\n//               default: {\n//                 name = equipmentFolders[document.data.armor.type].name;\n//                 break;\n//               }\n//             }\n//             break;\n//           }\n//           case \"weapon\": {\n//             name = weaponFolders[document.data.weaponType].name;\n//             break;\n//           }\n//           case \"consumable\": {\n//             const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;\n//             if (ddbType) {\n//               name = consumableFolders[ddbType].name;\n//             }\n//             break;\n//           }\n//           case \"loot\": {\n//             const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;\n//             if (ddbType) {\n//               name = lootFolders[ddbType].name;\n//             }\n//             break;\n//           }\n//           case \"backpack\": {\n//             const ddbType = document.data.flags?.ddbimporter?.dndbeyond?.type;\n//             if (ddbType) {\n//               name = backpackFolders[ddbType].name;\n//             }\n//             break;\n//           }\n//           default: {\n//             name = rootItemFolders[document.data.type].name;\n//             break;\n//           }\n//         }\n//         break;\n//       }\n//       // no default\n//     }\n//   } else {\n//     logger.error(`Unable to find folder \"${folderName}\" in \"${packName}\" for Item`);\n//   }\n// }\n\nexport async function addToCompendiumFolder(type, document, folders) {\n  const compendiumFoldersInstalled = utils.isModuleInstalledAndActive(\"compendium-folders\");\n\n  if (compendiumFoldersInstalled && (folders || game.customFolders?.fic?.folders)) {\n    if (!folders) folders = game.customFolders.fic.folders;\n    const packName = await getCompendiumLabel(type);\n    logger.debug(`Checking ${document.name} in ${packName}`);\n\n    switch (type) {\n      case \"inventory\":\n      case \"items\":\n      case \"item\":\n      case \"spells\":\n      case \"spell\":\n      case \"monsters\":\n      case \"npc\":\n      case \"monster\": {\n        const folderName = getCompendiumFolderName(type, document);\n        if (folderName) {\n          const folder = folders.find((f) => f.packCode === packName && f.name == folderName);\n          if (document?.data?.flags?.cf?.id) setProperty(document, \"data.flags.cf.id\", undefined);\n          if (folder) {\n            logger.info(`Moving ${type} ${document.name} to folder ${folder.name}`);\n            await game.CF.FICFolderAPI.moveDocumentToFolder(packName, document, folder);\n          } else {\n            logger.error(`Unable to find folder \"${folderName}\" in \"${packName}\" for ${type}`);\n          }\n        }\n      }\n      // no default\n    }\n  }\n}\n\n// create compendium folders for existing things\nexport async function migrateExistingCompendium(type) {\n  const compendiumFoldersInstalled = utils.isModuleInstalledAndActive(\"compendium-folders\");\n\n  if (!compendiumFoldersInstalled) {\n    logger.warn(\"Compendium Folders module is not installed\");\n    return new Promise((resolve) => {\n      resolve(false);\n    });\n  }\n  // loop through all existing monts/etc and generate a folder and move documents to it\n  const packName = await getCompendiumLabel(type);\n\n  if (game.CF.cleanupCompendium) {\n    await game.CF.cleanupCompendium(packName);\n  }\n\n  const folders = await createCompendiumFolderStructure(type);\n\n  logger.debug(\"Compendium Folders\", folders);\n\n  const compendium = await getCompendium(packName);\n  if (!compendium) return undefined;\n  let indexFields = [\"name\"];\n  switch (type) {\n    case \"spells\":\n    case \"spell\": {\n      indexFields = [\"name\", \"flags.cf\", \"data.level\"];\n      break;\n    }\n    case \"inventory\":\n    case \"items\":\n    case \"item\": {\n      indexFields = [\n        \"name\",\n        \"type\",\n        \"flags.cf\",\n        \"flags.ddbimporter.dndbeyond.type\",\n        \"data.armor.type\",\n        \"data.weaponType\",\n        \"data.rarity\"\n      ];\n      break;\n    }\n    // no default\n  }\n\n  const index = await compendium.getIndex({ fields: indexFields });\n\n  switch (type) {\n    case \"inventory\":\n    case \"items\":\n    case \"item\":\n    case \"spells\":\n    case \"spell\":\n    case \"monsters\":\n    case \"npc\":\n    case \"monster\": {\n      // loop through all existing monsters and move them to their type\n      await index\n        .filter((i) => i.name !== game.CF.TEMP_ENTITY_NAME)\n        .forEach(async (i) => {\n          const existing = await compendium.getDocument(i._id);\n          await addToCompendiumFolder(type, existing, folders);\n        });\n      break;\n    }\n    // no default\n  }\n\n  const newFolders = await game.CF.FICFolderAPI.loadFolders(packName);\n\n  return new Promise((resolve) => {\n    resolve(newFolders);\n  });\n}\n","// Modified from https://gitlab.com/tposney/dae/-/blob/master/src/module/migration.ts\n\n// MIT License\n\n// Copyright (c) 2020 Tim Posney\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nimport logger from \"../logger.js\";\nimport { updateCharacterItemFlags } from \"./import.js\";\n\nvar packsLoaded = false;\nvar itemPack;\nvar spellPack;\nvar featsPack;\nvar midiPack;\nvar magicItemsPack;\nvar midiItemsPack;\nvar midiSpellsPack;\nvar midiFeatsPack;\n\n\nexport async function loadPacks() {\n  if (packsLoaded) return;\n  const items = game.packs.get(\"Dynamic-Effects-SRD.DAE SRD Items\");\n  itemPack = items ? await items.getDocuments() : [];\n\n  const spells = game.packs.get(\"Dynamic-Effects-SRD.DAE SRD Spells\");\n  spellPack = spells ? await spells.getDocuments() : [];\n\n  const magicItems = game.packs.get(\"Dynamic-Effects-SRD.DAE SRD Magic Items\");\n  magicItemsPack = magicItems ? await magicItems.getDocuments() : [];\n\n  const feats = game.packs.get(\"Dynamic-Effects-SRD.DAE SRD Feats\");\n  featsPack = feats ? await feats.getDocuments() : [];\n\n  const srdMidi = game.packs.get(\"Dynamic-Effects-SRD.DAE SRD Midi-collection\");\n  midiPack = srdMidi ? await srdMidi.getDocuments() : [];\n\n  const midiItems = game.packs.get(\"midi-srd.Midi SRD Items\");\n  midiItemsPack = midiItems ? await midiItems.getDocuments() : [];\n  const midiSpells = game.packs.get(\"midi-srd.Midi SRD Spells\");\n  midiSpellsPack = midiSpells ? await midiSpells.getDocuments() : [];\n  const midiFeats = game.packs.get(\"midi-srd.Midi SRD Feats\");\n  midiFeatsPack = midiFeats ? await midiFeats.getDocuments() : [];\n\n  // eslint-disable-next-line require-atomic-updates\n  packsLoaded = true;\n}\n\nfunction findDAEItem(itemData, packs) {\n  for (let pack of packs) {\n    let matchItem = pack.find((pd) =>\n      pd.name === itemData.name &&\n      pd.type === itemData.type\n    );\n    // console.warn(itemData.name);\n    // console.warn(matchItem);\n    if (matchItem) return matchItem;\n  }\n  return undefined;\n}\n\nfunction dataSwap(itemData, replaceData) {\n  updateCharacterItemFlags(itemData, replaceData);\n  if (itemData._id) replaceData._id = itemData._id;\n  if (itemData.flags) replaceData.flags = { ...itemData.flags, ...replaceData.flags };\n  return replaceData;\n}\n\nfunction matchItem(itemData) {\n  // we only add the midi packs if midi is actually installed\n  let returnItem = null;\n  switch (itemData.type) {\n    case \"feat\": {\n      const featPacks = [midiFeatsPack, midiPack, featsPack];\n      returnItem = findDAEItem(itemData, featPacks);\n      break;\n    }\n    case \"spell\": {\n      const spellPacks = [midiSpellsPack, midiPack, spellPack];\n      returnItem = findDAEItem(itemData, spellPacks);\n      break;\n    }\n    case \"equipment\":\n    case \"weapon\":\n    case \"loot\":\n    case \"consumable\":\n    case \"tool\":\n    case \"backpack\": {\n      const equipmentPacks = [midiItemsPack, midiPack, itemPack, magicItemsPack];\n      returnItem = findDAEItem(itemData, equipmentPacks);\n      break;\n    }\n    default:\n      break;\n  }\n  return returnItem;\n}\n\n\n/**\n * Migrates items wholesale\n * @param {*} items\n */\nexport async function migrateItemsDAESRD(items) {\n  if (!packsLoaded) await loadPacks();\n\n  return new Promise((resolve) => {\n    resolve(\n      items.map((itemData) => {\n        let replaceData = matchItem(itemData);\n        if (replaceData) {\n          logger.debug(`migrating ${replaceData.data.name}`);\n          setProperty(replaceData.data.flags, \"dae.migrated\", true);\n          return dataSwap(itemData, replaceData.data);\n        }\n        return itemData;\n      })\n    );\n  });\n}\n\n/**\n * Adds dae effects to existing items\n * @param {*} items\n */\nexport async function addItemsDAESRD(items) {\n  // eslint-disable-next-line require-atomic-updates\n  if (!packsLoaded) await loadPacks();\n\n  return new Promise((resolve) => {\n    resolve(\n      items.map((itemData) => {\n        let replaceData = matchItem(itemData);\n        if (replaceData && !replaceData.name.startsWith(\"Unarmored Defense\")) {\n          replaceData = replaceData.data.toObject();\n          logger.debug(`Adding effects for ${replaceData.name}`);\n          itemData.effects = replaceData.effects;\n          if (replaceData.flags.dae) itemData.flags.dae = replaceData.flags.dae;\n          if (replaceData.flags['midi-qol']) itemData.flags['midi-qol'] = replaceData.flags['midi-qol'];\n          if (replaceData.flags.itemacro) itemData.flags.itemacro = replaceData.flags.itemacro;\n          if (replaceData.flags.itemmacro) itemData.flags.itemmacro = replaceData.flags.itemmacro;\n        }\n        return itemData;\n      })\n    );\n  });\n}\n\n/**\n * Replaces matching items in an actor\n * @param {*} actor\n */\nexport async function migrateActorDAESRD(actor, includeSRD = false) {\n  await DAE.migrateActorDAESRD(actor, includeSRD);\n}\n","import utils from \"../utils.js\";\nimport logger from \"../logger.js\";\nimport DICTIONARY from \"../dictionary.js\";\nimport { munchNote, getCompendiumLabel, getCompendiumType, getCompendium } from \"./utils.js\";\nimport { addItemsDAESRD } from \"./dae.js\";\nimport { copyInbuiltIcons } from \"../icons/index.js\";\nimport { addToCompendiumFolder } from \"./compendiumFolders.js\";\n\nconst srdCompendiumLookup = [\n  { type: \"inventory\", name: \"dnd5e.items\" },\n  { type: \"spells\", name: \"dnd5e.spells\" },\n  { type: \"features\", name: \"dnd5e.classfeatures\" },\n  { type: \"races\", name: \"dnd5e.races\" },\n  { type: \"traits\", name: \"dnd5e.races\" },\n  { type: \"features\", name: \"dnd5e.classfeatures\" },\n  { type: \"feat\", name: \"dnd5e.classfeatures\" },\n  { type: \"feats\", name: \"dnd5e.classfeatures\" },\n  { type: \"classes\", name: \"dnd5e.classfeatures\" },\n  { type: \"weapon\", name: \"dnd5e.items\" },\n  { type: \"consumable\", name: \"dnd5e.items\" },\n  { type: \"tool\", name: \"dnd5e.items\" },\n  { type: \"loot\", name: \"dnd5e.items\" },\n  { type: \"backpack\", name: \"dnd5e.items\" },\n  { type: \"spell\", name: \"dnd5e.spells\" },\n  { type: \"equipment\", name: \"dnd5e.items\" },\n  { type: \"monsters\", name: \"dnd5e.monsters\" },\n  { type: \"monsterfeatures\", name: \"dnd5e.monsterfeatures\" },\n];\n\nconst SUPPORTED_FLAG_GROUPS = [\n  \"dae\",\n  \"maestro\",\n  \"mess\",\n  \"favtab\",\n  \"midi-qol\",\n  \"itemacro\",\n  \"itemmacro\",\n  \"autoanimations\",\n  \"enhancedcombathud\",\n  \"cf\",\n  \"automated-evocations\",\n  \"inventory-plus\",\n  \"obsidian\",\n  \"siftoolkit\",\n];\n\nconst EFFECTS_IGNORE_FLAG_GROUPS = [\n  \"dae\",\n  \"midi-qol\",\n  \"itemacro\",\n  \"itemmacro\",\n];\n\nvar srdIconMapLoaded = false;\nvar srdIconMap = {};\nvar srdPacksLoaded = {};\nvar srdPacks = {};\n\nasync function loadSRDPacks(compendiumName) {\n  if (srdPacksLoaded[compendiumName]) return;\n  const srdPack = await getCompendium(compendiumName);\n  if (!srdPack) {\n    logger.error(`Failed to load SRDPack ${compendiumName}`);\n  } else {\n    srdPacks[compendiumName] = await srdPack.getDocuments().then((data) => data.map((i) => i.data));\n    // eslint-disable-next-line require-atomic-updates\n    srdPacksLoaded[compendiumName] = true;\n  }\n}\n\nconst gameFolderLookup = [\n  {\n    type: \"itemSpells\",\n    folder: \"magic-item-spells\",\n    itemType: \"spell\",\n  },\n  {\n    type: \"magicItems\",\n    folder: \"magic-items\",\n    itemType: \"item\",\n  },\n  {\n    type: \"spells\",\n    folder: \"spell\",\n    itemType: \"spell\",\n  },\n  {\n    type: \"monsters\",\n    folder: \"npc\",\n    itemType: \"actor\",\n  },\n];\n\n/**\n * Removes items\n * @param {*} items\n * @param {*} itemsToRemove\n */\nexport async function removeItems(items, itemsToRemove) {\n  return new Promise((resolve) => {\n    resolve(\n      items.filter(\n        (item) =>\n          !itemsToRemove.some((originalItem) => (\n            item.name === originalItem.name || item.flags?.ddbimporter?.originalName === originalItem.name) &&\n            item.type === originalItem.type)\n      )\n    );\n  });\n}\n\nconst getCharacterUpdatePolicyTypes = () => {\n  let itemTypes = [];\n  itemTypes.push(\"class\");\n  if (game.settings.get(\"ddb-importer\", \"character-update-policy-feat\")) itemTypes.push(\"feat\");\n  if (game.settings.get(\"ddb-importer\", \"character-update-policy-weapon\")) itemTypes.push(\"weapon\");\n  if (game.settings.get(\"ddb-importer\", \"character-update-policy-equipment\"))\n    itemTypes = itemTypes.concat(DICTIONARY.types.equipment);\n  if (game.settings.get(\"ddb-importer\", \"character-update-policy-spell\")) itemTypes.push(\"spell\");\n  return itemTypes;\n};\n\n/**\n * Returns a combined array of all items to process, filtered by the user's selection on what to skip and what to include\n * @param {object} result object containing all character items sectioned as individual properties\n * @param {array[string]} sections an array of object properties which should be filtered\n */\nexport const filterItemsByUserSelection = (result, sections) => {\n  let items = [];\n  const validItemTypes = getCharacterUpdatePolicyTypes();\n\n  for (const section of sections) {\n    items = items.concat(result[section]).filter((item) => validItemTypes.includes(item.type));\n  }\n  return items;\n};\n\nasync function copyFlagGroup(flagGroup, originalItem, targetItem) {\n  if (targetItem.flags === undefined) targetItem.flags = {};\n  // if we have generated effects we dont want to copy some flag groups. mostly for AE on spells\n  const effectsProperty = getProperty(targetItem, \"flags.ddbimporter.effectsApplied\") && EFFECTS_IGNORE_FLAG_GROUPS.includes(flagGroup);\n  if (originalItem.flags && !!originalItem.flags[flagGroup] && !effectsProperty) {\n    logger.debug(`Copying ${flagGroup} for ${originalItem.name}`);\n    targetItem.flags[flagGroup] = originalItem.flags[flagGroup];\n  }\n}\n\n/**\n * Copies across some flags for existing item\n * @param {*} items\n */\nexport async function copySupportedItemFlags(originalItem, item) {\n  SUPPORTED_FLAG_GROUPS.forEach((flagGroup) => {\n    copyFlagGroup(flagGroup, originalItem, item);\n  });\n}\n\nfunction getMonsterNames(name) {\n  let magicNames = [name, name.toLowerCase()];\n\n  // +2 sword\n  let frontPlus = name.match(/^(\\+\\d*)\\s*(.*)/);\n  if (frontPlus) {\n    magicNames.push(`${frontPlus[2].trim()}, ${frontPlus[1]}`.toLowerCase().trim());\n  }\n\n  // sword +2\n  let backPlus = name.match(/(.*)\\s*(\\+\\d*)$/);\n  if (backPlus) {\n    magicNames.push(`${backPlus[1].trim()}, ${backPlus[2]}`.toLowerCase().trim());\n  }\n\n  return magicNames;\n}\n\nfunction getLooseNames(name, extraNames = []) {\n  let looseNames = extraNames;\n  looseNames.push(name.toLowerCase());\n  let refactNameArray = name.split(\"(\")[0].trim().split(\", \");\n  refactNameArray.unshift(refactNameArray.pop());\n  const refactName = refactNameArray.join(\" \").trim();\n  looseNames.push(refactName, refactName.toLowerCase());\n  looseNames.push(refactName.replace(/\\+\\d*\\s*/, \"\").trim().toLowerCase());\n  looseNames.push(refactName.replace(/\\+\\d*\\s*/, \"\").trim().toLowerCase().replace(/s$/, \"\"));\n\n  let refactNamePlusArray = name.replace(/\\+\\d*\\s*/, \"\").trim().split(\"(\")[0].trim().split(\", \");\n  refactNamePlusArray.unshift(refactNamePlusArray.pop());\n  const refactNamePlus = refactNamePlusArray.join(\" \").trim();\n  looseNames.push(refactNamePlus.toLowerCase());\n\n  let deconNameArray = name.replace(\"(\", \"\").replace(\")\", \"\").trim().split(\",\");\n  deconNameArray.unshift(deconNameArray.pop());\n  const deconName = deconNameArray.join(\" \").trim();\n  looseNames.push(deconName, deconName.toLowerCase());\n\n  // word smart quotes are the worst\n  looseNames.push(name.replace(\"'\", \"\").toLowerCase());\n  looseNames.push(name.replace(\"\", \"'\").toLowerCase());\n  looseNames.push(name.replace(/s$/, \"\").toLowerCase()); // trim s, e.g. crossbow bolt(s)\n  looseNames.push(name.replace(\",\", \"\").toLowerCase()); // +1 weapons etc\n  looseNames.push(`${name} attack`.toLowerCase()); // Claw Attack\n  looseNames.push(name.split(\",\")[0].toLowerCase());\n\n  return looseNames;\n}\n\n// The monster setting is less vigorous!\nexport async function looseItemNameMatch(item, items, loose = false, monster = false, magicMatch = false) {\n  // first pass is a strict match\n  let matchingItem = items.find((matchItem) => {\n    let activationMatch = false;\n    const alternativeNames = matchItem.flags?.ddbimporter?.dndbeyond?.alternativeNames;\n    const extraNames = (alternativeNames) ? matchItem.flags.ddbimporter.dndbeyond.alternativeNames : [];\n\n    const itemActivationProperty = Object.prototype.hasOwnProperty.call(item.data, 'activation');\n    const matchItemActivationProperty = Object.prototype.hasOwnProperty.call(item.data, 'activation');\n\n    if (itemActivationProperty && item.data?.activation?.type == \"\") {\n      activationMatch = true;\n    } else if (matchItemActivationProperty && itemActivationProperty) {\n      // I can't remember why I added this. Maybe I was concerned about identical named items with\n      // different activation times?\n      // maybe I just want to check it exists?\n      // causing issues so changed.\n      // activationMatch = matchItem.data.activation.type === item.data.activation.type;\n      activationMatch = matchItemActivationProperty && itemActivationProperty;\n    } else if (!itemActivationProperty) {\n      activationMatch = true;\n    }\n\n    const nameMatch = item.name === matchItem.name || extraNames.includes(item.name);\n    const isMatch = nameMatch && item.type === matchItem.type && activationMatch;\n    return isMatch;\n  });\n\n  if (!matchingItem && monster) {\n    matchingItem = items.find(\n      (matchItem) => {\n        const monsterNames = getMonsterNames(matchItem.name);\n        const monsterMatch = (monsterNames.includes(item.name.toLowerCase())) &&\n          DICTIONARY.types.monster.includes(matchItem.type) &&\n          DICTIONARY.types.inventory.includes(item.type);\n        return monsterMatch;\n      });\n  }\n\n  if (!matchingItem && magicMatch) {\n    // is this an inverse match for updates?\n    // if so strip out the non-magic names, we want to match on the magic names\n    const magicName = item.name.replace(/(.*)\\s+(\\+\\d*)\\s*/, \"$1, $2\").trim().toLowerCase();\n    matchingItem = items.find(\n      (matchItem) => matchItem.name.trim().toLowerCase() == magicName\n    );\n  }\n\n  if (!matchingItem && loose) {\n    const looseNames = getLooseNames(item.name)\n      .filter((name) => {\n        if (!magicMatch) return true;\n        const removeMagicName = name.replace(/\\+\\d*\\s*/, \"\").trim();\n        if (name === removeMagicName) return false;\n        return true;\n      });\n    // lets go loosey goosey on matching equipment, we often get types wrong\n    matchingItem = items.find(\n      (matchItem) =>\n        (looseNames.includes(matchItem.name.toLowerCase()) || looseNames.includes(matchItem.name.toLowerCase().replace(\" armor\", \"\"))) &&\n        DICTIONARY.types.inventory.includes(item.type) &&\n        DICTIONARY.types.inventory.includes(matchItem.type)\n    );\n\n    // super loose name match!\n    if (!matchingItem) {\n      // still no matching item, lets do a final pass\n      matchingItem = items.find(\n        (matchItem) => looseNames.includes(matchItem.name.split(\"(\")[0].trim().toLowerCase())\n      );\n    }\n  }\n  return matchingItem;\n}\n\nfunction flagMatch(item1, item2, matchFlags) {\n  if (matchFlags.length === 0) return true;\n  let matched = false;\n  matchFlags.forEach((flag) => {\n    if (item1.flags.ddbimporter[flag] &&\n      item2.flags.ddbimporter[flag] &&\n      item1.flags.ddbimporter[flag] === item2.flags.ddbimporter[flag]\n    ) {\n      matched = true;\n    }\n  });\n\n  return matched;\n}\n\nasync function getFilteredItems(compendium, item, index, matchFlags) {\n  const indexEntries = index.filter((idx) => idx.name === item.name);\n\n  const mapped = await Promise.all(indexEntries.map((idx) => {\n    const entry = compendium.getDocument(idx._id).then((doc) => doc);\n    return entry;\n  }));\n\n  const flagFiltered = mapped.filter((idx) => {\n    const nameMatch = idx.name === item.name;\n    const flagMatched = flagMatch(idx.data, item, matchFlags);\n    return nameMatch && flagMatched;\n  });\n\n  return flagFiltered;\n}\n\n// async function getFlaggedItems(compendium, items, index, matchFlags) {\n//   let results = [];\n//   items.forEach((item) => {\n//     const flagged = getFilteredItems(compendium, item, index, matchFlags);\n//     results.push(flagged);\n//   });\n//   return Promise.all(results);\n// }\n\nasync function updateCompendiumItems(compendium, compendiumItems, index, matchFlags) {\n  let promises = [];\n  compendiumItems.forEach(async (item) => {\n    const existingItems = await getFilteredItems(compendium, item, index, matchFlags);\n    // we have a match, update first match\n    if (existingItems.length >= 1) {\n      const existing = existingItems[0];\n      delete item._id;\n      munchNote(`Updating ${item.name}`);\n      // purge existing active effects on this item\n      if (existing.results) await existing.deleteEmbeddedDocuments(\"TableResult\", [], { deleteAll: true });\n      if (existing.effects) await existing.deleteEmbeddedDocuments(\"ActiveEffect\", [], { deleteAll: true });\n      if (existing.data.flags) await copySupportedItemFlags(existing.data, item);\n      promises.push(existing.update(item));\n    }\n  });\n  return Promise.all(promises);\n}\n\nexport async function updateMidiFlags() {\n  const compendium = game.packs.get(\"midi-srd.Midi SRD Spells\");\n  const index = await compendium.getIndex();\n  const docs = await compendium.getDocuments();\n  const spells = docs.map((s) => s.toObject()).filter((s) => s.type === \"spell\");\n  const filteredSpells = spells.map((s) => {\n    delete s.flags.dynamiceffects;\n    delete s.flags.core;\n    if (s.flags.itemacro && s.flags.itemacro.macro.data.command == \"\") delete s.flags.itemacro;\n    if (s.flags.itemacro) {\n      delete s.flags.itemacro.macro._data;\n      delete s.flags.itemacro.macro.data.author;\n    }\n    const effects = s.effects.map((e) => {\n      if (e.flags) {\n        let flags = { };\n        if (e.flags.dae && e.flags.dae.macroRepeat !== \"none\") setProperty(flags, \"dae.macroRepeat\", e.flags.dae.macroRepeat);\n        if (e.flags[\"midi-qol\"]) flags[\"midi-qol\"] = e.flags[\"midi-qol\"];\n        e.flags = flags;\n      }\n      return e;\n    });\n    s.effects = effects;\n\n    return s;\n  });\n\n  updateCompendiumItems(compendium, filteredSpells, index, []);\n\n}\n\n// window.updateMidiFlags = updateMidiFlags;\n\nasync function createCompendiumItems(type, compendium, compendiumItems, index, matchFlags) {\n  let promises = [];\n  // compendiumItems.forEach(async (item) => {\n  for (const item of compendiumItems) {\n    // eslint-disable-next-line no-await-in-loop\n    const existingItems = await getFilteredItems(compendium, item, index, matchFlags);\n    // we have a single match\n    if (existingItems.length === 0) {\n      let newItem;\n      switch (type) {\n        case \"table\":\n        case \"tables\": {\n          newItem = new RollTable(item);\n          break;\n        }\n        default: {\n          // eslint-disable-next-line no-await-in-loop\n          newItem = await Item.create(item, {\n            temporary: true,\n            displaySheet: false,\n          });\n        }\n      }\n      munchNote(`Creating ${item.name}`);\n      logger.debug(`Pushing ${item.name} to compendium`);\n      promises.push(compendium.importDocument(newItem));\n    }\n  };\n  return Promise.all(promises);\n}\n\nexport async function compendiumFolders(document, type) {\n  // using compendium folders?\n  const compendiumFolderAdd = game.settings.get(\"ddb-importer\", \"munching-policy-use-compendium-folders\");\n  const compendiumFoldersInstalled = utils.isModuleInstalledAndActive(\"compendium-folders\");\n  if (compendiumFolderAdd && compendiumFoldersInstalled) {\n    // we create the compendium folder before import\n    munchNote(`Adding ${document.name} to compendium folder`);\n    logger.debug(`Adding ${document.name} to compendium folder`);\n    await addToCompendiumFolder(type, document);\n  }\n}\n\nexport async function updateCompendium(type, input, updateExisting = false, matchFlags = []) {\n  logger.debug(`Getting compendium for update of ${type} documents (checking ${input[type].length} docs)`);\n  const compendium = await getCompendiumType(type);\n  compendium.configure({ locked: false });\n\n  if (game.user.isGM) {\n    const initialIndex = await compendium.getIndex();\n    // remove duplicate items based on name and type\n    const compendiumItems = [...new Map(input[type].map((item) => [item[\"name\"] + item[\"type\"], item])).values()];\n\n    let updateResults = [];\n    // update existing items\n    munchNote(`Creating and updating ${compendiumItems.length} new ${type} items in compendium...`, true);\n\n    if (updateExisting) {\n      updateResults = await updateCompendiumItems(compendium, compendiumItems, initialIndex, matchFlags);\n    }\n\n    // create new items\n    const createResults = await createCompendiumItems(type, compendium, compendiumItems, initialIndex, matchFlags);\n    munchNote(\"\", true);\n\n    // compendium folders\n    createResults.forEach(async (document) => {\n      await compendiumFolders(document, type);\n    });\n\n    const results = createResults.concat(updateResults);\n    return new Promise((resolve) => resolve(results));\n  }\n  return [];\n}\n\n\nexport async function getImagePath(imageUrl, type = \"ddb\", name = \"\", download = false, remoteImages = false) {\n  const frameDirectory = game.settings.get(\"ddb-importer\", \"frame-image-upload-directory\").replace(/^\\/|\\/$/g, \"\");\n  const otherDirectory = game.settings.get(\"ddb-importer\", \"other-image-upload-directory\").replace(/^\\/|\\/$/g, \"\");\n  const uploadDirectory = type === \"frame\" ? frameDirectory : otherDirectory;\n  const downloadImage = (download) ? download : game.settings.get(\"ddb-importer\", \"munching-policy-download-images\");\n  const remoteImage = (remoteImages) ? remoteImages : game.settings.get(\"ddb-importer\", \"munching-policy-remote-images\");\n\n  if (imageUrl && downloadImage) {\n    const ext = imageUrl.split(\".\").pop().split(/#|\\?|&/)[0];\n    if (!name) name = imageUrl.split(\"/\").pop();\n\n    // image upload\n    const filename = type + \"-\" + name.replace(/[^a-zA-Z0-9]/g, \"-\").replace(/-+/g, \"-\").trim();\n    const imageExists = await utils.fileExists(uploadDirectory, filename + \".\" + ext);\n\n    if (imageExists) {\n      // eslint-disable-next-line require-atomic-updates\n      const image = await utils.getFileUrl(uploadDirectory, filename + \".\" + ext);\n      return image.trim();\n    } else {\n      // eslint-disable-next-line require-atomic-updates\n      const image = await utils.uploadImage(imageUrl, uploadDirectory, filename);\n      // did upload succeed? if not fall back to remote image path\n      if (image) {\n        return image.trim();\n      } else {\n        return null;\n      }\n\n    }\n  } else if (imageUrl && remoteImage) {\n    try {\n      // logger.debug('Trying: ' + imageUrl.trim());\n      // await utils.serverFileExists(imageUrl.trim());\n      return imageUrl.trim();\n    } catch (ignored) {\n      return null;\n    }\n  }\n  return null;\n}\n\nasync function getSRDIconMatch(type) {\n  const compendiumName = srdCompendiumLookup.find((c) => c.type == type).name;\n  if (!srdPacksLoaded[compendiumName]) await loadSRDPacks(compendiumName);\n\n  const items = srdPacks[compendiumName].map((item) => {\n    let smallItem = {\n      name: item.name,\n      img: item.img,\n      type: item.type,\n      data: {},\n    };\n    if (item.data.activation) smallItem.data.activation = item.data.activation;\n    return smallItem;\n  });\n\n  return items;\n}\n\nexport async function getSRDIconLibrary() {\n  if (srdIconMapLoaded) return srdIconMap;\n  const compendiumFeatureItems = await getSRDIconMatch(\"features\");\n  const compendiumInventoryItems = await getSRDIconMatch(\"inventory\");\n  const compendiumSpellItems = await getSRDIconMatch(\"spells\");\n  const compendiumMonsterFeatures = await getSRDIconMatch(\"monsterfeatures\");\n\n  srdIconMap = compendiumInventoryItems.concat(\n    compendiumSpellItems,\n    compendiumFeatureItems,\n    compendiumMonsterFeatures,\n  );\n  return srdIconMap;\n}\n\nexport async function copySRDIcons(items, srdIconLibrary = null, nameMatchList = []) {\n  // eslint-disable-next-line require-atomic-updates\n  if (!srdIconLibrary) srdIconLibrary = await getSRDIconLibrary();\n\n  return new Promise((resolve) => {\n    const srdItems = items.map((item) => {\n      logger.debug(`Matching ${item.name}`);\n      const nameMatch = nameMatchList.find((m) => m.name === item.name);\n      if (nameMatch) {\n        item.img = nameMatch.img;\n      } else {\n        looseItemNameMatch(item, srdIconLibrary, true).then((match) => {\n          if (match) {\n            srdIconLibrary.push({ name: item.name, img: match.img });\n            item.img = match.img;\n          }\n        });\n      }\n      return item;\n\n    });\n    resolve(srdItems);\n  });\n}\n\nexport async function retainExistingIcons(items) {\n  return new Promise((resolve) => {\n    const newItems = items.map((item) => {\n      if (item.flags.ddbimporter?.ignoreIcon) {\n        logger.debug(`Retaining icon for ${item.name} to ${item.flags.ddbimporter.matchedImg}`);\n        item.img = item.flags.ddbimporter.matchedImg;\n      }\n      return item;\n    });\n    resolve(newItems);\n  });\n}\n\nasync function getDDBItemImages(items, download) {\n  munchNote(`Fetching DDB Item Images`);\n  const downloadImages = (download) ? true : game.settings.get(\"ddb-importer\", \"munching-policy-download-images\");\n  const remoteImages = game.settings.get(\"ddb-importer\", \"munching-policy-remote-images\");\n\n  const itemMap = items.map(async (item) => {\n    let itemImage = {\n      name: item.name,\n      type: item.type,\n      img: null,\n      large: null,\n    };\n\n    if (item.flags && item.flags.ddbimporter && item.flags.ddbimporter && item.flags.ddbimporter.dndbeyond) {\n      if (item.flags.ddbimporter.dndbeyond.avatarUrl) {\n        const avatarUrl = item.flags.ddbimporter.dndbeyond['avatarUrl'];\n        if (avatarUrl && avatarUrl != \"\") {\n          munchNote(`Downloading ${item.name} image`);\n          const smallImage = await getImagePath(avatarUrl, 'item', item.name, downloadImages, remoteImages);\n          logger.debug(`Final image ${smallImage}`);\n          itemImage.img = smallImage;\n        }\n      }\n      if (item.flags.ddbimporter.dndbeyond.largeAvatarUrl) {\n        const largeAvatarUrl = item.flags.ddbimporter.dndbeyond['largeAvatarUrl'];\n        if (largeAvatarUrl && largeAvatarUrl != \"\") {\n          const largeImage = await getImagePath(largeAvatarUrl, 'item-large', item.name, downloadImages, remoteImages);\n          itemImage.large = largeImage;\n          if (!itemImage.img) itemImage.img = largeImage;\n        }\n      }\n    }\n\n    munchNote(\"\");\n    return itemImage;\n  });\n\n  return Promise.all(itemMap);\n}\n\nasync function getDDBGenericItemImages(download) {\n  munchNote(`Fetching DDB Generic Item icons`);\n  const itemMap = DICTIONARY.items.map(async (item) => {\n    const img = await getImagePath(item.img, 'item', item.filterType, download);\n    let itemIcons = {\n      filterType: item.filterType,\n      img: img,\n    };\n    return itemIcons;\n  });\n\n  munchNote(\"\");\n  return Promise.all(itemMap);\n}\n\nasync function getDDBGenericLootImages(download) {\n  munchNote(`Fetching DDB Generic Loot icons`);\n  const itemMap = DICTIONARY.genericItemIcons.map(async (item) => {\n    const img = await getImagePath(item.img, 'equipment', item.name, download);\n    let itemIcons = {\n      name: item.name,\n      img: img,\n    };\n    return itemIcons;\n  });\n\n  munchNote(\"\");\n  return Promise.all(itemMap);\n}\n\nexport async function getDDBGenericItemIcons(items, download) {\n  const genericItems = await getDDBGenericItemImages(download);\n  const genericLoots = await getDDBGenericLootImages(download);\n\n  let updatedItems = items.map((item) => {\n    // logger.debug(item.name);\n    // logger.debug(item.flags.ddbimporter.dndbeyond.filterType);\n    const excludedItems = [\"spell\", \"feat\", \"class\"];\n    if (!excludedItems.includes(item.type) &&\n        item.flags &&\n        item.flags.ddbimporter &&\n        item.flags.ddbimporter.dndbeyond) {\n      let generic = null;\n      if (item.flags.ddbimporter.dndbeyond.filterType) {\n        generic = genericItems.find((i) => i.filterType === item.flags.ddbimporter.dndbeyond.filterType);\n      } else if (item.flags.ddbimporter.dndbeyond.type) {\n        generic = genericLoots.find((i) => i.name === item.flags.ddbimporter.dndbeyond.type);\n      }\n      if (generic && (!item.img || item.img == \"\" || item.img == \"icons/svg/mystery-man.svg\")) {\n        item.img = generic.img;\n      }\n    }\n    return item;\n  });\n  return Promise.all(updatedItems);\n}\n\nasync function getDDBSchoolSpellImages(download) {\n  munchNote(`Fetching spell school icons`);\n  const schoolMap = DICTIONARY.spell.schools.map(async (school) => {\n    const img = await getImagePath(school.img, 'spell', school.name, download);\n    let schoolIcons = {\n      name: school.name,\n      img: img,\n      id: school.id,\n    };\n    return schoolIcons;\n  });\n\n  munchNote(\"\");\n  return Promise.all(schoolMap);\n}\n\nexport async function getDDBSpellSchoolIcons(items, download) {\n  const schools = await getDDBSchoolSpellImages(download);\n\n  let updatedItems = items.map((item) => {\n    // logger.debug(item.name);\n    // logger.debug(item.flags.ddbimporter.dndbeyond);\n    if (item.type == \"spell\") {\n      const school = schools.find((school) => school.id === item.data.school);\n      if (school && (!item.img || item.img == \"\" || item.img == \"icons/svg/mystery-man.svg\")) {\n        item.img = school.img;\n      }\n    }\n    return item;\n  });\n  return Promise.all(updatedItems);\n}\n\nexport async function getDDBEquipmentIcons(items, download) {\n  const itemImages = await getDDBItemImages(items.filter((item) => DICTIONARY.types.inventory.includes(item.type)), download);\n\n  let updatedItems = items.map((item) => {\n    // logger.debug(item.name);\n    // logger.debug(item.flags.ddbimporter.dndbeyond);\n    if (DICTIONARY.types.inventory.includes(item.type)) {\n      if (!item.img || item.img == \"\" || item.img == \"icons/svg/mystery-man.svg\") {\n        const imageMatch = itemImages.find((m) => m.name == item.name && m.type == item.type);\n        if (imageMatch && imageMatch.img) {\n          item.img = imageMatch.img;\n        }\n        if (imageMatch && imageMatch.large) {\n          item.flags.ddbimporter.dndbeyond['pictureUrl'] = imageMatch.large;\n        }\n      }\n    }\n    return item;\n  });\n  return Promise.all(updatedItems);\n}\n\n\nexport async function updateMagicItemImages(items) {\n  const useSRDCompendiumIcons = game.settings.get(\"ddb-importer\", \"character-update-policy-use-srd-icons\");\n  const ddbSpellIcons = game.settings.get(\"ddb-importer\", \"character-update-policy-use-ddb-spell-icons\");\n  const inbuiltIcons = game.settings.get(\"ddb-importer\", \"character-update-policy-use-inbuilt-icons\");\n  const ddbItemIcons = game.settings.get(\"ddb-importer\", \"character-update-policy-use-ddb-item-icons\");\n\n  // if we still have items to add, add them\n  if (items.length > 0) {\n    if (ddbItemIcons) {\n      logger.debug(\"Magic items: adding equipment icons\");\n      items = await getDDBEquipmentIcons(items, true);\n    }\n\n    if (inbuiltIcons) {\n      logger.debug(\"Magic items: adding inbuilt icons\");\n      items = await copyInbuiltIcons(items);\n    }\n\n    if (useSRDCompendiumIcons) {\n      logger.debug(\"Magic items: adding srd compendium icons\");\n      items = await copySRDIcons(items);\n    }\n\n    if (ddbSpellIcons) {\n      logger.debug(\"Magic items: adding ddb spell school icons\");\n      items = await getDDBSpellSchoolIcons(items, true);\n    }\n  }\n  return items;\n}\n\n/**\n * Updates game folder items\n * @param {*} type\n */\nasync function updateFolderItems(type, input, update = true) {\n  if (type === \"itemSpells\") {\n    // eslint-disable-next-line require-atomic-updates\n    input[type] = await updateMagicItemImages(input[type]);\n  }\n\n  const folderLookup = gameFolderLookup.find((c) => c.type == type);\n  const itemFolderNames = [...new Set(input[type]\n    .filter((item) => item.flags?.ddbimporter?.dndbeyond?.lookupName)\n    .map((item) => item.flags.ddbimporter.dndbeyond.lookupName))];\n\n  const getSubFolders = async () => {\n    return Promise.all(\n      itemFolderNames.map((name) => {\n        return utils.getFolder(folderLookup.folder, name);\n      })\n    );\n  };\n\n  const subFolders = await getSubFolders();\n\n  const defaultItemsFolder = await utils.getFolder(folderLookup.folder);\n  const existingItems = await game.items.entities.filter((item) => {\n    const itemFolder = subFolders.find((folder) =>\n      item.data.flags?.ddbimporter?.dndbeyond?.lookupName &&\n      folder.name === item.data.flags.ddbimporter.dndbeyond.lookupName\n    );\n    return itemFolder && item.type === folderLookup.itemType && item.data.folder === itemFolder._id;\n  });\n\n  // update or create folder items\n  const updateItems = async () => {\n    return Promise.all(\n      input[type]\n        .filter((item) => existingItems.some((idx) => idx.name === item.name))\n        .map(async (item) => {\n          const existingItem = await existingItems.find((existing) => item.name === existing.name);\n          item._id = existingItem._id;\n          logger.info(`Updating ${type} ${item.name}`);\n          await copySupportedItemFlags(existingItem, item);\n          await Item.update(item);\n          return item;\n        })\n    );\n  };\n\n  const createItems = async () => {\n    return Promise.all(\n      input[type]\n        .filter((item) => !existingItems.some((idx) => idx.name === item.name))\n        .map(async (item) => {\n          if (!game.user.can(\"ITEM_CREATE\")) {\n            ui.notifications.warn(`Cannot create ${folderLookup.type} ${item.name} for ${type}`);\n          } else {\n            logger.info(`Creating ${type} ${item.name}`);\n            const itemsFolder = subFolders.find((folder) =>\n              item.flags?.ddbimporter?.dndbeyond?.lookupName &&\n              folder.name === item.flags.ddbimporter.dndbeyond.lookupName\n            );\n            item.folder = (itemsFolder) ? itemsFolder._id : defaultItemsFolder._id;\n            await Item.create(item);\n          }\n          return item;\n        })\n    );\n  };\n\n  if (update) await updateItems();\n  await createItems();\n\n  // lets generate our compendium info like id, pack and img for use\n  // by things like magicitems\n  const folderIds = [defaultItemsFolder._id, ...subFolders.map((f) => f._id)];\n  const items = Promise.all(\n    game.items.entities\n      .filter((item) => item.type === folderLookup.itemType && folderIds.includes(item.data.folder))\n      .map((result) => {\n        const subFolder = (result.data.flags.ddbimporter?.dndbeyond?.lookupName)\n          ? result.data.flags.ddbimporter.dndbeyond.lookupName\n          : null;\n        return {\n          magicItem: {\n            _id: result._id,\n            id: result._id,\n            pack: \"world\",\n            img: result.img,\n            name: result.name,\n            subFolder: subFolder,\n            flatDc: result.data.flags?.ddbimporter?.dndbeyond?.overrideDC,\n            dc: result.data.flags?.ddbimporter?.dndbeyond?.dc,\n          },\n          _id: result._id,\n          name: result.name,\n          compendium: false,\n        };\n      })\n  );\n  return items;\n}\n\nexport function updateCharacterItemFlags(itemData, replaceData) {\n  if (itemData.flags?.ddbimporter?.importId) setProperty(replaceData, \"flags.ddbimporter.importId\", itemData.flags.ddbimporter.importId);\n  if (itemData.data.quantity) replaceData.data.quantity = itemData.data.quantity;\n  if (itemData.data.attuned) replaceData.data.attuned = itemData.data.attuned;\n  if (itemData.data.attunement) replaceData.data.attunement = itemData.data.attunement;\n  if (itemData.data.equipped) replaceData.data.equipped = itemData.data.equipped;\n  if (itemData.data.uses) replaceData.data.uses = itemData.data.uses;\n  if (itemData.data.resources) replaceData.data.resources = itemData.data.resources;\n  if (itemData.data.consume) replaceData.data.consume = itemData.data.consume;\n  if (itemData.data.preparation) replaceData.data.preparation = itemData.data.preparation;\n  if (itemData.data.proficient) replaceData.data.proficient = itemData.data.proficient;\n  if (itemData.data.ability) replaceData.data.ability = itemData.data.ability;\n  return replaceData;\n}\n\nasync function updateMatchingItems(oldItems, newItems, inOptions) {\n  let results = [];\n\n  const defaultOptions = {\n    looseMatch: false,\n    monster: false,\n    keepId: false,\n  };\n  const options = mergeObject(defaultOptions, inOptions);\n\n  for (let item of newItems) {\n    // logger.debug(`checking ${item.name}`);\n    const matched = await looseItemNameMatch(item, oldItems, options.looseMatch, options.monster); // eslint-disable-line no-await-in-loop\n\n    // logger.debug(`matched? ${JSON.stringify(matched)}`);\n    // console.log(matched);\n\n    if (matched) {\n      if (!item.flags.ddbimporter) {\n        item.flags.ddbimporter = matched.flags.ddbimporter;\n      } else if (matched.flags.ddbimporter && item.flags.ddbimporter) {\n        item.flags.ddbimporter = mergeObject(matched.flags.ddbimporter, item.flags.ddbimporter);\n      }\n      if (!item.flags.monsterMunch && matched.flags.monsterMunch) {\n        item.flags.monsterMunch = matched.flags.monsterMunch;\n      }\n      item.flags.ddbimporter[\"originalItemName\"] = matched.name;\n      item.flags.ddbimporter[\"replaced\"] = true;\n\n      item = updateCharacterItemFlags(matched, item);\n      // do we want to enrich the compendium item with our parsed flag data?\n      // item.flags = { ...matched.flags, ...item.flags };\n      if (!options.keepId) delete item[\"_id\"];\n      results.push(item);\n    }\n  }\n\n  return results;\n}\n\n/**\n *\n */\nexport async function loadPassedItemsFromCompendium(compendium, items, type, inOptions) {\n  if (!compendium) return [];\n  const defaultOptions = {\n    looseMatch: false,\n    monsterMatch: false,\n    keepId: false,\n    deleteCompendiumId: true,\n    indexFilter: {} // { fields: [\"name\", \"flags.ddbimporter.id\"] }\n  };\n  const options = mergeObject(defaultOptions, inOptions);\n\n  if (!compendium.indexed) await compendium.getIndex(options.indexFilter);\n  const index = compendium.index;\n  const firstPassItems = await index.filter((i) =>\n    items.some((orig) => {\n      const extraNames = (orig.flags?.ddbimporter?.dndbeyond?.alternativeNames)\n        ? orig.flags.ddbimporter.dndbeyond.alternativeNames\n        : [];\n      if (options.looseMatch) {\n        const looseNames = getLooseNames(orig.name, extraNames);\n        return looseNames.includes(i.name.split(\"(\")[0].trim().toLowerCase());\n      } else if (options.monsterMatch) {\n        const monsterNames = getMonsterNames(orig.name);\n        // console.log(magicNames)\n        if (i.name === orig.name) {\n          return true;\n        } else if (monsterNames.includes(i.name.toLowerCase())) {\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return i.name === orig.name || extraNames.includes(i.name);\n      }\n    })\n  );\n\n  let loadedItems = [];\n  for (const i of firstPassItems) {\n    // eslint-disable-next-line no-await-in-loop\n    let item = await compendium.getDocument(i._id).then((doc) => {\n      const docData = doc.toObject();\n      if (options.deleteCompendiumId) delete docData._id;\n      return docData;\n    });\n    setProperty(item, \"flags.ddbimporter.pack\", `${compendium.metadata.package}.${compendium.metadata.name}`);\n    loadedItems.push(item);\n  }\n  logger.debug(`compendium ${type} loaded items:`, loadedItems);\n\n  const matchingOptions = {\n    looseMatch: options.looseMatch,\n    monster: options.monsterMatch,\n    keepId: options.keepId,\n  };\n\n  const results = await updateMatchingItems(items, loadedItems, matchingOptions);\n  logger.debug(`compendium ${type} result items:`, results);\n  return results;\n}\n\n/**\n * gets items from compendium\n * @param {*} items\n */\nexport async function getCompendiumItems(items, type, compendiumLabel = null, looseMatch = false, monsterMatch = false, keepId = false, deleteCompendiumId = true) {\n  if (!compendiumLabel) {\n    compendiumLabel = getCompendiumLabel(type);\n  }\n  const compendium = await getCompendium(compendiumLabel, false);\n  if (!compendium) return [];\n\n  const loadOptions = {\n    looseMatch,\n    monsterMatch,\n    keepId,\n    deleteCompendiumId,\n  };\n  const results = await loadPassedItemsFromCompendium(compendium, items, type, loadOptions);\n\n  return results;\n}\n\nexport async function getSRDCompendiumItems(items, type, looseMatch = false, keepId = false, monster = false) {\n  const compendiumName = srdCompendiumLookup.find((c) => c.type == type).name;\n  if (!srdPacksLoaded[compendiumName]) await loadSRDPacks(compendiumName);\n  const compendiumItems = srdPacks[compendiumName];\n\n  const loadedItems = await compendiumItems.filter((i) =>\n    compendiumItems.some((orig) => {\n      const extraNames = (orig.flags?.ddbimporter?.dndbeyond?.alternativeNames)\n        ? orig.flags.ddbimporter.dndbeyond.alternativeNames\n        : [];\n      if (looseMatch) {\n        const looseNames = getLooseNames(orig.name, extraNames);\n        return looseNames.includes(i.name.split(\"(\")[0].trim().toLowerCase());\n      } else {\n        return i.name === orig.name || extraNames.includes(i.name);\n      }\n    })\n  ).map((i) => {\n    const item = i.toObject();\n    if (item.flags.ddbimporter) {\n      item.flags.ddbimporter[\"pack\"] = compendiumName;\n    } else {\n      item.flags.ddbimporter = { pack: compendiumName };\n    }\n    return item;\n  });\n  // logger.debug(`SRD ${type} loaded items:`, loadedItems);\n\n  const matchingOptions = {\n    looseMatch,\n    monster,\n    keepId,\n  };\n\n  const results = await updateMatchingItems(items, loadedItems, matchingOptions);\n  logger.debug(`SRD ${type} result items:`, results);\n\n  return results;\n}\n\n/**\n * Add an item to effects, if available\n * @param {*} items\n */\nexport function addItemEffectIcons(items) {\n  logger.debug(\"Adding Icons to effects\");\n\n  items.forEach((item) => {\n    if (item.effects && (item.img || item.img !== \"\" || item.img !== \"icons/svg/mystery-man.svg\")) {\n      item.effects.forEach((effect) => {\n\n        if (!effect.icon || effect.icon === \"\" || effect.icon === \"icons/svg/mystery-man.svg\") {\n          effect.icon = item.img;\n        }\n      });\n    }\n\n  });\n  return items;\n}\n\n/**\n * TO DO : This function should do something.\n * @param {*} effects\n */\nexport function addACEffectIcons(effects) {\n  logger.debug(\"Adding Icons to AC effects\");\n\n  // effects.forEach((item) => {\n  //   if (!effect.icon || effect.icon === \"\" || effect.icon === \"icons/svg/mystery-man.svg\") {\n  //     effect.icon = item.img;\n  //   }\n  // });\n  return effects;\n}\n\nexport async function updateIcons(items, srdIconUpdate = true, monster = false, monsterName = \"\") {\n  // this will use ddb item icons as a fall back\n  const ddbItemIcons = game.settings.get(\"ddb-importer\", \"munching-policy-use-ddb-item-icons\");\n  if (ddbItemIcons) {\n    logger.debug(\"DDB Equipment Icon Match\");\n    items = await getDDBEquipmentIcons(items);\n  }\n\n  const inBuiltIcons = game.settings.get(\"ddb-importer\", \"munching-policy-use-inbuilt-icons\");\n  if (inBuiltIcons) {\n    logger.debug(\"Inbuilt icon matching\");\n    items = await copyInbuiltIcons(items, monster, monsterName);\n  }\n\n  // check for SRD icons\n  const srdIcons = game.settings.get(\"ddb-importer\", \"munching-policy-use-srd-icons\");\n  // eslint-disable-next-line require-atomic-updates\n  if (srdIcons && srdIconUpdate) {\n    logger.debug(\"SRD Icon Matching\");\n    items = await copySRDIcons(items);\n  }\n\n  // this will use ddb spell school icons as a fall back\n  const ddbSpellIcons = game.settings.get(\"ddb-importer\", \"munching-policy-use-ddb-spell-icons\");\n  if (ddbSpellIcons) {\n    logger.debug(\"DDB Spell School Icon Match\");\n    items = await getDDBSpellSchoolIcons(items, true);\n  }\n\n  // this will use ddb generic icons as a fall back\n  const ddbGenericItemIcons = game.settings.get(\"ddb-importer\", \"munching-policy-use-ddb-generic-item-icons\");\n  if (ddbGenericItemIcons) {\n    logger.debug(\"DDB Generic Item Icon Match\");\n    items = await getDDBGenericItemIcons(items, true);\n  }\n\n  // update any generated effects\n  const addEffects = game.settings.get(\"ddb-importer\", \"munching-policy-add-effects\");\n  if (addEffects) {\n    items = addItemEffectIcons(items);\n  }\n\n  return items;\n}\n\nexport async function srdFiddling(items, type) {\n  const updateBool = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n  const useSrd = game.settings.get(\"ddb-importer\", \"munching-policy-use-srd\");\n\n  if (useSrd && type == \"monsters\") {\n    const srdItems = await getSRDCompendiumItems(items, type);\n    // removed existing items from those to be imported\n    logger.debug(\"Removing compendium items\");\n    const lessSrdItems = await removeItems(items, srdItems);\n    const newIcons = lessSrdItems.concat(srdItems);\n    const iconedItems = await updateIcons(newIcons);\n    // console.warn(\"Final Monsters\", srdItems);\n    return iconedItems;\n  } else if (useSrd) {\n    logger.debug(\"Removing compendium items\");\n    let itemMap = {};\n    const srdItems = await getSRDCompendiumItems(items, type);\n    itemMap[type] = srdItems;\n    logger.debug(\"Adding SRD compendium items\");\n    updateCompendium(type, itemMap, updateBool);\n    // removed existing items from those to be imported\n    return new Promise((resolve) => {\n      removeItems(items, srdItems)\n        .then((cleanedItems) => updateIcons(cleanedItems))\n        .then((iconItems) => resolve(iconItems));\n    });\n  } else {\n    const iconItems = await updateIcons(items);\n    return iconItems;\n  }\n}\n\n\nexport async function daeFiddling(items) {\n  const fiddle = game.settings.get(\"ddb-importer\", \"munching-policy-use-dae-effects\");\n  const installed = utils.isModuleInstalledAndActive(\"dae\") &&\n    (utils.isModuleInstalledAndActive(\"Dynamic-Effects-SRD\") || utils.isModuleInstalledAndActive(\"midi-srd\"));\n\n  if (fiddle && installed) {\n    return addItemsDAESRD(items);\n  } else return items;\n}\n\nasync function getCompendiumItemSpells(spells) {\n  const compendiumSpells = await getCompendiumItems(spells, \"spell\", null, true, false, true, false);\n  const lessCompendiumSpells = await removeItems(spells, compendiumSpells);\n  const srdSpells = await getSRDCompendiumItems(lessCompendiumSpells, \"spell\", true, true);\n  const foundSpells = compendiumSpells.concat(srdSpells);\n\n  const itemSpells = foundSpells.map((result) => {\n    return {\n      magicItem: {\n        _id: result._id,\n        id: result._id,\n        pack: result.flags.ddbimporter.pack,\n        img: result.img,\n        name: result.name,\n        flatDc: result.flags.ddbimporter.dndbeyond?.overrideDC,\n        dc: result.flags.ddbimporter.dndbeyond?.dc,\n      },\n      _id: result._id,\n      name: result.name,\n      compendium: true,\n    };\n  });\n\n  return [foundSpells, itemSpells];\n}\n\n/**\n * This adds magic item spells to an item, by looking in compendium or from a world.\n */\nexport async function addMagicItemSpells(input) {\n  // check for existing spells in spell compendium & srdCompendium\n  const [compendiumSpells, compendiumItemSpells] = await getCompendiumItemSpells(input.itemSpells);\n  // if spells not found create world version\n  const remainingSpells = {\n    itemSpells: await removeItems(input.itemSpells, compendiumSpells),\n  };\n  const worldSpells = remainingSpells.length > 0\n    ? await updateFolderItems(\"itemSpells\", remainingSpells)\n    : [];\n  const itemSpells = worldSpells.concat(compendiumItemSpells);\n\n  logger.debug(\"itemSpells fetched\", itemSpells);\n\n  // scan the inventory for each item with spells and copy the imported data over\n  input.inventory.forEach((item) => {\n    logger.debug(\"replacing spells for item\", item);\n    logger.debug(\"item.flags.magicitems.spells\", item.flags.magicitems.spells);\n    if (item.flags.magicitems.spells) {\n      for (let [i, spell] of Object.entries(item.flags.magicitems.spells)) {\n        const itemSpell = itemSpells.find((iSpell) => iSpell.name === spell.name &&\n          (iSpell.compendium || iSpell.magicItem.subFolder === item.name)\n        );\n        if (itemSpell) {\n          for (const [key, value] of Object.entries(itemSpell.magicItem)) {\n            item.flags.magicitems.spells[i][key] = value;\n          }\n        } else if (!game.user.can(\"ITEM_CREATE\")) {\n          ui.notifications.warn(`Magic Item ${item.name} cannot be enriched because of lacking player permissions`);\n        } else {\n          ui.notifications.warn(`Magic Item ${item.name}: cannot add spell ${spell.name}`);\n        }\n      }\n    }\n  });\n}\n","import utils from \"../utils.js\";\nimport logger from \"../logger.js\";\nimport DICTIONARY from \"../dictionary.js\";\nimport { updateIcons, getImagePath, getCompendiumItems, getSRDIconLibrary, copySRDIcons, copySupportedItemFlags, compendiumFolders } from \"./import.js\";\nimport { getCompendiumType, munchNote } from \"./utils.js\";\nimport { migrateItemsDAESRD } from \"./dae.js\";\n\nvar compendiumLoaded = false;\nvar monsterCompendium;\n\n/**\n *\n * @param {[string]} items Array of Strings or\n */\nasync function retrieveCompendiumItems(items, compendiumName) {\n  const GET_ENTITY = true;\n\n  const itemNames = items.map((item) => {\n    if (typeof item === \"string\") return item;\n    if (typeof item === \"object\" && Object.prototype.hasOwnProperty.call(item, \"name\")) return item.name;\n    return \"\";\n  });\n\n  const results = await utils.queryCompendiumEntries(compendiumName, itemNames, GET_ENTITY);\n  const cleanResults = results.filter((item) => item !== null);\n\n  return cleanResults;\n}\n\n\n/**\n *\n * @param {[items]} spells Array of Strings or items\n */\nasync function retrieveSpells(spells) {\n  const compendiumName = await game.settings.get(\"ddb-importer\", \"entity-spell-compendium\");\n  const compendiumItems = await retrieveCompendiumItems(spells, compendiumName);\n  const itemData = compendiumItems.map((i) => i.toJSON());\n\n  return itemData;\n}\n\n// /**\n//  *\n//  * @param {[string]} items Array of Strings or items\n//  */\n// async function retrieveItems(items) {\n//   const compendiumName = await game.settings.get(\"ddb-importer\", \"entity-item-compendium\");\n\n//   return retrieveCompendiumItems(items, compendiumName);\n// }\n\nfunction getMonsterCompendium() {\n  if (compendiumLoaded) return monsterCompendium;\n  monsterCompendium = getCompendiumType(\"monster\", false);\n  if (monsterCompendium) {\n    // eslint-disable-next-line require-atomic-updates\n    compendiumLoaded = true;\n    return monsterCompendium;\n  }\n  return undefined;\n}\n\nexport function checkMonsterCompendium() {\n  compendiumLoaded = false;\n  monsterCompendium = undefined;\n  return getMonsterCompendium();\n}\n\nasync function addNPCToCompendium(npc) {\n  const compendium = getMonsterCompendium();\n  if (compendium) {\n    let npcBasic = duplicate(npc);\n    // delete npcBasic.items;\n    let npcItems = npc.items;\n    // unlock the compendium for update/create\n    compendium.configure({ locked: false });\n\n    const index = await compendium.getIndex();\n    const npcMatch = index.contents.find((entity) => entity.name.toLowerCase() === npcBasic.name.toLowerCase());\n\n    let compendiumNPC;\n    if (npcMatch) {\n      if (game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\")) {\n        const existingNPC = await compendium.getDocument(npcMatch._id);\n\n        const updateImages = game.settings.get(\"ddb-importer\", \"munching-policy-update-images\");\n        if (!updateImages && existingNPC.data.img !== \"icons/svg/mystery-man.svg\") {\n          npcBasic.img = existingNPC.data.img;\n        }\n        if (!updateImages && existingNPC.data.token.img !== \"icons/svg/mystery-man.svg\") {\n          npcBasic.token.img = existingNPC.data.token.img;\n          npcBasic.token.scale = existingNPC.data.token.scale;\n          npcBasic.token.randomImg = existingNPC.data.token.randomImg;\n          npcBasic.token.mirrorX = existingNPC.data.token.mirrorX;\n          npcBasic.token.mirrorY = existingNPC.data.token.mirrorY;\n          npcBasic.token.lockRotation = existingNPC.data.token.lockRotation;\n          npcBasic.token.rotation = existingNPC.data.token.rotation;\n          npcBasic.token.alpha = existingNPC.data.token.alpha;\n          npcBasic.token.lightAlpha = existingNPC.data.token.lightAlpha;\n          npcBasic.token.lightAnimation = existingNPC.data.token.lightAnimation;\n          npcBasic.token.tint = existingNPC.data.token.tint;\n          npcBasic.token.lightColor = existingNPC.data.token.lightColor;\n        }\n        npcBasic._id = npcMatch._id;\n        await copySupportedItemFlags(existingNPC.data, npcBasic);\n\n        await existingNPC.deleteEmbeddedDocuments(\"Item\", [], { deleteAll: true });\n        delete npcBasic.items;\n        compendiumNPC = await existingNPC.update(npcBasic);\n        await compendiumNPC.createEmbeddedDocuments(\"Item\", npcItems);\n      }\n    } else {\n      // create the new npc\n      logger.debug(`Creating NPC actor ${npcBasic.name}`);\n      const options = {\n        temporary: true,\n        displaySheet: false,\n      };\n      delete npcBasic.items;\n      const newNPC = await Actor.create(npcBasic, options);\n      compendiumNPC = await compendium.importDocument(newNPC);\n      await compendiumNPC.createEmbeddedDocuments(\"Item\", npcItems);\n    }\n\n    // using compendium folders?\n    await compendiumFolders(compendiumNPC, \"npc\");\n  } else {\n    logger.error(\"Error opening compendium, check your settings\");\n  }\n}\n\n\nasync function getNPCImage(data) {\n  // check to see if we have munched flags to work on\n  if (!data.flags || !data.flags.monsterMunch || !data.flags.monsterMunch.img) {\n    return false;\n  }\n\n  const updateImages = game.settings.get(\"ddb-importer\", \"munching-policy-update-images\");\n  if (!updateImages && data.img !== \"icons/svg/mystery-man.svg\") {\n    return false;\n  }\n\n  let dndBeyondImageUrl = data.flags.monsterMunch.img;\n  let dndBeyondTokenImageUrl = data.flags.monsterMunch.tokenImg;\n  const useAvatarAsToken = game.settings.get(\"ddb-importer\", \"munching-policy-use-full-token-image\");\n  const useTokenAsAvatar = game.settings.get(\"ddb-importer\", \"munching-policy-use-token-avatar-image\");\n  if (useAvatarAsToken) {\n    dndBeyondTokenImageUrl = dndBeyondImageUrl;\n  } else if (useTokenAsAvatar) {\n    dndBeyondImageUrl = dndBeyondTokenImageUrl;\n  }\n\n  const npcType = data.data.details.type.value;\n  const genericNPCName = npcType.replace(/[^a-zA-Z]/g, \"-\").replace(/-+/g, \"-\").trim();\n  const npcName = data.name.replace(/[^a-zA-Z]/g, \"-\").replace(/-+/g, \"-\").trim();\n\n  if (!dndBeyondImageUrl && dndBeyondTokenImageUrl) dndBeyondImageUrl = dndBeyondTokenImageUrl;\n  if (!dndBeyondTokenImageUrl && dndBeyondImageUrl) dndBeyondTokenImageUrl = dndBeyondImageUrl;\n\n  if (dndBeyondImageUrl) {\n    const ext = dndBeyondImageUrl.split(\".\").pop().split(/#|\\?|&/)[0];\n\n    if (dndBeyondImageUrl.endsWith(npcType + \".\" + ext)) {\n      // eslint-disable-next-line require-atomic-updates\n      data.img = await getImagePath(dndBeyondImageUrl, \"npc-generic\", genericNPCName);\n    } else {\n      // eslint-disable-next-line require-atomic-updates\n      data.img = await getImagePath(dndBeyondImageUrl, \"npc\", npcName);\n    }\n  }\n\n  // Currently token images always have to be downloaded. Not sure why.\n  if (dndBeyondTokenImageUrl) {\n    const tokenExt = dndBeyondTokenImageUrl.split(\".\").pop().split(/#|\\?|&/)[0];\n\n    if (dndBeyondTokenImageUrl.endsWith(npcType + \".\" + tokenExt)) {\n      // eslint-disable-next-line require-atomic-updates\n      data.token.img = await getImagePath(dndBeyondTokenImageUrl, \"npc-generic-token\", genericNPCName, true, false);\n    } else {\n      // eslint-disable-next-line require-atomic-updates\n      data.token.img = await getImagePath(dndBeyondTokenImageUrl, \"npc-token\", npcName, true, false);\n    }\n  }\n\n  // check avatar, if not use token image\n  // eslint-disable-next-line require-atomic-updates\n  if (!data.img && data.token.img) data.img = data.token.img;\n\n  // final check if image comes back as null\n  // eslint-disable-next-line require-atomic-updates\n  if (data.img === null) data.img = \"icons/svg/mystery-man.svg\";\n  // eslint-disable-next-line require-atomic-updates\n  if (data.token.img === null) data.token.img = \"icons/svg/mystery-man.svg\";\n\n  return true;\n}\n\nfunction getSpellEdgeCase(spell, type, spellList) {\n  const edgeCases = spellList.edgeCases;\n  const edgeCase = edgeCases.find((edge) => edge.name.toLowerCase() === spell.name.toLowerCase() && edge.type === type);\n\n  if (edgeCase) {\n    logger.debug(`Spell edge case for ${spell.name}`);\n    switch (edgeCase.edge.toLowerCase()) {\n      case \"self\":\n      case \"self only\":\n        spell.data.target.type = \"self\";\n        logger.debug(\"spell target changed to self\");\n        break;\n      // no default\n    }\n    spell.name = `${spell.name} (${edgeCase.edge})`;\n    spell.data.description.chat = `<p><b>Special Notes: ${edgeCase.edge}.</b></p>\\n\\n${spell.data.description.chat}`;\n    spell.data.description.value = `<p><b>Special Notes: ${edgeCase.edge}.</b></p>\\n\\n${spell.data.description.value}`;\n\n    const diceSearch = /(\\d+)d(\\d+)/;\n    const diceMatch = edgeCase.edge.match(diceSearch);\n    if (diceMatch) {\n      if (spell.data.damage.parts[0] && spell.data.damage.parts[0][0]) {\n        spell.data.damage.parts[0][0] = diceMatch[0];\n      } else if (spell.data.damage.parts[0]) {\n        spell.data.damage.parts[0] = [diceMatch[0]];\n      } else {\n        spell.data.damage.parts = [[diceMatch[0]]];\n      }\n    }\n\n    // save DC 12\n    const saveSearch = /save DC (\\d+)/;\n    const saveMatch = edgeCase.edge.match(saveSearch);\n    if (saveMatch) {\n      spell.data.save.dc = saveMatch[1];\n      spell.data.save.scaling = \"flat\";\n    }\n\n  }\n\n  // remove material components?\n  if (!spellList.material) {\n    spell.data.materials = {\n      value: \"\",\n      consumed: false,\n      cost: 0,\n      supply: 0\n    };\n    spell.data.components.material = false;\n  }\n\n}\n\nasync function addSpells(data) {\n  // check to see if we have munched flags to work on\n  if (!data.flags || !data.flags.monsterMunch || !data.flags.monsterMunch.spellList) {\n    return;\n  }\n\n  const spellList = data.flags.monsterMunch.spellList;\n  logger.debug(`Spell List for edgecases`, spellList);\n  const atWill = spellList.atwill;\n  const klass = spellList.class;\n  const innate = spellList.innate;\n  const pact = spellList.pact;\n\n  if (atWill.length !== 0) {\n    logger.debug(\"Retrieving at Will spells:\", atWill);\n    let spells = await retrieveSpells(atWill);\n    spells = spells.filter((spell) => spell !== null).map((spell) => {\n      if (spell.data.level == 0) {\n        spell.data.preparation = {\n          mode: \"prepared\",\n          prepared: false,\n        };\n      } else {\n        spell.data.preparation = {\n          mode: \"atwill\",\n          prepared: false,\n        };\n        spell.data.uses = {\n          value: null,\n          max: null,\n          per: \"\",\n        };\n      }\n      getSpellEdgeCase(spell, \"atwill\", spellList);\n      return spell;\n    });\n    // eslint-disable-next-line require-atomic-updates\n    data.items = data.items.concat(spells);\n  }\n\n  // class spells\n  if (klass.length !== 0) {\n    logger.debug(\"Retrieving class spells:\", klass);\n    let spells = await retrieveSpells(klass);\n    spells = spells.filter((spell) => spell !== null).map((spell) => {\n      spell.data.preparation = {\n        mode: \"prepared\",\n        prepared: true,\n      };\n      getSpellEdgeCase(spell, \"class\", spellList);\n      return spell;\n    });\n    // eslint-disable-next-line require-atomic-updates\n    data.items = data.items.concat(spells);\n  }\n\n  // pact spells\n  if (pact.length !== 0) {\n    logger.debug(\"Retrieving pact spells:\", pact);\n    let spells = await retrieveSpells(pact);\n    spells = spells.filter((spell) => spell !== null).map((spell) => {\n      spell.data.preparation = {\n        mode: \"pact\",\n        prepared: true,\n      };\n      getSpellEdgeCase(spell, \"pact\", spellList);\n      return spell;\n    });\n    // eslint-disable-next-line require-atomic-updates\n    data.items = data.items.concat(spells);\n  }\n\n  // innate spells\n  if (innate.length !== 0) {\n    // innate:\n    // {name: \"\", type: \"srt/lng/day\", value: 0}\n    logger.debug(\"Retrieving innate spells:\", innate);\n    const spells = await retrieveSpells(innate);\n    const innateSpells = spells.filter((spell) => spell !== null)\n      .map((spell) => {\n        const spellInfo = innate.find((w) => w.name.toLowerCase() == spell.name.toLowerCase());\n        if (spellInfo) {\n          spell.data.preparation = {\n            mode: \"innate\",\n            prepared: true,\n          };\n          const per = DICTIONARY.resets.find((d) => d.id == spellInfo.type);\n          spell.data.uses = {\n            value: spellInfo.value,\n            max: spellInfo.value,\n            per: (per && per.type) ? per.type : \"day\",\n          };\n          getSpellEdgeCase(spell, \"innate\", spellList);\n        }\n        return spell;\n      });\n    // eslint-disable-next-line require-atomic-updates\n    data.items = data.items.concat(innateSpells);\n  }\n}\n\nasync function swapItems(data) {\n  const swap = game.settings.get(\"ddb-importer\", \"munching-policy-monster-items\");\n\n  if (swap) {\n    logger.debug(\"Replacing items...\");\n    // console.info(data.items);\n    const updatedItems = await getCompendiumItems(data.items, \"inventory\", null, false, true);\n    const itemsToRemove = updatedItems.map((item) => {\n      logger.debug(`${item.name} to ${item.flags.ddbimporter.originalItemName}`);\n      return { name: item.flags.ddbimporter.originalItemName, type: item.type };\n    });\n    logger.debug(\"Swapping items\", itemsToRemove);\n    // console.warn(itemsToRemove);\n    const lessUpdatedItems = data.items.filter((item) =>\n      !itemsToRemove.some((target) => item.name === target.name && item.type === target.type)\n    );\n    // console.log(lessUpdatedItems);\n    const newItems = lessUpdatedItems.concat(updatedItems);\n    // console.error(newItems);\n    // eslint-disable-next-line require-atomic-updates\n    data.items = newItems;\n\n  }\n}\n\nasync function linkResourcesConsumption(actor) {\n  if (actor.items.some((item) => item.data?.recharge?.value)) {\n    logger.debug(`Resource linking for ${actor.name}`);\n    actor.items.forEach((item) => {\n      if (item.data?.recharge?.value) {\n        const itemID = randomID(16);\n        item._id = itemID;\n        item.data.consume = {\n          type: \"charges\",\n          target: itemID,\n          amount: null,\n        };\n      }\n    });\n  }\n  return actor;\n}\n\n// async function buildNPC(data, srdIconLibrary, iconMap) {\nexport async function buildNPC(data, temporary = true, update = false, handleBuild = false) {\n  logger.debug(\"Importing Images\");\n  await getNPCImage(data);\n  logger.debug(\"Importing Spells\");\n  await addSpells(data);\n  logger.debug(\"Checking Items\");\n  await swapItems(data);\n\n  // DAE\n  const daeInstalled = utils.isModuleInstalledAndActive(\"dae\") &&\n    (utils.isModuleInstalledAndActive(\"Dynamic-Effects-SRD\") || utils.isModuleInstalledAndActive(\"midi-srd\"));\n  const daeCopy = game.settings.get(\"ddb-importer\", \"munching-policy-dae-copy\");\n  if (daeInstalled && daeCopy) {\n    munchNote(`Importing DAE Item for ${data.name}`);\n    // eslint-disable-next-line require-atomic-updates\n    data.items = await migrateItemsDAESRD(data.items);\n  }\n\n  logger.debug(\"Importing Icons\");\n  // eslint-disable-next-line require-atomic-updates\n  data.items = await updateIcons(data.items, false, true, data.name);\n  data = await linkResourcesConsumption(data);\n\n  if (handleBuild) {\n    // create the new npc\n    logger.debug(\"Creating NPC actor\");\n    const options = {\n      temporary: temporary,\n      displaySheet: false,\n    };\n    if (update) {\n      const npc = game.actors.get(data._id);\n      await npc.deleteEmbeddedDocuments(\"Item\", [], { deleteAll: true });\n      await Actor.updateDocuments([data]);\n      return npc;\n    } else {\n      const npc = await Actor.create(data, options);\n      return npc;\n    }\n\n  } else {\n    return data;\n  }\n\n}\n\nasync function parseNPC (data) {\n  let npc = await buildNPC(data);\n  logger.debug(`Adding actor ${npc.name} to compendium`);\n  await addNPCToCompendium(npc);\n  return npc;\n}\n\nexport function addNPC(data) {\n  return new Promise((resolve, reject) => {\n    parseNPC(data)\n      .then((npc) => {\n        resolve(npc);\n      })\n      .catch((error) => {\n        logger.error(`error parsing NPC: ${error} ${data.name}`);\n        logger.error(error.stack);\n        reject(error);\n      });\n  });\n}\n\nexport async function generateIconMap(monsters) {\n  let promises = [];\n\n  const srdIcons = game.settings.get(\"ddb-importer\", \"munching-policy-use-srd-icons\");\n  // eslint-disable-next-line require-atomic-updates\n  if (srdIcons) {\n    const srdIconLibrary = await getSRDIconLibrary();\n    munchNote(`Updating SRD Icons`, true);\n    let itemMap = [];\n\n    monsters.forEach((monster) => {\n      munchNote(`Processing ${monster.name}`);\n      promises.push(\n        copySRDIcons(monster.items, srdIconLibrary, itemMap).then((items) => {\n          monster.items = items;\n        })\n      );\n    });\n  }\n\n  return Promise.all(promises);\n}\n\nexport function copyExistingMonsterImages(monsters, existingMonsters) {\n  const updated = monsters.map((monster) => {\n    const existing = existingMonsters.find((m) => monster.name === m.name);\n    if (existing) {\n      monster.img = existing.img;\n      monster.token.img = existing.token.img;\n      return monster;\n    } else {\n      return monster;\n    }\n  });\n  return updated;\n}\n","export const ABILITIES = [\n  { id: 1, value: \"str\", long: \"strength\" },\n  { id: 2, value: \"dex\", long: \"dexterity\" },\n  { id: 3, value: \"con\", long: \"constitution\" },\n  { id: 4, value: \"int\", long: \"intelligence\" },\n  { id: 5, value: \"wis\", long: \"wisdom\" },\n  { id: 6, value: \"cha\", long: \"charisma\" },\n];\n\n//     \"abilities\": {\n// \"str\": {\n//   \"value\": 27,\n//   \"proficient\": 0,\n//   \"min\": 3,\n//   \"mod\": 8,\n//   \"save\": 8,\n//   \"prof\": 0,\n//   \"saveBonus\": 0,\n//   \"checkBonus\": 0,\n//   \"dc\": 23\n// },\n// \"dex\": {\n//   \"value\": 14,\n//   \"proficient\": 1,\n//   \"min\": 3,\n//   \"mod\": 2,\n//   \"save\": 9,\n//   \"prof\": 7,\n//   \"saveBonus\": 0,\n//   \"checkBonus\": 0,\n//   \"dc\": 17\n// },\n/**\n * Retrieves character abilities, including proficiency on saving throws\n * @param {obj} monster JSON Import\n * @param {obj} DDB_CONFIG config\n */\nexport function getAbilities(abilities, monster, DDB_CONFIG) {\n  // go through every ability\n  ABILITIES.forEach((ability) => {\n    const value = monster.stats.find((stat) => stat.statId === ability.id).value || 0;\n    const proficient = monster.savingThrows.find((stat) => stat.statId === ability.id) ? 1 : 0;\n    const proficiencyBonus = DDB_CONFIG.challengeRatings.find((cr) => cr.id == monster.challengeRatingId).proficiencyBonus;\n    const mod = DDB_CONFIG.statModifiers.find((s) => s.value == value).modifier;\n\n    abilities[ability.value]['value'] = value;\n    abilities[ability.value]['proficient'] = proficient;\n    abilities[ability.value]['mod'] = mod;\n\n    if (proficient) {\n      abilities[ability.value]['prof'] = proficiencyBonus;\n      abilities[ability.value]['saveBonus'] = monster.savingThrows.find((stat) => stat.statId === ability.id).bonusModifier || 0;\n      abilities[ability.value]['save'] = mod + proficiencyBonus + abilities[ability.value]['saveBonus'];\n    }\n\n    abilities[ability.value]['dc'] = mod + proficiencyBonus + 8;\n  });\n\n  return abilities;\n}\n\n\nexport function getAbilityMods(monster, DDB_CONFIG) {\n  let abilities = {};\n\n  ABILITIES.forEach((ability) => {\n    const value = monster.stats.find((stat) => stat.statId === ability.id).value || 0;\n    const mod = DDB_CONFIG.statModifiers.find((s) => s.value == value).modifier;\n    abilities[ability.value] = mod;\n  });\n\n  return abilities;\n\n}\n","import logger from \"../../logger.js\";\nimport { loadPassedItemsFromCompendium } from \"../import.js\";\nimport { getCompendiumLabel, getCompendium } from \"../utils.js\";\n\nconst BAD_AC_MONSTERS = [\n  \"arkhan the cruel\"\n];\n\nvar equipmentCompendium;\n\nexport function resetEquipment() {\n  equipmentCompendium = null;\n}\n\nasync function getEquipmentCompendium() {\n  if (!equipmentCompendium) {\n    const label = getCompendiumLabel(\"inventory\");\n    // eslint-disable-next-line require-atomic-updates\n    equipmentCompendium = await getCompendium(label);\n    if (!equipmentCompendium.indexed) await equipmentCompendium.getIndex();\n  }\n  return equipmentCompendium;\n}\n\nexport async function generateAC(monster, DDB_CONFIG, useItemAC) {\n\n  const ac = {\n    \"flat\": monster.armorClass,\n    \"calc\": \"\",\n    \"formula\": \"\",\n    \"label\": monster.armorClassDescription ? monster.armorClassDescription.replace(\"(\", \"\").replace(\")\", \"\") : \"\",\n  };\n\n  let flatAC = true;\n\n  const stat = monster.stats.find((stat) => stat.statId === 2).value || 10;\n  const dexBonus = DDB_CONFIG.statModifiers.find((s) => s.value == stat).modifier;\n\n  let acItems = [];\n\n  const descriptionItems = monster.armorClassDescription\n    ? monster.armorClassDescription.toLowerCase().replace(\"(\", \"\").replace(\")\", \"\")\n      .split(\";\")[0]\n      .split(\",\").map((item) => item.trim())\n    : [];\n\n  // arkhan the cruel has Armor Class 23 (obsidian flint dragon plate, shield)\n\n  // archmage 12 (15 with mage armor)\n\n  // Jarlaxle Baenre 24 (+3 leather armor, Suave Defense)\n  // Suave Defense. While Jarlaxle is wearing light or no armor and wielding no shield, his AC includes his Charisma modifier.\n\n  // Eternal flame guardian 17 (breastplate, shield; 15 while using a crossbow)\n\n  let itemsToCheck = [];\n  if (descriptionItems.length > 0) {\n    descriptionItems.forEach((item) => {\n      if (item == \"natural\" || item == \"natural armor\") {\n        ac.calc = \"natural\";\n      } else if (!item.includes(\"with mage armor\")) {\n        if (item === \"leather armor\") {\n          item = \"leather\";\n        } else if (item.startsWith(\"+\")) {\n          const bonusRegex = /(\\+\\d+)(?:\\s+)(.*)/;\n          const matches = item.match(bonusRegex);\n          if (matches) {\n            item = `${matches[2]}, ${matches[1]}`;\n          }\n        }\n        const type = item.includes(\"ring\") || item.includes(\"cloak\") ? \"trinket\" : \"equipment\";\n        itemsToCheck.push({ name: item, type, flags: {}, data: { equipped: true } });\n      };\n    });\n  }\n\n  const compendium = await getEquipmentCompendium();\n  const unAttunedItems = await loadPassedItemsFromCompendium(compendium, itemsToCheck, \"inventory\", { monsterMatch: true });\n  const attunedItems = unAttunedItems.map((item) => {\n    if (item.data.attunement === 1) item.data.attunement = 2;\n    return item;\n  });\n\n\n  const allItemsMatched = attunedItems.length > 0 && attunedItems.length == itemsToCheck.length;\n  const badACMonster = BAD_AC_MONSTERS.includes(monster.name.toLowerCase());\n\n  if (allItemsMatched && useItemAC && ac.calc !== \"natural\" && !badACMonster) {\n    ac.flat = null;\n    ac.calc = \"default\";\n    ac.formula = \"\";\n    flatAC = false;\n  }\n\n  const result = {\n    ac,\n    flatAC,\n    acItems,\n    dexBonus,\n    ddbItems: attunedItems,\n    allItemsMatched,\n    badACMonster,\n  };\n  logger.debug(`${monster.name} ac calcs`, result);\n  return result;\n\n}\n","export function getTextSenses(monster) {\n  return monster.sensesHtml;\n}\n\nconst SENSE_MAP = {\n  Blindsight: \"dimSight\",\n  Darkvision: \"dimSight\",\n  Tremorsense: \"brightSight\",\n  Truesight: \"brightSight\",\n  Unknown: \"dimsight\",\n};\n\n//   \"senses\": [{\n//   \"id\": 1,\n//   \"entityTypeId\": 668550506,\n//   \"name\": \"Blindsight\"\n// }, {\n//   \"id\": 2,\n//   \"entityTypeId\": 668550506,\n//   \"name\": \"Darkvision\"\n// }, {\n//   \"id\": 3,\n//   \"entityTypeId\": 668550506,\n//   \"name\": \"Tremorsense\"\n// }, {\n//   \"id\": 4,\n//   \"entityTypeId\": 668550506,\n//   \"name\": \"Truesight\"\n// }, {\n//   \"id\": 5,\n//   \"entityTypeId\": 668550506,\n//   \"name\": \"Unknown\"\n// }],\n\nexport function getTokenSenses(token, monster, DDB_CONFIG) {\n  const senseLookup = DDB_CONFIG.senses;\n\n  monster.senses.forEach((sense) => {\n    const senseMatch = senseLookup.find((l) => l.id == sense.senseId);\n    if (senseMatch && sense.notes) {\n      const senseType = SENSE_MAP[senseMatch.name];\n      const rangeMatch = sense.notes.trim().match(/^(\\d+)/);\n      if (rangeMatch) {\n        token[senseType] = parseInt(rangeMatch[1]);\n      }\n    }\n  });\n\n  return token;\n}\n\n\nexport function getSenses(monster, DDB_CONFIG) {\n  let senses = {\n    darkvision: 0,\n    blindsight: 0,\n    tremorsense: 0,\n    truesight: 0,\n    units: \"ft\",\n    special: \"\"\n  };\n  const senseLookup = DDB_CONFIG.senses;\n\n  monster.senses.forEach((sense) => {\n    const senseMatch = senseLookup.find((l) => l.id == sense.senseId);\n    if (senseMatch && sense.notes && senseMatch.name.toLowerCase() in senses) {\n      const rangeMatch = sense.notes.trim().match(/^(\\d+)/);\n      if (rangeMatch) {\n        senses[senseMatch.name.toLowerCase()] = parseInt(rangeMatch[1]);\n      } else {\n        senses.special += `${senseMatch.name}: ${sense.notes}; `;\n      }\n    } else {\n      senses.special += `${senseMatch.name}: ${sense.notes}; `;\n    }\n  });\n\n  return senses;\n\n}\n\n// \"senses\": [\n//   {\n//       \"senseId\": 1,\n//       \"notes\": \"60 ft.\"\n//   },\n//   {\n//       \"senseId\": 2,\n//       \"notes\": \"120 ft.\"\n//   }\n// ],\n\n// \"senses\": [{\n//   \"senseId\": 1,\n//   \"notes\": \" 60 ft. (blind beyond this radius)\"\n// }],\n\n","import utils from \"../../utils.js\";\n\nconst CONDITION_TYPES = [\n  { name: \"Blinded\", value: \"blinded\" },\n  { name: \"Charmed\", value: \"charmed\" },\n  { name: \"Deafened\", value: \"deafened\" },\n  { name: \"Exhaustion\", value: \"exhaustion\" },\n  { name: \"Frightened\", value: \"frightened\" },\n  { name: \"Grappled\", value: \"grappled\" },\n  { name: \"Incapacitated\", value: \"incapacitated\" },\n  { name: \"Invisible\", value: \"invisible\" },\n  { name: \"Paralyzed\", value: \"paralyzed\" },\n  { name: \"Petrified\", value: \"petrified\" },\n  { name: \"Poisoned\", value: \"poisoned\" },\n  { name: \"Prone\", value: \"prone\" },\n  { name: \"Restrained\", value: \"restrained\" },\n  { name: \"Stunned\", value: \"stunned\" },\n  { name: \"Unconscious\", value: \"unconscious\" },\n  { name: \"Diseased\", value: \"diseased\" },\n  { name: \"Disease\", value: \"diseased\" },\n];\n\nconst DAMAGE_TYPES = [\n  \"acid\",\n  \"bludgeoning\",\n  \"cold\",\n  \"fire\",\n  \"force\",\n  \"lightning\",\n  \"necrotic\",\n  \"piercing\",\n  \"poison\",\n  \"psychic\",\n  \"radiant\",\n  \"slashing\",\n  \"thunder\",\n];\n\n\nfunction getAdjustmentsConfig(type, DDB_CONFIG) {\n  const damageAdjustments = DDB_CONFIG.damageAdjustments;\n\n  switch (type) {\n    case \"resistances\":\n      return damageAdjustments.filter((adj) => adj.type == 1);\n    case \"immunities\":\n      return damageAdjustments.filter((adj) => adj.type == 2);\n    case \"vulnerabilities\":\n      return damageAdjustments.filter((adj) => adj.type == 3);\n    case \"conditions\":\n      return DDB_CONFIG.conditions.map((condition) => {\n        return {\n          id: condition.definition.id,\n          name: condition.definition.name,\n          type: condition.definition.type,\n          slug: condition.definition.slug,\n        };\n      });\n    default:\n      return null;\n  }\n}\n\nfunction getDamageAdjustments(monster, type, DDB_CONFIG) {\n  const config = getAdjustmentsConfig(type, DDB_CONFIG);\n\n  let values = [];\n  let custom = [];\n\n  monster.damageAdjustments.forEach((adj) => {\n    const adjustment = config.find((cadj) => adj === cadj.id);\n    if (adjustment && DAMAGE_TYPES.includes(adjustment.name.toLowerCase())) {\n      values.push(adjustment.name.toLowerCase());\n    } else if (adjustment && adjustment.slug === \"bludgeoning-piercing-and-slashing-from-nonmagical-attacks\") {\n      values.push(\"physical\");\n    } else if (adjustment) {\n      const midiQolInstalled = utils.isModuleInstalledAndActive(\"midi-qol\");\n      if (midiQolInstalled) {\n        if (adjustment.name.toLowerCase().includes(\"silvered\")) {\n          values.push(\"silver\");\n        } else if (adjustment.name.toLowerCase().includes(\"adamantine\")) {\n          values.push(\"adamant\");\n        } else if (adjustment.slug === \"damage-from-spells\") {\n          values.push(\"spell\");\n        } else {\n          custom.push(adjustment.name);\n        }\n      } else {\n        custom.push(adjustment.name);\n      }\n    }\n  });\n\n  const adjustments = {\n    value: values,\n    custom: custom.join(\"; \"),\n  };\n\n  return adjustments;\n}\n\nexport function getDamageImmunities(monster, DDB_CONFIG) {\n  return getDamageAdjustments(monster, \"immunities\", DDB_CONFIG);\n}\n\nexport function getDamageResistances(monster, DDB_CONFIG) {\n  return getDamageAdjustments(monster, \"resistances\", DDB_CONFIG);\n}\nexport function getDamageVulnerabilities(monster, DDB_CONFIG) {\n  return getDamageAdjustments(monster, \"vulnerabilities\", DDB_CONFIG);\n}\nexport function getConditionImmunities(monster, DDB_CONFIG) {\n  const config = getAdjustmentsConfig(\"conditions\", DDB_CONFIG);\n\n  let values = [];\n  let custom = [];\n\n  monster.conditionImmunities.forEach((adj) => {\n    const adjustment = config.find((cadj) => adj === cadj.id);\n    const valueAdjustment = CONDITION_TYPES.find((condition) => condition.name.toLowerCase() == adjustment.name.toLowerCase());\n    if (adjustment && valueAdjustment) {\n      values.push(valueAdjustment.value);\n    } else if (adjustment) {\n      custom.push(adjustment.name);\n    }\n  });\n\n  const adjustments = {\n    value: values,\n    custom: custom.join(\"; \"),\n  };\n\n  return adjustments;\n}\n","const LANGUAGES = [\n  { name: \"Common\", value: \"common\" },\n  { name: \"Aarakocra\", value: \"aarakocra\" },\n  { name: \"Abyssal\", value: \"abyssal\" },\n  { name: \"Aquan\", value: \"aquan\" },\n  { name: \"Auran\", value: \"auran\" },\n  { name: \"Celestial\", value: \"celestial\" },\n  { name: \"Deep Speech\", value: \"deep\" },\n  { name: \"Draconic\", value: \"draconic\" },\n  { name: \"Druidic\", value: \"druidic\" },\n  { name: \"Dwarvish\", value: \"dwarvish\" },\n  { name: \"Elvish\", value: \"elvish\" },\n  { name: \"Giant\", value: \"giant\" },\n  { name: \"Gith\", value: \"gith\" },\n  { name: \"Gnomish\", value: \"gnomish\" },\n  { name: \"Goblin\", value: \"goblin\" },\n  { name: \"Gnoll\", value: \"gnoll\" },\n  { name: \"Halfling\", value: \"halfling\" },\n  { name: \"Ignan\", value: \"ignan\" },\n  { name: \"Infernal\", value: \"infernal\" },\n  { name: \"Orc\", value: \"orc\" },\n  { name: \"Primordial\", value: \"primordial\" },\n  { name: \"Terran\", value: \"terran\" },\n  { name: \"Sylvan\", value: \"sylvan\" },\n  { name: \"Thieves' Cant\", value: \"cant\" },\n  { name: \"Thieves Cant\", value: \"cant\" },\n  { name: \"Undercommon\", value: \"undercommon\" },\n];\n\n\n//      \"languages\": {\n//   \"value\": [\n//     \"common\",\n//     \"draconic\"\n//   ],\n//   \"custom\": \"\"\n// },\nexport function getLanguages (monster, DDB_CONFIG) {\n  const config = DDB_CONFIG.languages;\n\n  let values = [];\n  let custom = [];\n\n  monster.languages.forEach((lng) => {\n    const language = config.find((cfg) => lng.languageId == cfg.id);\n    const foundryLanguage = LANGUAGES.find((lang) => lang.name == language.name);\n    if (foundryLanguage && lng.notes == '') {\n      values.push(foundryLanguage.value);\n    } else {\n      const notes = (lng.notes !== '') ? ` ${lng.notes}` : \"\";\n      custom.push(language.name + notes);\n    }\n  });\n\n  custom.push(monster.languageNote);\n\n  const languages = {\n    value: values,\n    custom: custom.join(\"; \"),\n  };\n\n  return languages;\n}\n","\n\n// \"hp\": {\n//   \"value\": 0,\n//   \"min\": 0,\n//   \"max\": 0,\n//   \"temp\": 0,\n//   \"tempmax\": 0,\n//   \"formula\": \"\"\n// },\n\n// \"hp\": {\n//   \"value\": 367,\n//   \"min\": 0,\n//   \"max\": 367,\n//   \"temp\": 0,\n//   \"tempmax\": 0,\n//   \"formula\": \"21d20 + 147\"\n// },\n\n// data.\n// \"hitPointDice\": {\n//   \"diceCount\": 21,\n//   \"diceValue\": 20,\n//   \"diceMultiplier\": 0,\n//   \"fixedValue\": 147,\n//   \"diceString\": \"21d20 + 147\"\n// },\n\n\nexport function getHitPoints (monster, removedHitPoints, temporaryHitPoints) {\n  const hitPointDice = monster.hitPointDice;\n  // const maxHP = (hitPointDice.diceCount * hitPointDice.diceValue) + hitPointDice.fixedValue;\n\n  const hp = {\n    \"value\": monster.averageHitPoints - removedHitPoints,\n    \"min\": 0,\n    \"max\": monster.averageHitPoints,\n    \"temp\": temporaryHitPoints,\n    \"tempmax\": 0,\n    \"formula\": hitPointDice.diceString,\n  };\n\n  return hp;\n}\n","// \"movements\": [\n//   {\n//     \"movementId\": 1,\n//     \"speed\": 40,\n//     \"notes\": null\n// },\n// {\n//     \"movementId\": 4,\n//     \"speed\": 80,\n//     \"notes\": null\n// },\n// {\n//     \"movementId\": 5,\n//     \"speed\": 40,\n//     \"notes\": null\n// }\n// ],\n\n// \"speed\": {\n//   \"value\": \"40 ft.\",\n//   \"special\": \"Fly 80 ft., Swim 40 ft.\"\n// },\nexport function getSpeed (monster, DDB_CONFIG) {\n  const movementConfig = DDB_CONFIG.movements;\n  const monsterMovements = monster.movements;\n\n  let values = \"\";\n  let special = [];\n\n  let movements = {\n    burrow: 0,\n    climb: 0,\n    fly: 0,\n    swim: 0,\n    walk: 0,\n    units: \"ft\",\n    hover: false,\n  };\n\n  monsterMovements.forEach((monsterMovement) => {\n    const movement = movementConfig.find((mv) => mv.id == monsterMovement.movementId);\n    movements[movement.name.toLowerCase()] = monsterMovement.speed;\n\n    if (monsterMovement.notes && monsterMovement.notes.toLowerCase().includes('hover')) movements.hover = true;\n\n    if (movement.name == \"Walk\") {\n      values = `${monsterMovement.speed}ft.`;\n      if (monsterMovement.notes !== null) {\n        special.push(`${monsterMovement.speed}ft. ${movement.description} (${monsterMovement.notes})`);\n      }\n    } else {\n      const noteMovement = monsterMovement.notes ? ` ${monsterMovement.notes}` : \"\";\n      const specialMovement = `${monsterMovement.speed}ft ${movement.description}${noteMovement}`;\n      special.push(specialMovement);\n    }\n  });\n\n  const speed = {\n    value: values,\n    special: special.join(\", \"),\n  };\n\n  return {\n    speed: speed,\n    movement: movements,\n  };\n\n}\n","// \"creatureSizes\": [{\n//   \"id\": 2,\n//   \"entityTypeId\": 127108918,\n//   \"name\": \"Tiny\",\n//   \"weightType\": 1\n// }, {\n\n\n//   \"traits\": {\n//     \"size\": \"grg\",\n\n\n//     \"sizeId\": 7,\n\nimport logger from '../../logger.js';\n\nconst SIZES = [\n  { name: \"Tiny\", value: \"tiny\", size: 0.5 },\n  { name: \"Small\", value: \"sm\", size: 0.8 },\n  { name: \"Medium\", value: \"med\", size: 1 },\n  { name: \"Large\", value: \"lg\", size: 2 },\n  { name: \"Huge\", value: \"huge\", size: 3 },\n  { name: \"Gargantuan\", value: \"grg\", size: 4 },\n];\n\nexport function getSizeFromId(sizeId, DDB_CONFIG) {\n  const size = DDB_CONFIG.creatureSizes.find((s) => s.id == sizeId).name;\n  const sizeData = SIZES.find((s) => size == s.name);\n\n  if (!sizeData) {\n    logger.warn(`No size found for, using medium`, size);\n    return { name: \"Medium\", value: \"med\", size: 1 };\n  }\n  return sizeData;\n}\n\nexport function getSize (monster, DDB_CONFIG) {\n  const sizeData = getSizeFromId(monster.sizeId, DDB_CONFIG);\n  const token = {\n    scale: sizeData.size >= 1 ? 1 : sizeData.size,\n    value: sizeData.size >= 1 ? sizeData.size : 1,\n  };\n\n  const data = {\n    value: sizeData.value,\n    token: token,\n  };\n\n  return data;\n\n}\n","export function getSource(monster, DDB_CONFIG) {\n  const fullSource = game.settings.get(\"ddb-importer\", \"use-full-source\");\n  const sourceObject = DDB_CONFIG.sources.find((cnf) => cnf.id == monster.sourceId);\n  const sourceBook = (sourceObject)\n    ? (fullSource) ? sourceObject.description : sourceObject.name\n    : \"Homebrew\";\n  const page = (monster.sourcePageNumber) ? ` pg ${monster.sourcePageNumber}` : \"\";\n  const source = `${sourceBook}${page}`;\n  return source;\n}\n","\nexport function getEnvironments(monster, DDB_CONFIG) {\n  const environments = monster.environments.filter((env) =>\n    DDB_CONFIG.environments.some((c) => env == c.id)\n  ).map((env) => {\n    return DDB_CONFIG.environments.find((c) => env == c.id).name;\n  });\n\n  return environments.join(\", \");\n}\n","import utils from '../../../utils.js';\n\nexport function newFeat(name) {\n  let feat = {\n    name: name,\n    type: \"feat\",\n    data: JSON.parse(utils.getTemplate(\"feat\")),\n    flags: {\n      ddbimporter: {\n        dndbeyond: {\n        },\n      },\n    },\n  };\n  return feat;\n};\n","const DICTIONARY = {\n  weapons: [\n    { name: \"Hand Crossbow\", actionType: \"rwak\", weaponType: \"martialR\", properties: { amm: true, lgt: true, lod: true } },\n    { name: \"Glaive\", actionType: \"mwak\", weaponType: \"martialM\", properties: { hvy: true, rch: true, two: true } },\n    { name: \"Dagger\", actionType: \"mwak\", weaponType: \"simpleM\", properties: { lgt: true, fin: true, thr: true } },\n    { name: \"Longsword\", actionType: \"mwak\", weaponType: \"martialM\", properties: { ver: true } },\n    { name: \"Club\", actionType: \"mwak\", weaponType: \"simpleM\", properties: { lgt: true } },\n    { name: \"Greatclub\", actionType: \"mwak\", weaponType: \"simpleM\", properties: { two: true } },\n    { name: \"Handaxe\", actionType: \"mwak\", weaponType: \"simpleM\", properties: { lgt: true, thr: true } },\n    { name: \"Javelin\", actionType: \"mwak\", weaponType: \"simpleM\", properties: { thr: true } },\n    { name: \"Light Hammer\", actionType: \"mwak\", weaponType: \"simpleM\", properties: { lgt: true, thr: true } },\n    { name: \"Mace\", actionType: \"mwak\", weaponType: \"simpleM\", properties: {} },\n    { name: \"Quarterstaff\", actionType: \"mwak\", weaponType: \"simpleM\", properties: { ver: true } },\n    { name: \"Sickle\", actionType: \"mwak\", weaponType: \"simpleM\", properties: { lgt: true } },\n    { name: \"Spear\", actionType: \"mwak\", weaponType: \"simpleM\", properties: { thr: true, ver: true } },\n    { name: \"Light Crossbow\", actionType: \"rwak\", weaponType: \"simpleR\", properties: { amm: true, lod: true, two: true } },\n    { name: \"Dart\", actionType: \"rwak\", weaponType: \"simpleR\", properties: { fin: true, thr: true } },\n    { name: \"Shortbow\", actionType: \"rwak\", weaponType: \"simpleR\", properties: { amm: true, two: true } },\n    { name: \"Sling\", actionType: \"rwak\", weaponType: \"simpleR\", properties: { amm: true } },\n    { name: \"Battleaxe\", actionType: \"mwak\", weaponType: \"martialM\", properties: { ver: true } },\n    { name: \"Flail\", actionType: \"mwak\", weaponType: \"martialM\", properties: {} },\n    { name: \"Greataxe\", actionType: \"mwak\", weaponType: \"martialM\", properties: { hvy: true, two: true } },\n    { name: \"Greatsword\", actionType: \"mwak\", weaponType: \"martialM\", properties: { hvy: true, two: true } },\n    { name: \"Halberd\", actionType: \"mwak\", weaponType: \"martialM\", properties: { hvy: true, two: true, rch: true } },\n    { name: \"Lance\", actionType: \"mwak\", weaponType: \"martialM\", properties: { rch: true, spc: true } },\n    { name: \"Maul\", actionType: \"mwak\", weaponType: \"martialM\", properties: { hvy: true, two: true } },\n    { name: \"Morningstar\", actionType: \"mwak\", weaponType: \"martialM\", properties: {} },\n    { name: \"Pike\", actionType: \"mwak\", weaponType: \"martialM\", properties: { hvy: true, two: true, rch: true } },\n    { name: \"Rapier\", actionType: \"mwak\", weaponType: \"martialM\", properties: { fin: true } },\n    { name: \"Scimitar\", actionType: \"mwak\", weaponType: \"martialM\", properties: { fin: true, lgt: true } },\n    { name: \"Shortsword\", actionType: \"mwak\", weaponType: \"martialM\", properties: { fin: true, lgt: true } },\n    { name: \"Trident\", actionType: \"mwak\", weaponType: \"martialM\", properties: { ver: true, thr: true } },\n    { name: \"War Pick\", actionType: \"mwak\", weaponType: \"martialM\", properties: {} },\n    { name: \"Warhammer\", actionType: \"mwak\", weaponType: \"martialM\", properties: { ver: true } },\n    { name: \"Whip\", actionType: \"mwak\", weaponType: \"martialM\", properties: { fin: true, rch: true } },\n    { name: \"Blowgun\", actionType: \"rwak\", weaponType: \"martialR\", properties: { amm: true, lod: true } },\n    { name: \"Heavy Crossbow\", actionType: \"rwak\", weaponType: \"martialR\", properties: { amm: true, hvy: true, two: true, lod: true } },\n    { name: \"Longbow\", actionType: \"rwak\", weaponType: \"martialR\", properties: { amm: true, hvy: true, two: true } },\n    { name: \"Net\", actionType: \"mwak\", weaponType: \"martialR\", properties: { spc: true, thw: true } },\n    { name: \"Boomerang\", actionType: \"rwak\", weaponType: \"simpleR\", properties: { amm: true } },\n    { name: \"Yklwa\", actionType: \"rwak\", weaponType: \"simpleR\", properties: { amm: true } },\n    { name: \"Pistol\", actionType: \"rwak\", weaponType: \"martialR\", properties: { amm: true, lod: true, fir: true } },\n    { name: \"Musket\", actionType: \"rwak\", weaponType: \"martialR\", properties: { amm: true, lod: true, fir: true } },\n    { name: \"Bite\", actionType: \"mwak\", weaponType: \"natural\", properties: {} },\n    { name: \"Claw\", actionType: \"mwak\", weaponType: \"natural\", properties: {} },\n    { name: \"Tail\", actionType: \"mwak\", weaponType: \"natural\", properties: {} },\n    { name: \"Wing\", actionType: \"mwak\", weaponType: \"natural\", properties: {} },\n    { name: \"Slam\", actionType: \"mwak\", weaponType: \"natural\", properties: {} },\n    { name: \"Rake\", actionType: \"mwak\", weaponType: \"natural\", properties: {} },\n    { name: \"Beak\", actionType: \"mwak\", weaponType: \"natural\", properties: {} },\n    { name: \"Tentacles\", actionType: \"mwak\", weaponType: \"natural\", properties: {} },\n  ],\n  resets: [\n    { id: 1, value: \"sr\" },\n    { id: \"ShortRest\", value: \"sr\" },\n    { id: \"Short\", value: \"sr\" },\n    { id: \"short\", value: \"sr\" },\n    { id: 2, value: \"lr\" },\n    { id: \"LongRest\", value: \"lr\" },\n    { id: \"Long\", value: \"lr\" },\n    { id: \"long\", value: \"lr\" },\n    { id: \"Day\", value: \"day\" },\n    { id: \"day\", value: \"day\" },\n    { id: \"Dawn\", value: \"day\" },\n    { id: \"dusk\", value: \"day\" },\n    { id: \"Consumable\", value: \"charges\" },\n    { id: \"Other\", value: \"charges\" },\n  ],\n};\nexport default DICTIONARY;\n\n","import DICTIONARY from './dict.js';\nimport { getAbilityMods } from \"./abilities.js\";\nimport logger from '../../logger.js';\nimport utils from '../../utils.js';\n\n// replaces matchAll, requires a non global regexp\nfunction reMatchAll(regexp, string) {\n  const matches = string.match(new RegExp(regexp, \"gm\"));\n  if (matches) {\n    let start = 0;\n    return matches.map((group0) => {\n      const match = group0.match(regexp);\n      match.index = string.indexOf(group0, start);\n      start = match.index;\n      return match;\n    });\n  }\n  return matches;\n}\n\n// some monsters now have [rollable] tags - if these exist we need to parse them out\n// in the future we may be able to use them, but not consistent yet\nexport function replaceRollable(text) {\n  const rollableRegex = new RegExp(/(\\[rollable\\])([^;]*);(.*)(\\[\\/rollable\\])/);\n  const rollableMatches = reMatchAll(rollableRegex, text) || [];\n  for (let match of rollableMatches) {\n    if (match[2]) {\n      text = text.replace(match[0], match[2]);\n    }\n  }\n  return text;\n}\n\nfunction damageModReplace(text, attackInfo, damageType) {\n  let result;\n  const globalDamageHints = game.settings.get(\"ddb-importer\", \"use-damage-hints\");\n  const damageHint = globalDamageHints && damageType ? `[${damageType}]` : \"\";\n  const diceParse = utils.parseDiceString(text, null, damageHint);\n  if (attackInfo.baseAbility) {\n    const baseAbilityMod = attackInfo.abilities[attackInfo.baseAbility];\n    const bonusMod = (diceParse.bonus && diceParse.bonus !== 0) ? diceParse.bonus - baseAbilityMod : \"\";\n    const useMod = (diceParse.bonus && diceParse.bonus !== 0) ? \" + @mod \" : \"\";\n    const reParse = utils.diceStringResultBuild(diceParse.diceMap, diceParse.dice, bonusMod, useMod, damageHint);\n    result = reParse.diceString;\n  } else {\n    result = diceParse.diceString;\n  }\n\n  return result;\n}\n\n// eslint-disable-next-line complexity\nfunction getExtendedDamage(description, attackInfo) {\n  let result = {\n    damage: {\n      parts: [],\n      versatile: \"\"\n    },\n    save: {\n      dc: null,\n      ability: null\n    },\n    formula: \"\",\n  };\n\n  const hitIndex = description.indexOf(\"Hit:\");\n  let hit = description;\n  if (hitIndex > 0) hit = description.slice(hitIndex);\n  hit = hit.replace(/[-]/g, \"-\");\n  // console.warn(hit);\n  // Using match with global modifier then map to regular match because RegExp.matchAll isn't available on every browser\n  // eslint-disable-next-line no-useless-escape\n  const damageExpression = new RegExp(/([\\w]* )(?:([0-9]+))?(?:\\s*\\(?([0-9]*d[0-9]+(?:\\s*[-+]\\s*[0-9]+)?(?:\\s+plus [^\\)]+)?)\\)?)?\\s*([\\w ]*?)\\s*damage(?: when used with | if used with )?(\\s?two hands|\\s?at the start of)?/);\n  const matches = reMatchAll(damageExpression, hit) || [];\n  const regainExpression = new RegExp(/(regains)\\s+?(?:([0-9]+))?(?: *\\(?([0-9]*d[0-9]+(?:\\s*[-+]\\s*[0-9]+)??)\\)?)?\\s+hit\\s+points/);\n  const regainMatch = hit.match(regainExpression);\n\n  // console.warn(matches);\n  let versatile = false;\n  for (let dmg of matches) {\n    let other = false;\n    if (dmg[1] == \"DC \" || dmg[4] == \"hit points by this\") {\n      continue; // eslint-disable-line no-continue\n    }\n    // check for versatile\n    if (dmg[1] == \"or \" || dmg[5] == \"two hands\") {\n      versatile = true;\n    }\n    // check for other\n    if (dmg[5] && dmg[5].trim() == \"at the start of\") other = true;\n    const damage = dmg[3] || dmg[2];\n    // Make sure we did match a damage\n    if (damage) {\n      const includesDiceRegExp = /[0-9]*d[0-9]+/;\n      const includesDice = includesDiceRegExp.test(damage);\n      const finalDamage = (attackInfo && includesDice)\n        ? damageModReplace(damage.replace(\"plus\", \"+\"), attackInfo, dmg[4])\n        : damage.replace(\"plus\", \"+\");\n      // assumption here is that there is just one field added to versatile. this is going to be rare.\n      if (other) {\n        if (result.formula == \"\") result.formula = finalDamage;\n      } else if (versatile) {\n        if (result.damage.versatile == \"\") result.damage.versatile = finalDamage;\n        // so things like the duergar mind master have oddity where we might want to use a different thing\n        // } else {\n        //   result.damage.versatile += ` + ${finalDamage}`;\n        // }\n      } else {\n        result.damage.parts.push([finalDamage, dmg[4]]);\n      }\n    }\n  }\n\n  if (regainMatch) {\n    const globalDamageHints = game.settings.get(\"ddb-importer\", \"use-damage-hints\");\n    const damageHint = globalDamageHints ? `[healing]` : \"\";\n    result.damage.parts.push([utils.parseDiceString(regainMatch[3], null, damageHint).diceString, 'healing']);\n  }\n\n  const save = hit.match(/DC ([0-9]+) (.*?) saving throw/);\n  if (save) {\n    result.save.dc = save[1];\n    result.save.ability = save[2].toLowerCase().substr(0, 3);\n  } else {\n    const escape = hit.match(/escape DC ([0-9]+)/);\n    if (escape) {\n      result.save.dc = escape[1];\n      result.save.ability = \"Escape\";\n    }\n  }\n\n  return result;\n}\n\nexport function getDamage(description) {\n  const extendedDamage = getExtendedDamage(description);\n  return extendedDamage.damage;\n}\n\nexport function getAction(text, type = \"action\") {\n  let action = type;\n  // fodunry doesn't support mythic actions\n  if (type === \"mythic\") action = \"special\";\n  const actionAction = text.toLowerCase().match(/as (a|an) action/);\n  const bonusAction = text.toLowerCase().match(/as a bonus action/);\n  const reAction = text.toLowerCase().match(/as a reaction/);\n  // e.g. mephit death\n  const specialDie = text.toLowerCase().match(/dies/);\n  if (bonusAction) {\n    action = \"bonus\";\n  } else if (reAction) {\n    action = \"reaction\";\n  } else if (specialDie) {\n    action = \"special\";\n  } else if (actionAction) {\n    action = \"action\";\n  }\n  return action;\n}\n\nexport function getUses(text, name = false) {\n  let uses = {\n    value: 0,\n    max: 0,\n    per: null,\n  };\n\n  const usesSearch = name ? /(\\d+)\\/(\\w+)\\)/ : /\\((\\d+)\\/(\\w+)\\)/;\n  const usesMatch = text.match(usesSearch);\n  // console.log(usesMatch);\n  if (usesMatch && usesMatch[2].toLowerCase() !== \"turn\") {\n    uses.value = usesMatch[1];\n    uses.max = usesMatch[1];\n    uses.per = \"day\";\n    const perMatch = DICTIONARY.resets.find((reset) => reset.id === usesMatch[2]);\n    if (perMatch) uses.per = perMatch.value;\n  }\n\n  return uses;\n}\n\nexport function getRecharge(text) {\n  const matches = text.toLowerCase().match(/\\(recharge ([0-9-]+)\\)/);\n  if (matches) {\n    const value = matches[1].replace(/[-]/, \"-\").split(\"-\").shift();\n    return {\n      value: parseInt(value),\n      charged: true\n    };\n  }\n\n  return {\n    value: null,\n    charged: null\n  };\n}\n\nexport function getActivation(text) {\n  const matches = text.toLowerCase().match(/\\(costs ([0-9]+) actions\\)/i);\n  if (matches) return parseInt(matches[1]);\n  return null;\n}\n\nexport function getFeatSave(text, save) {\n  const saveSearch = /DC (\\d+) (\\w+) saving throw/;\n  const match = text.match(saveSearch);\n  if (match) {\n    save.dc = parseInt(match[1]);\n    save.ability = match[2].toLowerCase().substr(0, 3);\n    save.scaling = \"flat\";\n  }\n  return save;\n}\n\nexport function getReach(text) {\n  const reachSearch = /reach\\s*(\\s*\\d+\\s*)\\s*ft/;\n  const match = text.match(reachSearch);\n  if (match) {\n    return match[1];\n  }\n  return \"\";\n}\n\nexport function getRange(text) {\n  let range = {\n    value: null,\n    long: null,\n    units: \"\",\n  };\n\n  const rangeSearch1 = /range\\s*(\\d+)\\s*\\s*\\/\\s*(\\d+)\\s*\\s*ft/;\n  const rangeSearch2 = /range\\s*(\\d+)\\s*ft[.]*\\s*\\s*\\/\\s*(\\d+)\\s*\\s*ft/;\n  const rangeSearch3 = /range\\s*(\\d+)\\s*\\s*ft/;\n  const reachSearch = /reach\\s*(\\d+)\\s*\\s*ft/;\n\n  const matches1 = text.match(rangeSearch1);\n  const matches2 = text.match(rangeSearch2);\n  const matches3 = text.match(rangeSearch3);\n  const reachMatch = text.match(reachSearch);\n\n  if (matches1) {\n    range.value = parseInt(matches1[1]);\n    range.long = parseInt(matches1[2]);\n    range.units = \"ft\";\n  } else if (matches2) {\n    range.value = parseInt(matches2[1]);\n    range.long = parseInt(matches2[2]);\n    range.units = \"ft\";\n  } else if (matches3) {\n    range.value = parseInt(matches3[1]);\n    range.units = \"ft\";\n  } else if (reachMatch) {\n    range.value = parseInt(reachMatch[1]);\n    range.units = \"ft\";\n  }\n\n  return range;\n}\n\nfunction checkAbility(abilities, mods, proficiencyBonus, target) {\n  let result = {\n    success: false,\n    ability: null,\n    proficient: null\n  };\n\n  for (const ability of abilities) {\n    if (target == proficiencyBonus + mods[ability]) {\n      result.success = true;\n      result.ability = ability;\n      result.proficient = true;\n      break;\n    } else if (result.toHit == mods[ability]) {\n      result.success = true;\n      result.ability = ability;\n      result.proficient = false;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction checkAbilities(abilities, mods, proficiencyBonus, target, negatives = false) {\n\n  const results = abilities.map((ability) => {\n    let result = {\n      success: false,\n      ability: ability,\n      proficient: null,\n      bonus: 0\n    };\n    if (target > proficiencyBonus + mods[ability]) {\n      result.success = true;\n      result.proficient = true;\n      result.bonus = target - proficiencyBonus - mods[ability];\n    } else if (result.toHit > mods[ability]) {\n      result.success = true;\n      result.proficient = false;\n      result.bonus = target - mods[ability];\n    } else if (negatives) {\n      result.success = true;\n      result.proficient = false;\n      result.bonus = target - mods[ability];\n    }\n    return result;\n  });\n\n  return results;\n}\n\nfunction getWeaponAttack(resultData, proficiencyBonus) {\n  let result = JSON.parse(JSON.stringify(resultData));\n  const abilities = [\"str\", \"dex\", \"int\", \"wis\", \"cha\", \"con\"];\n  let initialAbilities = [];\n  let weaponAbilities = [\"str\", \"dex\"];\n  let spellAbilities = [\"cha\", \"wis\", \"int\"];\n\n  const lookup = DICTIONARY.weapons.find((weapon) => result.name.startsWith(weapon.name));\n  // we have a weapon name match so we can infer a bit more\n  if (lookup) {\n    for (const [key, value] of Object.entries(lookup.properties)) {\n      // logger.info(`${key}: ${value}`);\n      result.properties[key] = value;\n    }\n    const versatileWeapon = result.properties.ver && result.abilities['dex'] > result.abilities['str'];\n    if (versatileWeapon || lookup.actionType == \"rwak\") {\n      weaponAbilities = [\"dex\"];\n    } else if (lookup.actionType == \"mwak\") {\n      weaponAbilities = [\"str\"];\n    }\n    result.weaponType = lookup.weaponType;\n  }\n\n  if (result.spellAttack) {\n    initialAbilities = spellAbilities;\n  } else if (result.weaponAttack) {\n    initialAbilities = weaponAbilities;\n  } else {\n    initialAbilities = abilities;\n  }\n\n  if (result.weaponAttack || result.spellAttack) {\n    // check most likely initial attacks - str and dex based weapon, mental for spell\n    const checkInitialAbilities = checkAbility(initialAbilities, result.abilities, proficiencyBonus, result.toHit);\n    if (checkInitialAbilities.success) {\n      result.baseAbility = checkInitialAbilities.ability;\n      result.proficient = checkInitialAbilities.proficient;\n    }\n\n    // okay lets see if its one of the others then!\n    if (!result.baseAbility) {\n      const checkAllAbilities = checkAbility(abilities, result.abilities, proficiencyBonus, result.toHit);\n      if (checkAllAbilities.success) {\n        result.baseAbility = checkAllAbilities.ability;\n        result.proficient = checkAllAbilities.proficient;\n      }\n    }\n\n    // okay, some oddity, maybe magic bonus, lets calculate one!\n    // we are going to assume it's dex or str based.\n    if (!result.baseAbility) {\n      const magicAbilities = checkAbilities(initialAbilities, result.abilities, proficiencyBonus, result.toHit);\n      // logger.info(magicAbilities);\n\n      const filteredAbilities = magicAbilities.filter((ab) => ab.success == true).sort((a, b) => {\n        if (a.proficient == !b.proficient) return -1;\n        if (b.proficient == !a.proficient) return 1;\n        if (a.proficient == b.proficient) {\n          if (a.bonus > b.bonus) return 1;\n          if (b.bonus > a.bonus) return -1;\n        }\n        return 0;\n      });\n\n      // fine lets use the first hit\n      if (filteredAbilities.length >= 1 && filteredAbilities[0].success) {\n        result.baseAbility = filteredAbilities[0].ability;\n        result.proficient = filteredAbilities[0].proficient;\n        result.extraAttackBonus = filteredAbilities[0].bonus;\n      }\n    }\n\n    // negative mods!\n    if (!result.baseAbility) {\n      logger.info(`Negative ability parse for ${result.monsterName}, to hit ${result.toHit} with ${result.name}`);\n\n      const magicAbilities = checkAbilities(initialAbilities, result.abilities, proficiencyBonus, result.toHit, true);\n      // logger.info(magicAbilities);\n\n      const filteredAbilities = magicAbilities.filter((ab) => ab.success == true).sort((a, b) => {\n        if (a.proficient == !b.proficient) return -1;\n        if (b.proficient == !a.proficient) return 1;\n        if (a.proficient == b.proficient) {\n          if (a.bonus < b.bonus) return 1;\n          if (b.bonus < a.bonus) return -1;\n        }\n        return 0;\n      });\n      logger.debug(\"Filtered abilities\", filteredAbilities);\n      logger.debug(result.text);\n      // fine lets use the first hit\n      if (filteredAbilities.length >= 1 && filteredAbilities[0].success) {\n        result.baseAbility = filteredAbilities[0].ability;\n        result.proficient = filteredAbilities[0].proficient;\n        result.extraAttackBonus = filteredAbilities[0].bonus;\n      } else {\n        logger.error(\"Unable to calculate attack!\");\n        logger.info(result.text);\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function getTarget(text) {\n  let target = {\n    \"value\": null,\n    \"width\": null,\n    \"units\": \"\",\n    \"type\": \"\"\n  };\n\n  // 90-foot line that is 10 feet wide\n  // in a 90-foot cone\n  const matchText = text.replace(/[-]/gu, \"-\").replace(/-+/g, \"-\");\n  // console.warn(matchText);\n  const lineSearch = /(\\d+)-foot line/;\n  const coneSearch = /(\\d+)-foot cone/;\n  const cubeSearch = /(\\d+)-foot cube/;\n  const sphereSearch = /(\\d+)-foot-radius sphere/;\n\n  const coneMatch = matchText.match(coneSearch);\n  const lineMatch = matchText.match(lineSearch);\n  const cubeMatch = matchText.match(cubeSearch);\n  const sphereMatch = matchText.match(sphereSearch);\n\n  // console.log(coneMatch);\n  // console.log(lineMatch);\n  // console.log(cubeMatch);\n  // console.log(sphereMatch);\n\n  if (coneMatch) {\n    target.value = parseInt(coneMatch[1]);\n    target.units = \"ft\";\n    target.type = \"cone\";\n  } else if (lineMatch) {\n    target.value = parseInt(lineMatch[1]);\n    target.units = \"ft\";\n    target.type = \"line\";\n  } else if (cubeMatch) {\n    target.value = parseInt(cubeMatch[1]);\n    target.units = \"ft\";\n    target.type = \"cube\";\n  } else if (sphereMatch) {\n    target.value = parseInt(sphereMatch[1]);\n    target.units = \"ft\";\n    target.type = \"sphere\";\n  }\n\n  return target;\n}\n\nexport function getActionInfo(monster, DDB_CONFIG, name, text) {\n  const matches = text.match(\n    /(Melee|Ranged|Melee\\s+or\\s+Ranged)\\s+(|Weapon|Spell)\\s*Attack:\\s*([+-]\\d+)\\s+to\\s+hit/i\n  );\n  const proficiencyBonus = DDB_CONFIG.challengeRatings.find((cr) => cr.id == monster.challengeRatingId).proficiencyBonus;\n  const abilities = getAbilityMods(monster, DDB_CONFIG);\n\n  replaceRollable(text);\n\n  let result = {\n    monsterName: monster.name,\n    name: name,\n    abilities: abilities,\n    weaponAttack: false,\n    spellAttack: false,\n    meleeAttack: false,\n    rangedAttack: false,\n    weaponType: null,\n    toHit: 0,\n    damage: {\n      parts: [],\n      versatile: \"\"\n    },\n    target: {\n      \"value\": null,\n      \"width\": null,\n      \"units\": \"\",\n      \"type\": \"\"\n    },\n    duration: {\n      \"value\": null,\n      \"units\": \"inst\"\n    },\n    extraAttackBonus: 0,\n    baseAbility: null,\n    proficient: false,\n    properties: {\n      \"amm\": false,\n      \"fin\": false,\n      \"fir\": false,\n      \"foc\": false,\n      \"hvy\": false,\n      \"lgt\": false,\n      \"lod\": false,\n      \"rch\": false,\n      \"rel\": false,\n      \"ret\": false,\n      \"spc\": false,\n      \"thr\": false,\n      \"two\": false,\n      \"ver\": false\n    },\n    reach: \"\",\n    range: {\n      value: null,\n      long: null,\n      units: \"\",\n    },\n    recharge: { value: null, charged: true },\n    activation: null,\n    save: {\n      dc: null,\n      ability: null,\n      scaling: \"flat\",\n    },\n    text: text,\n    uses: {\n      value: 0,\n      max: 0,\n      per: null,\n    },\n  };\n  if (matches) {\n    result.isAttack = matches[1] !== undefined;\n    result.weaponAttack = matches[2].toLowerCase() === \"weapon\" || matches[2] === \"\";\n    result.spellAttack = matches[2].toLowerCase() === \"spell\";\n    result.meleeAttack = matches[1].indexOf(\"Melee\") !== -1;\n    result.rangedAttack = matches[1].indexOf(\"Ranged\") !== -1;\n    result.toHit = parseInt(matches[3]);\n  }\n\n  if (result.weaponAttack || result.spellAttack) {\n    result = getWeaponAttack(result, proficiencyBonus);\n  }\n  const damage = getExtendedDamage(text, result);\n  result.damage = damage.damage;\n  result.formula = damage.formula;\n\n  result.reach = getReach(text);\n  result.range = getRange(text);\n  if (result.reach != \"\") result.properties.rch = true;\n  result.recharge = getRecharge(name);\n  result.activation = getActivation(text);\n  result.save = getFeatSave(text, result.save);\n  result.target = getTarget(text);\n  result.uses = getUses(text);\n\n  return result;\n}\n\nexport function stripHtml(html) {\n  let tmp = document.createElement(\"DIV\");\n  tmp.innerHTML = html;\n  return tmp.textContent || tmp.innerText || \"\";\n}\n","import { getSource } from \"../source.js\";\nimport { newFeat } from \"../templates/feat.js\";\nimport { generateTable } from \"../../table.js\";\nimport { replaceRollable } from \"../utils.js\";\n\n// \"lairDescription\": \"<p>Black dragons dwell in swamps on the frayed edges of civilization. A black dragon&rsquo;s lair is a dismal cave, grotto, or ruin that is at least partially flooded, providing pools where the dragon rests, and where its victims can ferment. The lair is littered with the acid-pitted bones of previous victims and the fly-ridden carcasses of fresh kills, watched over by crumbling statues. Centipedes, scorpions, and snakes infest the lair, which is filled with the stench of death and decay.</p>\\r\\n<h4>Lair Actions</h4>\\r\\n<p>On initiative count 20 (losing initiative ties), the dragon takes a lair action to cause one of the following effects; the dragon can&rsquo;t use the same effect two rounds in a row:</p>\\r\\n<ul>\\r\\n<li>Pools of water that the dragon can see within 120 feet of it surge outward in a grasping tide. Any creature on the ground within 20 feet of such a pool must succeed on a DC 15 Strength saving throw or be pulled up to 20 feet into the water and knocked prone.</li>\\r\\n<li>A cloud of swarming insects fills a 20-foot-radius sphere centered on a point the dragon chooses within 120 feet of it. The cloud spreads around corners and remains until the dragon dismisses it as an action, uses this lair action again, or dies. The cloud is lightly obscured. Any creature in the cloud when it appears must make on a DC 15 Constitution saving throw, taking 10 (3d6) piercing damage on a failed save, or half as much damage on a successful one. A creature that ends its turn in the cloud takes 10 (3d6) piercing damage.</li>\\r\\n<li>Magical darkness spreads from a point the dragon chooses within 60 feet of it, filling a 15-foot-radius sphere until the dragon dismisses it as an action, uses this lair action again, or dies. The darkness spreads around corners. A creature with darkvision can&rsquo;t see through this darkness, and nonmagical light can&rsquo;t illuminate it. If any of the effect&rsquo;s area overlaps with an area of light created by a spell of 2nd level or lower, the spell that created the light is dispelled.</li>\\r\\n</ul>\\r\\n<h4>Regional Effects</h4>\\r\\n<p>The region containing a legendary black dragon&rsquo;s lair is warped by the dragon&rsquo;s magic, which creates one or more of the following effects:</p>\\r\\n<ul>\\r\\n<li>The land within 6 miles of the lair takes twice as long as normal to traverse, since the plants grow thick and twisted, and the swamps are thick with reeking mud.</li>\\r\\n<li>Water sources within 1 mile of the lair are supernaturally fouled. Enemies of the dragon that drink such water regurgitate it within minutes.<br />Fog lightly obscures the land within 6 miles of the lair.</li>\\r\\n</ul>\\r\\n<p>If the dragon dies, vegetation remains as it has grown, but other effects fade over 1d10 days.</p>\",\n\nfunction addPlayerDescription(monster, action) {\n  let playerDescription = `</section>\\nThe ${monster.name} uses a ${action.name}!`;\n  return playerDescription;\n}\n\nexport function getLairActions(monster, DDB_CONFIG) {\n  let resource = {\n    value: false,\n    initiative: null\n  };\n\n  if (!monster.hasLair && monster.lairDescription == \"\") {\n    return {\n      resource: resource,\n      lairActions: [],\n    };\n  }\n\n  const lairDescription = replaceRollable(monster.lairDescription);\n\n  const updateExisting = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n  const hideDescription = game.settings.get(\"ddb-importer\", \"munching-policy-hide-description\");\n\n  let dom = new DocumentFragment();\n  $.parseHTML(lairDescription).forEach((element) => {\n    dom.appendChild(element);\n  });\n\n  dom.childNodes.forEach((node) => {\n    if (node.textContent == \"\\n\" || node.textContent == \"\\r\\n\") {\n      dom.removeChild(node);\n    }\n  });\n\n  let dynamicActions = [];\n\n  let defaultAction = newFeat(\"Lair Actions\");\n  defaultAction.data.activation.type = \"lair\";\n  defaultAction.data.source = getSource(monster, DDB_CONFIG);\n  dynamicActions.push(defaultAction);\n\n  dom.querySelectorAll(\"h4\").forEach((node) => {\n    const name = node.textContent.trim();\n    let action = newFeat(name);\n    if (node.textContent == \"Lair Actions\" || node.textContent == \"\") {\n      return;\n    }\n    action.data.source = getSource(monster, DDB_CONFIG);\n    if (action.name !== \"\") dynamicActions.push(action);\n  });\n\n  dom.querySelectorAll(\"h3\").forEach((node) => {\n    const name = node.textContent.trim();\n    let action = newFeat(name);\n    if (node.textContent == \"Lair Actions\" || action.name == \"\") {\n      return;\n    }\n    action.data.source = getSource(monster, DDB_CONFIG);\n    if (action.name !== \"\") dynamicActions.push(action);\n  });\n\n  let actionType = \"Lair Actions\";\n  let action = dynamicActions.find((act) => act.name == actionType);\n\n  if (!action) {\n    action = dynamicActions[0];\n  } else if (hideDescription) {\n    action.data.description.value = \"<section class=\\\"secret\\\">\\n\";\n  }\n\n  dom.childNodes.forEach((node) => {\n    // const switchAction = dynamicActions.find((act) => act.name == node.textContent);\n    const nodeName = node.textContent.split('.')[0].trim();\n    const switchAction = dynamicActions.find((act) => nodeName === act.name);\n    let startFlag = false;\n    if (switchAction) {\n      actionType = node.textContent;\n      if (action.data.description.value !== \"\" && hideDescription) {\n        action.data.description.value += addPlayerDescription(monster, action);\n      }\n      action = switchAction;\n      if (action.data.description.value === \"\") startFlag = true;\n      if ((action.data.description.value === \"\" || action.name === \"Lair Actions\") && hideDescription) {\n        action.data.description.value += \"<section class=\\\"secret\\\">\\n\";\n      }\n    }\n    if (node.outerHTML) {\n      let outerHTML = node.outerHTML;\n      if (switchAction && startFlag) {\n        outerHTML = outerHTML.replace(`${nodeName}.`, \"\");\n      }\n      action.data.description.value += outerHTML;\n    }\n\n    const initiativeMatch = node.textContent.match(/initiative count (\\d+)/);\n    if (initiativeMatch) {\n      resource = {\n        value: true,\n        initiative: parseInt(initiativeMatch[1]),\n      };\n    }\n  });\n\n  if (action && action.data.description.value !== \"\" && hideDescription) {\n    action.data.description.value += addPlayerDescription(monster, action);\n  }\n  if (action) action.data.description.value = generateTable(monster.name, action.data.description.value, updateExisting);\n\n  return {\n    resource: resource,\n    lairActions: dynamicActions,\n  };\n}\n","import { getSource } from \"../source.js\";\nimport { getRecharge, getActivation, getFeatSave, getDamage, getRange, getTarget, replaceRollable } from \"../utils.js\";\nimport { newFeat } from \"../templates/feat.js\";\nimport { generateTable } from \"../../table.js\";\n\nfunction addPlayerDescription(monster, action) {\n  let playerDescription = `</section>\\nThe ${monster.name} performs ${action.name}!`;\n  return playerDescription;\n}\n\n\nexport function getLegendaryActions(monster, DDB_CONFIG, monsterActions) {\n  if (monster.legendaryActionsDescription == \"\") {\n    return {\n      actions: {\n        \"value\": 0,\n        \"max\": 0\n      },\n      legendaryActions: [],\n    };\n  }\n\n  const updateExisting = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n  const hideDescription = game.settings.get(\"ddb-importer\", \"munching-policy-hide-description\");\n\n  let actionResource = {\n    value: 3,\n    max: 3\n  };\n\n  let dom = new DocumentFragment();\n\n  let fixedLegendaryActionsDescription = replaceRollable(monster.legendaryActionsDescription)\n    .replace(/<\\/strong> <strong>/g, \"\").replace(/<\\/strong><strong>/g, \"\");\n  $.parseHTML(fixedLegendaryActionsDescription).forEach((element) => {\n    dom.appendChild(element);\n  });\n\n  dom.childNodes.forEach((node) => {\n    if (node.textContent == \"\\n\") {\n      dom.removeChild(node);\n    }\n  });\n\n  let dynamicActions = [];\n\n  // Base feat\n  let feat = newFeat(\"Legendary Actions\");\n  feat.data.source = getSource(monster, DDB_CONFIG);\n  feat.data.description.value = \"\";\n  if (hideDescription) feat.data.description.value += \"<section class=\\\"secret\\\">\\n\";\n  feat.data.description.value += monster.legendaryActionsDescription;\n  if (hideDescription) feat.data.description.value += \"</section>\\n Performing a Legendary Action.\\n\\n\";\n  feat.flags.monsterMunch = {};\n  feat.flags.monsterMunch['actionCopy'] = false;\n  dynamicActions.push(feat);\n\n\n  // build out skeleton actions\n  dom.querySelectorAll(\"strong\").forEach((node) => {\n    const name = node.textContent.trim().replace(/\\.$/, '').trim();\n    let action = newFeat(name);\n\n    const actionMatch = monsterActions.find((mstAction) =>\n      name == mstAction.name ||\n      name == `${mstAction.name} Attack` ||\n      name == `${mstAction.name}`.split('(', 1)[0].trim() ||\n      name == `${mstAction.name} Attack`.split('(', 1)[0].trim()\n    );\n\n    action.flags.monsterMunch = {};\n    if (actionMatch) {\n      action = JSON.parse(JSON.stringify(actionMatch));\n      action.flags.monsterMunch['actionCopy'] = true;\n    } else {\n      action.flags.monsterMunch['actionCopy'] = false;\n    }\n    action.data.activation.type = \"legendary\";\n    action.data.source = getSource(monster, DDB_CONFIG);\n    action.data.consume = {\n      type: \"attribute\",\n      target: \"resources.legact.value\",\n      amount: 1\n    };\n    dynamicActions.push(action);\n  });\n\n  let action = dynamicActions.find((act) => act.name == \"Legendary Actions\");\n\n  dom.childNodes\n    .forEach((node) => {\n    // check for action numbers\n    // can take 3 legendary actions\n      let startFlag = false;\n      const actionMatch = node.textContent.match(/can take (d+) legendary actions/);\n      if (actionMatch) {\n        actionResource.value = parseInt(actionMatch[1]);\n        actionResource.max = parseInt(actionMatch[1]);\n      }\n\n      //    const switchAction = dynamicActions.find((act) => node.textContent.startsWith(act.name));\n      const nodeName = node.textContent.split('.')[0].trim();\n      const switchAction = dynamicActions.find((act) => nodeName === act.name);\n      if (action.name !== \"Legendary Actions\" || switchAction) {\n\n        if (switchAction) {\n          if (action.data.description.value !== \"\" && hideDescription && action.name !== \"Legendary Actions\") {\n            action.data.description.value += addPlayerDescription(monster, action);\n          }\n          action.data.description.value = generateTable(action.name, action.data.description.value, updateExisting);\n          action = switchAction;\n          if (action.data.description.value === \"\") {\n            startFlag = true;\n            if (hideDescription) {\n              action.data.description.value = \"<section class=\\\"secret\\\">\\n\";\n            }\n          }\n        }\n        // console.log(action)\n        if (action.flags && action.flags.monstersMunch && action.flags.monsterMunch.actionCopy) return;\n        if (node.outerHTML) {\n          let outerHTML = node.outerHTML;\n          if (switchAction && startFlag) {\n            outerHTML = outerHTML.replace(`${nodeName}.`, \"\");\n          }\n          action.data.description.value += outerHTML;\n        }\n\n        const activationCost = getActivation(node.textContent);\n        if (activationCost) {\n          action.data.activation.cost = activationCost;\n          action.data.consume.amount = activationCost;\n        } else {\n          action.data.activation.cost = 1;\n        }\n\n        // only attempt to update these if we don't parse an action\n        if (!action.flags.monsterMunch.actionCopy) {\n          action.data.recharge = getRecharge(node.textContent);\n          action.data.save = getFeatSave(node.textContent, action.data.save);\n          // assumption - if we have parsed a save dc set action type to save\n          if (action.data.save.dc) {\n            action.data.actionType = \"save\";\n          // action.type = \"weapon\";\n          }\n          action.data.range = getRange(node.textContent);\n          action.data.target = getTarget(node.textContent);\n          action.data.damage = getDamage(node.textContent);\n        }\n      }\n    });\n\n  if (action && action.data.description.value !== \"\" && hideDescription && action.name !== \"Legendary Actions\") {\n    action.data.description.value += addPlayerDescription(monster, action);\n  }\n  if (action) action.data.description.value = generateTable(monster.name, action.data.description.value, updateExisting);\n\n\n  // console.log(dynamicActions);\n\n  return {\n    actions: actionResource,\n    legendaryActions: dynamicActions,\n  };\n}\n","import { getSource } from \"../source.js\";\nimport { getActionInfo, getAction, getUses, stripHtml, replaceRollable } from \"../utils.js\";\nimport { newFeat } from \"../templates/feat.js\";\nimport { generateTable } from \"../../table.js\";\n\n// \"actionsDescription\": \"<p><em><strong>Multiattack.</strong></em> The dragon can use its Frightful Presence. It then makes three attacks: one with its bite and two with its claws.</p>\\r\\n<p><em><strong>Bite.</strong></em> <em>Melee Weapon Attack:</em> +15 to hit, reach 15 ft., one target. <em>Hit:</em> 19 (2d10 + 8) piercing damage plus 9 (2d8) acid damage.</p>\\r\\n<p><em><strong>Claw.</strong></em> <em>Melee Weapon Attack:</em> +15 to hit, reach 10 ft., one target. <em>Hit:</em> 15 (2d6 + 8) slashing damage.</p>\\r\\n<p><em><strong>Tail.</strong></em> <em>Melee Weapon Attack:</em> +15 to hit, reach 20 ft., one target. <em>Hit:</em> 17 (2d8 + 8) bludgeoning damage.</p>\\r\\n<p><em><strong>Frightful Presence.</strong></em> Each creature of the dragon's choice that is within 120 feet of the dragon and aware of it must succeed on a DC 19 Wisdom saving throw or become frightened for 1 minute. A creature can repeat the saving throw at the end of each of its turns, ending the effect on itself on a success. If a creature's saving throw is successful or the effect ends for it, the creature is immune to the dragon's Frightful Presence for the next 24 hours.</p>\\r\\n<p><em><strong>Acid Breath (Recharge 5&ndash;6).</strong></em> The dragon exhales acid in a 90-foot line that is 10 feet wide. Each creature in that line must make a DC 22 Dexterity saving throw, taking 67 (15d8) acid damage on a failed save, or half as much damage on a successful one.</p>\",\n\nfunction generatePlayerDescription(monster, action) {\n  let playerDescription = `<section class=\"secret\">\\n${action.data.description.value}`;\n  if ([\"rwak\", \"mwak\"].includes(action.data.actionType)) {\n    playerDescription += `\\n</section>\\nThe ${monster.name} attacks with its ${action.name}.`;\n  } else if ([\"rsak\", \"msak\"].includes(action.data.actionType)) {\n    playerDescription += `\\n</section>\\nThe ${monster.name} casts ${action.name}.`;\n  } else if ([\"save\"].includes(action.data.actionType)) {\n    playerDescription += `\\n</section>\\nThe ${monster.name} uses ${action.name} and a save is required.`;\n  } else {\n    playerDescription += `\\n</section>\\nThe ${monster.name} uses ${action.name}.`;\n  }\n  return playerDescription;\n}\n\nfunction buildAction(action, actionInfo, textContent, type) {\n  // console.log(\"&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\");\n  // console.log(JSON.stringify(actionInfo, null, 4));\n  // console.log(\"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\");\n  // console.warn(action.name);\n\n  if (actionInfo.activation) {\n    action.data.activation.cost = actionInfo.activation;\n    action.data.consume.amount = actionInfo.activation;\n  } else {\n    action.data.activation.cost = 1;\n  }\n  action.data.activation.type = getAction(textContent, type);\n\n  action.data.recharge = actionInfo.recharge;\n  action.data.save = actionInfo.save;\n  // assumption - if we have parsed a save dc set action type to save\n  if (action.data.save.dc) {\n    action.data.actionType = \"save\";\n  }\n\n  action.data.damage = actionInfo.damage;\n  action.data.formula = actionInfo.formula;\n  action.data.properties = actionInfo.properties;\n  action.data.proficient = actionInfo.proficient;\n  action.data.ability = actionInfo.baseAbility;\n  action.data.attackBonus = actionInfo.extraAttackBonus;\n\n  if (actionInfo.weaponAttack) {\n    action.data.weaponType = actionInfo.weaponType;\n    action.data.equipped = true;\n    // console.log(actionInfo.weaponAttack);\n    // console.log(actionInfo.meleeAttack);\n    // console.log(actionInfo.rangedAttack);\n    if (actionInfo.meleeAttack) {\n      action.data.actionType = \"mwak\";\n    } else if (actionInfo.rangedAttack) {\n      action.data.actionType = \"rwak\";\n    }\n  } else if (actionInfo.spellAttack) {\n    if (actionInfo.meleeAttack) {\n      action.data.actionType = \"msak\";\n    } else if (actionInfo.rangedAttack) {\n      action.data.actionType = \"rsak\";\n    } else {\n      action.data.actionType = \"save\";\n    }\n  } else if (actionInfo.save.dc) {\n    action.data.actionType = \"save\";\n  }\n\n  if (actionInfo.isAttack) {\n    action.type = \"weapon\";\n  }\n\n  action.data.range = actionInfo.range;\n  action.data.target = actionInfo.target;\n  action.data.duration = actionInfo.duration;\n  action.data.uses = actionInfo.uses;\n\n  if (action.name.includes(\"/Day\")) {\n    action.data.uses = getUses(action.name, true);\n  }\n\n  return action;\n}\n\nexport function getActions(monster, DDB_CONFIG, type = \"action\") {\n  const hideDescription = game.settings.get(\"ddb-importer\", \"munching-policy-hide-description\");\n  const updateExisting = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n  let actions;\n  let characterDescription;\n\n  switch (type) {\n    case \"action\":\n      actions = monster.actionsDescription ?? \"\";\n      break;\n    case \"reaction\":\n      actions = monster.reactionsDescription ?? \"\";\n      break;\n    case \"bonus\":\n      actions = monster.bonusActionsDescription ?? \"\";\n      break;\n    case \"mythic\":\n      actions = monster.mythicActionsDescription ?? \"\";\n      break;\n    default:\n      actions = \"\";\n  }\n\n  if (actions == \"\") {\n    return [[], null];\n  }\n\n  actions = replaceRollable(actions);\n\n  let splitActions = actions.split(\"<h3>Roleplaying Information</h3>\");\n  if (splitActions.length > 1) {\n    characterDescription = `<h3>Roleplaying Information</h3>${splitActions[1]}`;\n  }\n  actions = splitActions[0]\n    .replace(/<\\/strong> <strong>/g, \"\")\n    .replace(/<\\/strong><strong>/g, \"\")\n    .replace(/&shy;/g, \"\");\n\n  let dom = new DocumentFragment();\n  $.parseHTML(actions).forEach((element) => {\n    dom.appendChild(element);\n  });\n\n  // console.error(`Starting ${type} processing`)\n  // console.warn(dom);\n  // console.log(actions);\n  // console.log(dom.childNodes);\n\n  dom.childNodes.forEach((node) => {\n    if (node.textContent == \"\\n\") {\n      dom.removeChild(node);\n    }\n  });\n\n  let dynamicActions = [];\n\n  // build out skeleton actions\n  dom.querySelectorAll(\"p\").forEach((node) => {\n\n    let pDom = new DocumentFragment();\n    $.parseHTML(node.outerHTML).forEach((element) => {\n      pDom.appendChild(element);\n    });\n    const query = pDom.querySelector(\"strong\");\n    if (!query) return;\n    let name = query.textContent.trim().replace(/\\./g, '');\n    if (!name.includes(\"Spell;\") && !name.includes(\"Mythic Trait;\")) {\n      name = name.split(\";\").pop().trim();\n    }\n    let action = newFeat(name);\n    action.data.source = getSource(monster, DDB_CONFIG);\n    action.flags.monsterMunch = {\n      titleHTML: query.outerHTML,\n      fullName: query.textContent,\n    };\n    dynamicActions.push(action);\n  });\n\n  let action = dynamicActions[0];\n\n  // there is inconsistent formatting\n  if (dynamicActions.length == 0) {\n    dom.querySelectorAll(\"p\").forEach((node) => {\n\n      let pDom = new DocumentFragment();\n      $.parseHTML(node.outerHTML).forEach((element) => {\n        pDom.appendChild(element);\n      });\n      const query = pDom.querySelector(\"b\");\n      if (!query) return;\n      let name = query.textContent.trim().replace(/\\./g, '');\n      if (!name.includes(\"Spell;\") && !name.includes(\"Mythic Trait;\")) {\n        name = name.split(\";\").pop().trim();\n      }\n      let action = newFeat(name);\n      action.data.source = getSource(monster, DDB_CONFIG);\n      action.flags.monsterMunch = {\n        titleHTML: query.outerHTML,\n        fullName: query.textContent,\n      };\n      dynamicActions.push(action);\n    });\n    action = dynamicActions[0];\n  }\n\n\n  // there is inconsistent formatting\n  if (dynamicActions.length == 0) {\n    dom.querySelectorAll(\"p\").forEach((node) => {\n\n      let pDom = new DocumentFragment();\n      $.parseHTML(node.outerHTML).forEach((element) => {\n        pDom.appendChild(element);\n      });\n      const title = pDom.textContent.split('.')[0];\n      const name = title.trim();\n      let action = newFeat(name);\n      action.data.source = getSource(monster, DDB_CONFIG);\n      if (pDom.outerHTML) {\n        action.flags.monsterMunch = {\n          titleHTML: pDom.outerHTML.split('.')[0],\n        };\n      }\n      if (action.name) dynamicActions.push(action);\n    });\n    action = dynamicActions[0];\n  }\n\n  // homebrew fun\n  if (dynamicActions.length == 0) {\n    dom.querySelectorAll(\"div\").forEach((node) => {\n\n      let pDom = new DocumentFragment();\n      $.parseHTML(node.outerHTML).forEach((element) => {\n        pDom.appendChild(element);\n      });\n      const title = pDom.textContent.split('.')[0];\n      const name = title.trim();\n      let action = newFeat(name);\n      action.data.source = getSource(monster, DDB_CONFIG);\n      if (pDom.outerHTML) {\n        action.flags.monsterMunch = {\n          titleHTML: pDom.outerHTML.split('.')[0],\n        };\n      }\n      if (action.name) dynamicActions.push(action);\n    });\n    action = dynamicActions[0];\n  }\n\n  // console.error(dynamicActions);\n\n  dom.childNodes.forEach((node) => {\n    // console.log(\"***\");\n    // console.warn(action);\n    // console.log(\"***\");\n    // console.log(node.textContent);\n    // const switchAction = dynamicActions.find((act) => node.textContent.startsWith(act.name));\n    const nodeContextSplit = node.textContent.split('.');\n    // console.log(nodeContextSplit);\n    const nodeName = nodeContextSplit[0].trim();\n    const longNodeName = (nodeContextSplit.length > 2 && nodeContextSplit[1].trim().startsWith('('))\n      ? `${nodeName} ${nodeContextSplit[1].trim()}`\n      : nodeName;\n    let switchAction = dynamicActions.find((act) => nodeName === act.name || longNodeName === act.name);\n\n    if (!switchAction) {\n      switchAction = dynamicActions.find((act) => act.flags?.monsterMunch?.fullName && node.textContent.startsWith(act.flags.monsterMunch.fullName));\n    }\n    // console.warn(nodeName);\n    // console.warn(longNodeName);\n    // console.warn(switchAction);\n    let startFlag = false;\n    if (switchAction) {\n      action = switchAction;\n      if (action.data.description.value === \"\") {\n        startFlag = true;\n      }\n    }\n\n    // console.warn(node);\n    // console.warn(action);\n    if (!action) return;\n\n    if (node.outerHTML) {\n      let outerHTML = node.outerHTML;\n      if (switchAction && startFlag) {\n        // const name = new RegExp(`^${nodeName}\\.?`);\n        // outerHTML = outerHTML.replace(name, \"\");\n        if (action.flags?.monsterMunch?.fullName) {\n          outerHTML = outerHTML.replace(action.flags.monsterMunch.fullName, \"\");\n        } else {\n          outerHTML = outerHTML.replace(nodeName, \"\");\n        }\n        const titleDom = new DocumentFragment();\n        $.parseHTML(outerHTML).forEach((element) => {\n          titleDom.appendChild(element);\n        });\n        if (titleDom.textContent.startsWith(\".\")) outerHTML = outerHTML.replace(\".\", \"\");\n      }\n      action.data.description.value += outerHTML;\n    }\n  });\n\n  dynamicActions = dynamicActions.map((da) => {\n    const actionDescription = stripHtml(da.data.description.value);\n    const actionInfo = getActionInfo(monster, DDB_CONFIG, da.name, actionDescription);\n    const result = buildAction(da, actionInfo, actionDescription, type);\n    if (hideDescription) {\n      da.data.description.value = generatePlayerDescription(monster, da);\n    }\n    da.data.description.value = generateTable(monster.name, da.data.description.value, updateExisting);\n    return result;\n  });\n\n  // console.warn(dynamicActions);\n  // console.log(JSON.stringify(dynamicActions, null, 4));\n\n  return [dynamicActions, characterDescription];\n}\n","// specialTraitsDescription\n// handle legendary resistance here\n\nimport { getSource } from \"../source.js\";\nimport { getRecharge, getActivation, getFeatSave, getDamage, getAction, getUses, getTarget, replaceRollable } from \"../utils.js\";\nimport { newFeat } from \"../templates/feat.js\";\nimport { generateTable } from \"../../table.js\";\n\nfunction addPlayerDescription(monster, action) {\n  let playerDescription = `</section>\\nThe ${monster.name} uses ${action.name}!`;\n  return playerDescription;\n}\n\nexport function getSpecialTraits(monster, DDB_CONFIG) {\n  if (monster.specialTraitsDescription == \"\") {\n    return {\n      resistance: {\n        \"value\": 0,\n        \"max\": 0\n      },\n      specialActions: [],\n      characterDescription: null,\n    };\n  }\n\n  const updateExisting = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n  const hideDescription = game.settings.get(\"ddb-importer\", \"munching-policy-hide-description\");\n\n  let resistanceResource = {\n    value: 0,\n    max: 0\n  };\n  let characterDescription;\n\n  let dom = new DocumentFragment();\n  let splitActions = replaceRollable(monster.specialTraitsDescription).split(\"<h3>Roleplaying Information</h3>\");\n  if (splitActions.length > 1) {\n    characterDescription = `<h3>Roleplaying Information</h3>${splitActions[1]}`;\n  }\n\n  const fixedDescription = splitActions[0]\n    .replace(/<\\/strong> <strong>/g, \"\").replace(/<\\/strong><strong>/g, \"\")\n    .replace(/&shy;/g, \"\")\n    .replace(/<br \\/>/g, \"</p><p>\");\n  $.parseHTML(fixedDescription).forEach((element) => {\n    dom.appendChild(element);\n  });\n\n  dom.childNodes.forEach((node) => {\n    if (node.textContent == \"\\n\") {\n      dom.removeChild(node);\n    }\n  });\n\n  // console.error(`Starting special traits processing`)\n  // console.warn(dom);\n  // console.log(fixedDescription);\n  // console.log(dom.childNodes);\n\n  let dynamicActions = [];\n\n  // build out skeleton actions\n  dom.querySelectorAll(\"p\").forEach((node) => {\n    let pDom = new DocumentFragment();\n    $.parseHTML(node.outerHTML).forEach((element) => {\n      pDom.appendChild(element);\n    });\n    const query = pDom.querySelector(\"em\");\n    if (!query) return;\n    let name = query.textContent.trim().replace(/\\./g, '');\n    if (!name.includes(\"Spell;\") && !name.includes(\"Mythic Trait;\")) {\n      name = name.split(\";\").pop().trim();\n    }\n    let action = newFeat(name);\n    action.name = name;\n    action.data.source = getSource(monster, DDB_CONFIG);\n    action.flags.monsterMunch = {\n      titleHTML: query.outerHTML,\n      fullName: query.textContent,\n    };\n    if (action.name) dynamicActions.push(action);\n  });\n\n  if (dynamicActions.length == 0) {\n    dom.querySelectorAll(\"p\").forEach((node) => {\n      let pDom = new DocumentFragment();\n      $.parseHTML(node.outerHTML).forEach((element) => {\n        pDom.appendChild(element);\n      });\n      const query = pDom.querySelector(\"strong\");\n      if (!query) return;\n      let name = query.textContent.trim().replace(/\\./g, '');\n      if (!name.includes(\"Spell;\") && !name.includes(\"Mythic Trait;\")) {\n        name = name.split(\";\").pop().trim();\n      }\n      let action = newFeat(name);\n      action.data.source = getSource(monster, DDB_CONFIG);\n      action.flags.monsterMunch = {\n        titleHTML: query.outerHTML,\n        fullName: query.textContent,\n      };\n      if (action.name) dynamicActions.push(action);\n    });\n  }\n\n  if (dynamicActions.length == 0) {\n    dom.querySelectorAll(\"em\").forEach((node) => {\n      const name = node.textContent.trim().replace(/\\.$/, '').trim();\n      let action = newFeat(name);\n      action.data.source = getSource(monster, DDB_CONFIG);\n      action.flags.monsterMunch = {\n        titleHTML: node.outerHTML,\n        fullName: node.textContent,\n      };\n      if (action.name) dynamicActions.push(action);\n    });\n  }\n\n  if (dynamicActions.length == 0) {\n    dom.querySelectorAll(\"strong\").forEach((node) => {\n      const name = node.textContent.trim().replace(/\\.$/, '').trim();\n      let action = newFeat(name);\n      action.data.source = getSource(monster, DDB_CONFIG);\n      action.flags.monsterMunch = {\n        titleHTML: node.outerHTML,\n        fullName: node.textContent,\n      };\n      if (action.name) dynamicActions.push(action);\n    });\n  }\n\n  if (dynamicActions.length == 0) {\n    let action = newFeat(\"Special Traits\");\n    action.data.source = getSource(monster, DDB_CONFIG);\n    action.flags.monsterMunch = {};\n    if (action.name) dynamicActions.push(action);\n  }\n\n  let action = dynamicActions[0];\n\n  // console.warn(dynamicActions);\n\n  dom.childNodes.forEach((node) => {\n    // console.warn(node.textContent);\n    // const switchAction = dynamicActions.find((act) => node.textContent.startsWith(act.name));\n    const nodeName = node.textContent.split('.')[0].trim();\n    let switchAction = dynamicActions.find((act) => nodeName === act.name);\n    if (action.name.includes(\"; Recharges after a Short or Long Rest\")) action.name = action.name.replace(\"; Recharges after a Short or Long Rest\", \"\");\n    if (!switchAction) {\n      switchAction = dynamicActions.find((act) => node.textContent.startsWith(act.flags.monsterMunch.fullName));\n    }\n    // console.log(switchAction);\n    let startFlag = false;\n    if (switchAction) {\n      if (action.data.description.value !== \"\" && hideDescription) {\n        action.data.description.value += addPlayerDescription(monster, action);\n      }\n      action.data.description.value = generateTable(action.name, action.data.description.value, updateExisting);\n      action = switchAction;\n      if (action.data.description.value === \"\") {\n        startFlag = true;\n        if (hideDescription) {\n          action.data.description.value = \"<section class=\\\"secret\\\">\\n\";\n        }\n      }\n    }\n\n    if (node.outerHTML) {\n      let outerHTML = node.outerHTML;\n      if (switchAction && startFlag) {\n        if (action.flags?.monsterMunch?.fullName) {\n          outerHTML = outerHTML.replace(action.flags.monsterMunch.fullName, \"\");\n        } else {\n          outerHTML = outerHTML.replace(nodeName, \"\");\n          // outerHTML = outerHTML.replace(`${nodeName}.`, \"\");\n        }\n      }\n      const titleDom = new DocumentFragment();\n      $.parseHTML(outerHTML).forEach((element) => {\n        titleDom.appendChild(element);\n      });\n      if (titleDom.textContent.startsWith(\". \")) outerHTML = outerHTML.replace(\". \", \"\");\n      action.data.description.value += outerHTML;\n    }\n\n    // If we have already parsed bits of this action, we probably don't want to\n    // do it again!\n    // if (!startFlag) return;\n\n    action.data.activation.type = getAction(node.textContent, \"\");\n    const activationCost = getActivation(node.textContent);\n    if (activationCost) {\n      action.data.activation.cost = activationCost;\n      action.data.consume.amount = activationCost;\n    } else if (action.data.activation.type !== \"\") {\n      action.data.activation.cost = 1;\n    }\n\n    action.data.uses = getUses(node.textContent);\n    action.data.recharge = getRecharge(node.textContent);\n    action.data.save = getFeatSave(node.textContent, action.data.save);\n    action.data.target = getTarget(node.textContent);\n    // assumption - if we have parsed a save dc set action type to save\n    if (action.data.save.dc) {\n      action.data.actionType = \"save\";\n    }\n    action.data.damage = getDamage(node.textContent);\n    // assumption - if the action type is not set but there is damage, the action type is other\n    if (!action.data.actionType && action.data.damage.parts.length != 0) {\n      action.data.actionType = \"other\";\n    }\n\n    // legendary resistance check\n    const actionMatch = node.textContent.match(/Legendary Resistance \\((\\d+)\\/Day\\)/);\n    if (actionMatch) {\n      resistanceResource.value = parseInt(actionMatch[1]);\n      resistanceResource.max = parseInt(actionMatch[1]);\n      action.data.activation.type = \"special\";\n      action.data.activation.const = null;\n      action.data.consume = {\n        type: \"attribute\",\n        target: \"resources.legres.value\",\n        amount: 1\n      };\n    }\n\n  });\n\n  if (action && action.data.description.value !== \"\" && hideDescription) {\n    action.data.description.value += addPlayerDescription(monster, action);\n  }\n  if (action) action.data.description.value = generateTable(monster.name, action.data.description.value, updateExisting);\n\n  // console.log(dynamicActions);\n\n  return {\n    resistance: resistanceResource,\n    specialActions: dynamicActions,\n    characterDescription: characterDescription,\n  };\n}\n","import { getAbilityMods } from \"./abilities.js\";\nimport logger from '../../logger.js';\n\n\nfunction parseSpellcasting(text) {\n  let spellcasting = \"\";\n  const abilitySearch = \"(?:spellcasting ability is|uses) (\\\\w+)(?: as \\\\w+ spellcasting ability| )\";\n  const match = text.match(abilitySearch);\n  if (match) {\n    spellcasting = match[1].toLowerCase().substr(0, 3);\n  }\n  return spellcasting;\n}\n\nfunction parseSpellLevel(text) {\n  let spellLevel = 0;\n  const levelSearch = /is (?:a|an) (\\d+)(?:th|nd|rd|st)(?:-| )level spellcaster/;\n  const match = text.match(levelSearch);\n  if (match) {\n    spellLevel = parseInt(match[1]);\n  }\n  return spellLevel;\n}\n\nfunction parseSpelldc(text) {\n  let dc = 10;\n  const dcSearch = \"spell\\\\s+save\\\\s+DC\\\\s*(\\\\d+)(?:,|\\\\)|\\\\s)\";\n  const match = text.match(dcSearch);\n  // console.log(\"\")\n  // console.log(match);\n  if (match) {\n    dc = parseInt(match[1]);\n  }\n  return dc;\n}\n\nfunction parseBonusSpellAttack(text, monster, DDB_CONFIG) {\n  let spellAttackBonus = 0;\n  const dcSearch = \"([+-]\\\\d+)\\\\s+to\\\\s+hit\\\\s+with\\\\s+spell\\\\s+attacks\";\n  const match = text.match(dcSearch);\n  if (match) {\n    const toHit = match[1];\n    const proficiencyBonus = DDB_CONFIG.challengeRatings.find((cr) => cr.id == monster.challengeRatingId).proficiencyBonus;\n    const abilities = getAbilityMods(monster, DDB_CONFIG);\n    const castingAbility = parseSpellcasting(text);\n    spellAttackBonus = toHit - proficiencyBonus - abilities[castingAbility];\n  }\n  return spellAttackBonus;\n}\n\nfunction parseInnateSpells(text, spells, spellList) {\n  // handle innate style spells here\n  // 3/day each: charm person (as 5th-level spell), color spray, detect thoughts, hold person (as 3rd-level spell)\n  // console.log(text);\n  const innateSearch = /^(\\d+)\\/(\\w+)(?:\\s+each)?:\\s+(.*$)/;\n  const innateMatch = text.match(innateSearch);\n  // console.log(innateMatch);\n  if (innateMatch) {\n    const spellArray = innateMatch[3].split(\",\").map((spell) => spell.trim());\n    spellArray.forEach((spell) => {\n      spellList.innate.push({ name: spell, type: innateMatch[2], value: innateMatch[1] });\n    });\n  }\n\n  // At will: dancing lights\n  const atWillSearch = /^At (?:Will|will):\\s+(.*$)/;\n  const atWillMatch = text.match(atWillSearch);\n  if (atWillMatch) {\n    const spellArray = atWillMatch[1].split(\",\").map((spell) => spell.trim());\n    spellArray.forEach((spell) => {\n      spellList.atwill.push(spell);\n    });\n  }\n\n  // last ditch attempt, mephits have some weird formating\n  if (!innateMatch && !atWillMatch) {\n    const mephitMatch = text.match(/(\\d+)\\/(\\w+)(?:.*)?cast (.*),/);\n    if (mephitMatch) {\n      const spell = mephitMatch[3].trim();\n      spellList.innate.push({ name: spell, type: mephitMatch[2], value: mephitMatch[1] });\n    }\n  }\n\n  return [spells, spellList];\n\n}\n\n\n// e.g. The archmage can cast disguise self and invisibility at will and has the following wizard spells prepared:\nfunction parseAdditionalAtWill(text) {\n  const atWillSearch = /can cast (.*?) at will/;\n  const atWillMatch = text.match(atWillSearch);\n  let atWillSpells = [];\n  if (atWillMatch) {\n    atWillSpells = atWillMatch[1].replace(\" and\", \",\").split(\",\").map((spell) => spell.split('(', 1)[0].trim());\n  }\n  return atWillSpells;\n}\n\nfunction parseSpells(text, spells, spellList) {\n  // console.log(text);\n  const spellLevelSearch = /^(Cantrip|\\d)(?:st|th|nd|rd)?(?:\\s*(?:Level|level))?(?:s)?\\s+\\((at will|at-will|\\d)\\s*(?:slot|slots)?\\):\\s+(.*$)/;\n  const match = text.match(spellLevelSearch);\n  // console.log(match);\n\n  const warlockLevelSearch = /^1st(\\d)(?:st|th|nd|rd)\\s+level\\s+\\((\\d)\\s+(\\d)(?:st|th|nd|rd)?\\s*(?:Level|level|-level)\\s*(?:slot|slots)?\\):\\s+(.*$)/;\n  const warlockMatch = text.match(warlockLevelSearch);\n\n  if (!match && !warlockMatch) return parseInnateSpells(text, spells, spellList);\n\n  const spellLevel = (match) ? match[1] : 'pact';\n  const slots = (match) ? match[2] : warlockMatch[2];\n  const spellMatches = (match) ? match[3] : warlockMatch[4];\n\n  if (Number.isInteger(parseInt(spellLevel)) && Number.isInteger(parseInt(slots))) {\n    spells[`spell${spellLevel}`]['value'] = slots;\n    spells[`spell${spellLevel}`]['max'] = slots;\n    spells[`spell${spellLevel}`]['override'] = slots;\n    const spellArray = spellMatches.split(\",\").map((spell) => spell.trim());\n    spellList.class.push(...spellArray);\n  } else if (spellLevel === 'pact' && Number.isInteger(parseInt(slots))) {\n    spells[spellLevel]['value'] = slots;\n    spells[spellLevel]['max'] = slots;\n    spells[spellLevel]['override'] = slots;\n    spells[spellLevel]['level'] = warlockMatch[3];\n    const spellArray = spellMatches.split(\",\").map((spell) => spell.trim());\n    spellList.pact.push(...spellArray);\n  } else if ([\"at will\", \"at-will\"].includes(slots)) {\n    // at will spells\n    const spellArray = spellMatches.replace(/\\*/g, '').split(\",\").map((spell) => spell.trim());\n    spellList.atwill.push(...spellArray);\n  }\n\n  // console.log(spellList);\n\n  return [spells, spellList];\n\n}\n\n\nfunction splitEdgeCase(spell) {\n  let result = {\n    name: spell,\n    edge: null,\n  };\n\n  const splitSpell = spell.split(\"(\");\n  if (splitSpell.length > 1) {\n    result.name = splitSpell[0].trim();\n    result.edge = splitSpell[1].split(\")\")[0].trim();\n  }\n\n  return result;\n}\n\nfunction getEdgeCases(spellList) {\n  let results = {\n    class: [],\n    pact: [],\n    atwill: [],\n    // {name: \"\", type: \"srt/lng/day\", value: 0} // check these values\n    innate: [],\n    edgeCases: [], // map { name: \"\", type: \"\", edge: \"\" }\n    material: spellList.material,\n  };\n\n  // class and atwill\n  spellList.class.forEach((spell) => {\n    const edgeCheck = splitEdgeCase(spell);\n    results.class.push(edgeCheck.name);\n    if (edgeCheck.edge) {\n      const edgeEntry = {\n        name: edgeCheck.name,\n        type: \"class\",\n        edge: edgeCheck.edge,\n      };\n      results.edgeCases.push(edgeEntry);\n    }\n  });\n  spellList.atwill.forEach((spell) => {\n    const edgeCheck = splitEdgeCase(spell);\n    results.atwill.push(edgeCheck.name);\n    if (edgeCheck.edge) {\n      const edgeEntry = {\n        name: edgeCheck.name,\n        type: \"atwill\",\n        edge: edgeCheck.edge,\n      };\n      results.edgeCases.push(edgeEntry);\n    }\n  });\n  spellList.pact.forEach((spell) => {\n    const edgeCheck = splitEdgeCase(spell);\n    results.pact.push(edgeCheck.name);\n    if (edgeCheck.edge) {\n      const edgeEntry = {\n        name: edgeCheck.name,\n        type: \"pact\",\n        edge: edgeCheck.edge,\n      };\n      results.edgeCases.push(edgeEntry);\n    }\n  });\n  // innate\n  spellList.innate.forEach((spellMap) => {\n    const edgeCheck = splitEdgeCase(spellMap.name);\n    spellMap.name = edgeCheck.name;\n    results.innate.push(spellMap);\n    if (edgeCheck.edge) {\n      const edgeEntry = {\n        name: edgeCheck.name,\n        type: \"innate\",\n        edge: edgeCheck.edge,\n      };\n      results.edgeCases.push(edgeEntry);\n    }\n  });\n\n  return results;\n}\n\n\n// <p><em><strong>Innate Spellcasting.</strong></em> The oblex&rsquo;s innate spellcasting ability is Intelligence (spell save DC 15). It can innately cast the following spells, requiring no components:</p>\\r\\n<p>3/day each: charm person (as 5th-level spell), color spray, detect thoughts, hold person (as 3rd-level spell)</p>\n\n\nexport function getSpells(monster, DDB_CONFIG) {\n  let spelldc = 10;\n  // data.details.spellLevel (spellcasting level)\n  let spellLevel = 0;\n  let spellList = {\n    class: [],\n    pact: [],\n    atwill: [],\n    // {name: \"\", type: \"srt/lng/day\", value: 0} // check these values\n    innate: [],\n    edgeCases: [], // map { name: \"\", type: \"\", edge: \"\" }\n    material: true,\n  };\n\n  // ability associated\n  let spellcasting = \"\";\n  let spellAttackBonus = 0;\n\n  let spells = {\n    \"spell1\": {\n      \"value\": 0,\n      \"max\": 0,\n      \"override\": null\n    },\n    \"spell2\": {\n      \"value\": 0,\n      \"max\": 0,\n      \"override\": null\n    },\n    \"spell3\": {\n      \"value\": 0,\n      \"max\": 0,\n      \"override\": null\n    },\n    \"spell4\": {\n      \"value\": 0,\n      \"max\": 0,\n      \"override\": null\n    },\n    \"spell5\": {\n      \"value\": 0,\n      \"max\": 0,\n      \"override\": null\n    },\n    \"spell6\": {\n      \"value\": 0,\n      \"max\": 0,\n      \"override\": null\n    },\n    \"spell7\": {\n      \"value\": 0,\n      \"max\": 0,\n      \"override\": null\n    },\n    \"spell8\": {\n      \"value\": 0,\n      \"max\": 0,\n      \"override\": null\n    },\n    \"spell9\": {\n      \"value\": 0,\n      \"max\": 0,\n      \"override\": null\n    },\n    \"pact\": {\n      \"value\": 0,\n      \"max\": 0,\n      \"override\": null,\n      \"level\": 0\n    }\n  };\n\n  let dom = new DocumentFragment();\n\n  // some monsters have poor spell formating, reported and might be able to remove in future\n  // https://www.dndbeyond.com/forums/d-d-beyond-general/bugs-support/91228-sir-godfrey-gwilyms-spell-statblock\n  // let specialTraits = monster.specialTraitsDescription;\n  const possibleSpellSources = monster.specialTraitsDescription + monster.actionsDescription;\n  let specialTraits = possibleSpellSources.replace(/<br \\/>/g, \"</p><p>\");\n  //   const specialCases = [\"Sir Godfrey Gwilym\", \"Hlam\", \"Ygorl, Lord of Entropy\",\n  //     \"Whymsee (Kraken Priest Variant)\", \"Strahd Zombie\", \"Skra Sorsk\",\n  //     \"Mongrelfolk\", \"Laeral Silverhand\", \"Jarlaxle Baenre\", \"Gar Shatterkeel (Noncore)\", \"Forlarren\",\n  //     \"Fog Giant\", \"Fhenimore (Kraken Priest Variant)\", \"Drow Arachnomancer\",\n  //     \"Archon of the Triumvirate\", \"Amble\",\n  // ];\n  //   if (specialCases.includes(monster.name)) {\n  //     specialTraits = specialTraits.replace(/<br \\/>/g, \"</p><p>\");\n  //     logger.warn(`Fiddling with ${monster.name} spells due to bad formatting`);\n  //   }\n  //   if (specialTraits.includes(\"<br />\")) console.error(`\"SPECIAL CASE ${monster.name}`);\n\n  // console.warn(specialTraits);\n  $.parseHTML(specialTraits).forEach((element) => {\n    dom.appendChild(element);\n  });\n\n  dom.childNodes.forEach((node) => {\n    if (node.textContent == \"\\n\") {\n      dom.removeChild(node);\n    }\n  });\n\n  dom.childNodes.forEach((node) => {\n    const spellText = node.textContent.replace(//g, \"'\");\n    const spellcastingMatch = spellText.trim().match(/^Spellcasting|^Innate Spellcasting/);\n    if (spellcastingMatch) {\n      spellcasting = parseSpellcasting(spellText);\n      spelldc = parseSpelldc(spellText);\n      spellLevel = parseSpellLevel(spellText);\n      spellAttackBonus = parseBonusSpellAttack(spellText, monster, DDB_CONFIG);\n    }\n\n    const noMaterialSearch = /no material component|no component/;\n    const noMaterialMatch = spellText.match(noMaterialSearch);\n\n    if (noMaterialMatch) {\n      spellList.material = false;\n    }\n\n    [spells, spellList] = parseSpells(spellText, spells, spellList);\n    const additionalAtWill = parseAdditionalAtWill(spellText);\n    spellList.atwill.push(...additionalAtWill);\n  });\n\n  spellList = getEdgeCases(spellList);\n\n  // console.warn(spellList);\n  logger.debug(\"Parsed spell list\", spellList);\n\n  // console.log(\"*****\")\n\n  const result = {\n    spelldc: spelldc,\n    spellcasting: spellcasting,\n    spellLevel: spellLevel,\n    spells: spells,\n    spellList: spellList,\n    spellAttackBonus: spellAttackBonus,\n  };\n\n  // console.log(JSON.stringify(result, null, 4));\n  return result;\n\n}\n\n","import { getSizeFromId } from \"./size.js\";\n\n//   \"value\": \"\",\n//   \"subtype\": \"\",\n//   \"swarm\": {\n//     \"isSwarm\": false,\n//     \"size\": \"\"\n//   },\n//   \"custom\": \"\"\n\n\nexport function getType(monster, DDB_CONFIG) {\n\n  const result = {\n    \"value\": \"\",\n    \"subtype\": \"\",\n    \"swarm\": \"\",\n    // \"swarm\": {\n    //   \"isSwarm\": false,\n    //   \"size\": \"\"\n    // },\n    \"custom\": \"\"\n  };\n\n  if (monster.swarm) {\n    // result.swarm.isSwarm = true;\n    // result.swarm.size = getSizeFromId(monster.swarm.sizeId, DDB_CONFIG).value;\n    result.swarm = getSizeFromId(monster.swarm.sizeId, DDB_CONFIG).value;\n  }\n\n  const type = DDB_CONFIG.monsterTypes.find((c) => monster.typeId == c.id);\n  if (!type) {\n    result.custom = \"Unknown\";\n    return result;\n  }\n\n  const typeName = type.name.toLowerCase();\n\n  if (CONFIG.DND5E.creatureTypes[typeName]) result.value = typeName;\n\n  result.subtype = DDB_CONFIG.monsterSubTypes\n    .filter((c) => monster.subTypes.includes(c.id))\n    .map((c) => c.name)\n    .join(\", \");\n\n  return result;\n\n}\n","import utils from '../../../utils.js';\n\nexport function newNPC(name) {\n  let npc = {\n    name: name,\n    type: \"npc\",\n    data: JSON.parse(utils.getTemplate(\"npc\")),\n    flags: {\n      dnd5e: {},\n      monsterMunch: {},\n      ddbimporter: {\n        dndbeyond: {},\n      },\n    },\n    img: \"icons/svg/mystery-man.svg\",\n    items: [],\n    effects: [],\n    token: {\n      \"flags\": {},\n      \"name\": name,\n      \"displayName\": 20,\n      \"img\": \"icons/svg/mystery-man.svg\",\n      \"width\": 1,\n      \"height\": 1,\n      \"scale\": 1,\n      \"vision\": true,\n      \"dimSight\": 0,\n      \"brightSight\": 0,\n      \"dimLight\": 0,\n      \"brightLight\": 0,\n      \"sightAngle\": 360,\n      \"lightAngle\": 360,\n      \"disposition\": -1,\n      \"displayBars\": 40,\n      \"bar1\": {\n        \"attribute\": \"attributes.hp\"\n      },\n      \"randomImg\": false\n    },\n  };\n  return npc;\n};\n","import { baseItemEffect } from \"../../effects/effects.js\";\nimport utils from \"../../utils.js\";\n\nfunction absorption(monster) {\n  monster.items.forEach((item) => {\n    const absRegEx = /is subjected to (\\w+) damage, it takes no damage and instead regains a number of hit points equal to the (\\w+) damage/;\n    const match = absRegEx.exec(item.data.description.value);\n    if (!item.effects) item.effects = [];\n    if (match) {\n      let effect = baseItemEffect(item, `${item.name}`);\n      effect.changes.push(\n        {\n          key: `flags.midi-qol.absorption.${match[1]}`,\n          value: \"1\",\n          mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n          priority: 20,\n        }\n      );\n      effect.icon = \"icons/svg/downgrade.svg\";\n      item.effects.push(effect);\n    }\n  });\n  return monster;\n}\n\n\n// these are non-compliant monsters\nexport function specialCases(monster) {\n  switch (monster.name) {\n    case \"Sephek Kaltro\": {\n      monster.flags.monsterMunch.spellList.innate = [{ name: \"Misty Step\", type: \"day\", value: 3 }];\n      monster.flags.monsterMunch.spellList.material = false;\n      break;\n    }\n    case \"Reduced-threat Aboleth\":\n    case \"Aboleth\":\n      monster.items.forEach((item) => {\n        if (item.name === \"Tentacle\") {\n          item.data.formula = item.data.damage.parts[1][0];\n          item.data.damage.parts.splice(1, 1);\n        }\n      });\n      break;\n    // no default\n  }\n  const midiQolInstalled = utils.isModuleInstalledAndActive(\"midi-qol\");\n  if (midiQolInstalled) {\n    monster = absorption(monster);\n  }\n  return monster;\n}\n","\nimport { getTokenSenses, getSenses } from \"./senses.js\";\nimport {\n  getDamageImmunities,\n  getDamageResistances,\n  getDamageVulnerabilities,\n  getConditionImmunities,\n} from \"./conditions.js\";\nimport { getAbilities } from \"./abilities.js\";\nimport { getSkills, getSkillsHTML } from \"./skills.js\";\nimport { getLanguages } from \"./languages.js\";\nimport { getHitPoints } from \"./hp.js\";\nimport { getSpeed } from \"./movement.js\";\nimport { getSize } from \"./size.js\";\nimport { getSource } from \"./source.js\";\nimport { getEnvironments } from \"./environments.js\";\nimport { getLairActions } from \"./features/lair.js\";\nimport { getLegendaryActions } from \"./features/legendary.js\";\nimport { getActions } from \"./features/actions.js\";\nimport { getSpecialTraits } from \"./features/specialtraits.js\";\nimport { getSpells } from \"./spells.js\";\nimport { getType } from \"./type.js\";\nimport { generateAC } from \"./ac.js\";\n\nimport { DDB_CONFIG } from \"../../ddbConfig.js\";\nimport { newNPC } from \"./templates/monster.js\";\nimport { specialCases } from \"./special.js\";\n\nimport logger from '../../logger.js';\n\nasync function parseMonster(monster, setVision, extra, useItemAC) {\n  let foundryActor = JSON.parse(JSON.stringify(newNPC(monster.name)));\n  // logger.info(monster);\n  let items = [];\n\n  // name\n  // foundryActor.name = monster.name;\n  // logger.info(\"********************\");\n  // logger.info(monster.name);\n  let img = (monster.basicAvatarUrl) ? monster.basicAvatarUrl : monster.largeAvatarUrl;\n  // foundry doesn't support gifs\n  if (img && img.match(/.gif$/)) {\n    img = null;\n  }\n  foundryActor.token.name = monster.name;\n  foundryActor.flags.monsterMunch = {\n    url: monster.url,\n    img: (img) ? img : monster.avatarUrl,\n    tokenImg: monster.avatarUrl,\n  };\n  foundryActor.flags.ddbimporter = {\n    id: monster.id,\n    entityTypeId: monster.entityTypeId,\n    creatureGroup: monster.creatureGroup ? monster.creatureGroup : null,\n    creatureFlags: monster.creatureFlags ? monster.creatureFlags : [],\n    automatedEvcoationAnimation: monster.automatedEvcoationAnimation ? monster.automatedEvcoationAnimation : undefined,\n    version: CONFIG.DDBI.version,\n  };\n\n  const removedHitPoints = monster.removedHitPoints ? monster.removedHitPoints : 0;\n  const temporaryHitPoints = monster.temporaryHitPoints ? monster.removedHitPoints : 0;\n\n  // abilities\n  foundryActor.data.abilities = getAbilities(foundryActor.data.abilities, monster, DDB_CONFIG);\n\n  // skills\n  foundryActor.data.skills = (extra)\n    ? getSkills(foundryActor.data.skills, monster, DDB_CONFIG)\n    : getSkillsHTML(foundryActor.data.skills, monster, DDB_CONFIG);\n\n  // Senses\n  foundryActor.data.attributes.senses = getSenses(monster, DDB_CONFIG);\n  foundryActor.token = getTokenSenses(foundryActor.token, monster, DDB_CONFIG);\n  foundryActor.token.vision = setVision;\n\n  // Conditions\n  foundryActor.data.traits.di = getDamageImmunities(monster, DDB_CONFIG);\n  foundryActor.data.traits.dr = getDamageResistances(monster, DDB_CONFIG);\n  foundryActor.data.traits.dv = getDamageVulnerabilities(monster, DDB_CONFIG);\n  foundryActor.data.traits.ci = getConditionImmunities(monster, DDB_CONFIG);\n  const size = getSize(monster, DDB_CONFIG);\n  foundryActor.data.traits.size = size.value;\n  foundryActor.token.width = size.token.value;\n  foundryActor.token.height = size.token.value;\n  foundryActor.token.scale = size.token.scale;\n\n\n  // languages\n  foundryActor.data.traits.languages = getLanguages(monster, DDB_CONFIG);\n\n  // attributes\n  foundryActor.data.attributes.hp = getHitPoints(monster, removedHitPoints, temporaryHitPoints);\n  const movement = getSpeed(monster, DDB_CONFIG);\n  foundryActor.data.attributes.movement = movement['movement'];\n\n  foundryActor.data.attributes.prof = DDB_CONFIG.challengeRatings.find((cr) => cr.id == monster.challengeRatingId).proficiencyBonus;\n\n  // ac\n  const ac = await generateAC(monster, DDB_CONFIG, useItemAC);\n  foundryActor.data.attributes.ac = ac.ac;\n  foundryActor.flags.ddbimporter.flatAC = ac.flatAC;\n  items.push(...ac.ddbItems);\n\n  // details\n  const cr = DDB_CONFIG.challengeRatings.find((cr) => cr.id == monster.challengeRatingId);\n  foundryActor.data.details.type = getType(monster, DDB_CONFIG);\n  const alignment = DDB_CONFIG.alignments.find((c) => monster.alignmentId == c.id);\n  foundryActor.data.details.alignment = alignment ? alignment.name : \"\";\n  foundryActor.data.details.cr = cr.value;\n  foundryActor.data.details.source = getSource(monster, DDB_CONFIG);\n  foundryActor.data.details.xp = {\n    value: cr.xp\n  };\n  foundryActor.data.details.environment = getEnvironments(monster, DDB_CONFIG);\n  foundryActor.data.details.biography.value = monster.characteristicsDescription;\n\n  let actions, lairActions, legendaryActions, specialTraits, reactions, bonus, mythic;\n  let characterDescriptionAction, characterDescriptionReaction, unexpectedDescription;\n\n  [actions, characterDescriptionAction] = getActions(monster, DDB_CONFIG);\n  items.push(...actions);\n\n  if (monster.hasLair) {\n    lairActions = getLairActions(monster, DDB_CONFIG);\n    items.push(...lairActions.lairActions);\n    foundryActor.data.resources[\"lair\"] = lairActions.resource;\n  }\n\n  if (monster.legendaryActionsDescription != \"\") {\n    legendaryActions = getLegendaryActions(monster, DDB_CONFIG, actions);\n    items.push(...legendaryActions.legendaryActions);\n    foundryActor.data.resources[\"legact\"] = legendaryActions.actions;\n    foundryActor.token.bar2 = {\n      attribute: \"resources.legact\"\n    };\n  }\n\n  if (monster.specialTraitsDescription != \"\") {\n    specialTraits = getSpecialTraits(monster, DDB_CONFIG, actions);\n    items.push(...specialTraits.specialActions);\n    foundryActor.data.resources[\"legres\"] = specialTraits.resistance;\n  }\n\n  [reactions, characterDescriptionReaction] = getActions(monster, DDB_CONFIG, \"reaction\");\n  items.push(...reactions);\n  [bonus, unexpectedDescription] = getActions(monster, DDB_CONFIG, \"bonus\");\n  items.push(...bonus);\n  [mythic, unexpectedDescription] = getActions(monster, DDB_CONFIG, \"mythic\");\n  items.push(...mythic);\n\n  if (unexpectedDescription) {\n    logger.warn(`Unexpected description for ${monster.name}`);\n  }\n  if (characterDescriptionAction) {\n    foundryActor.data.details.biography.value += characterDescriptionAction;\n  }\n  if (characterDescriptionReaction) {\n    foundryActor.data.details.biography.value += characterDescriptionReaction;\n  }\n  if (specialTraits?.characterDescription) {\n    foundryActor.data.details.biography.value += specialTraits.characterDescription;\n  }\n\n  // Spellcasting\n  const spellcastingData = getSpells(monster, DDB_CONFIG);\n  foundryActor.data.attributes.spellcasting = spellcastingData.spellcasting;\n  foundryActor.data.attributes.spelldc = spellcastingData.spelldc;\n  foundryActor.data.attributes.spellLevel = spellcastingData.spellLevel;\n  foundryActor.data.details.spellLevel = spellcastingData.spellLevel;\n  foundryActor.data.spells = spellcastingData.spells;\n  foundryActor.flags.monsterMunch['spellList'] = spellcastingData.spellList;\n\n  const badItems = items.filter((i) => i.name === \"\" || !i.name);\n  if (badItems.length > 0) {\n    logger.error(`${monster.name} - ${badItems.length} items have no name.`, badItems);\n    items = items.filter((i) => i.name && i.name !== \"\");\n  }\n\n  foundryActor.items = items;\n\n  foundryActor = specialCases(foundryActor);\n  // logger.warn(\"Monster:\", JSON.parse(JSON.stringify(foundryActor)));\n  // console.warn(\"Data:\", monster);\n  // console.warn(\"Monster:\", JSON.parse(JSON.stringify(foundryActor)));\n  // logger.info(foundryActor.data.resources);\n  // logger.info(foundryActor.data.traits.languages);\n\n  // logger.info(foundryActor.data.attributes);\n  return foundryActor;\n\n}\n\nexport async function parseMonsters(monsterData, extra = false) {\n\n  let foundryActors = [];\n  let failedMonsterNames = [];\n\n  const setVision = game.settings.get(\"ddb-importer\", \"munching-policy-monster-use-vision\");\n  const useItemAC = game.settings.get(\"ddb-importer\", \"munching-policy-monster-use-item-ac\");\n\n  monsterData.forEach((monster) => {\n    try {\n      const foundryActor = parseMonster(monster, setVision, extra, useItemAC);\n      foundryActors.push(foundryActor);\n    } catch (err) {\n      logger.error(`Failed parsing ${monster.name}`);\n      logger.error(err);\n      logger.error(err.stack);\n      failedMonsterNames.push(monster.name);\n    }\n\n\n  });\n\n  const result = {\n    actors: await Promise.all(foundryActors),\n    failedMonsterNames: failedMonsterNames,\n  };\n\n  return result;\n}\n\n","export const SKILLS = [\n  { name: \"acr\", label: \"Acrobatics\", ability: \"dex\", subType: \"acrobatics\", valueId: 3 },\n  { name: \"ani\", label: \"Animal Handling\", ability: \"wis\", subType: \"animal-handling\", valueId: 11 },\n  { name: \"arc\", label: \"Arcana\", ability: \"int\", subType: \"arcana\", valueId: 6 },\n  { name: \"ath\", label: \"Athletics\", ability: \"str\", subType: \"athletics\", valueId: 2 },\n  { name: \"dec\", label: \"Deception\", ability: \"cha\", subType: \"deception\", valueId: 16 },\n  { name: \"his\", label: \"History\", ability: \"int\", subType: \"history\", valueId: 7 },\n  { name: \"ins\", label: \"Insight\", ability: \"wis\", subType: \"insight\", valueId: 12 },\n  { name: \"itm\", label: \"Intimidation\", ability: \"cha\", subType: \"intimidation\", valueId: 17 },\n  { name: \"inv\", label: \"Investigation\", ability: \"int\", subType: \"investigation\", valueId: 8 },\n  { name: \"med\", label: \"Medicine\", ability: \"wis\", subType: \"medicine\", valueId: 13 },\n  { name: \"nat\", label: \"Nature\", ability: \"int\", subType: \"nature\", valueId: 9 },\n  { name: \"prc\", label: \"Perception\", ability: \"wis\", subType: \"perception\", valueId: 14 },\n  { name: \"prf\", label: \"Performance\", ability: \"cha\", subType: \"performance\", valueId: 18 },\n  { name: \"per\", label: \"Persuasion\", ability: \"cha\", subType: \"persuasion\", valueId: 19 },\n  { name: \"rel\", label: \"Religion\", ability: \"int\", subType: \"religion\", valueId: 10 },\n  { name: \"slt\", label: \"Sleight of Hand\", ability: \"dex\", subType: \"sleight-of-hand\", valueId: 4 },\n  { name: \"ste\", label: \"Stealth\", ability: \"dex\", subType: \"stealth\", valueId: 5 },\n  { name: \"sur\", label: \"Survival\", ability: \"wis\", subType: \"survival\", valueId: 15 },\n];\n\nimport logger from \"../../logger.js\";\nimport { ABILITIES } from \"./abilities.js\";\n\n// skills: [\n//   { skillId: 5, value: 9, additionalBonus: null },\n//   { skillId: 14, value: 9, additionalBonus: null }\n// ],\n\n// \"skills\": [{\n//   \"skillId\": 7, # History\n//   \"value\": 8,\n//   \"additionalBonus\": null\n// }, {\n//   \"skillId\": 14, # Perception\n//   \"value\": 6,\n//   \"additionalBonus\": null\n// }],\n\n// \"ste\": {\n//   \"value\": 1,\n//   \"ability\": \"dex\",\n//   \"bonus\": 0,\n//   \"mod\": 2,\n//   \"passive\": 19,\n//   \"prof\": 7,\n//   \"total\": 9\n// },\nexport function getSkills (skills, monster, DDB_CONFIG) {\n  const proficiencyBonus = DDB_CONFIG.challengeRatings.find((cr) => cr.id == monster.challengeRatingId).proficiencyBonus;\n\n  const keys = Object.keys(skills);\n  keys.forEach((key) => {\n    let skill = skills[key];\n    const ability = ABILITIES.find((ab) => ab.value === skill.ability);\n    const stat = monster.stats.find((stat) => stat.statId === ability.id).value || 10;\n    const mod = DDB_CONFIG.statModifiers.find((s) => s.value == stat).modifier;\n    const lookupSkill = SKILLS.find((s) => s.name == key);\n    const monsterSkill = monster.skills.find((s) => s.skillId == lookupSkill.valueId);\n\n    skills[key].mod = mod;\n\n    const calculatedScore = proficiencyBonus + mod;\n\n    if (monsterSkill) {\n      skills[key].value = 1;\n      skills[key].prof = proficiencyBonus;\n      skills[key].bonus = monsterSkill.additionalBonus || 0;\n    }\n\n    skills[key].total = calculatedScore;\n    skills[key].passive = 10 + calculatedScore;\n\n    if (monsterSkill && monsterSkill.value != calculatedScore) {\n      if (monsterSkill.value == calculatedScore + proficiencyBonus) {\n        skills[key].passive += proficiencyBonus;\n        skills[key].value = 2;\n        skills[key].total += proficiencyBonus;\n        skills[key].prof += proficiencyBonus;\n        skills[key].bonus = 0;\n      } else if (monsterSkill.value > calculatedScore + proficiencyBonus) {\n        skills[key].passive += proficiencyBonus;\n        skills[key].value = 2;\n        skills[key].total += proficiencyBonus;\n        skills[key].prof += proficiencyBonus;\n      }\n    }\n\n  });\n\n  return skills;\n}\n\n\nexport function getSkillsHTML (skills, monster, DDB_CONFIG) {\n  const proficiencyBonus = DDB_CONFIG.challengeRatings.find((cr) => cr.id == monster.challengeRatingId).proficiencyBonus;\n  //  \"skillsHtml\": \"History + 12, Perception + 10\"\n  const skillsHTML = monster.skillsHtml.split(',');\n  const skillsMaps = skillsHTML.filter((str) => str != '').map((str) => {\n    const skillMatch = str.match(/(\\w+\\s*\\w*\\s*\\w*)(?:\\s*)([+-])(?:\\s*)(\\d+)/);\n    let result = {};\n    if (skillMatch) {\n      result = {\n        name: skillMatch[1].trim(),\n        value: skillMatch[2] + skillMatch[3],\n      };\n    } else {\n      logger.error(`Skill Parsing failed for ${monster.name}`);\n      logger.debug(skillsHTML);\n      logger.debug(str);\n      logger.debug(skillMatch);\n    }\n    return result;\n  });\n\n  const keys = Object.keys(skills);\n  keys.forEach((key) => {\n    let skill = skills[key];\n    const ability = ABILITIES.find((ab) => ab.value === skill.ability);\n    const stat = monster.stats.find((stat) => stat.statId === ability.id).value || 10;\n    const mod = DDB_CONFIG.statModifiers.find((s) => s.value == stat).modifier;\n    const lookupSkill = SKILLS.find((s) => s.name == key);\n    const monsterSkill = monster.skills.find((s) => s.skillId == lookupSkill.valueId);\n\n    skills[key].mod = mod;\n\n    if (monsterSkill) {\n      skills[key].value = 1;\n      skills[key].prof = proficiencyBonus;\n      skills[key].bonus = monsterSkill.additionalBonus || 0;\n    }\n    const calculatedScore = skills[key].prof + mod + skills[key].bonus;\n    skills[key].total = calculatedScore;\n    skills[key].passive = 10 + calculatedScore;\n\n    const htmlSkill = skillsMaps.find((skl) => skl.name == lookupSkill.label);\n\n    if (htmlSkill) {\n      if (htmlSkill.value > calculatedScore) {\n        skills[key].passive += proficiencyBonus;\n        skills[key].value = 2;\n        skills[key].total += proficiencyBonus;\n        skills[key].prof += proficiencyBonus;\n      }\n    }\n\n  });\n\n  return skills;\n}\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array ? array.length : 0;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\n/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  if (value !== value) {\n    return baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * Checks if a cache value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    Set = getNative(root, 'Set'),\n    nativeCreate = getNative(Object, 'create');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each\n * element is kept.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nexport function uniq(array) {\n  return (array && array.length)\n    ? baseUniq(array)\n    : [];\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n","/**\n * @license\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Nick Williams\n * Copyright (c) 2021 Jack Holloway\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nimport { uniq } from \"./lowdash/uniq.js\";\n\n/**\n * generates factory functions to convert table rows to objects,\n * based on the titles in the table's <thead>\n * @param  {Array<String>} headings the values of the table's <thead>\n * @return {(row: HTMLTableRowElement) => Object} a function that takes a table row and spits out an object\n */\nfunction mapRow(headings, highSplit = false) {\n  return function mapRowToObject({ cells }) {\n    const lowCells = [...cells];\n    const highCells = lowCells.length > headings.length ? lowCells.splice(lowCells.length / 2) : [];\n    const range = highSplit ? highCells : lowCells;\n\n    return range.reduce((result, cell, i) => {\n      const input = cell.querySelector(\"input,select\");\n      var value;\n\n      if (input) {\n        value = input.type === \"checkbox\" ? input.checked : input.value;\n      } else {\n        value = cell.innerHTML;\n      }\n\n      return Object.assign(result, { [headings[i]]: value });\n    }, {});\n  };\n}\n\n/**\n * given a table, generate an array of keys/column names\n *\n * @param  {HTMLTableElement} table the table to convert\n * @return {Array<String>}       array of strings representing each header in the table\n */\nexport function getHeadings(table, unique = true) {\n  if (!table.tHead || table.tHead.rows.length === 0) return [];\n  const headings = [...table.tHead.rows[0].cells].map((heading) => {\n    return heading.textContent;\n  });\n\n  if (unique) return uniq(headings);\n  return headings;\n}\n\n\nfunction getRowsFromHeader(table) {\n  let rows = [...table.tHead.rows];\n  rows.splice(0, 1);\n  return rows;\n}\n\n/**\n * given a table, generate an array of objects.\n * each object corresponds to a row in the table.\n * each object's key/value pairs correspond to a column's heading and the row's value for that column\n *\n * @param  {HTMLTableElement} table the table to convert\n * @return {Array<Object>}       array of objects representing each row in the table\n */\nexport function parseTable(table) {\n  const headings = getHeadings(table);\n  const allHeadings = getHeadings(table, false);\n\n  if (headings.length === 0) return [];\n  // some tables are misformated and only have a thead and no tbody\n  const rows = table.tBodies[0]\n    ? [...table.tBodies[0].rows]\n    : table.tHead.rows.length > 1\n      ? getRowsFromHeader(table)\n      : [];\n  // DDB often puts d rolls alongside each other. we attempt to detect these\n  const lowResults = rows.map(mapRow(headings));\n  const highResults =\n    allHeadings.length !== headings.length ? rows.map(mapRow(headings, true)) : [];\n\n  return lowResults.concat(highResults);\n}\n\n","import { parseTable, getHeadings } from \"../../vendor/parseTable.js\";\nimport utils from \"../utils.js\";\nimport logger from \"../logger.js\";\nimport { updateCompendium } from \"./import.js\";\n\nfunction diceRollMatcher(match, p1, p2, p3, p4, p5) {\n  if (p5 && p5.toLowerCase() === \"damage\") {\n    let dmgString = `${p4} damage`;\n    dmgString = dmgString[0].toUpperCase() + dmgString.substring(1);\n    const diceString = utils.parseDiceString(p2, null, `[${p4.toLowerCase()}]`).diceString;\n    return `${p1 ? p1 : \"\"}[[/r ${diceString} # ${dmgString}]]${p3} damage`;\n  } else if (p5 && p1 && p5.toLowerCase() === \"points\" && p1.toLowerCase() === \"regains\") {\n    const diceString = utils.parseDiceString(p2, null, \"[healing]\").diceString;\n    return `${p1 ? p1 : \"\"}[[/r ${diceString} # Healing]]${p3} hit points`;\n  } else {\n    const diceString = utils.parseDiceString(p2).diceString;\n    const result = `${p1 ? p1 : \"\"}[[/r ${diceString}]]${p3 ? p3 : \"\"} ${p4 ? p4 : \"\"} ${p5 ? p5 : \"\"}`.trim();\n    return result;\n  }\n}\n\nfunction replaceRollLinks(text) {\n  text = text.replace(/[-]/gu, \"-\").replace(/-+/g, \"-\");\n  const damageRegex = new RegExp(/([.>( ^]|^|regains +)?(\\d*d\\d+(?:\\s*[+-]\\s*\\d*d*\\d*)*)([.,<)]|$| +) *([a-z,A-Z]*) *(damage|points)?/, \"g\");\n  text = text.replace(damageRegex, diceRollMatcher);\n\n  // const Regex\n  // to hit rolls\n  const toHitRegex = new RegExp(/ ([+-]) *(\\d+) to hit/, \"g\");\n  text = text.replace(toHitRegex, \" [[/r 1d20 $1 $2]] to hit\");\n  return text;\n}\n\nfunction findDiceColumns(table) {\n  let result = [];\n  if (table.tHead) {\n    const headings = getHeadings(table);\n    headings.forEach((h) => {\n      const diceRegex = new RegExp(/(\\d*[d|D]\\d+(\\s*[+-]?\\s*\\d*)?)/, \"g\");\n      const match = h.replace(/[-]/gu, \"-\").replace(/-+/g, \"-\").match(diceRegex);\n      if (match) {\n        result.push(h);\n      }\n    });\n  }\n  return result;\n}\n\nfunction guessTableName(parentName, htmlDocument, tableNum) {\n  const element = htmlDocument.querySelectorAll('table');\n  let track = element[tableNum];\n  let sibling = track.previousElementSibling;\n\n  while (!sibling && track.parentElement?.nodeName === \"DIV\") {\n    if (!track.parentElement.previousElementSibling) {\n      track = track.parentElement;\n    } else {\n      sibling = track.parentElement.previousElementSibling;\n    }\n  }\n\n  if (sibling) {\n    return sibling.textContent;\n  } else {\n    logger.warn(`No table name identified for ${parentName}`);\n    return \"\";\n  }\n}\n\n\nfunction tableReplacer(htmlDocument, tableNum, compendiumTables) {\n  // future enhancement - replace liks to DDB spells, monsters, items etc to munched compendium\n  const element = htmlDocument.querySelectorAll('table');\n  const tablePoint = element[tableNum];\n\n  if (tablePoint) {\n    const rollCompendiumLabel = game.settings.get(\"ddb-importer\", \"entity-table-compendium\");\n    compendiumTables.slice().reverse().forEach((table) => {\n      logger.debug(`Updating table reference for: ${table.name}`);\n      tablePoint.insertAdjacentHTML(\"afterend\", `<div id=\"table-link\">@Compendium[${rollCompendiumLabel}.${table.name}]{Open RollTable ${table.name}}</div>`);\n    });\n  }\n\n  return htmlDocument;\n}\n\n\nfunction diceInt(text) {\n  if (text === \"0\") return 10;\n  if (text === \"00\") return 100;\n  return parseInt(text);\n}\n\n/**\n * This could be:\n * a single value e.g. 19\n * a range of values 19-20\n * remaining values 19+\n * @param {*} value\n * @returns array of range\n */\nfunction getDiceTableRange(value) {\n  const document = utils.htmlToDoc(value);\n  const text = document.body.textContent.replace(/[-]/gu, \"-\").replace(/-+/g, \"-\").replace(/\\s/g, \"\").trim();\n  // eslint-disable-next-line no-useless-escape\n  const valueRegex = new RegExp(/^(\\d+)\\-(\\d+)|^(\\d+)(\\+?)$/);\n  const valueMatch = text.match(valueRegex);\n\n  if (valueMatch) {\n    if (valueMatch[1] !== undefined && valueMatch[2] !== undefined) {\n      const low = diceInt(valueMatch[1]);\n      const high = diceInt(valueMatch[2]);\n      return [low, high];\n    }\n\n    if (valueMatch[3]) {\n      if (valueMatch[4] !== undefined && valueMatch[4] === \"+\") {\n        const low = diceInt(valueMatch[3]);\n        return [low, 0];\n      }\n      if (valueMatch[4] !== undefined && valueMatch[4] === \"\") {\n        const low = diceInt(valueMatch[3]);\n        return [low, low];\n      }\n    }\n  }\n\n  // logger.debug(`Dice range: Unable to table range match '${value}' text was '${text}'`);\n  return [];\n}\n\n\nfunction buildTable(parsedTable, keys, diceKeys, tableName, parentName) {\n  let generatedTables = [];\n\n  diceKeys.forEach((diceKey) => {\n    const nameExtension = diceKeys > 1 ? ` [${diceKeys}]` : \"\";\n    const realName = ((tableName && tableName !== \"\") ? tableName : \"Unnamed Table\") + nameExtension;\n    logger.debug(`Generating table ${realName}`);\n\n    const diceRegex = new RegExp(/(\\d*d\\d+(\\s*[+-]?\\s*\\d*d*\\d*)?)/, \"g\");\n    const formulaMatch = diceKey.match(diceRegex);\n\n    let table = {\n      \"name\": realName,\n      \"sort\": 100000,\n      \"flags\": {\n        \"ddbimporter\": {\n          \"parentName\": parentName,\n          \"keys\": keys,\n          \"diceKeys\": diceKeys\n        }\n      },\n      \"img\": \"icons/svg/d20-grey.svg\",\n      \"description\": \"\",\n      \"results\": [],\n      \"formula\": formulaMatch ? formulaMatch[0].trim() : \"\",\n      \"replacement\": true,\n      \"displayRoll\": true,\n    };\n\n    const concatKeys = (keys.length - diceKeys.length) > 1;\n    // loop through rows and build result entry.\n    // if more than one result key then we will concat the results.\n    parsedTable.forEach((entry) => {\n      const result = {\n        flags: {},\n        type: 0,\n        text: \"\",\n        img: \"icons/svg/d20-black.svg\",\n        resultId: \"\",\n        weight: 1,\n        range: [],\n        drawn: false\n      };\n      Object.entries(entry).forEach(([key, value]) => {\n        if (key === diceKey) {\n          result.range = getDiceTableRange(value);\n        } else if (diceKeys.includes(key)) return;\n        if (concatKeys) {\n          if (result.text != \"\") result.text += \"\\n\\n\";\n          result.text += `<b>${key}</b>${value}`;\n        } else {\n          result.text = value;\n        }\n      });\n      result.text = replaceRollLinks(result.text);\n      const diceRollerRegexp = new RegExp(/\\[\\[\\/r\\s*([0-9d+-\\s]*)(:?#.*)?\\]\\]/);\n      result.text = result.text.replace(diceRollerRegexp, \"[[$1]] ($&)\");\n      table.results.push(result);\n    });\n\n    generatedTables.push(table);\n\n  });\n\n  return generatedTables;\n}\n\nvar tables = {};\n\nexport function generateTable(parentName, html, updateExisting) {\n  const document = utils.htmlToDoc(html);\n  const tableNodes = document.querySelectorAll(\"table\");\n  let tablesMatched = [];\n  let updatedDocument = utils.htmlToDoc(html);\n  if (parentName.startsWith(\"Background:\")) {\n    const parentNamesArray = parentName.split(\":\");\n    if (parentNamesArray.lenghth > 2) parentNamesArray.pop();\n    parentName = parentNamesArray.join(\":\");\n  }\n\n  let tableNum = 0;\n  tableNodes.forEach((node) => {\n  // for (let i = 0; i < tableNodes.length; i++) {\n    // const node = tableNodes[i];\n    const parsedTable = parseTable(node);\n    const keys = getHeadings(node);\n    const diceKeys = findDiceColumns(node);\n    let nameGuess = guessTableName(parentName, document, tableNum);\n    if (nameGuess.split(\" \").length > 5 && diceKeys.length === 1 && keys.length === 2) {\n      nameGuess = keys[1];\n    }\n    const finalName = `${parentName}: ${nameGuess}`;\n    const tableGenerated = (finalName in tables);\n\n    logger.debug(`Table detection triggered for ${parentName}!`);\n    logger.debug(`Table: \"${finalName}\"`);\n    logger.debug(`Dice Keys: ${diceKeys.join(\", \")}`);\n    logger.debug(`Keys: ${keys.join(\", \")}`);\n\n    const builtTables = tableGenerated\n      ? tables[finalName]\n      : buildTable(parsedTable, keys, diceKeys, finalName, parentName);\n\n    if (builtTables.length > 0) {\n      // these updates are done async, and we continue. this is fine as we actually use the table name for linking\n      if (!tableGenerated) {\n        tables[finalName] = builtTables;\n        updateCompendium(\"tables\", { tables: builtTables }, updateExisting);\n      }\n\n      let tableData = {\n        nameGuess,\n        finalName,\n        parentName,\n        tableNum,\n        length: parsedTable.length,\n        keys: keys,\n        diceKeys: diceKeys,\n        diceTable: diceKeys.length > 0,\n        multiDiceKeys: diceKeys.length > 1,\n        diceKeysNumber: diceKeys.length,\n        totalKeys: keys.length,\n        builtTables: tables[finalName],\n      };\n      tablesMatched.push(tableData);\n      updatedDocument = tableReplacer(updatedDocument, tableNum, tableData.builtTables);\n\n    }\n    tableNum++;\n  // }\n  });\n\n  return updatedDocument.body.innerHTML;\n\n}\n","import logger from \"../logger.js\";\n\nexport const BAD_DIRS = [\"[data]\", \"[data] \", \"\", null];\n\nexport function download(content, fileName, contentType) {\n  var a = document.createElement(\"a\");\n  var file = new Blob([content], { type: contentType });\n  a.href = URL.createObjectURL(file);\n  a.download = fileName;\n  a.click();\n}\n\n/**\n * Display information when Munching\n * @param {*} note\n * @param {*} nameField\n */\nexport function munchNote(note, nameField = false, monsterNote = false) {\n  if (nameField) {\n    $('#munching-task-name').text(note);\n    $('#ddb-importer-monsters').css(\"height\", \"auto\");\n  } else if (monsterNote) {\n    $('#munching-task-monster').text(note);\n    $('#ddb-importer-monsters').css(\"height\", \"auto\");\n  } else {\n    $('#munching-task-notes').text(note);\n    $('#ddb-importer-monsters').css(\"height\", \"auto\");\n  }\n}\n\n// a mapping of compendiums with content type\nconst compendiumLookup = [\n  { type: \"spells\", compendium: \"entity-spell-compendium\" },\n  { type: \"spell\", compendium: \"entity-spell-compendium\" },\n  { type: \"feats\", compendium: \"entity-feat-compendium\" },\n  { type: \"features\", compendium: \"entity-feature-compendium\" },\n  { type: \"feature\", compendium: \"entity-feature-compendium\" },\n  { type: \"feat\", name: \"entity-feature-compendium\" },\n  { type: \"classes\", compendium: \"entity-class-compendium\" },\n  { type: \"class\", compendium: \"entity-class-compendium\" },\n  { type: \"races\", compendium: \"entity-race-compendium\" },\n  { type: \"race\", compendium: \"entity-race-compendium\" },\n  { type: \"traits\", compendium: \"entity-trait-compendium\" },\n  { type: \"trait\", compendium: \"entity-trait-compendium\" },\n  { type: \"npc\", compendium: \"entity-monster-compendium\" },\n  { type: \"monsters\", compendium: \"entity-monster-compendium\" },\n  { type: \"monster\", compendium: \"entity-monster-compendium\" },\n  { type: \"custom\", compendium: \"entity-override-compendium\" },\n  { type: \"override\", compendium: \"entity-override-compendium\" },\n  { type: \"inventory\", compendium: \"entity-item-compendium\" },\n  { type: \"item\", compendium: \"entity-item-compendium\" },\n  { type: \"items\", compendium: \"entity-item-compendium\" },\n  { type: \"weapon\", name: \"entity-item-compendium\" },\n  { type: \"consumable\", name: \"entity-item-compendium\" },\n  { type: \"tool\", name: \"entity-item-compendium\" },\n  { type: \"loot\", name: \"entity-item-compendium\" },\n  { type: \"backpack\", name: \"entity-item-compendium\" },\n  { type: \"spell\", name: \"entity-spell-compendium\" },\n  { type: \"equipment\", name: \"entity-item-compendium\" },\n  { type: \"table\", compendium: \"entity-table-compendium\" },\n  { type: \"tables\", compendium: \"entity-table-compendium\" },\n];\n\nexport function getCompendiumLabel(type) {\n  const compendiumName = compendiumLookup.find((c) => c.type == type).compendium;\n  const compendiumLabel = game.settings.get(\"ddb-importer\", compendiumName);\n  return compendiumLabel;\n}\n\nexport function getCompendium(label, fail = true) {\n  const compendium = game.packs.get(label);\n  if (compendium) {\n    return compendium;\n  } else {\n    if (fail) {\n      logger.error(`Unable to find compendium ${label}`);\n      ui.notifications.error(`Unable to open the Compendium ${label}`);\n      throw new Error(`Unable to open the Compendium ${label}`);\n    }\n    return undefined;\n  }\n}\n\nexport function getCompendiumType(type, fail = true) {\n  const compendiumLabel = getCompendiumLabel(type);\n  logger.debug(`Getting compendium ${compendiumLabel} for update of ${type}`);\n  const compendium = getCompendium(compendiumLabel, false);\n  if (compendium) {\n    return compendium;\n  } else {\n    logger.error(`Unable to find compendium ${compendiumLabel} for ${type} documents`);\n    ui.notifications.error(`Unable to open the Compendium ${compendiumLabel}`);\n    if (fail) {\n      throw new Error(`Unable to open the Compendium ${compendiumLabel}`);\n    }\n    return undefined;\n  }\n}\n\nexport function getCampaignId() {\n  const campaignId = game.settings.get(\"ddb-importer\", \"campaign-id\").split('/').pop();\n\n  if (campaignId && campaignId !== \"\" && !Number.isInteger(parseInt(campaignId))) {\n    munchNote(`Campaign Id is invalid! Set to \"${campaignId}\", using empty string`, true);\n    logger.error(`Campaign Id is invalid! Set to \"${campaignId}\", using empty string`);\n    return \"\";\n  } else if (campaignId.includes(\"join\")) {\n    munchNote(`Campaign URL is a join campaign link, using empty string! Set to \"${campaignId}\"`, true);\n    logger.error(`Campaign URL is a join campaign link, using empty string! Set to \"${campaignId}\"`);\n    return \"\";\n  }\n  return campaignId;\n}\n\nexport async function getPatreonTier() {\n  const customProxy = game.settings.get(\"ddb-importer\", \"custom-proxy\");\n  if (customProxy) return { success: true, message: \"custom proxy\", data: \"CUSTOM\" };\n  const key = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const body = { betaKey: key };\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/patreon/tier`, {\n      method: \"POST\",\n      mode: \"cors\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (!data.success) {\n          munchNote(`API Failure: ${data.message}`);\n          reject(data.message);\n        }\n        resolve(data.data);\n      })\n      .catch((error) => reject(error));\n  });\n}\n\nexport async function getPatreonValidity(betaKey) {\n  const customProxy = game.settings.get(\"ddb-importer\", \"custom-proxy\");\n  if (customProxy) return { success: true, message: \"custom proxy\", data: true };\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const body = { betaKey: betaKey };\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/patreon/valid`, {\n      method: \"POST\",\n      mode: \"cors\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body), // body data type must match \"Content-Type\" header\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        resolve(data);\n      })\n      .catch((error) => reject(error));\n  });\n}\n\nexport function getPatreonTiers(tier) {\n  const godTier = tier === \"GOD\";\n  const undyingTier = tier === \"UNDYING\";\n  const coffeeTier = tier === \"COFFEE\";\n  const customProxy = game.settings.get(\"ddb-importer\", \"custom-proxy\");\n  const custom = tier === \"CUSTOM\" || customProxy;\n\n  const tiers = {\n    god: godTier,\n    undying: undyingTier,\n    custom: custom,\n    coffee: coffeeTier,\n    source: godTier || undyingTier || coffeeTier || custom,\n    experimentalMid: godTier || undyingTier,\n    homebrew: godTier || undyingTier || coffeeTier || custom,\n    all: godTier || undyingTier || coffeeTier || custom,\n    supporter: godTier || undyingTier || coffeeTier,\n    not: !godTier && !undyingTier && !coffeeTier && !custom,\n  };\n\n  return tiers;\n}\n\nexport async function checkPatreon() {\n  const tier = await getPatreonTier();\n  const tiers = getPatreonTiers(tier);\n  return tiers;\n}\n\nexport async function setPatreonTier() {\n  const tier = await getPatreonTier();\n  game.settings.set(\"ddb-importer\", \"patreon-tier\", tier);\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport utils from \"../../utils.js\";\n\nimport { DDB_CONFIG } from \"../../ddbConfig.js\";\n\nfunction getCustomProficiencies(data, type) {\n  const profGroup = DDB_CONFIG.proficiencyGroups.find((group) => group.label == type);\n  const profCharacterValues = data.character.characterValues.filter(\n    (value) =>\n      profGroup.customAdjustments.includes(parseInt(value.typeId)) &&\n      profGroup.entityTypeIds.includes(parseInt(value.valueTypeId)) &&\n      value.value == 3\n  );\n  const customProfs = DDB_CONFIG[type.toLowerCase()]\n    .filter((prof) => profCharacterValues.some((value) => value.valueId == prof.id))\n    .map((prof) => prof.name);\n\n  return customProfs;\n}\n\nexport function getProficiencies(data, includeItemEffects = false) {\n  const coreProficiencies = utils\n    .filterBaseModifiers(data, \"proficiency\", null, null, includeItemEffects)\n    .map((proficiency) => {\n      return { name: proficiency.friendlySubtypeName };\n    });\n\n  const customProficiencies = [\n    ...getCustomProficiencies(data, \"Armor\"),\n    ...getCustomProficiencies(data, \"Tools\"),\n    ...getCustomProficiencies(data, \"Weapons\"),\n    ...getCustomProficiencies(data, \"Languages\"),\n  ].map((proficiency) => {\n    return { name: proficiency };\n  });\n  const proficiencies = coreProficiencies.concat(customProficiencies);\n\n  return proficiencies;\n}\n\nexport function getArmorProficiencies(data, proficiencyArray) {\n  let values = [];\n  let custom = [];\n\n  // lookup the characters's proficiencies in the DICT\n  let allProficiencies = DICTIONARY.character.proficiencies.filter((prof) => prof.type === \"Armor\");\n  proficiencyArray.forEach((prof) => {\n    if (prof.name === \"Light Armor\" && !values.includes(\"lgt\")) {\n      values.push(\"lgt\");\n    }\n    if (prof.name === \"Medium Armor\" && !values.includes(\"med\")) {\n      values.push(\"med\");\n    }\n    if (prof.name === \"Heavy Armor\" && !values.includes(\"hvy\")) {\n      values.push(\"hvy\");\n    }\n    if (prof.name === \"Shields\" && !values.includes(\"shl\")) {\n      values.push(\"shl\");\n    }\n    if (allProficiencies.find((p) => p.name === prof.name) !== undefined && !custom.includes(prof.name)) {\n      custom.push(prof.name);\n    }\n  });\n\n  if (data) {\n    // load custom proficiencies in characterValues\n    const customProfs = getCustomProficiencies(data, \"Armor\");\n    custom = custom.concat(customProfs);\n  }\n  return {\n    value: [...new Set(values)],\n    custom: [...new Set(custom)].join(\";\"),\n  };\n}\n\n//\n// DND5E.toolProficiencies = {\n// \"art\": \"Artisan's Tools\",\n// \"disg\": \"Disguise Kit\",\n// \"forg\": \"Forgery Kit\",\n// \"game\": \"Gaming Set\",\n// \"herb\": \"Herbalism Kit\",\n// \"music\": \"Musical Instrument\",\n// \"navg\": \"Navigator's Tools\",\n// \"pois\": \"Poisoner's Kit\",\n// \"thief\": \"Thieves' Tools\",\n// \"vehicle\": \"Vehicle (Land or Water)\"\n// };\n//\nexport function getToolProficiencies(data, proficiencyArray) {\n  let values = [];\n  let custom = [];\n\n  // lookup the characters's proficiencies in the DICT\n  let allToolProficiencies = DICTIONARY.character.proficiencies\n    .filter((prof) => prof.type === \"Tool\")\n    .map((prof) => {\n      return prof;\n    });\n\n  proficiencyArray.forEach((prof) => {\n    // Some have values we can match too in foundry, others have to be custom imported\n    switch (prof.name) {\n      default: {\n        const allProfMatch = allToolProficiencies.find((allProf) => allProf.name === prof.name);\n        if (allProfMatch && allProfMatch.baseTool && allProfMatch.baseTool !== \"\") {\n          values.push(allProfMatch.baseTool);\n        } else if (allProfMatch) {\n          custom.push(prof.name);\n        }\n      }\n    }\n  });\n\n  if (data) {\n    // Custom proficiencies!\n    data.character.customProficiencies.forEach((proficiency) => {\n      if (proficiency.type === 2) {\n        // type 2 is TOOL, 1 is SKILL, 3 is LANGUAGE\n        custom.push(proficiency.name);\n      }\n    });\n\n    // load custom proficiencies in characterValues\n    const customProfs = getCustomProficiencies(data, \"Tools\");\n    custom = custom.concat(customProfs);\n  }\n\n  return {\n    value: [...new Set(values)],\n    custom: [...new Set(custom)].join(\";\"),\n  };\n}\n\nexport function getWeaponProficiencies(data, proficiencyArray) {\n  let values = [];\n  let custom = [];\n\n  // lookup the characters's proficiencies in the DICT\n  const allProficiencies = DICTIONARY.character.proficiencies.filter((prof) => prof.type === \"Weapon\");\n  proficiencyArray.forEach((prof) => {\n    if (prof.name === \"Simple Weapons\" && !values.includes(\"sim\")) {\n      values.push(\"sim\");\n    }\n    if (prof.name === \"Martial Weapons\" && !values.includes(\"mar\")) {\n      values.push(\"mar\");\n    }\n    // new  1.5\n    const systemWeaponIds = CONFIG.DND5E.weaponIds;\n    const dnd5eNameArray = prof.name.toLowerCase().split(\",\");\n    const dnd5eName = dnd5eNameArray.length === 2\n      ? `${dnd5eNameArray[1].trim()}${dnd5eNameArray[0].trim()}`\n      : prof.name.toLowerCase();\n    if (systemWeaponIds && dnd5eName in systemWeaponIds) {\n      if (!values.includes(dnd5eName)) values.push(dnd5eName);\n    } else if (allProficiencies.some((p) => p.name === prof.name) && !custom.includes(prof.name)) {\n      custom.push(prof.name);\n    }\n  });\n\n  if (data) {\n    // load custom proficiencies in characterValues\n    const customProfs = getCustomProficiencies(data, \"Weapons\");\n    custom = custom.concat(customProfs);\n  }\n\n  return {\n    value: [...new Set(values)],\n    custom: [...new Set(custom)].join(\"; \"),\n  };\n}\n\nexport function getLanguagesFromModifiers(data, modifiers) {\n  let languages = [];\n  let custom = [];\n\n  modifiers\n    .filter((mod) => mod.type === \"language\")\n    .forEach((language) => {\n      let result = DICTIONARY.character.languages.find((lang) => lang.name === language.friendlySubtypeName);\n      if (result) {\n        languages.push(result.value);\n      } else {\n        custom.push(language.friendlySubtypeName);\n      }\n    });\n\n  if (data) {\n    data.character.customProficiencies.forEach((proficiency) => {\n      if (proficiency.type === 3) {\n        // type 3 is LANGUAGE, 1 is SKILL, 2 is TOOL\n        custom.push(proficiency.name);\n      }\n    });\n\n    // load custom proficiencies in characterValues\n    const customProfs = getCustomProficiencies(data, \"Languages\");\n    custom = custom.concat(customProfs);\n  }\n\n  return {\n    value: languages,\n    custom: custom.map((entry) => utils.capitalize(entry)).join(\";\"),\n  };\n}\n\nexport function getLanguages(data) {\n  const modifiers = utils.filterBaseModifiers(data, \"language\");\n\n  return getLanguagesFromModifiers(data, modifiers);\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport utils from \"../../utils.js\";\nimport { generateBaseSkillEffect } from \"../../effects/effects.js\";\n\nlet isHalfProficiencyRoundedUp = (data, skill, modifiers = null) => {\n  const longAbility = DICTIONARY.character.abilities\n    .filter((ability) => skill.ability === ability.value)\n    .map((ability) => ability.long)[0];\n\n  const roundUp = (modifiers)\n    ? utils.filterModifiers(modifiers, \"half-proficiency-round-up\", `${longAbility}-ability-checks`)\n    : utils.filterBaseModifiers(data, \"half-proficiency-round-up\", `${longAbility}-ability-checks`, [\"\", null], true);\n  return Array.isArray(roundUp) && roundUp.length;\n};\n\nexport function getSkillProficiency (data, skill, modifiers = null) {\n  if (!modifiers) {\n    modifiers = [\n      utils.getChosenClassModifiers(data, true),\n      utils.getModifiers(data, \"race\", true),\n      utils.getModifiers(data, \"background\", true),\n      utils.getModifiers(data, \"feat\", true),\n      utils.getActiveItemModifiers(data, true),\n    ].flat();\n  }\n\n  const skillMatches = modifiers\n    .filter((modifier) => modifier.friendlySubtypeName === skill.label)\n    .map((mod) => mod.type);\n\n  const halfProficiency = modifiers.find(\n    (modifier) =>\n    // Jack of All trades/half-rounded down\n      (modifier.type === \"half-proficiency\" && modifier.subType === \"ability-checks\") ||\n        // e.g. champion for specific ability checks\n        isHalfProficiencyRoundedUp(data, skill, modifiers)\n  ) !== undefined\n    ? 0.5\n    : 0;\n\n  const proficient = skillMatches.includes(\"expertise\") ? 2 : skillMatches.includes(\"proficiency\") ? 1 : halfProficiency;\n\n  return proficient;\n}\n\nlet getCustomSkillProficiency = (data, skill) => {\n  // Overwrite the proficient value with any custom set over rides\n  if (data.character.characterValues) {\n    const customProficiency = data.character.characterValues.find(\n      (value) => value.typeId === 26 && value.valueId == skill.valueId && value.value\n    );\n    if (customProficiency) {\n      return DICTIONARY.character.customSkillProficiencies.find((prof) => prof.value === customProficiency.value)\n        .proficient;\n    }\n  }\n  return undefined;\n};\n\nlet getCustomSkillAbility = (data, skill) => {\n  // Overwrite the proficient value with any custom set over rides\n  let mod;\n  if (data.character.characterValues) {\n    const customAbility = data.character.characterValues.find(\n      (value) => value.typeId === 27 && value.valueId == skill.valueId\n    );\n    if (customAbility) {\n      const ability = DICTIONARY.character.abilities.find((ability) => ability.id == customAbility.value);\n      if (ability) mod = ability.value;\n    }\n  }\n  return mod;\n};\n\nlet getCustomSkillBonus = (data, skill) => {\n  // Get any custom skill bonuses\n  if (data.character.characterValues) {\n    const customBonus = data.character.characterValues.filter(\n      (value) => (value.typeId == 24 || value.typeId == 25) && value.valueId == skill.valueId\n    ).reduce((total, bonus) => {\n      return total + bonus.value;\n    }, 0);\n\n    if (customBonus) {\n      return customBonus;\n    }\n  }\n  return 0;\n};\n\n\nexport function getSkills(data, character) {\n  let result = {};\n\n  const addEffects = utils.isModuleInstalledAndActive(\"dae\");\n  // dnd 1.5.0 +\n  const SAVE_BONUSES = utils.versionCompare(game.data.system.data.version, \"1.5.0\") >= 0;\n\n  if (!addEffects) character.flags['skill-customization-5e'] = {};\n  DICTIONARY.character.skills.forEach((skill) => {\n    const customProficient = getCustomSkillProficiency(data, skill);\n    // we use !== undefined because the return value could be 0, which is falsey\n    const proficient = customProficient !== undefined ? customProficient : getSkillProficiency(data, skill);\n\n    // some abilities round half prof up, some down\n    const proficiencyBonus = isHalfProficiencyRoundedUp(data, skill)\n      ? Math.ceil(2 * character.data.attributes.prof * proficient)\n      : Math.floor(2 * character.data.attributes.prof * proficient);\n\n    // Skill bonuses e.g. items\n    // These no longer seems to be picked up in recent versions of the DND5e module\n    const skillModifierBonus = utils\n      .filterBaseModifiers(data, \"bonus\", skill.subType)\n      .map((skl) => skl.value)\n      .reduce((a, b) => a + b, 0) || 0;\n    const customSkillBonus = getCustomSkillBonus(data, skill);\n    const skillBonus = skillModifierBonus + customSkillBonus;\n\n    if (addEffects && skillBonus && skillBonus > 0 && !SAVE_BONUSES) {\n      const label = \"Misc Skill Bonuses\";\n      const key = `data.skills.${skill.name}.mod`;\n      const change = {\n        key: key,\n        mode: CONST.ACTIVE_EFFECT_MODES.ADD,\n        value: skillBonus,\n        priority: 20\n      };\n\n      const changeIndex = character.effects.findIndex((effect) => effect.label === label);\n      if (changeIndex >= 0) {\n        character.effects[changeIndex].changes.push(change);\n      } else {\n        let skillEffect = generateBaseSkillEffect(data.character.id, label);\n        skillEffect.changes.push(change);\n        character.effects.push(skillEffect);\n      }\n\n    } else if (skillBonus && skillBonus > 0 && !SAVE_BONUSES) {\n      character.flags['skill-customization-5e'][skill.name] = {\n        \"skill-bonus\": skillBonus\n      };\n    }\n\n    const value = character.data.abilities[skill.ability].value + proficiencyBonus + skillBonus;\n\n    const customAbility = getCustomSkillAbility(data, skill);\n    const ability = customAbility !== undefined ? customAbility : skill.ability;\n\n    // custom skill ability over ride effects\n    if (customAbility) {\n      const label = \"Skill Ability Changes\";\n      const change = {\n        key: `data.skills.${skill.name}.ability`,\n        mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n        value: `${customAbility}`,\n        priority: \"20\"\n      };\n\n      const changeIndex = character.effects.findIndex((effect) => effect.label === label);\n      if (changeIndex >= 0) {\n        character.effects[changeIndex].changes.push(change);\n      } else {\n        let skillEffect = generateBaseSkillEffect(data.character.id, label);\n        skillEffect.changes.push(change);\n        character.effects.push(skillEffect);\n      }\n    }\n\n    result[skill.name] = {\n      type: \"Number\",\n      label: skill.label,\n      ability: ability,\n      value: proficient,\n      mod: utils.calculateModifier(value),\n      bonus: 0,\n    };\n\n    // dnd 1.5.0 +\n    if (SAVE_BONUSES) {\n      result[skill.name].bonuses = {\n        \"check\": `${skillBonus}`,\n        \"passive\": \"\"\n      };\n    } else {\n      result[skill.name].bonus = skillBonus;\n    }\n  });\n\n  return result;\n}\n\n\n","import utils from \"../utils.js\";\nimport logger from \"../logger.js\";\n\nvar srdRules;\n\nexport async function loadSRDRules() {\n  if (srdRules) return;\n  try {\n    // eslint-disable-next-line require-atomic-updates\n    srdRules = await game.packs.get(\"dnd5e.rules\").getIndex();\n  } catch (err) {\n    logger.error(\"5e SRD Rules compendium failed to load\");\n    // eslint-disable-next-line require-atomic-updates\n    srdRules = [];\n  }\n}\n\n/**\n * Gets the levelscaling value for a feature\n * @param {*} feature\n */\nconst getScalingValue = (feature) => {\n  if (feature && feature.levelScale && feature.levelScale.fixedValue) {\n    return feature.levelScale.fixedValue;\n  } else if (feature && feature.levelScale && feature.levelScale.dice) {\n    return feature.levelScale.dice.diceString;\n  } else {\n    return \"{{scalevalue-unknown}}\";\n  }\n};\n\n/**\n * Parse a match and replace template values ready for evaluation\n * @param {*} ddb\n * @param {*} character\n * @param {*} match\n * @param {*} feature\n */\nlet parseMatch = (ddb, character, match, feature) => {\n  const splitMatchAt = match.split(\"@\");\n  let result = splitMatchAt[0];\n  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;\n\n  // scalevalue\n  if (result.includes(\"scalevalue\")) {\n    const feat = feature.levelScale ? feature : utils.findComponentByComponentId(ddb, feature.componentId);\n    const scaleValue = getScalingValue(feat);\n    result = result.replace(\"scalevalue\", scaleValue);\n  }\n\n  // savedc:int\n  // savedc:str,dex\n  if (result.includes(\"savedc\")) {\n    const regexp = /savedc:([a-z]{3})(?:,)?([a-z]{3})?/g;\n    const matches = [...result.matchAll(regexp)];\n\n    matches.forEach((match) => {\n      const saves = match.slice(1);\n      const saveDCs = saves\n        .filter((save) => save)\n        .map((save) => {\n          const abilityModifier = utils.calculateModifier(characterAbilities[save].value);\n          // not sure if we should add this, probably not.\n          // const bonus = utils.getModifierSum(utils.filterBaseModifiers(ddb, \"bonus\", \"spell-save-dc\"), character);\n          const dc = 8 + character.data.attributes.prof + abilityModifier;\n          return dc;\n        });\n      const saveRegexp = RegExp(match[0], \"g\");\n      result = result.replace(saveRegexp, Math.max(...saveDCs));\n    });\n  }\n\n  // modifier:int@min:1\n  // (modifier:cha)+1\n  if (result.includes(\"modifier\")) {\n    const regexp = /modifier:([a-z]{3})/g;\n    // creates array from match groups and dedups\n    const ability = [...new Set(Array.from(result.matchAll(regexp), (m) => m[1]))];\n\n    ability.forEach((ab) => {\n      const abilityModifier = characterAbilities[ab].mod;\n      const abRegexp = RegExp(`modifier:${ab}`, \"g\");\n      result = result.replace(abRegexp, abilityModifier);\n    });\n  }\n\n  // classlevel*5\n  // (classlevel/2)@roundup\n  if (result.includes(\"classlevel\")) {\n    const cls = feature.classId\n      ? ddb.character.classes.find((cls) => cls.definition.id == feature.classId)\n      : utils.findClassByFeatureId(ddb, feature.componentId);\n    if (cls) {\n      result = result.replace(\"classlevel\", cls.level);\n    } else {\n      // still not found a cls? could be an option\n      const classOption = [ddb.character.options.race, ddb.character.options.class, ddb.character.options.feat]\n        .flat()\n        .find((option) => option.definition.id === feature.componentId);\n      if (!classOption) {\n        if (!feature.componentId) {\n          logger.debug(\"Feature failed componentID parse\", feature);\n        }\n        logger.error(`Unable to parse option class info. ComponentId is ${feature.componentId}`);\n      } else {\n        const optionCls = utils.findClassByFeatureId(ddb, classOption.componentId);\n        if (optionCls) {\n          result = result.replace(\"classlevel\", optionCls.level);\n        } else {\n          logger.error(`Unable to parse option class info. classOption ComponentId is: ${classOption.componentId}.  ComponentId is ${feature.componentId}`);\n        }\n      }\n    }\n  }\n\n  if (result.includes(\"characterlevel\")) {\n    result = result.replace(\"characterlevel\", character.flags.ddbimporter.dndbeyond.totalLevels);\n  }\n\n  if (result.includes(\"proficiency\")) {\n    const profBonus = character.data.attributes.prof;\n    result = result.replace(\"proficiency\", profBonus);\n  }\n\n  // abilityscore:int\n  if (result.includes(\"abilityscore\")) {\n    const regexp = /abilityscore:([a-z]{3})/g;\n    // creates array from match groups and dedups\n    const ability = [...new Set(Array.from(result.matchAll(regexp), (m) => m[1]))];\n\n    ability.forEach((ab) => {\n      const abilityModifier = characterAbilities[ab].value;\n      const abRegexp = RegExp(`abilityscore:${ab}`, \"g\");\n      result = result.replace(abRegexp, abilityModifier);\n    });\n  }\n\n  // limiteduse\n  if (result.includes(\"limiteduse\")) {\n    const limitedUse = feature.limitedUse?.maxUses || \"\";\n    result = result.replace(\"limiteduse\", limitedUse);\n  }\n\n  return result;\n};\n\n/**\n * Apply the expression constraint\n * @param {*} value\n * @param {*} constraint\n */\nconst applyConstraint = (value, constraint) => {\n  // {{(classlevel/2)@rounddown#unsigned}}\n  // @ features\n  // @roundup\n  // @roundown\n  // min:1\n  // max:3\n  const splitConstraint = constraint.split(\":\");\n  const multiConstraint = splitConstraint[0].split(\"*\");\n  const match = multiConstraint[0];\n\n  let result = value;\n\n  switch (match) {\n    case \"max\": {\n      if (splitConstraint[1] < result) result = splitConstraint[1];\n      break;\n    }\n    case \"min\": {\n      if (splitConstraint[1] > result) result = splitConstraint[1];\n      break;\n    }\n    case \"roundup\": {\n      result = Math.ceil(result);\n      break;\n    }\n    case \"rounddown\":\n    case \"roundown\": {\n      result = Math.floor(result);\n      break;\n    }\n    default: {\n      logger.debug(`Missed match is ${match}`);\n      logger.warn(`ddb-importer does not know about template constraint {{@${constraint}}}. Please log a bug.`); // eslint-disable-line no-console\n    }\n  }\n\n  if (multiConstraint.length > 1) {\n    const evalStatement = `${result}*${multiConstraint[1]}`;\n    /* eslint-disable no-eval */\n    result = eval(evalStatement);\n    /* eslint-enable no-eval */\n  }\n\n  return result;\n};\n\nconst escapeRegExp = (string) => {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n};\n\nconst getNumber = (theNumber) => {\n  if (theNumber >= 0) {\n    return \"+\" + theNumber;\n  } else {\n    return theNumber.toString();\n  }\n};\n\n// eslint-disable-next-line no-unused-vars\nfunction replaceTag(match, p1, p2, p3, offset, string) {\n  if (!p2) {\n    logger.warn(`Unable to tag parse ${match}`);\n    return match;\n  }\n  // console.warn(\"stuff\", {\n  //   match, p1, p2, p3, offset, string\n  // })\n  // logger.debug(`Checking tag ${p2} in SRD rules`);\n  const srdMatch = srdRules.find((rule) => rule.name.toLowerCase() === p2.toLowerCase());\n  if (srdMatch) {\n    return `@Compendium[dnd5e.rules.${srdMatch._id}]{${p2}}`;\n  } else {\n    logger.info(`Unable to find tag parse compendium match for ${match}`);\n  }\n  return p2;\n}\n\nfunction parseTags(text) {\n  if (!srdRules) return text;\n  // older chrome/chromium and electron app do not support replaceAll\n  if (typeof text.replaceAll !== \"function\") {\n    return text;\n  }\n  const tagRegEx = /\\[([^\\]]+)]([^[]+)\\[\\/([^\\]]+)]/g;\n  const matches = text.match(tagRegEx);\n  if (matches) {\n    return text.replaceAll(tagRegEx, replaceTag);\n  }\n  return text;\n}\n\n/**\n * This will parse a snippet/description with template boilerplate in from DDB.\n * e.g. Each creature in the area must make a DC {{savedc:con}} saving throw.\n * @param {*} ddb\n * @param {*} text\n */\nexport default function parseTemplateString(ddb, character, text, feature) {\n  if (!text) return text;\n  let result = {\n    id: feature.id,\n    entityTypeId: feature.entityTypeId,\n    componentId: (feature.componentId) ? feature.componentId : null,\n    componentTypeId: (feature.componentTypeId) ? feature.componentTypeId : null,\n    damageTypeId: (feature.damageTypeId) ? feature.damageTypeId : null,\n    text: text,\n    resultString: \"\",\n    definitions: [],\n  };\n\n  const regexp = /{{(.*?)}}/g;\n  // creates array from match groups and dedups\n  const matches = [...new Set(Array.from(result.text.matchAll(regexp), (m) => m[1]))];\n\n  matches.forEach((match) => {\n    let entry = {\n      parsed: null,\n      match: match,\n      replacePattern: new RegExp(`{{${escapeRegExp(match)}}}`, \"g\"),\n      type: null,\n      subType: null,\n    };\n\n    const splitRemoveUnsigned = match.split(\"#\")[0];\n    const splitMatchAt = splitRemoveUnsigned.split(\"@\");\n    const parsedMatch = parseMatch(ddb, character, splitRemoveUnsigned, feature);\n    const dicePattern = /\\d*d\\d\\d*/;\n    const typeSplit = splitMatchAt[0].split(':');\n    entry.type = typeSplit[0];\n    if (typeSplit.length > 1) entry.subType = typeSplit[1];\n    // do we have a dice string, e.g. sneak attack?\n    if (parsedMatch.match(dicePattern)) {\n      entry.type = \"dice\";\n      entry.parsed = parsedMatch;\n      result.text = result.text.replace(entry.replacePattern, entry.parsed);\n    } else {\n      // we try and eval the expression!\n      try {\n        /* eslint-disable no-eval */\n        // eval is bad, it's quite slow and risky, however it avoids having to write a string parsing engine\n        const evalMatch = eval(parsedMatch);\n        /* eslint-enable no-eval */\n        if (splitMatchAt.length > 1) {\n          const constraintAdjusted = applyConstraint(evalMatch, splitMatchAt[1]);\n          entry.parsed = getNumber(constraintAdjusted);\n        } else {\n          entry.parsed = getNumber(evalMatch);\n        }\n        entry.parsed = entry.parsed.replace(\"+ +\", \"+\");\n        result.text = result.text.replace(entry.replacePattern, entry.parsed);\n      } catch (err) {\n        result.text = result.text.replace(entry.replacePattern, `{{${match}}}`);\n        logger.warn(`ddb-importer does not know about template value {{${match}}}. Please log a bug.`, err);\n        logger.warn(err.stack);\n      }\n    }\n    if (entry.parsed) result.resultString += entry.parsed;\n    result.definitions.push(entry);\n  });\n\n  result.text = result.text.replace(\"+ +\", \"+\");\n  // result.text = await parseTags(result.text);\n  result.text = parseTags(result.text);\n  character.flags.ddbimporter.dndbeyond.templateStrings.push(result);\n  return result;\n}\n","import { DirectoryPicker } from \"./lib/DirectoryPicker.js\";\nimport DICTIONARY from \"./dictionary.js\";\nimport logger from \"./logger.js\";\nimport { DDB_CONFIG } from \"./ddbConfig.js\";\nimport { getEffectExcludedModifiers } from \"./effects/effects.js\";\n\nconst existingFiles = new Set();\n\nconst utils = {\n  debug: () => {\n    return true;\n  },\n\n  getDamageType: (data) => {\n    if (data.definition.damageType) {\n      const damageTypeReplace = data.definition.grantedModifiers.find((mod) =>\n        mod.type === \"replace-damage-type\" &&\n        (!mod.restriction || mod.restriction === \"\")\n      );\n\n      const damageType = damageTypeReplace\n        ? damageTypeReplace.subType.toLowerCase()\n        : data.definition.damageType.toLowerCase();\n      return damageType;\n    } else {\n      return undefined;\n    }\n  },\n\n  globalDamageTagInfo: (mod) => {\n    const globalDamageHints = game.settings.get(\"ddb-importer\", \"use-damage-hints\");\n    const damageRestrictionHints = game.settings.get(\"ddb-importer\", \"add-damage-restrictions-to-hints\");\n    const hintOrRestriction = globalDamageHints || damageRestrictionHints;\n    const restriction = damageRestrictionHints && mod.restriction && mod.restriction !== \"\" ? mod.restriction : \"\";\n    const hintAndRestriction = globalDamageHints && restriction !== \"\" ? \" - \" : \"\";\n\n    return {\n      globalDamageHints,\n      damageRestrictionHints,\n      hintOrRestriction,\n      hintAndRestriction,\n      restriction,\n    };\n  },\n\n  getDamageTag(mod, overrideDamageType) {\n    const damageTagData = utils.globalDamageTagInfo(mod);\n    const damageType = overrideDamageType\n      ? overrideDamageType\n      : mod.subType && damageTagData.globalDamageHints ? mod.subType : \"\";\n    const damageHint = damageTagData.hintOrRestriction\n      ? `${damageType}${damageTagData.hintAndRestriction}${damageTagData.restriction}`\n      : \"\";\n    const damageTag = damageTagData.hintOrRestriction ? `[${damageHint}]` : \"\";\n    return {\n      globalDamageHints: damageTagData.globalDamageHints,\n      damageRestrictionHints: damageTagData.damageRestrictionHints,\n      hintOrRestriction: damageTagData.hintOrRestriction,\n      hintAndRestriction: damageTagData.hintAndRestriction,\n      restriction: damageTagData.restriction,\n      damageType,\n      damageHint,\n      damageTag,\n    };\n  },\n\n  getDamageTagForMod: (mod) => {\n    const damageTagData = utils.getDamageTag(mod);\n    return damageTagData;\n  },\n\n  getDamageTagForItem(data) {\n    const damageType = utils.getDamageType(data);\n    const damageTagData = utils.getDamageTag({}, damageType);\n    return damageTagData;\n  },\n\n  findByProperty: (arr, property, searchString) => {\n    function levenshtein(a, b) {\n      let tmp;\n      if (a.length === 0) {\n        return b.length;\n      }\n      if (b.length === 0) {\n        return a.length;\n      }\n      if (a.length > b.length) {\n        tmp = a;\n        a = b;\n        b = tmp;\n      }\n\n      let i,\n        j,\n        res,\n        alen = a.length,\n        blen = b.length,\n        row = Array(alen);\n      for (i = 0; i <= alen; i++) {\n        row[i] = i;\n      }\n\n      for (i = 1; i <= blen; i++) {\n        res = i;\n        for (j = 1; j <= alen; j++) {\n          tmp = row[j - 1];\n          row[j - 1] = res;\n          res = b[i - 1] === a[j - 1] ? tmp : Math.min(tmp + 1, Math.min(res + 1, row[j] + 1));\n        }\n      }\n      return res;\n    }\n\n    const maxDistance = 3;\n    let minDistance = 100;\n    let nearestHit = undefined;\n    let nearestDistance = minDistance;\n\n    if (!Array.isArray(arr)) return undefined;\n    arr\n      .filter((entry) => Object.prototype.hasOwnProperty.call(entry, property))\n      .forEach((entry) => {\n        let distance = levenshtein(searchString, entry[property]);\n        if (distance < nearestDistance && distance <= maxDistance && distance < minDistance) {\n          nearestHit = entry;\n          nearestDistance = distance;\n        }\n      });\n\n    return nearestHit;\n  },\n\n  hasChosenCharacterOption: (data, optionName) => {\n    const hasClassOptions = [data.character.options.race, data.character.options.class, data.character.options.feat]\n      .flat()\n      .some((option) => option.definition.name === optionName);\n    return hasClassOptions;\n  },\n\n  getClassFromOptionID: (data, optionId) => {\n    // Use case class spell - which class?\n    // componentId on spells.class[0].componentId = options.class[0].definition.id\n    // options.class[0].definition.componentId = classes[0].classFeatures[0].definition.id\n    const option = data.character.options.class.find((option) => option.definition.id === optionId);\n\n    if (option) {\n      const klass = data.character.classes.find((klass) =>\n        klass.classFeatures.some((feature) => feature.definition.id === option.componentId)\n      );\n      return klass;\n    }\n    return undefined;\n  },\n\n  /**\n   * Look up a component by id\n   * For now we assume that most features we are going to want to get a scaling value\n   * from are character options\n   * @param {*} ddb\n   * @param {*} featureId\n   */\n\n  findComponentByComponentId: (ddb, componentId) => {\n    let result;\n\n    ddb.character.classes.forEach((cls) => {\n      const feature = cls.classFeatures.find((component) => component.definition.id === componentId);\n      if (feature) result = feature;\n    });\n\n    const optionalClassFeature = ddb.classOptions.find((option) => option.id == componentId);\n    if (optionalClassFeature && !result) {\n      result = optionalClassFeature;\n      const optionalLevelScales = optionalClassFeature.levelScales && optionalClassFeature.levelScales.length > 0;\n      if (result && !result.levelScale && optionalLevelScales) {\n        const klass = ddb.character.classes.find((cls) => cls.definition.id === optionalClassFeature.classId);\n        const klassLevel = klass ? klass.level : undefined;\n        if (klassLevel) {\n          const levelFilteredScales = optionalClassFeature.levelScales.filter((scale) => scale.level <= klassLevel);\n          if (levelFilteredScales.length > 0) {\n            result.levelScale = levelFilteredScales\n              .reduce((previous, current) => {\n                if (previous.level > current.level) return previous;\n                return current;\n              });\n          }\n        }\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   *\n   * Gets the sourcebook for a subset of dndbeyond sources\n   * @param {obj} definition item definition\n   */\n  getSourceData: (definition) => {\n    const fullSource = game.settings.get(\"ddb-importer\", \"use-full-source\");\n    const result = {\n      name: null,\n      page: null,\n    };\n    if (definition.sources?.length > 0) {\n      result.name = DDB_CONFIG.sources\n        .filter((source) => definition.sources.some((ds) => source.id === ds.sourceId))\n        .map((source) => {\n          const dSource = definition.sources.find((ds) => source.id === ds.sourceId);\n          const page = dSource.pageNumber ? ` pg ${dSource.pageNumber}` : \"\";\n          const sourceBook = dSource ? (fullSource ? source.description : source.name) : \"Homebrew\";\n          return `${sourceBook}${page}`;\n        })\n        .join(\", \");\n    } else {\n      if (definition.sourceIds) {\n        result.name = DDB_CONFIG.sources\n          .filter((source) => definition.sourceIds.includes(source.id))\n          .map((source) => source.description)\n          .join();\n      } else if (definition.sourceId) {\n        result.name = DDB_CONFIG.sources\n          .filter((source) => source.id === definition.sourceId)\n          .map(\n            fullSource\n              ? ({ description }) => description\n              : ({ name }) => name\n          );\n      }\n\n      // add a page num if available\n      if (definition.sourcePageNumber) result.page = definition.sourcePageNumber;\n    }\n    return result;\n  },\n\n  /**\n   * Fetches the sources and pages for a definition\n   * @param {obj} data item\n   */\n  parseSource: (definition) => {\n    const sourceData = utils.getSourceData(definition);\n\n    let source = sourceData.name;\n    if (sourceData.page) source += ` (pg. ${sourceData.page})`;\n\n    return source;\n  },\n\n  getActiveItemModifiers: (data, includeExcludedEffects = false) => {\n    // are we adding effects to items?\n    const addEffects = game.settings.get(\"ddb-importer\", \"character-update-policy-add-item-effects\");\n    const daeInstalled = utils.isModuleInstalledAndActive(\"dae\");\n    const excludedModifiers = (addEffects && daeInstalled && !includeExcludedEffects) ? getEffectExcludedModifiers(\"item\", true, true) : [];\n    // get items we are going to interact on\n    const modifiers = data.character.inventory\n      .filter(\n        (item) =>\n          ((!item.definition.canEquip && !item.definition.canAttune && !item.definition.isConsumable) || // if item just gives a thing and not potion/scroll\n          (item.isAttuned && item.equipped) || // if it is attuned and equipped\n          (item.isAttuned && !item.definition.canEquip) || // if it is attuned but can't equip\n            (!item.definition.canAttune && item.equipped)) && // can't attune but is equipped\n          item.definition.grantedModifiers.length > 0\n      )\n      .flatMap((item) => item.definition.grantedModifiers)\n      .filter((mod) => !excludedModifiers.some((exMod) =>\n        mod.type === exMod.type &&\n        (mod.subType === exMod.subType || !exMod.subType))\n      );\n\n    return modifiers;\n  },\n\n  getActiveItemEffectModifiers: (data) => {\n    return utils.getActiveItemModifiers(data, true).filter((mod) =>\n      getEffectExcludedModifiers(\"item\", true, true).some((exMod) => mod.type === exMod.type &&\n      (mod.subType === exMod.subType || !exMod.subType))\n    );\n  },\n\n  getModifiers: (data, type, includeExcludedEffects = false, effectOnly = false) => {\n    // are we adding effects to items?\n    const featureEffects = game.settings.get(\"ddb-importer\", \"character-update-policy-add-character-effects\");\n    const acEffects = game.settings.get(\"ddb-importer\", \"character-update-policy-generate-ac-feature-effects\");\n    const daeInstalled = utils.isModuleInstalledAndActive(\"dae\");\n    const excludedModifiers = ((featureEffects || acEffects) && daeInstalled &&\n      (!includeExcludedEffects || (includeExcludedEffects && effectOnly)))\n      ? getEffectExcludedModifiers(type, featureEffects, acEffects)\n      : getEffectExcludedModifiers(type, false, false);\n    // get items we are going to interact on\n    let modifiers = [];\n    if (effectOnly) {\n      modifiers = data.character.modifiers[type]\n        .filter((mod) => excludedModifiers.some((exMod) =>\n          mod.type === exMod.type &&\n        (mod.subType === exMod.subType || !exMod.subType))\n        );\n    } else {\n      modifiers = data.character.modifiers[type]\n        .filter((mod) => !excludedModifiers.some((exMod) =>\n          mod.type === exMod.type &&\n        (mod.subType === exMod.subType || !exMod.subType))\n        );\n    }\n\n    return modifiers;\n  },\n\n  filterModifiers: (modifiers, type, subType = null, restriction = [\"\", null]) => {\n    return modifiers\n      .flat()\n      .filter(\n        (modifier) =>\n          modifier.type === type &&\n          (subType !== null ? modifier.subType === subType : true) &&\n          (!restriction ? true : restriction.includes(modifier.restriction))\n      );\n  },\n\n  getChosenClassModifiers: (data, includeExcludedEffects = false, effectOnly = false) => {\n    // get items we are going to interact on\n    const modifiers = utils.getModifiers(data, 'class', includeExcludedEffects, effectOnly).filter((mod) => {\n      const isClassFeature = data.character.classes.some((klass) => klass.classFeatures.some((feat) =>\n        feat.definition.id == mod.componentId && feat.definition.entityTypeId == mod.componentTypeId &&\n        // make sure this class feature is not replaced\n        !data.character.optionalClassFeatures.some((f) => f.affectedClassFeatureId == feat.definition.id)\n      ));\n      // generate a list to check in option check\n      const classFeatureIds = data.character.classes.map((klass) => klass.classFeatures.map((feat) => feat.definition.id)).flat();\n      const isClassOption = data.character.options.class.some((option) =>\n        // does this class option match a modifier?\n        ((option.componentTypeId == mod.componentTypeId && option.componentId == mod.componentId) ||\n        (option.definition.entityTypeId == mod.componentTypeId && option.definition.id == mod.componentId)) &&\n        // has this feature set been replacd by an optional class feature?\n        !data.character.optionalClassFeatures.some((f) => f.affectedClassFeatureId == option.componentId) &&\n        // has it been chosen?\n        data.character.choices.class.some((choice) =>\n          choice.componentId == option.componentId && choice.componentTypeId == option.componentTypeId && choice.optionValue\n        ) &&\n        // is this option actually part of the class list?\n        classFeatureIds.includes(option.componentId)\n      );\n      // if it's been replaced by a class feature lets check that\n      const isOptionalClassOption = data.character.options.class.some((option) =>\n        ((option.componentTypeId == mod.componentTypeId && option.componentId == mod.componentId) ||\n        (option.definition.entityTypeId == mod.componentTypeId && option.definition.id == mod.componentId)) &&\n        // !data.character.optionalClassFeatures.some((f) => f.affectedClassFeatureId == option.definition.id) &&\n        (\n          data.character.choices.class.some((choice) =>\n            choice.componentId == option.componentId && choice.componentTypeId == option.componentTypeId && choice.optionValue\n          ) ||\n          data.classOptions?.some((classOption) =>\n            classOption.id == option.componentId && classOption.entityTypeId == option.componentTypeId\n          )\n        ) &&\n        data.character.optionalClassFeatures?.some((f) => f.classFeatureId == option.componentId)\n      );\n\n      // new class feature choice\n      const isOptionalClassChoice = data.character.choices.class.some((choice) =>\n        choice.componentTypeId == mod.componentTypeId &&\n        choice.componentId == mod.componentId &&\n        data.character.optionalClassFeatures?.some((f) => f.classFeatureId == choice.componentId)\n      );\n\n      return isClassFeature || isClassOption || isOptionalClassOption || isOptionalClassChoice;\n    });\n\n    return modifiers;\n  },\n\n\n  filterBaseCharacterModifiers: (data, type, subType = null, restriction = [\"\", null], includeExcludedEffects = false, effectOnly = false) => {\n    const modifiers = [\n      utils.getChosenClassModifiers(data, includeExcludedEffects, effectOnly),\n      utils.getModifiers(data, \"race\", includeExcludedEffects, effectOnly),\n      utils.getModifiers(data, \"background\", includeExcludedEffects, effectOnly),\n      utils.getModifiers(data, \"feat\", includeExcludedEffects, effectOnly),\n    ];\n\n    return utils.filterModifiers(modifiers, type, subType, restriction);\n  },\n\n  // I need to getChosenOriginFeatures from data.optionalOriginFeatures\n\n  filterBaseModifiers: (data, type, subType = null, restriction = [\"\", null], includeExcludedEffects = false, effectOnly = false) => {\n    const modifiers = [\n      utils.getChosenClassModifiers(data, includeExcludedEffects, effectOnly),\n      utils.getModifiers(data, \"race\", includeExcludedEffects, effectOnly),\n      utils.getModifiers(data, \"background\", includeExcludedEffects, effectOnly),\n      utils.getModifiers(data, \"feat\", includeExcludedEffects, effectOnly),\n      utils.getActiveItemModifiers(data, includeExcludedEffects),\n    ];\n\n    return utils.filterModifiers(modifiers, type, subType, restriction);\n  },\n\n  /**\n   * Checks the list of modifiers provided for a matching bonus type\n   * and returns a sum of it's value. May include a dice string.\n   * @param {*} modifiers\n   * @param {*} character\n   * @param {*} bonusSubType\n   */\n  getModifierSum: (modifiers, character) => {\n    let sum = 0;\n    let diceString = \"\";\n    let modBonus = 0;\n    modifiers.forEach((modifier) => {\n      const fixedBonus = modifier.dice?.fixedValue ? modifier.dice.fixedValue : 0;\n      const statBonus = (modifier.statId)\n        ? modifier.statId\n        : modifier.abilityModifierStatId\n          ? modifier.abilityModifierStatId\n          : null;\n      if (statBonus) {\n        const ability = DICTIONARY.character.abilities.find((ability) => ability.id === modifier.statId);\n        modBonus += character.data.abilities[ability.value].mod;\n      }\n      if (modifier.dice) {\n        const mod = modifier.dice.diceString;\n        diceString += diceString === \"\" ? mod : \" + \" + mod;\n        if (modifier.dice.diceString) {\n          const mod = modifier.dice.diceString + modBonus + fixedBonus;\n          diceString += diceString === \"\" ? mod : \" + \" + mod;\n        } else if (fixedBonus) {\n          sum += fixedBonus + modBonus;\n        }\n      } else if (modifier.fixedValue) {\n        sum += modifier.fixedValue;\n      } else if (modifier.value) {\n        sum += modifier.value;\n      } else if (modBonus !== 0) {\n        sum += modBonus;\n      } else if (modifier.modifierTypeId === 1 && modifier.modifierSubTypeId === 218) {\n        // prof bonus\n        sum += character.data.attributes.prof;\n      }\n    });\n    if (diceString !== \"\") {\n      sum = diceString + \" + \" + sum;\n    }\n\n    return sum;\n  },\n\n  /**\n   * Searches for selected options if a given feature provides choices to the user\n   * @param {string} type character property: \"class\", \"race\" etc.\n   * @param {object} feat options to search for\n   */\n  getChoices: (ddb, type, feat) => {\n    const id = feat.id ? feat.id : feat.definition.id ? feat.definition.id : null;\n\n    if (ddb.character.choices[type] && Array.isArray(ddb.character.choices[type])) {\n      // find a choice in the related choices-array\n      const choices = ddb.character.choices[type].filter(\n        (characterChoice) => characterChoice.componentId && characterChoice.componentId === id\n      );\n\n      if (choices) {\n        const choiceDefinitions = ddb.character.choices.choiceDefinitions;\n\n        const options = choices\n          .filter(\n            (choice) => {\n              const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);\n              const validOption = optionChoice && optionChoice.options.find((option) => option.id === choice.optionValue);\n              return validOption;\n            })\n          .map((choice) => {\n            // console.warn(choice);\n            const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);\n            let result = optionChoice.options.find((option) => option.id === choice.optionValue);\n            result.componentId = choice.componentId;\n            result.componentTypeId = choice.componentTypeId;\n            result.choiceId = choice.id;\n            result.parentChoiceId = choice.parentChoiceId;\n            result.subType = choice.subType;\n            // console.log(result);\n            return result;\n          });\n        return options;\n      }\n    }\n    // we could not determine if there are any choices left\n    return undefined;\n  },\n\n  getComponentIdFromOptionValue: (ddb, type, optionId) => {\n    if (ddb.character.choices[type] && Array.isArray(ddb.character.choices[type])) {\n      // find a choice in the related choices-array\n      const choice = ddb.character.choices[type].find(\n        (characterChoice) => characterChoice.optionValue && characterChoice.optionValue === optionId\n      );\n      if (choice) return choice.componentId;\n    }\n    // we could not determine if there are any choices left\n    return undefined;\n  },\n\n  determineActualFeatureId: (data, featureId, type = \"class\") => {\n    const optionalFeatureReplacement = data.character.optionalClassFeatures\n      .filter((f) => f.classFeatureId === featureId)\n      .map((f) => f.affectedClassFeatureId);\n    // are we dealing with an optional class feature?\n    const choiceFeature = utils.getComponentIdFromOptionValue(data, type, featureId);\n\n    if (choiceFeature) {\n      const choiceOptionalFeature = data.character.optionalClassFeatures\n        .filter((f) => f.classFeatureId === choiceFeature)\n        .map((f) => f.affectedClassFeatureId);\n      if (choiceOptionalFeature && choiceOptionalFeature.length > 0) {\n        return choiceOptionalFeature[0];\n      }\n    } else if (optionalFeatureReplacement && optionalFeatureReplacement.length > 0) {\n      logger.debug(`Feature ${featureId} is replacing ${optionalFeatureReplacement[0]}`);\n      return optionalFeatureReplacement[0];\n    }\n    return featureId;\n  },\n\n  findClassByFeatureId: (data, featureId) => {\n    // optional class features need this filter, as they replace existing features\n    const featId = utils.determineActualFeatureId(data, featureId);\n    logger.debug(`Finding featureId ${featureId} with featId ${featId}`);\n\n    let klass = data.character.classes.find((cls) => {\n      let classFeatures = cls.classFeatures;\n      let featureMatch = classFeatures.find((feature) => feature.definition.id === featId);\n\n      if (featureMatch) {\n        return true;\n      } else {\n        // if not in global class feature list lets dig down\n        classFeatures = cls.definition.classFeatures;\n        if (cls.subclassDefinition && cls.subclassDefinition.classFeatures) {\n          classFeatures = classFeatures.concat(cls.subclassDefinition.classFeatures);\n        }\n        return classFeatures.some((feature) => feature.id === featId);\n      }\n    });\n    // try class option lookup\n    if (!klass) {\n      const option = data.character.options.class.find((option) => option.definition.id == featureId);\n      if (option) {\n        klass = data.character.classes.find((cls) => cls.classFeatures.find((feature) => feature.definition.id == option.componentId));\n      }\n    }\n    // class option lookups\n    if (!klass && data.classOptions) {\n      const classOption = data.classOptions.find((option) => option.id == featureId);\n      if (classOption) {\n        klass = data.character.classes.find((cls) => cls.definition.id == classOption.classId);\n      }\n    }\n    if (klass) {\n      logger.debug(`Class ${klass.definition.name} found for ${featureId} with featId ${featId}`);\n    } else {\n      logger.debug(`Class not found for ${featureId}`);\n    }\n\n    return klass;\n  },\n\n  calculateModifier: (val) => {\n    return Math.floor((val - 10) / 2);\n  },\n\n  diceStringResultBuild: (diceMap, dice, bonus = \"\", mods = \"\", diceHint = \"\", specialFlags = \"\") => {\n    const globalDamageHints = game.settings.get(\"ddb-importer\", \"use-damage-hints\");\n    const resultBonus = bonus === 0 ? \"\" : `${bonus > 0 ? ' +' : ' '} ${bonus}`;\n    const diceHintAdd = globalDamageHints && diceHint && diceMap;\n    const hintString = diceHintAdd ? diceHint : \"\";\n    const diceHintString = diceMap.map(({ sign, count, die }, index) =>\n      `${index ? `${sign} ` : ''}${count}d${die}${specialFlags}${hintString}`\n    ).join(' ');\n\n    const result = {\n      dice,\n      diceMap,\n      diceHintString,\n      bonus,\n      diceString: [\n        diceHintString,\n        mods,\n        resultBonus\n      ].join('').trim(),\n    };\n    return result;\n  },\n\n  parseDiceString: (inStr, mods = \"\", diceHint = \"\", specialFlags = \"\") => {\n    // sanitizing possible inputs a bit\n    const str = `${inStr}`.toLowerCase().replace(/[-]/gu, \"-\").replace(/\\s+/gu, \"\");\n\n    // all found dice strings, e.g. 1d8, 4d6\n    let dice = [];\n    // all bonuses, e.g. -1+8\n    let bonuses = [];\n\n    const diceRegex = /(?<rawSign>[+-]*)(?<count>\\d+)(?:d(?<die>\\d+))?/gu;\n\n    for (const { groups } of str.matchAll(diceRegex)) {\n      const {\n        rawSign = '+',\n        count,\n        die\n      } = groups;\n\n      // sign. We only take the sign standing exactly in front of the dice string\n      // so +-1d8 => -1d8. Just as a failsave\n      const sign = rawSign === \"\" ? \"+\" : rawSign.slice(-1);\n\n      if (die) {\n        dice.push({\n          sign,\n          count: parseInt(sign + count),\n          die: parseInt(die)\n        });\n      } else {\n        bonuses.push({\n          sign,\n          count: parseInt(sign + count)\n        });\n      }\n    }\n\n    // sum up the bonus\n    const bonus = bonuses.reduce((prev, cur) => prev + cur.count, 0);\n\n    // group the dice, so that all the same dice are summed up if they have the same sign\n    // e.g.\n    // +1d8+2d8 => 3d8\n    // +1d8-2d8 => +1d8 -2d8 will remain as-is\n    const diceMap = [];\n\n    const groupBySign = utils.groupBy(dice, 'sign');\n    for (const group of groupBySign.values()) {\n      const groupByDie = utils.groupBy(group, 'die');\n\n      for (const dieGroup of groupByDie.values()) {\n        diceMap.push(\n          dieGroup.reduce((acc, item) => ({\n            ...acc,\n            count: acc.count + item.count\n          }))\n        );\n      }\n    }\n\n    diceMap.sort((a, b) => {\n      if (a.die < b.die) return -1;\n      if (a.die > b.die) return 1;\n      if (a.sign === b.sign) {\n        if (a.count < b.count) return -1;\n        if (a.count > b.count) return 1;\n        return 0;\n      } else {\n        return a.sign === \"+\" ? -1 : 1;\n      }\n    });\n\n    const result = utils.diceStringResultBuild(diceMap, dice, bonus, mods, diceHint, specialFlags);\n    return result;\n  },\n\n  capitalize: (s) => {\n    if (typeof s !== \"string\") return \"\";\n    return s.charAt(0).toUpperCase() + s.slice(1);\n  },\n\n  htmlToDoc: (text) => {\n    const parser = new DOMParser();\n    return parser.parseFromString(text, \"text/html\");\n  },\n\n  // DEVELOPMENT FUNCTION\n  // loads a character.json from a file in the file system\n  // loadFromFile: (filename) => {\n  //   return require(`./input/${filename}.json`);\n  // },\n\n  // checks for a given file\n  serverFileExists: (path) => {\n    return new Promise((resolve, reject) => {\n      let http = new XMLHttpRequest();\n      http.open(\"HEAD\", path);\n      http.onreadystatechange = function () {\n        if (this.readyState == this.DONE) {\n          if (this.status >= 200 && this.status <= 399) {\n            // Assume any 2xx or 3xx responses mean the image is there.\n            resolve(path);\n          } else {\n            reject(path);\n          }\n        }\n      };\n\n      http.send();\n    });\n  },\n\n  fileExistsUpdate: (fileList) => {\n    const targetFiles = fileList.filter((f) => !existingFiles.has(f));\n    for (const file of targetFiles) {\n      existingFiles.add(file);\n    }\n  },\n\n  generateCurrentFiles: async (directoryPath) => {\n    logger.debug(`Checking for files in ${directoryPath}...`);\n    const dir = DirectoryPicker.parse(directoryPath);\n    const fileList = await DirectoryPicker.browse(dir.activeSource, dir.current, { bucket: dir.bucket });\n    utils.fileExistsUpdate(fileList.files);\n  },\n\n  fileExists: async (directoryPath, filename) => {\n    const fileUrl = await utils.getFileUrl(directoryPath, filename);\n    let existingFile = existingFiles.has(fileUrl);\n    if (existingFile) return true;\n\n    logger.debug(`Checking for ${filename} at ${fileUrl}...`);\n    const dir = DirectoryPicker.parse(directoryPath);\n    const fileList = await DirectoryPicker.browse(dir.activeSource, dir.current, { bucket: dir.bucket });\n\n    if (fileList.files.includes(fileUrl)) {\n      logger.debug(`Found ${fileUrl}`);\n      existingFiles.add(fileUrl);\n      return true;\n    } else {\n      logger.debug(`Could not find ${fileUrl}`);\n      return false;\n    }\n  },\n\n  getTemplate: (type) => {\n    let isObject = (item) => {\n      return item && typeof item === \"object\" && !Array.isArray(item);\n    };\n\n    let mergeDeep = (target, source) => {\n      let output = Object.assign({}, target);\n      if (isObject(target) && isObject(source)) {\n        Object.keys(source).forEach((key) => {\n          if (isObject(source[key])) {\n            if (!(key in target)) Object.assign(output, { [key]: source[key] });\n            else output[key] = mergeDeep(target[key], source[key]);\n          } else {\n            Object.assign(output, { [key]: source[key] });\n          }\n        });\n      }\n      return output;\n    };\n    let filterDeprecated = (data) => {\n      for (let prop in data) {\n        if (\n          data[prop] &&\n          Object.prototype.hasOwnProperty.call(data[prop], \"_deprecated\") &&\n          data[prop][\"_deprecated\"] === true\n        ) {\n          delete data[prop];\n        }\n        if (prop === \"_deprecated\" && data[prop] === true) {\n          delete data[prop];\n        }\n      }\n      return data;\n    };\n\n    let templates = game.data.system.template;\n    for (let entityType in templates) {\n      if (\n        templates[entityType].types &&\n        Array.isArray(templates[entityType].types) &&\n        templates[entityType].types.includes(type)\n      ) {\n        let obj = mergeDeep({}, filterDeprecated(templates[entityType][type]));\n        if (obj.templates) {\n          obj.templates.forEach((tpl) => {\n            obj = mergeDeep(obj, filterDeprecated(templates[entityType].templates[tpl]));\n          });\n          delete obj.templates;\n        }\n        // store the result as JSON for easy cloning\n        return JSON.stringify(obj);\n      }\n    }\n    return undefined;\n  },\n\n  uploadImage: async function (url, targetDirectory, baseFilename, useProxy = true) {\n    async function downloadImage(url) {\n      return new Promise((resolve, reject) => {\n        fetch(url, {\n          method: \"GET\",\n          headers: {\n            \"x-requested-with\": \"foundry\"\n          },\n        })\n          .then((response) => {\n            if (!response.ok) {\n              reject(\"Could not retrieve image\");\n            }\n            return response.blob();\n          })\n          .then((blob) => resolve(blob))\n          .catch((error) => reject(error.message));\n      });\n    }\n\n    async function upload(data, path, filename) {\n      return new Promise((resolve, reject) => {\n        // create new file from the response\n\n        const uploadFile = async (data, path, filename) => {\n          const file = new File([data], filename, { type: data.type });\n          const result = await DirectoryPicker.uploadToPath(path, file);\n          return result;\n        };\n\n        uploadFile(data, path, filename)\n          .then((result) => {\n            resolve(result.path);\n          })\n          .catch((error) => {\n            logger.error(\"error uploading file: \", error);\n            reject(error);\n          });\n      });\n    }\n\n    async function process(url, path, filename) {\n      // let data = await download(url);\n      let data = await downloadImage(url);\n      // hack as proxy returns ddb access denied as application/xml\n      if (data.type === \"application/xml\") return null;\n      let result = await upload(data, path, filename);\n      return result;\n    }\n\n    // prepare filenames\n    let filename = baseFilename;\n    let ext = url\n      .split(\".\")\n      .pop()\n      .split(/#|\\?|&/)[0];\n\n    // uploading the character avatar and token\n    try {\n      const proxyEndpoint = game.settings.get(\"ddb-importer\", \"cors-endpoint\");\n      const urlEncode = game.settings.get(\"ddb-importer\", \"cors-encode\");\n      const target = urlEncode ? encodeURIComponent(url) : url;\n      url = useProxy ? proxyEndpoint + target : url;\n      // console.error(`URL: ${url}`);\n      let result = await process(url, targetDirectory, filename + \".\" + ext);\n      return result;\n    } catch (error) {\n      logger.error(\"Image upload error\", error);\n      ui.notifications.warn(`Image upload failed. Please check your ddb-importer upload folder setting. ${url}`);\n      return null;\n    }\n  },\n\n  getOrCreateFolder: async (root, entityType, folderName, folderColor = \"\") => {\n    let folder = game.folders.contents.find((f) =>\n      f.data.type === entityType && f.data.name === folderName &&\n      f.data.parent === (root ? root.id : null)\n    );\n    // console.warn(`Looking for ${root} ${entityType} ${folderName}`);\n    // console.warn(folder);\n    if (folder) return folder;\n    folder = await Folder.create(\n      {\n        name: folderName,\n        type: entityType,\n        color: folderColor,\n        parent: (root) ? root.id : null,\n      },\n      { displaySheet: false }\n    );\n    return folder;\n  },\n\n  // eslint-disable-next-line no-unused-vars\n  getFolder: async (kind, subFolder = \"\", baseFolderName = \"D&D Beyond Import\", baseColor = \"#6f0006\", subColor = \"#98020a\", typeFolder = true) => {\n    let entityTypes = new Map();\n    entityTypes.set(\"spell\", \"Item\");\n    entityTypes.set(\"equipment\", \"Item\");\n    entityTypes.set(\"consumable\", \"Item\");\n    entityTypes.set(\"tool\", \"Item\");\n    entityTypes.set(\"loot\", \"Item\");\n    entityTypes.set(\"class\", \"Item\");\n    entityTypes.set(\"backpack\", \"Item\");\n    entityTypes.set(\"magic-items\", \"Item\");\n    entityTypes.set(\"magic-item-spells\", \"Item\");\n    entityTypes.set(\"npc\", \"Actor\");\n    entityTypes.set(\"character\", \"Actor\");\n    entityTypes.set(\"extras\", \"Actor\");\n    entityTypes.set(\"scene\", \"Scene\");\n    entityTypes.set(\"page\", \"JournalEntry\");\n    entityTypes.set(\"journal\", \"JournalEntry\");\n    entityTypes.set(\"journalEntry\", \"JournalEntry\");\n\n    const folderName = game.i18n.localize(`ddb-importer.item-type.${kind}`);\n    const entityType = entityTypes.get(kind);\n    const baseFolder = await utils.getOrCreateFolder(null, entityType, baseFolderName, baseColor);\n    const entityFolder = typeFolder ? await utils.getOrCreateFolder(baseFolder, entityType, folderName, subColor) : baseFolder;\n    if (subFolder !== \"\") {\n      const subFolderName = subFolder.charAt(0).toUpperCase() + subFolder.slice(1);\n      const typeFolder = await utils.getOrCreateFolder(entityFolder, entityType, subFolderName, subColor);\n      return typeFolder;\n    } else {\n      return entityFolder;\n    }\n  },\n\n  normalizeString: (str) => {\n    return str.toLowerCase().replace(/\\W/g, \"\");\n  },\n\n  /**\n   * Queries a compendium for a single document\n   * Returns either the entry from the index, or the complete document from the compendium\n   */\n  queryCompendiumEntry: async (compendiumName, documentName, getDocument = false) => {\n    // normalize the entity name for comparison\n    documentName = utils.normalizeString(documentName);\n\n    // get the compendium\n    const compendium = game.packs.get(compendiumName);\n    if (!compendium) return null;\n\n    // retrieve the compendium index\n    const index = await compendium.getIndex();\n\n    let id = index.find((entity) => utils.normalizeString(entity.name) === documentName);\n    if (id && getDocument) {\n      let entity = await compendium.getDocument(id._id);\n      return entity;\n    }\n    return id ? id : null;\n  },\n\n  /**\n   * Queries a compendium for a single document\n   * Returns either the entry from the index, or the complete document from the compendium\n   */\n  queryCompendiumEntries: async (compendiumName, documentNames, getDocuments = false) => {\n    // get the compendium\n    let compendium = game.packs.get(compendiumName);\n    if (!compendium) return null;\n\n    // retrieve the compendium index\n    let index = await compendium.getIndex();\n    index = index.map((entry) => {\n      entry.normalizedName = utils.normalizeString(entry.name);\n      return entry;\n    });\n\n    // get the indices of all the entitynames, filter un\n    let indices = documentNames\n      .map((entityName) => {\n        // sometimes spells do have restricted use in paranthesis after the name. Let's try to find those restrictions and add them later\n        if (entityName.search(/(.+)\\(([^()]+)\\)*/) !== -1) {\n          const match = entityName.match(/(.+)\\(([^()]+)\\)*/);\n          return {\n            name: utils.normalizeString(match[1].trim()),\n            restriction: match[2].trim(),\n          };\n        } else {\n          return {\n            name: utils.normalizeString(entityName),\n            restriction: null,\n          };\n        }\n      })\n      .map((data) => {\n        let entry = index.find((entity) => entity.normalizedName === data.name);\n        if (entry) {\n          return {\n            _id: entry._id,\n            name: data.restriction ? `${entry.name} (${data.restriction})` : entry.name,\n          };\n        } else {\n          return null;\n        }\n      });\n\n    if (getDocuments) {\n      // replace non-null values with the complete entity from the compendium\n      let entities = await Promise.all(\n        indices.map((entry) => {\n          return new Promise((resolve) => {\n            if (entry) {\n              compendium.getDocument(entry._id).then((entity) => {\n                entity.data.name = entry.name; // transfer restrictions over, if any\n                // remove redudant info\n                delete entity.data.id;\n                delete entity.data.permission;\n                resolve(entity.data);\n              });\n            } else {\n              resolve(null);\n            }\n          });\n        })\n      );\n      return entities;\n    }\n    return indices;\n  },\n\n  /**\n   * Queries a compendium for a given document name\n   * @returns the index entries of all matches, otherwise an empty array\n   */\n  queryCompendium: async (compendiumName, documentName, getDocument = false) => {\n    documentName = utils.normalizeString(documentName);\n\n    let compendium = game.packs.get(compendiumName);\n    if (!compendium) return null;\n    let index = await compendium.getIndex();\n    let id = index.find((entity) => utils.normalizeString(entity.name) === documentName);\n    if (id && getDocument) {\n      let entity = await compendium.getEntity(id._id);\n      return entity;\n    }\n    return id ? id : null;\n  },\n\n  getFileUrl: async (directoryPath, filename) => {\n    let uri;\n    try {\n      let dir = DirectoryPicker.parse(directoryPath);\n      if (dir.activeSource == \"data\") {\n        // Local on-server file system\n        uri = dir.current + \"/\" + filename;\n      } else if (dir.activeSource == \"forgevtt\") {\n        const status = ForgeAPI.lastStatus || await ForgeAPI.status();\n        const userId = status.user;\n        uri = \"https://assets.forge-vtt.com/\" + userId + \"/\" + dir.current + \"/\" + filename;\n      } else {\n        // S3 Bucket\n        uri =\n          game.data.files.s3.endpoint.protocol +\n          \"//\" +\n          dir.bucket +\n          \".\" +\n          game.data.files.s3.endpoint.hostname +\n          \"/\" +\n          dir.current +\n          \"/\" +\n          filename;\n      }\n    } catch (exception) {\n      throw new Error(\n        'Unable to determine file URL for directoryPath\"' + directoryPath + '\" and filename\"' + filename + '\"'\n      );\n    }\n    return encodeURI(uri);\n  },\n\n  versionCompare: (v1, v2, options) => {\n    var lexicographical = options && options.lexicographical,\n      zeroExtend = options && options.zeroExtend,\n      v1parts = v1.split(\".\"),\n      v2parts = v2.split(\".\");\n\n    function isValidPart(x) {\n      return (lexicographical ? /^\\d+[A-Za-z]*$/ : /^\\d+$/).test(x);\n    }\n\n    if (!v1parts.every(isValidPart) || !v2parts.every(isValidPart)) {\n      return NaN;\n    }\n\n    if (zeroExtend) {\n      while (v1parts.length < v2parts.length) v1parts.push(\"0\");\n      while (v2parts.length < v1parts.length) v2parts.push(\"0\");\n    }\n\n    if (!lexicographical) {\n      v1parts = v1parts.map(Number);\n      v2parts = v2parts.map(Number);\n    }\n\n    for (var i = 0; i < v1parts.length; ++i) {\n      if (v2parts.length == i) {\n        return 1;\n      }\n\n      if (v1parts[i] > v2parts[i]) {\n        return 1;\n      }\n      if (v1parts[i] < v2parts[i]) {\n        return -1;\n      }\n    }\n\n    if (v1parts.length != v2parts.length) {\n      return -1;\n    }\n\n    return 0;\n  },\n\n  isModuleInstalledAndActive: (moduleName) => {\n    return game.modules.has(moduleName) && game.modules.get(moduleName).active;\n  },\n\n  groupBy(arr, property) {\n    const map = new Map();\n\n    for (const item of arr) {\n      const prop = item[property];\n      const group = map.get(prop) ?? [];\n\n      group.push(item);\n      map.set(prop, group);\n    }\n\n    return map;\n  },\n\n  getCustomValue(data, character, type) {\n    if (!character) return null;\n    const characterValues = character.flags.ddbimporter.dndbeyond.characterValues;\n    const customValue = characterValues.filter((value) => value.valueId == data.id && value.valueTypeId == data.entityTypeId);\n\n    if (customValue) {\n      const value = customValue.find((value) => value.typeId == type);\n      if (value) return value.value;\n    }\n    return null;\n  },\n\n  getName(data, character) {\n    // spell name\n    const customName = utils.getCustomValue(data, character, 8);\n    if (customName) {\n      return customName;\n    } else if (data.definition?.name) {\n      return data.definition.name;\n    } else if (data.name) {\n      return data.name;\n    } else {\n      logger.error(\"Unable to determine name for:\", data);\n      return \"Unknown thing.\";\n    }\n  }\n};\n\nexport default utils;\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {boolean} [bitmask] The bitmask of comparison flags.\n *  The bitmask may be composed of the following flags:\n *     1 - Unordered comparison\n *     2 - Partial comparison\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, bitmask, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = getTag(object);\n    objTag = objTag == argsTag ? objectTag : objTag;\n  }\n  if (!othIsArr) {\n    othTag = getTag(other);\n    othTag = othTag == argsTag ? objectTag : othTag;\n  }\n  var objIsObj = objTag == objectTag && !isHostObject(object),\n      othIsObj = othTag == objectTag && !isHostObject(other),\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n  }\n  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!seen.has(othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n              return seen.add(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, customizer, bitmask, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= UNORDERED_COMPARE_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are **not** supported.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nexport function isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.hmd = (module) => {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: () => {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export default function () {\n  let enabledDebugLogging = false;\n\n  let defaults = {\n    general: enabledDebugLogging,\n    messaging: enabledDebugLogging,\n    character: enabledDebugLogging,\n    extension: enabledDebugLogging,\n  };\n\n  if (!CONFIG.debug.ddbimporter) {\n    CONFIG.debug.ddbimporter = { dndbeyond: defaults };\n  } else {\n    CONFIG.debug.ddbimporter.dndbeyond = defaults;\n  }\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport logger from \"../../logger.js\";\nimport utils from \"../../utils.js\";\n\nlet getEldritchInvocations = (data) => {\n  let damage = \"\";\n  let range = 0;\n\n  const eldritchBlastMods = utils.filterBaseModifiers(data, \"eldritch-blast\").filter((modifier) => modifier.isGranted);\n\n  eldritchBlastMods.forEach((mod) => {\n    switch (mod.subType) {\n      case \"bonus-damage\": {\n        // almost certainly CHA :D\n        const abilityModifierLookup = DICTIONARY.character.abilities.find((ability) => ability.id === mod.statId);\n        if (abilityModifierLookup) {\n          if (damage !== \"\") damage += \" + \";\n          damage += `@abilities.${abilityModifierLookup.value}.mod`;\n        } else if (mod.fixedValue) {\n          if (damage !== \"\") damage += \" + \";\n          damage += `${mod.fixedValue}`;\n        }\n        break;\n      }\n      case \"bonus-range\":\n        range = mod.value;\n        break;\n      default:\n        logger.warn(`Not yet able to process ${mod.subType}, please raise an issue.`);\n    }\n  });\n\n  return {\n    damage: damage,\n    range: range,\n  };\n};\n\nfunction getCustomValue(data, ddb, type) {\n  if (!ddb) return null;\n  const characterValues = ddb.character.characterValues;\n  const customValue = characterValues.filter(\n    (value) =>\n      value.valueId == data.flags.ddbimporter.dndbeyond.id &&\n      value.valueTypeId == data.flags.ddbimporter.dndbeyond.entityTypeId\n  );\n\n  if (customValue) {\n    const customName = customValue.find((value) => value.typeId == type);\n    if (customName) return customName.value;\n  }\n  return null;\n}\n\nfunction addCustomValues(item, ddb) {\n  // to hit override requires a lot of crunching\n  // const toHitOverride = getCustomValue(item, character, 13);\n  const toHitBonus = getCustomValue(item, ddb, 12);\n  const damageBonus = getCustomValue(item, ddb, 10);\n  const dcOverride = getCustomValue(item, ddb, 15);\n  const dcBonus = getCustomValue(item, ddb, 14);\n\n  if (toHitBonus) item.data.attackBonus += toHitBonus;\n  if (damageBonus && item.data.damage.parts.length !== 0) {\n    item.data.damage.parts[0][0] = item.data.damage.parts[0][0].concat(` +${damageBonus}`);\n  } else if (damageBonus) {\n    const part = [`+${damageBonus}`, \"\"];\n    item.data.damage.parts.push(part);\n  }\n  // if (damageBonus) item.data.damage.parts[0] = item.data.damage.parts[0].concat(` +${damageBonus}`);\n  if (dcBonus) {\n    if (item.flags.ddbimporter.dndbeyond.dc) {\n      item.data.save.dc = parseInt(item.flags.ddbimporter.dndbeyond.dc) + dcBonus;\n      item.data.save.scaling = \"flat\";\n    }\n  }\n  if (dcOverride) {\n    item.data.save.dc = dcOverride;\n    item.data.save.scaling = \"flat\";\n  }\n}\n\n/**\n * Some spells we need to fix up or massage because they are modified\n * in interesting ways\n * @param {*} ddb\n * @param {*} items\n */\n/* eslint-disable complexity */\nexport function fixSpells(ddb, items) {\n  const midiQolInstalled = utils.isModuleInstalledAndActive(\"midi-qol\");\n  items.forEach((spell) => {\n    const name = spell.flags.ddbimporter.originalName || spell.name;\n    switch (name) {\n      // Eldritch Blast is a special little kitten and has some fun Eldritch\n      // Invocations which can adjust it.\n      case \"Eldritch Blast\": {\n        if (!ddb) break;\n        const eldritchBlastMods = getEldritchInvocations(ddb);\n        spell.data.damage.parts[0][0] += \" + \" + eldritchBlastMods[\"damage\"];\n        spell.data.range.value += eldritchBlastMods[\"range\"];\n        break;\n      }\n      case \"Aid\": {\n        spell.data.scaling = { mode: \"level\", formula: \"(@item.level - 1) * 5\" };\n        break;\n      }\n      case \"Darkvision\": {\n        spell.data[\"target\"][\"type\"] = \"creature\";\n        break;\n      }\n      // The target/range input data are incorrect on some AOE spells centred\n      // on self.\n      // Range is self with an AoE target of 15 ft cube\n      // i.e. affects all creatures within 5 ft of caster\n      case \"Thunderclap\":\n      case \"Word of Radiance\":\n        spell.data.range = { value: null, units: \"self\", long: null };\n        spell.data.target = { value: 15, units: \"ft\", type: \"cube\" };\n        break;\n      case \"Sleep\": {\n        spell.data.damage = { parts: [[\"5d8\", \"\"]], versatile: \"\", value: \"\" };\n        spell.data.scaling = { mode: \"level\", formula: \"2d8\" };\n        break;\n      }\n      case \"Ray of Enfeeblement\":\n        spell.data.actionType = \"rsak\";\n        break;\n      case \"Color Spray\": {\n        spell.data.damage = { parts: [[\"6d10\", \"\"]], versatile: \"\", value: \"\" };\n        spell.data.scaling = { mode: \"level\", formula: \"2d10\" };\n        break;\n      }\n      case \"Gust of Wind\":\n        spell.data.target = { value: 60, units: \"ft\", type: \"line\", width: 10 };\n        break;\n      case \"Produce Flame\":\n        spell.data.range = { value: 30, units: \"ft\", long: null };\n        break;\n      case \"Hex\":\n      case \"Shadow of Moil\":\n      case \"Cloud of Daggers\":\n      case \"Magic Missile\":\n        spell.data.actionType = \"other\";\n        break;\n      // dnd beyond lists a damage for each type\n      case \"Chaos Bolt\":\n        spell.data.damage = { parts: [[\"2d8\", \"\"], [\"1d6\", \"\"]], versatile: \"\", value: \"\", };\n        break;\n      // dnd beyond lists a damage for each type\n      case \"Chromatic Orb\":\n        if (midiQolInstalled) {\n          spell.data.damage = { parts: [], versatile: \"\", value: \"\" };\n        } else {\n          spell.data.damage = { parts: [[\"3d8\", \"\"]], versatile: \"\", value: \"\" };\n          spell.data.chatFlavor = \"Choose from Acid, Cold, Fire, Lightning, Poison, Thunder, or Acid\";\n        }\n        break;\n      case \"Dragon's Breath\":\n        spell.data.damage = { parts: [[\"3d6\", \"\"]], versatile: \"\", value: \"\" };\n        spell.data.chatFlavor = \"Choose one of Acid, Cold, Fire, Lightning, or Poison.\";\n        break;\n      case \"Hunter's Mark\":\n      case \"Hunters Mark\": {\n        spell.data.actionType = \"other\";\n        if (midiQolInstalled) {\n          spell.data.damage = { parts: [], versatile: \"\", value: \"\" };\n        } else {\n          spell.data.damage = { parts: [[\"1d6\", \"\"]], versatile: \"\", value: \"\" };\n        }\n        break;\n      }\n      case \"Call Lightning\": {\n        if (midiQolInstalled) {\n          spell.data.damage = { parts: [], versatile: \"\", value: \"\" };\n          spell.data[\"target\"][\"type\"] = \"self\";\n          spell.data.range = { value: null, units: \"self\", long: null };\n          spell.data.save.ability = \"\";\n        }\n        break;\n      }\n      case \"Pyrotechnics\":\n        spell.data[\"target\"][\"value\"] = 15;\n        break;\n      case \"Absorb Elements\":\n        spell.data.damage = { parts: [[\"1d6\", \"\"]], versatile: \"\", value: \"\" };\n        spell.data.chatFlavor = \"Uses the damage type of the triggered attack: Acid, Cold, Fire, Lightning, or Poison.\";\n        spell.data[\"target\"][\"value\"] = 1;\n        break;\n      case \"Booming Blade\":\n        spell.data.damage = { parts: [[\"0\", \"thunder\"]], versatile: \"1d8\", value: \"\" };\n        spell.data.scaling = { mode: \"cantrip\", formula: \"1d8\" };\n        spell.data.actionType = \"other\";\n        break;\n      case \"Green-Flame Blade\":\n        spell.data.damage = { parts: [[\"0\", \"fire\"]], versatile: \"@mod\", value: \"\" };\n        spell.data.scaling = { mode: \"cantrip\", formula: \"1d8\" };\n        spell.data.actionType = \"other\";\n        break;\n      case \"Toll the Dead\":\n        spell.data.scaling = { mode: \"cantrip\", formula: \"\" };\n        break;\n      case \"Goodberry\":\n        spell.data.damage = { parts: [[\"1\", \"healing\"]], versatile: \"\", value: \"\" };\n        break;\n      case \"Flaming Sphere\":\n        spell.data.target[\"value\"] = 2.5;\n        break;\n      case \"Heat Metal\":\n        spell.data.actionType = \"save\";\n        break;\n      case \"Searing Smite\": {\n        if (spell.data.damage.parts.length > 1) {\n          spell.data.formula = spell.data.damage.parts[1][0];\n          spell.data.damage.parts = [spell.data.damage.parts[0]];\n        }\n        spell.data.scaling = { mode: \"level\", formula: \"1d6\" };\n        break;\n      }\n      case \"Spirit Guardians\": {\n        if (!ddb) break;\n        const radiantAlignments = [1, 2, 3, 4, 5, 6, 10, 14];\n        const necroticAlignments = [7, 8, 9, 11];\n        if (radiantAlignments.includes(ddb.character.alignmentId)) {\n          setProperty(spell, \"flags.ddbimporter.damageType\", \"radiant\");\n          spell.data.damage = { parts: [[\"3d8\", \"radiant\"]], versatile: \"\", value: \"\" };\n        } else if (necroticAlignments.includes(ddb.character.alignmentId)) {\n          setProperty(spell, \"flags.ddbimporter.damageType\", \"necrotic\");\n          spell.data.damage = { parts: [[\"3d8\", \"necrotic\"]], versatile: \"\", value: \"\" };\n        }\n        break;\n      }\n      case \"Armor of Agathys\": {\n        spell.data.actionType = \"heal\";\n        spell.data[\"target\"][\"type\"] = \"self\";\n        spell.data.damage.parts[0] = [\"5\", \"temphp\"];\n        spell.data.scaling = { mode: \"level\", formula: \"(@item.level - 1) * 5\" };\n        break;\n      }\n      case \"False Life\": {\n        spell.data.actionType = \"heal\";\n        spell.data[\"target\"][\"type\"] = \"self\";\n        spell.data.damage.parts[0] = [\"1d4 + 4\", \"temphp\"];\n        spell.data.scaling = { mode: \"level\", formula: \"(@item.level - 1) * 5\" };\n        break;\n      }\n      case \"Divine Favor\": {\n        spell.data.actionType = \"util\";\n        spell.data[\"target\"][\"type\"] = \"self\";\n        break;\n      }\n      case \"Bones of the Earth\": {\n        spell.data.target.value = 2.5;\n        break;\n      }\n      case \"Heroes Feast\": {\n        spell.data.duration = { value: 1, units: \"day\" };\n        break;\n      }\n      case \"Heroism\": {\n        spell.data.damage.parts[0] = [\"@mod\", \"temphp\"];\n        break;\n      }\n      case \"Protection from Energy\":\n        spell.data[\"target\"][\"type\"] = \"creature\";\n        break;\n      // no default\n    }\n\n    if (ddb) addCustomValues(spell, ddb);\n  });\n}\n/* eslint-enable complexity */\n","export function getComponents (data) {\n  return {\n    value: data.definition.componentsDescription,\n    vocal: data.definition.components.includes(1),\n    somatic: data.definition.components.includes(2),\n    material: data.definition.components.includes(3),\n    ritual: data.definition.ritual,\n    concentration: data.definition.concentration,\n  };\n}\n\nexport function getMaterials(data) {\n  // this is mainly guessing\n  if (data.definition.componentsDescription && data.definition.componentsDescription.length > 0) {\n    let cost = 0;\n    let matches = data.definition.componentsDescription.toLowerCase().match(/([\\d.,]+)\\s*gp/);\n    if (matches) {\n      cost = parseInt(matches[1].replace(/,|\\./g, \"\"));\n    }\n\n    return {\n      value: data.definition.componentsDescription,\n      consumed: data.definition.componentsDescription.toLowerCase().indexOf(\"consume\") !== -1,\n      cost: cost,\n      supply: 0,\n    };\n  } else {\n    return {\n      value: \"\",\n      consumed: false,\n      cost: 0,\n      supply: 0,\n    };\n  }\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport utils from \"../../utils.js\";\n\n\nfunction classSpell(data, result) {\n  const classPrepMode = utils.findByProperty(\n    DICTIONARY.spell.preparationModes,\n    \"name\",\n    data.flags.ddbimporter.dndbeyond.class\n  );\n  if (data.restriction === \"As Ritual Only\") {\n    result.mode = \"prepared\";\n    result.prepared = false;\n  } else if (!data.usesSpellSlot && data.definition.level !== 0) {\n    // some class features such as druid circle of stars grants x uses of a spell\n    // at the lowest level. for these we add as an innate.\n    result.mode = \"innate\";\n  } else if (data.alwaysPrepared) {\n    result.mode = \"always\";\n  } else if (result.mode && classPrepMode) {\n    result.mode = classPrepMode.value;\n  }\n  // Warlocks should use Pact spells\n  // but lets mark level 0 as regular spells so they show up as cantrips\n  if (result.mode === \"pact\" && data.definition.level === 0) {\n    result.mode = \"prepared\";\n    result.prepared = true;\n  }\n  return result;\n}\n\n/**\n * Retrieves the spell preparation mode, depending on the location this spell came from\n *\n */\nexport function getSpellPreparationMode(data) {\n  // default values\n  let result = {\n    mode: \"prepared\",\n    // If always prepared mark as such, if not then check to see if prepared\n    prepared: data.alwaysPrepared || data.prepared,\n  };\n\n  // handle classSpells\n  const featureClass = data.flags.ddbimporter.dndbeyond.lookup === \"classFeature\" &&\n    data.flags.ddbimporter.dndbeyond.class;\n\n  if (data.flags.ddbimporter.dndbeyond.lookup === \"classSpell\" || featureClass) {\n    result = classSpell(data, result);\n  } else if (data.flags.ddbimporter.dndbeyond.lookup === \"race\" && data.definition.level !== 0) {\n    // set race spells as innate\n    result.mode = \"innate\";\n    if (data.usesSpellSlot) {\n      // some racial spells allow the spell to also be added to spell lists\n      result.mode = \"always\";\n    }\n  } else if (\n    // Warlock Mystic Arcanum are passed in as Features\n    data.flags.ddbimporter.dndbeyond.lookupName.startsWith(\"Mystic Arcanum\")\n  ) {\n    // these have limited uses (set with getUses())\n    result.mode = \"pact\";\n    result.prepared = false;\n  } else if (data.flags.ddbimporter.dndbeyond.lookup === \"item \" && data.definition.level !== 0) {\n    result.mode = \"prepared\";\n    result.prepared = false;\n  } else {\n    // If spell doesn't use a spell slot and is not a cantrip, mark as always preped\n    let always = !data.usesSpellSlot && data.definition.level !== 0;\n    let ritaulOnly = data.ritualCastingType !== null || data.castOnlyAsRitual; // e.g. Book of ancient secrets & totem barb\n    if (always && ritaulOnly) {\n      // in this case we want the spell to appear in the spell list unprepared\n      result.prepared = false;\n    } else if (always) {\n      // these spells are always prepared, and have a limited use that's\n      // picked up by getUses() later\n      // this was changed to \"atwill\"\n      result.mode = \"atwill\";\n    }\n    if (data.flags.ddbimporter.dndbeyond.lookup === \"classFeature\") {\n      if (data.alwaysPrepared) {\n        result.mode = \"always\";\n      }\n    }\n  }\n\n  return result;\n}\n","import DICTIONARY from \"../../dictionary.js\";\n\n/**\n * Get the reset condition of the spell, if uses restricted\n * @param {*} data Spell data\n */\nexport function getUses(data) {\n  let resetType = null;\n  let limitedUse = null;\n  // we check this, as things like items have useage attached to the item, not spell\n  if (data.flags.ddbimporter.dndbeyond.limitedUse !== undefined && data.flags.ddbimporter.dndbeyond.limitedUse !== null) {\n    limitedUse = data.flags.ddbimporter.dndbeyond.limitedUse;\n    resetType = DICTIONARY.resets.find((reset) => reset.id == limitedUse.resetType);\n  } else if (data.limitedUse !== undefined && data.limitedUse !== null) {\n    limitedUse = data.limitedUse;\n    resetType = DICTIONARY.resets.find((reset) => reset.id == limitedUse.resetType);\n  }\n\n  if (resetType !== null && resetType !== undefined) {\n    return {\n      value: limitedUse.numberUsed ? limitedUse.maxUses - limitedUse.numberUsed : parseInt(limitedUse.maxUses),\n      max: parseInt(limitedUse.maxUses),\n      per: resetType.value,\n    };\n  } else {\n    return {};\n  }\n}\n","import DICTIONARY from \"../../dictionary.js\";\n\n/**\n * Gets the activation information of this spell\n */\nexport function getActivation(data) {\n  const activationType = DICTIONARY.spell.activationTypes.find(\n    (type) => type.activationType === data.definition.activation.activationType\n  );\n  if (activationType && data.definition.activation.activationTime) {\n    return {\n      type: activationType.value,\n      cost: data.definition.activation.activationTime,\n      condition: data.definition.castingTimeDescription || \"\",\n    };\n  } else {\n    return {\n      type: \"action\",\n      cost: 1,\n      condition: data.definition.castingTimeDescription || \"\",\n    };\n  }\n}\n","/**\n * Retrieves the spell duration\n */\nexport function getDuration(data) {\n  if (data.definition.duration) {\n    let units = \"\";\n    if (data.definition.duration.durationUnit !== null) {\n      units = data.definition.duration.durationUnit.toLowerCase();\n    } else {\n      units = data.definition.duration.durationType.toLowerCase().substring(0, 4);\n    }\n    return {\n      value: data.definition.duration.durationInterval || \"\",\n      units: units,\n    };\n  } else {\n    return {};\n  }\n}\n","import DICTIONARY from \"../../dictionary.js\";\n\n/**\n * Does the spell target creatures?\n * @param {*} data\n */\nlet doesTargetCreature = (data) => {\n  const creature = /a creature you|creature( that)? you can see|interrupt a creature|would strike a creature|creature of your choice|creature or object within range|cause a creature|creature must be within range/gi;\n  const creaturesRange = /(humanoid|monster|creature|target)(s)? (or loose object )?(of your choice )?(that )?(you can see )?within range/gi;\n  return data.definition.description.match(creature) || data.definition.description.match(creaturesRange);\n};\n\n/**\n * Get Target Values\n * Uses regex magic to try and determine the number of creatures affected\n * @param {*} data\n */\nlet getTargetValues = (data) => {\n  const numCreatures = /(?!At Higher Levels.*)(\\w*) (falling )?(willing )?(creature|target|monster|celestial|fiend|fey|corpse(s)? of|humanoid)(?!.*you have animated)/gim;\n  const targets = [...data.definition.description.matchAll(numCreatures)];\n  const targetValues = targets\n    .filter((target) => {\n      const matches = DICTIONARY.numbers.filter((n) => n.natural === target[1].toLowerCase());\n      return Array.isArray(matches) && !!matches.length;\n    })\n    .map((target) => DICTIONARY.numbers.find((n) => n.natural === target[1].toLowerCase()).num);\n\n  if (Array.isArray(targetValues) && !!targetValues.length) {\n    return Math.max(...targetValues);\n  } else {\n    return null;\n  }\n};\n\n/**\n * Spell targets\n */\n// eslint-disable-next-line complexity\nexport function getTarget(data) {\n  const result = {\n    value: null,\n    units: null,\n    type: null,\n    width: null,\n  };\n\n  // if spell is an AOE effect get some details\n  if (data.definition.range.aoeType && data.definition.range.aoeValue) {\n    result.value = parseInt(data.definition.range.aoeValue);\n    result.type = data.definition.range.aoeType.toLowerCase();\n    result.units = \"ft\";\n    return result;\n  }\n\n  // does the spell target a creature?\n  const creatures = doesTargetCreature(data);\n\n  if (creatures) {\n    result.value = getTargetValues(data);\n  }\n\n  switch (data.definition.range.origin) {\n    case \"Touch\":\n      result.units = \"touch\";\n      if (creatures) result.type = \"creature\";\n      break;\n    case \"Self\": {\n      const dmgSpell = data.definition.modifiers.some((mod) => mod.type === \"damage\");\n      result.type = (dmgSpell) ? \"creature\" : \"self\";\n      break;\n    }\n    case \"None\":\n      result.type = \"none\";\n      break;\n    case \"Ranged\":\n      if (creatures) result.type = \"creature\";\n      break;\n    case \"Feet\":\n      if (creatures) result.type = \"creature\";\n      break;\n    case \"Miles\":\n      if (creatures) result.type = \"creature\";\n      break;\n    case \"Sight\":\n    case \"Special\":\n      result.units = \"special\";\n      break;\n    case \"Any\":\n      result.units = \"any\";\n      break;\n    case undefined:\n      result.type = null;\n      break;\n    // no default\n  }\n\n  // wall type spell?\n  if (data.definition.name.includes(\"Wall\")) {\n    result.type = \"wall\";\n    result.units = \"ft\";\n\n    if (data.definition.description.includes(\"ten 10-foot-\")) {\n      result.value = 100;\n    } else {\n      const wallReg = new RegExp(/ (\\d*) feet long/);\n      const matches = data.definition.description.match(wallReg);\n      if (matches) {\n        result.value = parseInt(matches[1]);\n      }\n    }\n    const thickReg = new RegExp(/ (\\d*) foot (thick|wide)/);\n    const thickMatch = data.definition.description.match(thickReg);\n    if (thickMatch && thickMatch[1] > 5) {\n      result.width = parseInt(thickMatch[1]);\n    }\n  }\n\n  return result;\n}\n","/** Spell range */\nexport function getRange(data) {\n  // else lets try and fill in some target details\n  let value = data.definition.range.rangeValue ? data.definition.range.rangeValue : null;\n  let units = \"ft\";\n  let long = null;\n\n  switch (data.definition.range.origin) {\n    case \"Touch\":\n      value = null;\n      units = \"touch\";\n      break;\n    case \"Self\":\n      value = null;\n      units = \"self\";\n      break;\n    case \"None\":\n      units = \"none\";\n      break;\n    case \"Ranged\":\n      units = \"ft\";\n      break;\n    case \"Feet\":\n      units = \"ft\";\n      break;\n    case \"Miles\":\n      units = \"ml\";\n      break;\n    case \"Sight\":\n    case \"Special\":\n      units = \"special\";\n      break;\n    case \"Any\":\n      units = \"any\";\n      break;\n    case undefined:\n      units = null;\n      break;\n    // no default\n  }\n\n  return {\n    value: value,\n    long: long,\n    units: units,\n  };\n}\n","export function getActionType(data) {\n  if (data.definition.requiresSavingThrow && !data.definition.requiresAttackRoll) {\n    return \"save\";\n  }\n\n  if (\n    data.definition.tags.includes(\"Damage\") &&\n    data.definition.range.rangeValue &&\n    data.definition.range.rangeValue > 0\n  ) {\n    return \"rsak\";\n  }\n\n  if (data.definition.tags.includes(\"Damage\")) {\n    return \"msak\";\n  }\n\n  if (data.definition.tags.includes(\"Healing\")) {\n    return \"heal\";\n  }\n\n  if (data.definition.tags.includes(\"Buff\")) {\n    return \"util\";\n  }\n\n  return \"other\";\n}\n","import utils from \"../../utils.js\";\n\nlet getAlternativeFormula = (data) => {\n  // this might be specificially for Toll the Dead only, but it's better than nothing\n\n  let description = data.definition.description;\n  let match = description.match(/instead[\\w\\s]+(\\d+d\\d+) (\\w+) damage/);\n  if (match) {\n    return match[1];\n  } else {\n    return \"\";\n  }\n};\n\nexport function getDamage(data, spell) {\n  let result = {\n    parts: [],\n    versatile: \"\",\n  };\n\n  const globalDamageHints = game.settings.get(\"ddb-importer\", \"use-damage-hints\");\n  const damageRestrictionHints = game.settings.get(\"ddb-importer\", \"add-damage-restrictions-to-hints\");\n  const hintOrRestriction = globalDamageHints || damageRestrictionHints;\n\n  // damage\n  const attacks = data.definition.modifiers.filter((mod) => mod.type === \"damage\");\n  if (attacks.length !== 0) {\n    const cantripBoost = data.definition.level === 0 && !!data.flags.ddbimporter.dndbeyond.cantripBoost;\n    attacks.forEach((attack) => {\n      const restriction = damageRestrictionHints && attack.restriction && attack.restriction !== \"\" ? attack.restriction : \"\";\n      const hintAndRestriction = globalDamageHints && restriction !== \"\" ? \" - \" : \"\";\n      const damageHint = globalDamageHints ? attack.subType : \"\";\n      const damageTag = hintOrRestriction ? `[${damageHint}${hintAndRestriction}${restriction}]` : \"\";\n      const addMod = attack.usePrimaryStat || cantripBoost ? \" + @mod\" : \"\";\n      let diceString = utils.parseDiceString(attack.die.diceString, addMod, damageTag).diceString;\n      result.parts.push([diceString, attack.subType]);\n    });\n\n    // This is probably just for Toll the dead.\n    const alternativeFormula = getAlternativeFormula(data);\n    result.versatile = cantripBoost ? `${alternativeFormula} + @mod` : alternativeFormula;\n    return result;\n  }\n\n  // healing\n  const heals = data.definition.modifiers.filter((mod) => mod.type === \"bonus\" && mod.subType === \"hit-points\");\n  if (heals.length !== 0) {\n    const healingBonus = (spell.flags.ddbimporter.dndbeyond.healingBoost) ? ` + ${spell.flags.ddbimporter.dndbeyond.healingBoost} + @item.level` : \"\";\n    heals.forEach((heal) => {\n      const restriction = damageRestrictionHints && heal.restriction && heal.restriction !== \"\" ? heal.restriction : \"\";\n      const hintAndRestriction = globalDamageHints && restriction !== \"\" ? \" - \" : \"\";\n      const damageHint = globalDamageHints ? \"healing\" : \"\";\n      const damageTag = hintOrRestriction ? `[${damageHint}${hintAndRestriction}${restriction}]` : \"\";\n      const healValue = (heal.die.diceString) ? `${heal.die.diceString}${damageTag}` : heal.die.fixedValue;\n      const diceString = heal.usePrimaryStat\n        ? `${healValue} + @mod${healingBonus}`\n        : `${healValue}${healingBonus}`;\n      result.parts.push([diceString, \"healing\"]);\n    });\n    return result;\n  }\n  return result;\n}\n","import DICTIONARY from \"../../dictionary.js\";\n\nexport function getSave(data) {\n  if (data.definition.requiresSavingThrow && data.definition.saveDcAbilityId) {\n    const saveAbility = DICTIONARY.character.abilities.find((ability) => ability.id === data.definition.saveDcAbilityId)\n      .value;\n    if (data.overrideSaveDc) {\n      return {\n        ability: saveAbility,\n        dc: data.overrideSaveDc,\n        scaling: \"flat\",\n      };\n    } else {\n      return {\n        ability: saveAbility,\n        dc: null,\n        scaling: \"spell\",\n      };\n    }\n  } else {\n    return {\n      ability: \"\",\n      dc: null,\n    };\n  }\n}\n","import logger from \"../../logger.js\";\n\n/**\n * Get the scaling type for a spell mod\n * This is complex logic and is broken out to help simplify\n * @param {*} name\n * @param {*} mod\n */\nlet getScaleType = (name, data, mod) => {\n  // scaleTypes:\n  // SPELLSCALE - typical spells that scale\n  // SPELLLEVEL - these spells have benefits that come in at particular levels e.g. bestow curse, hex. typically  duration changes\n  // CHARACTERLEVEL - typical cantrip based levelling, some expections (eldritch blast)\n  let scaleType = null;\n  const modScaleType = mod.atHigherLevels.scaleType ? mod.atHigherLevels.scaleType : data.definition.scaleType;\n  const isHigherLevelDefinitions =\n    mod.atHigherLevels.higherLevelDefinitions &&\n    Array.isArray(mod.atHigherLevels.higherLevelDefinitions) &&\n    mod.atHigherLevels.higherLevelDefinitions.length >= 1;\n\n  if (isHigherLevelDefinitions && modScaleType === \"spellscale\") {\n    const definition = mod.atHigherLevels.higherLevelDefinitions[0];\n    if (definition) {\n      scaleType = modScaleType;\n    } else {\n      logger.warn(\"No spell definition found for \" + name);\n    }\n  } else if (modScaleType === \"spellscale\") {\n    // lets handle cases where there is a spellscale type but no damage\n    // increase/ higherleveldefinitins e.g. chain lighting\n    // these type of spells typically increase targets so we set the\n    // scaling to null as we don't want to increase damage when upcast.\n    // this also deals with cases like Ice Knife where the upscale damage\n    // is in one of the two mods provided.\n    // we are capturing this else because we don't want to trigger\n    // an update to scaleType or a warning.\n  } else if (modScaleType === \"characterlevel\") {\n    // lets handle odd cantrips like Eldritch Blast\n    // (in fact this might be the only case)\n    if (mod.atHigherLevels.higherLevelDefinitions.length === 0) {\n      // if this array is empty it does not contain levelling information\n      // the only case found is Eldritch Blast.\n      // this does have some info around multiple beams in\n      // data.atHigherLevels but we ignore this. we will set the scaling\n      // to null as each beam is best modelled by \"casting\" the cantrip again/\n      // pressing the attack/damage buttons in FVTT\n      scaleType = null;\n    } else {\n      scaleType = modScaleType;\n    }\n  } else if (modScaleType === \"spelllevel\") {\n    // spells that have particular level associated benefits\n    // these seem to be duration increases or target increases for\n    // the most part we can't handle these in FVTT right now (we could\n    // in theory create a new spell at a higher level).\n    // some duration upcasting (like bestow curse) affects concentration\n    // for now we will do nothing with these spells.\n    // examples include: hex, shadowblade, magic weapon, bestow curse\n    scaleType = modScaleType;\n  } else {\n    logger.warn(`${name} parse failed: `, modScaleType);\n    scaleType = modScaleType; // if this is new/unknow will use default\n  }\n\n  return scaleType;\n};\n\nexport function getSpellScaling(data) {\n  let baseDamage = \"\";\n  let scaleDamage = \"\";\n  let scaleType = null; // defaults to null, so will be picked up as a None scaling spell.\n\n  // spell scaling\n  if (data.definition.canCastAtHigherLevel) {\n    // iterate over each spell modifier\n    data.definition.modifiers\n      .filter((mod) => mod.type === \"damage\" || (mod.type === \"bonus\" && mod.subType === \"hit-points\"))\n      // eslint-disable-next-line complexity\n      .forEach((mod) => {\n        // if the modifier has a die for damage, lets use the string or fixed value\n        // for the base damage\n        if (mod && mod.die) {\n          if (mod.die.diceString !== null) {\n            baseDamage = mod.die.diceString;\n          }\n\n          if (mod.die.fixedValue !== null && baseDamage === \"\") {\n            baseDamage = mod.die.fixedValue;\n          }\n        }\n\n        // defines some details about higher level casting\n        if (mod.atHigherLevels) {\n          // scaleTypes:\n          // SPELLSCALE - typical spells that scale\n          // SPELLLEVEL - these spells have benefits that come in at particular levels e.g. bestow curse, hex. typically  duration changes\n          // CHARACTERLEVEL - typical cantrip based levelling, some expections (eldritch blast)\n\n          // mod.atHigherLevels.higherLevelDefinitions contains info about the\n          // spells damage die at higher levels, but we can't use this for cantrips as\n          // FVTT use a formula to work out the scaling (ddb has a fixed value structure)\n          const isHigherLevelDefinitions =\n            mod.atHigherLevels.higherLevelDefinitions &&\n            Array.isArray(mod.atHigherLevels.higherLevelDefinitions) &&\n            mod.atHigherLevels.higherLevelDefinitions.length >= 1;\n\n          // lets handle normal spell leveling first\n          const modScaleType = mod.atHigherLevels.scaleType ? mod.atHigherLevels.scaleType : data.definition.scaleType;\n          if (isHigherLevelDefinitions && modScaleType === \"spellscale\") {\n            const definition = mod.atHigherLevels.higherLevelDefinitions[0];\n            if (definition) {\n              const modScaleDamage =\n                definition.dice && definition.dice.diceString // if dice string\n                  ? definition.dice.diceString // use dice string\n                  : definition.dice && definition.dice.fixedValue // else if fixed value\n                    ? definition.dice.fixedValue // use fixed value\n                    : definition.value; // else use value\n\n              // some spells have multiple scaling damage (e.g. Wall of Ice,\n              // Glyph of warding, Acid Arrow, Arcane Hand, Dragon's Breath,\n              // Chromatic Orb, Absorb Elements, Storm Sphere, Spirit Guardians)\n              // it's hard to model most of these in FVTT, and for some it makes\n              // no difference. so...\n              // lets optimistically use the highest\n              // assumptions: these are going to be dice strings, and we don't care\n              // about dice value, just number of dice\n              const diceFormula = /(\\d*)d\\d*/;\n              const existingMatch = diceFormula.exec(scaleDamage);\n              const modMatch = diceFormula.exec(modScaleDamage);\n\n              if (!existingMatch || modMatch[1] > existingMatch[1]) {\n                scaleDamage = modScaleDamage;\n              }\n            } else {\n              logger.warn(\"No definition found for \" + data.definition.name);\n            }\n          } else if (isHigherLevelDefinitions && modScaleType === \"characterlevel\") {\n            // cantrip support, important to set to a fixed vaue if using abilities like potent spellcasting\n            scaleDamage = baseDamage;\n          }\n\n          scaleType = getScaleType(data.definition.name, data, mod);\n        }\n      });\n  }\n\n  switch (scaleType) {\n    case \"characterlevel\":\n      return {\n        mode: \"cantrip\",\n        formula: scaleDamage,\n      };\n    case \"spellscale\":\n      return {\n        mode: \"level\",\n        formula: scaleDamage,\n      };\n    case \"spelllevel\":\n    case null:\n      return {\n        mode: \"none\",\n        formula: \"\",\n      };\n    default:\n      return {\n        mode: \"level\",\n        formula: \"\",\n      };\n  }\n}\n","function getCustomName(data, character) {\n  if (!hasProperty(character, \"flags.ddbimporter.dndbeyond.characterValues\")) return null;\n  const characterValues = character.flags.ddbimporter.dndbeyond.characterValues;\n  const customValue = characterValues.filter((value) => value.valueId == data.id && value.valueTypeId == data.entityTypeId);\n\n  if (customValue) {\n    const customName = customValue.find((value) => value.typeId == 8);\n\n    if (customName) {\n      data.name = customName.vale;\n      return customName.value;\n    }\n    if (customName) return customName.value;\n  }\n  return null;\n}\n\n\nexport function getName(data, character) {\n  // spell name\n  const customName = getCustomName(data, character);\n  if (customName) {\n    return customName;\n  } else if (data.flags.ddbimporter.dndbeyond.nameOverride !== undefined) {\n    return data.flags.ddbimporter.dndbeyond.nameOverride;\n  } else {\n    return data.definition.name;\n  }\n}\n","import utils from \"../../utils.js\";\nimport DICTIONARY from \"../../dictionary.js\";\n\n// Import parsing functions\nimport { getMaterials, getComponents } from \"./components.js\";\nimport { getSpellPreparationMode } from \"./prepartion.js\";\nimport { getUses } from \"./uses.js\";\nimport { getActivation } from \"./activation.js\";\nimport { getDuration } from \"./duration.js\";\nimport { getTarget } from \"./target.js\";\nimport { getRange } from \"./range.js\";\nimport { getActionType } from \"./action.js\";\nimport { getDamage } from \"./damage.js\";\nimport { getSave } from \"./save.js\";\nimport { getSpellScaling } from \"./scaling.js\";\nimport { generateTable } from \"../../muncher/table.js\";\nimport { spellEffectAdjustment } from \"../../effects/specialSpells.js\";\nimport { getName } from \"./name.js\";\n\nexport function parseSpell(data, character) {\n  let spell = {\n    type: \"spell\",\n    data: JSON.parse(utils.getTemplate(\"spell\")),\n    name: getName(data, character),\n    flags: {\n      ddbimporter: {\n        id: data.id,\n        definitionId: data.definition.id,\n        entityTypeId: data.entityTypeId,\n        dndbeyond: data.flags.ddbimporter.dndbeyond,\n        originalName: data.definition.name.replace(//g, \"'\"),\n        sources: data.definition.sources,\n        tags: data.definition.tags,\n        version: CONFIG.DDBI.version,\n      },\n    },\n  };\n\n  // spell level\n  spell.data.level = data.definition.level;\n\n  // get the spell school\n  const school = DICTIONARY.spell.schools.find((s) => s.name === data.definition.school.toLowerCase());\n  spell.data.school = (school) ? school.id : null;\n\n  /**\n   * Gets the necessary spell components VSM + material\n   */\n  spell.data.components = getComponents(data);\n  spell.data.materials = getMaterials(data);\n  spell.data.preparation = getSpellPreparationMode(data);\n\n  const updateExisting = data.flags.ddbimporter.generic\n    ? game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\")\n    : false;\n  data.definition.description = generateTable(spell.name, data.definition.description, updateExisting);\n\n  spell.data.description = {\n    value: data.definition.description,\n    chat: data.definition.description,\n    unidentified: data.definition.type,\n  };\n\n  spell.data.source = utils.parseSource(data.definition);\n  spell.data.activation = getActivation(data);\n  spell.data.duration = getDuration(data);\n  spell.data.target = getTarget(data);\n  spell.data.range = getRange(data);\n  spell.data.actionType = getActionType(data);\n  spell.data.damage = getDamage(data, spell);\n  spell.data.save = getSave(data);\n  spell.data.scaling = getSpellScaling(data);\n  spell.data.uses = getUses(data);\n\n  // attach the spell ability id to the spell data so VTT always uses the\n  // correct one, useful if multi-classing and spells have different\n  // casting abilities\n  if (character && character.data.attributes.spellcasting !== data.flags.ddbimporter.dndbeyond.ability) {\n    spell.data.ability = data.flags.ddbimporter.dndbeyond.ability;\n    if (spell.data.save.scaling == \"spell\") {\n      spell.data.save.scaling = data.flags.ddbimporter.dndbeyond.ability;\n    }\n  }\n\n  // If using better rolls we set alt to be versatile for spells like\n  // Toll The Dead\n  if (utils.isModuleInstalledAndActive(\"betterrolls5e\")) {\n    spell.flags.betterRolls5e = {\n      quickVersatile: {\n        altValue: true,\n      },\n      quickCharges: {\n        value: {\n          use: true,\n          resource: true\n        },\n        altValue: {\n          use: true,\n          resource: true\n        }\n      },\n    };\n  }\n\n  const isGeneric = getProperty(data, \"flags.ddbimporter.generic\");\n  const addSpellEffects = isGeneric\n    ? game.settings.get(\"ddb-importer\", \"munching-policy-add-spell-effects\")\n    : game.settings.get(\"ddb-importer\", \"character-update-policy-add-spell-effects\");\n  if (addSpellEffects) {\n    spellEffectAdjustment(spell);\n    setProperty(spell, \"flags.ddbimporter.effectsApplied\", true);\n  }\n\n  return spell;\n}\n","// Import parsing functions\nimport { fixSpells } from \"./special.js\";\nimport { parseSpell } from \"./parseSpell.js\";\n\nexport function getSpells(spells) {\n  let items = [];\n\n  spells.filter((spell) => {\n    // remove archived material\n    if (spell.definition.sources && spell.definition.sources.some((source) => source.sourceId === 39)) {\n      return false;\n    } else {\n      return true;\n    }\n  })\n    .forEach((spell) => {\n      if (!spell.definition) return;\n\n      spell.flags = {\n        ddbimporter: {\n          generic: true,\n          dndbeyond: {\n            lookup: \"generic\",\n            lookupName: \"generic\",\n            level: spell.castAtLevel,\n            castAtLevel: spell.castAtLevel,\n          },\n        },\n      };\n\n      items.push(parseSpell(spell, null));\n    });\n\n  if (items) fixSpells(null, items);\n\n  return items;\n}\n","import logger from \"../logger.js\";\n\nfunction isJSON(str) {\n  try {\n    return (JSON.parse(str) && !!str && str !== null);\n  } catch (e) {\n    return false;\n  }\n}\n\nexport function isLocalCobalt(keyPostfix) {\n  return keyPostfix && keyPostfix !== \"\" && localStorage.getItem(`ddb-cobalt-cookie-${keyPostfix}`) !== null;\n}\n\nexport function getCobalt(keyPostfix = \"\") {\n  let cobalt;\n  const localCookie = game.settings.get(\"ddb-importer\", \"cobalt-cookie-local\");\n  const characterCookie = isLocalCobalt(keyPostfix);\n\n  logger.debug(`Getting Cookie: Key postfix? \"${keyPostfix}\" -  Local? ${localCookie} - Character? ${characterCookie}`);\n  if (characterCookie) {\n    cobalt = localStorage.getItem(`ddb-cobalt-cookie-${keyPostfix}`);\n  } else if (localCookie) {\n    cobalt = localStorage.getItem(\"ddb-cobalt-cookie\");\n  } else {\n    cobalt = game.settings.get(\"ddb-importer\", \"cobalt-cookie\");\n  }\n\n  return cobalt;\n}\n\nexport async function setCobalt(value, keyPostfix = \"\") {\n  const localCookie = game.settings.get(\"ddb-importer\", \"cobalt-cookie-local\");\n  const characterCookie = keyPostfix && keyPostfix !== \"\";\n\n  let cobaltValue = value;\n  if (isJSON(value)) {\n    cobaltValue = JSON.parse(value).cbt;\n  }\n\n  logger.debug(`Setting Cookie: Key postfix? \"${keyPostfix}\" -  Local? ${localCookie} - Character? ${characterCookie}`);\n  if (characterCookie) {\n    localStorage.setItem(`ddb-cobalt-cookie-${keyPostfix}`, cobaltValue);\n  } else if (localCookie) {\n    localStorage.setItem(\"ddb-cobalt-cookie\", cobaltValue);\n  } else {\n    await game.settings.set(\"ddb-importer\", \"cobalt-cookie\", cobaltValue);\n  }\n}\n\nexport function deleteLocalCobalt(keyPostfix) {\n  const localCookie = isLocalCobalt(keyPostfix);\n\n  if (localCookie) {\n    localStorage.removeItem(`ddb-cobalt-cookie-${keyPostfix}`);\n  }\n}\n\nexport async function moveCobaltToLocal() {\n  localStorage.setItem('ddb-cobalt-cookie', game.settings.get(\"ddb-importer\", \"cobalt-cookie\"));\n  await game.settings.set(\"ddb-importer\", \"cobalt-cookie\", \"\");\n  game.settings.set(\"ddb-importer\", \"cobalt-cookie-local\", true);\n}\n\nexport async function moveCobaltToSettings() {\n  game.settings.set(\"ddb-importer\", \"cobalt-cookie\", localStorage.getItem('ddb-cobalt-cookie'));\n  game.settings.set(\"ddb-importer\", \"cobalt-cookie-local\", false);\n}\n\nexport async function checkCobalt(keyPostfix = \"\", alternativeKey = null) {\n  const cobaltCookie = alternativeKey ? alternativeKey : getCobalt(keyPostfix);\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const body = { cobalt: cobaltCookie, betaKey: betaKey };\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/proxy/auth`, {\n      method: \"POST\",\n      cache: \"no-cache\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    })\n      .then((response) => response.json())\n      .then((data) => resolve(data))\n      .catch((error) => {\n        logger.error(`Cobalt cookie check error`);\n        logger.error(error);\n        logger.error(error.stack);\n        reject(error);\n      });\n  });\n}\n","// Main module class\nimport { updateCompendium, srdFiddling, daeFiddling } from \"./import.js\";\nimport { munchNote, getCampaignId, download } from \"./utils.js\";\nimport { getSpells } from \"../parser/spells/getGenericSpells.js\";\nimport utils from \"../utils.js\";\nimport logger from \"../logger.js\";\nimport { getCobalt } from \"../lib/Secrets.js\";\nimport { createCompendiumFolderStructure } from \"./compendiumFolders.js\";\n\nfunction getSpellData(className, sourceFilter) {\n  const cobaltCookie = getCobalt();\n  const campaignId = getCampaignId();\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey, className: className };\n  const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n  const enableSources = game.settings.get(\"ddb-importer\", \"munching-policy-use-source-filter\");\n  const sources = enableSources\n    ? game.settings.get(\"ddb-importer\", \"munching-policy-muncher-sources\").flat()\n    : [];\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/proxy/class/spells`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body), // body data type must match \"Content-Type\" header\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (debugJson) {\n          download(JSON.stringify(data), `spells-raw.json`, \"application/json\");\n        }\n        if (!data.success) {\n          munchNote(`Failure: ${data.message}`);\n          reject(data.message);\n        }\n        return data;\n      })\n      .then((data) => {\n        if (sources.length == 0 || !sourceFilter) return data.data;\n        return data.data.filter((spell) =>\n          spell.definition.sources.some((source) => sources.includes(source.sourceId))\n        );\n      })\n      .then((data) => resolve(data))\n      .catch((error) => {\n        logger.warn(error);\n        reject(error);\n      });\n  });\n}\n\nexport async function parseSpells(ids = null) {\n  const updateBool = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n  const uploadDirectory = game.settings.get(\"ddb-importer\", \"other-image-upload-directory\").replace(/^\\/|\\/$/g, \"\");\n\n  // to speed up file checking we pregenerate existing files now.\n  await utils.generateCurrentFiles(uploadDirectory);\n\n  const addToCompendiumFolder = game.settings.get(\"ddb-importer\", \"munching-policy-use-compendium-folders\");\n  const compendiumFoldersInstalled = utils.isModuleInstalledAndActive(\"compendium-folders\");\n  if (addToCompendiumFolder && compendiumFoldersInstalled) {\n    munchNote(`Checking compendium folders..`, true);\n    await createCompendiumFolderStructure(\"spells\");\n    munchNote(\"\", true);\n  }\n\n  munchNote(\"Downloading spell data..\");\n\n  // disable source filter if ids provided\n  const sourceFilter = !(ids !== null && ids.length > 0);\n  const results = await Promise.allSettled([\n    getSpellData(\"Cleric\", sourceFilter),\n    getSpellData(\"Druid\", sourceFilter),\n    getSpellData(\"Sorcerer\", sourceFilter),\n    getSpellData(\"Warlock\", sourceFilter),\n    getSpellData(\"Wizard\", sourceFilter),\n    getSpellData(\"Paladin\", sourceFilter),\n    getSpellData(\"Ranger\", sourceFilter),\n    getSpellData(\"Bard\", sourceFilter),\n    getSpellData(\"Graviturgy\", sourceFilter),\n    getSpellData(\"Chronurgy\", sourceFilter),\n    getSpellData(\"Artificer\", sourceFilter),\n  ]);\n\n  munchNote(\"Parsing spell data..\");\n\n  const filteredResults = results\n    .filter((r) => r.status === \"fulfilled\")\n    .map((r) => r.value).flat().flat();\n\n  const rawSpells = getSpells(filteredResults);\n\n  const spells = rawSpells\n    .filter((spell) => spell?.name)\n    .map((spell) => {\n      spell.name = spell.name.replace(//g, \"'\");\n      return spell;\n    });\n\n  if (results.some((r) => r.status === \"rejected\")) {\n    munchNote(\"Failed to parse some spells, see the developer console (F12) for details.\");\n    logger.error(\"Failed spell parsing\", results);\n  }\n\n  let uniqueSpells = spells.filter((v, i, a) => a.findIndex((t) => t.name === v.name) === i);\n  const srdSpells = await srdFiddling(uniqueSpells, \"spells\");\n  const filteredSpells = (ids !== null && ids.length > 0)\n    ? srdSpells.filter((s) => s.flags?.ddbimporter?.definitionId && ids.includes(String(s.flags.ddbimporter.definitionId)))\n    : srdSpells;\n  const finalSpells = await daeFiddling(filteredSpells);\n\n  const finalCount = finalSpells.length;\n  munchNote(`Importing ${finalCount} spells...`, true);\n\n  return new Promise((resolve) => {\n    resolve(updateCompendium(\"spells\", { spells: finalSpells }, updateBool));\n  });\n}\n\n\n","import utils from \"../../utils.js\";\nimport DICTIONARY from \"../../dictionary.js\";\n\n\nexport function getItemRarity(data) {\n  const rarityDropdown = utils.versionCompare(game.data.system.data.version, \"1.4.2\") >= 0;\n  let tmpRarity = data.definition.rarity;\n  const rarity = data.definition.rarity\n    ? rarityDropdown\n      ? tmpRarity.charAt(0).toLowerCase() + tmpRarity.slice(1).replace(/\\s/g, \"\")\n      : tmpRarity\n    : \"\";\n  return rarity;\n}\n\n/**\n * Checks if the character can attune to an item and if yes, if he is attuned to it.\n */\nexport function getAttuned(data) {\n  if (data.definition.canAttune !== undefined && data.definition.canAttune === true) {\n    return data.isAttuned;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Checks if the character can equip an item and if yes, if he is has it currently equipped.\n */\nexport function getEquipped(data) {\n  if (data.definition.canEquip !== undefined && data.definition.canEquip === true) {\n    return data.equipped;\n  } else {\n    return false;\n  }\n}\n\n\n/**\n * Gets Limited uses information, if any\n * uses: { value: 0, max: 0, per: null }\n */\nexport function getUses(data) {\n  if (data.limitedUse !== undefined && data.limitedUse !== null) {\n    let resetType = DICTIONARY.resets.find((reset) => reset.id == data.limitedUse.resetType);\n    return {\n      max: data.limitedUse.maxUses,\n      value: data.limitedUse.numberUsed\n        ? data.limitedUse.maxUses - data.limitedUse.numberUsed\n        : data.limitedUse.maxUses,\n      per: resetType ? resetType.value : \"\",\n      description: data.limitedUse.resetTypeDescription,\n    };\n  } else {\n    return { value: 0, max: 0, per: null };\n  }\n}\n\nexport function getConsumableUses(data) {\n  if (data.limitedUse) {\n    let uses = getUses(data);\n    if (uses.per === \"\") uses.per = \"charges\";\n    uses.autoUse = false;\n    uses.autoDestroy = true;\n    return uses;\n  } else {\n    // default\n    return { value: 1, max: 1, per: \"charges\", autoUse: false, autoDestroy: true };\n  }\n}\n\n/**\n * Checks the proficiency of the character with this specific weapon\n * @param {obj} data Item data\n * @param {string} weaponType The DND5E weaponType\n * @param {array} proficiencies The character's proficiencies as an array of `{ name: 'PROFICIENCYNAME' }` objects\n */\nexport function getWeaponProficient(data, weaponType, proficiencies) {\n  // if it's a simple weapon and the character is proficient in simple weapons:\n  if (\n    proficiencies.find((proficiency) => proficiency.name === \"Simple Weapons\") &&\n    weaponType.indexOf(\"simple\") !== -1\n  ) {\n    return true;\n  } else if (\n    proficiencies.find((proficiency) => proficiency.name === \"Martial Weapons\") &&\n    weaponType.indexOf(\"martial\") !== -1\n  ) {\n    return true;\n  } else {\n    const proficient = proficiencies.some((proficiency) => proficiency.name.toLowerCase() === data.definition.type.toLowerCase());\n    return proficient;\n  }\n};\n\n/**\n * Searches for a magical attack bonus granted by this weapon\n * @param {obj} data item data\n */\nexport function getMagicalBonus(data) {\n  let boni = data.definition.grantedModifiers.filter(\n    (mod) => mod.type === \"bonus\" && mod.subType === \"magic\" && mod.value && mod.value !== 0\n  );\n  let bonus = boni.reduce((prev, cur) => prev + cur.value, 0);\n  return bonus;\n}\n\nexport function getAttunement(item) {\n  if (item.isAttuned) {\n    return 2;\n  } else if (item.definition.canAttune) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function getBaseItem(data) {\n  let baseItem = \"\";\n\n  if (data.definition.filterType === \"Weapon\") {\n    baseItem = data.definition.type.toLowerCase().split(\",\").reverse().join(\"\").replace(/\\s/g, \"\");\n  } else if (data.definition.filterType === \"Armor\" && data.definition.baseArmorName) {\n    baseItem = data.definition.baseArmorName.toLowerCase().split(\",\").reverse().join(\"\").replace(/\\s/g, \"\");\n  } else if (data.definition.filterType === \"Other Gear\" &&\n    ((data.definition.gearTypeId === 1 && data.definition.subType === \"Tool\") ||\n      (data.definition.gearTypeId === 11))) {\n    const toolProficiencies = DICTIONARY.character.proficiencies\n      .filter((prof) => prof.type === \"Tool\")\n      .map((prof) => {\n        return prof;\n      });\n\n    const baseTool = toolProficiencies.find((allProf) => allProf.name === data.definition.name);\n    if (baseTool && baseTool.baseTool && baseTool.baseTool !== \"\") {\n      baseItem = baseTool.baseTool;\n    }\n  } else if (data.definition.filterType === \"Staff\") {\n    baseItem = \"quarterstaff\";\n  }\n\n\n  return baseItem;\n}\n\nexport function getQuantity(data) {\n  return data.definition.quantity\n    ? data.definition.quantity\n    : data.quantity\n      ? data.quantity\n      : 1;\n}\n\nexport function getSingleItemWeight(data) {\n  const bundleSize = data.definition?.bundleSize ? data.definition.bundleSize : 1;\n  const totalWeight = data.definition?.weight ? data.definition.weight : 0;\n  const weight = totalWeight / bundleSize;\n  return weight;\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport utils from \"../../utils.js\";\nimport { getItemRarity, getEquipped, getUses, getWeaponProficient, getMagicalBonus, getSingleItemWeight, getQuantity } from \"./common.js\";\n\n/**\n * Gets the DND5E weapontype (simpleM, martialR etc.) as string\n * Supported Types only: Simple/Martial Melee/Ranged and Ammunition (Firearms in D&DBeyond)\n * @param {obj} data item data\n */\nfunction getWeaponType(data) {\n  const type = DICTIONARY.weapon.weaponType.find(\n    (type) => type.categoryId === data.definition.categoryId\n  );\n  const range = DICTIONARY.weapon.weaponRange.find(\n    (type) => type.attackType === data.definition.attackType\n  );\n\n  if (type && range) {\n    return `${type.value}${range.value}`;\n  } else {\n    return \"simpleM\";\n  }\n}\n\n/**\n * Gets the weapons's properties (Finesse, Reach, Heavy etc.)\n * @param {obj} data Item data\n */\nfunction getProperties(data) {\n  let result = {};\n  DICTIONARY.weapon.properties.forEach((property) => {\n    if (data.definition.properties && Array.isArray(data.definition.properties)) {\n      result[property.value] = data.definition.properties.some((prop) => prop.name === property.name);\n    }\n    if (\n      !result[property.value] &&\n      data.definition.grantedModifiers &&\n      Array.isArray(data.definition.grantedModifiers)\n    ) {\n      result[property.value] = data.definition.grantedModifiers.some(\n        (prop) => prop.type === \"weapon-property\" && prop.friendlySubtypeName === property.name\n      );\n    }\n  });\n  return result;\n}\n\n/**\n * Gets the range(s) of a given weapon\n */\nfunction getRange(data, weaponProperties) {\n  // range: { value: null, long: null, units: '' },\n  // sometimes reach weapons have their range set as 5. it's not clear why.\n  const shortRange = data.definition.range ? data.definition.range : 5;\n  const reach = weaponProperties.rch && data.definition.range == 5 ? 5 : 0;\n  return {\n    value: shortRange + reach,\n    long: (data.definition.longRange && data.definition.longRange != data.definition.range)\n      ? data.definition.longRange + reach\n      : \"\",\n    units: \"ft\",\n  };\n};\n\n/**\n * Gets the ability which the to hit modifier is baed on\n * Melee: STR\n * Ranged: DEX\n * Finesse: STR || DEX\n * Thrown: STR, unless Finesse, then STR || DEX\n * @param {obj} data item data\n * @param {obj} weaponProperties weapon properties\n * @param {obj} weaponRange weapon range information\n * @param {obj} abilities character abilities (scores)\n */\nfunction getAbility(weaponProperties, weaponRange) {\n  // finesse weapons can choose freely, so we choose the higher one\n  if (weaponProperties.fin) {\n    return null;\n  }\n\n  // thrown, but not finesse weapon: STR\n  if (weaponProperties.thr) {\n    return \"str\";\n  }\n\n  // if it's a ranged weapon, and not a reach weapon (long = 10 (?))\n  if (weaponRange.long > 5 && !weaponProperties.rch) {\n    return \"dex\";\n  }\n  // the default is STR\n  return null;\n}\n\n/**\n * Searches for a magical attack bonus granted by this weapon\n * @param {obj} data item data\n * @param {obj} flags\n */\nfunction getWeaponMagicalBonus(data, flags) {\n  const bonus = getMagicalBonus(data);\n  if (flags.classFeatures.includes(\"Improved Pact Weapon\") && bonus === 0) {\n    return 1;\n  } else {\n    return bonus;\n  }\n};\n\n/**\n *\n * @param {obj} data item data\n * @param {obj} flags\n * /* damage: { parts: [], versatile: '' }, * /\n */\nfunction getDamage(data, flags, betterRolls5e) {\n  const magicalDamageBonus = getWeaponMagicalBonus(data, flags);\n  // we can safely make these assumptions about GWF and Dueling because the\n  // flags are only added for melee attacks\n  const greatWeaponFighting = flags.classFeatures.includes(\"greatWeaponFighting\") ? \"r<=2\" : \"\";\n  const dueling = flags.classFeatures.includes(\"Dueling\") ? \" + 2\" : \"\";\n  const offHand = flags.classFeatures.includes(\"OffHand\");\n  const twoWeapon = flags.classFeatures.includes(\"Two-Weapon Fighting\");\n  const twoHanded = data.definition.properties.find((property) => property.name === \"Two-Handed\");\n  const mod = (offHand && !twoWeapon) ? \"\" : \" + @mod\";\n\n  const baseDamageTagData = utils.getDamageTagForItem(data);\n  const damageTag = baseDamageTagData.damageTag;\n  const damageType = baseDamageTagData.damageType;\n\n  const versatile = data.definition.properties\n    .filter((property) => property.name === \"Versatile\")\n    .map((versatile) => {\n      if (versatile && versatile.notes) {\n        return (\n          utils.parseDiceString(versatile.notes + ` + ${magicalDamageBonus}`, null, damageTag, greatWeaponFighting).diceString + mod\n        );\n      } else {\n        return \"\";\n      }\n    })[0];\n\n  let chatFlavor = \"\";\n  let parts = [];\n  let otherFormula = \"\";\n\n  // first damage part\n  // blowguns and other weapons rely on ammunition that provides the damage parts\n  if (data.definition.damage && data.definition.damage.diceString && damageType) {\n    // if we have greatweapon fighting style and this is two handed, add the roll tweak\n    // else if we have duelling we add the bonus here (assumption- if you have dueling\n    // you're going to use it! (DDB also makes this assumption))\n    const fightingStyleDiceMod = twoHanded ? greatWeaponFighting : \"\";\n\n    // if we are a martial artist and the weapon is eligable we may need to use a bigger dice type.\n    // this martial arts die info is addedd to the weapon flags before parse weapon is called\n    const martialArtsDie = flags.martialArtsDie;\n    let diceString = data.definition.damage.diceString;\n\n    if (martialArtsDie.diceValue && data.definition.damage.diceValue && martialArtsDie.diceValue > data.definition.damage.diceValue) {\n      diceString = martialArtsDie.diceString;\n    }\n\n    // if there is a magical damage bonus, it probably should only be included into the first damage part.\n    parts.push([\n      utils.parseDiceString(diceString + ` + ${magicalDamageBonus}`, `${mod}${dueling}`, damageTag, fightingStyleDiceMod)\n        .diceString,\n      damageType,\n    ]);\n  }\n\n  // additional damage parts with no restrictions\n  data.definition.grantedModifiers\n    .filter((mod) => mod.type === \"damage\" && (!mod.restriction || mod.restriction === \"\"))\n    .forEach((mod) => {\n      const damagePart = (mod.dice) ? mod.dice.diceString : mod.value;\n      if (damagePart) {\n        const subDamageTagData = utils.getDamageTagForMod(mod);\n        const damageParsed = utils.parseDiceString(damagePart, \"\", subDamageTagData.damageTag).diceString;\n        parts.push([`${damageParsed}`, subDamageTagData.damageType]);\n      }\n    });\n\n  // loop over restricted damage types\n  // we do this so we can either break this out for midi users\n  data.definition.grantedModifiers\n    .filter((mod) => mod.type === \"damage\" && mod.restriction && mod.restriction !== \"\")\n    .forEach((mod) => {\n      const damagePart = (mod.dice) ? mod.dice.diceString : `${mod.value}`;\n      if (damagePart) {\n        const subDamageTagData = utils.getDamageTagForMod(mod);\n        const damageParsed = utils.parseDiceString(damagePart, \"\", subDamageTagData.damageTag).diceString;\n\n        if (utils.isModuleInstalledAndActive(\"betterrolls5e\")) {\n          const attackNum = parts.length;\n          betterRolls5e.quickDamage.context[attackNum] = mod.restriction;\n          parts.push([`${damageParsed}`, subDamageTagData.damageType]);\n        } else {\n          // if (utils.isModuleInstalledAndActive(\"midi-qol\")) {\n          parts.forEach((part) => {\n            otherFormula += (otherFormula === \"\") ? part[0] : ` + ${part[0]}`;\n          });\n          otherFormula += ` + ${damageParsed}`;\n          chatFlavor = `Use Other damage ${mod.restriction}`;\n        }\n      }\n    });\n\n  // add damage modifiers from other sources like improved divine smite\n  if (flags.damage.parts) {\n    flags.damage.parts.forEach((part) => {\n      parts.push(part);\n    });\n  }\n\n  const result = {\n    parts: parts,\n    versatile: versatile,\n  };\n\n  return [result, betterRolls5e, otherFormula, chatFlavor];\n}\n\nfunction getActionType(data) {\n  if (data.definition.attackType === 1) {\n    return \"mwak\";\n  } else {\n    return \"rwak\";\n  }\n}\n\nexport default function parseWeapon(data, character, flags) {\n  let weapon = {\n    name: data.definition.name,\n    type: \"weapon\",\n    data: JSON.parse(utils.getTemplate(\"weapon\")),\n    flags: {\n      ddbimporter: {\n        dndbeyond: {\n          type: data.definition.type,\n          damage: flags.damage,\n          classFeatures: flags.classFeatures,\n        },\n      },\n    },\n  };\n\n  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;\n  const characterProficiencies = character.flags.ddbimporter.dndbeyond.proficienciesIncludingEffects;\n\n  // if using better rolls lets add some useful QOL information.\n  // marks context as magical attack and makes alt click a versatile damage click\n  const brFlags = (utils.isModuleInstalledAndActive(\"betterrolls5e\"))\n    ? {\n      quickDamage: {\n        context: {\n          \"0\": getWeaponMagicalBonus(data, flags) > 0 ? \"Magical\" : \"\",\n        },\n        value: {\n          \"0\": true,\n        },\n        altValue: {\n          \"0\": true,\n        },\n      },\n      quickVersatile: {\n        altValue: true,\n      },\n      quickCharges: {\n        value: {\n          use: false,\n          resource: true\n        },\n        altValue: {\n          use: false,\n          resource: true\n        }\n      },\n    }\n    : {};\n  setProperty(weapon, \"flags.betterRolls5e\", brFlags);\n\n  weapon.data.weaponType = getWeaponType(data);\n  weapon.data.properties = getProperties(data);\n\n  const proficientFeatures = [\"pactWeapon\", \"kensaiWeapon\"];\n  if (flags.classFeatures.some((feat) => proficientFeatures.includes(feat))) {\n    weapon.data.proficient = true;\n  } else {\n    weapon.data.proficient = getWeaponProficient(data, weapon.data.weaponType, characterProficiencies);\n  }\n\n  weapon.data.description = {\n    value: data.definition.description,\n    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,\n    unidentified: data.definition.type,\n  };\n  weapon.data.source = utils.parseSource(data.definition);\n  weapon.data.quantity = getQuantity(data);\n  weapon.data.weight = getSingleItemWeight(data);\n  weapon.data.equipped = getEquipped(data);\n  weapon.data.rarity = getItemRarity(data);\n  weapon.data.identified = true;\n  weapon.data.activation = { type: \"action\", cost: 1, condition: \"\" };\n  if (flags.classFeatures.includes(\"OffHand\")) weapon.data.activation.type = \"bonus\";\n\n  weapon.data.range = getRange(data, weapon.data.properties);\n  weapon.data.uses = getUses(data);\n  weapon.data.ability = getAbility(weapon.data.properties, weapon.data.range);\n  const mockAbility = weapon.data.ability === null\n    ? weapon.data.properties.fin ? \"dex\" : \"str\"\n    : weapon.data.ability;\n\n  // warlocks can use cha for their Hex weapon\n  if (flags.classFeatures.includes(\"hexWarrior\")) {\n    if (characterAbilities.cha.value >= characterAbilities[mockAbility].value) {\n      weapon.data.ability = \"cha\";\n    }\n  }\n  // kensai monks\n  if (flags.classFeatures.includes(\"kensaiWeapon\") || flags.classFeatures.includes(\"monkWeapon\")) {\n    if (characterAbilities.dex.value >= characterAbilities[mockAbility].value) {\n      weapon.data.ability = \"dex\";\n    }\n  }\n  if (flags.magicItemAttackInt && (data.definition.magic || weapon.data.properties.mgc)) {\n    if (characterAbilities.int.value > characterAbilities[mockAbility].value) {\n      weapon.data.ability = \"int\";\n    }\n  }\n\n  weapon.data.actionType = getActionType(data);\n  weapon.data.attackBonus = getWeaponMagicalBonus(data, flags);\n\n  [\n    weapon.data.damage,\n    weapon.flags.betterRolls5e,\n    weapon.data.formula,\n    weapon.data.chatFlavor\n  ] = getDamage(data, flags, weapon.flags.betterRolls5e);\n\n\n  return weapon;\n}\n","import utils from \"../../utils.js\";\nimport { getItemRarity, getEquipped, getMagicalBonus, getSingleItemWeight, getQuantity } from \"./common.js\";\n\n/**\n * Gets the range(s) of a given weapon\n */\nfunction getRange(data) {\n  // range: { value: null, long: null, units: '' },\n  return {\n    value: data.definition.range ? data.definition.range : null,\n    long: data.definition.longRange ? data.definition.longRange : null,\n    units: (data.definition.range || data.definition.range) ? \"ft.\" : \"\",\n  };\n}\n\n/**\n *\n * @param {obj} data item data\n * @param {obj} weaponProperties weapon properties\n * /* damage: { parts: [], versatile: '' }, * /\n */\nlet getDamage = (data, magicalDamageBonus) => {\n  let parts = [];\n\n  // first damage part\n  // blowguns and other weapons rely on ammunition that provides the damage parts\n  if (data.definition.damage && data.definition.damage.diceString && data.definition.damageType) {\n    // if there is a magical damage bonus, it probably should only be included into the first damage part.\n    parts.push([\n      utils.parseDiceString(data.definition.damage.diceString + `+${magicalDamageBonus}`).diceString,\n      data.definition.damageType.toLowerCase(),\n    ]);\n  }\n\n  // additional damage parts\n  // Note: For the time being, restricted additional bonus parts are not included in the damage\n  //       The Saving Throw Freature within Foundry is not fully implemented yet, to this will/might change\n  data.definition.grantedModifiers\n    .filter((mod) => mod.type === \"damage\" && mod.restriction && mod.restriction.length === 0)\n    .forEach((mod) => {\n      if (mod.dice) {\n        parts.push([mod.dice.diceString, mod.subType]);\n      } else if (mod.value) {\n        parts.push([mod.value, mod.subType]);\n      }\n    });\n\n  let result = {\n    // label: utils.parseDiceString(parts.map(part => part[0]).join(' + ')).diceString,\n    parts: parts,\n    versatile: \"\",\n  };\n\n  return result;\n};\n\nexport default function parseAmmunition(data, itemType) {\n  /**\n   * MAIN parseWeapon\n   */\n  let template = JSON.parse(utils.getTemplate(\"consumable\"));\n  let ammunition = {\n    name: data.definition.name,\n    type: \"consumable\",\n    data: template,\n    flags: {\n      ddbimporter: {\n        dndbeyond: {\n          type: itemType,\n        },\n      },\n    },\n  };\n\n  ammunition.data.description = {\n    value: data.definition.description,\n    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,\n    unidentified: data.definition.type,\n  };\n  ammunition.data.source = utils.parseSource(data.definition);\n  ammunition.data.properties = {};\n  ammunition.data.quantity = getQuantity(data);\n  ammunition.data.weight = getSingleItemWeight(data);\n  ammunition.data.equipped = getEquipped(data);\n  ammunition.data.rarity = getItemRarity(data);\n  ammunition.data.identified = true;\n  ammunition.data.activation = { type: \"action\", cost: 1, condition: \"\" };\n  ammunition.data.range = getRange(data);\n  ammunition.data.ability = \"\";\n  ammunition.data.actionType = \"rwak\";\n  ammunition.data.attackBonus = getMagicalBonus(data);\n  ammunition.data.damage = getDamage(data, getMagicalBonus(data));\n  ammunition.data.consumableType = \"ammo\";\n\n  return ammunition;\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport utils from \"../../utils.js\";\nimport { getItemRarity, getEquipped, getWeaponProficient, getMagicalBonus, getSingleItemWeight, getQuantity } from \"./common.js\";\n\n/**\n * Gets the DND5E weapontype (simpleM, martialR etc.) as string\n * Supported Types only: Simple/Martial Melee/Ranged and Ammunition (Firearms in D&DBeyond)\n * @param {obj} data item data\n */\nfunction getWeaponType(data) {\n  const weaponBehavior = data.definition.weaponBehaviors[0];\n  const type = DICTIONARY.weapon.weaponType.find((type) => type.categoryId === weaponBehavior.categoryId);\n  const range = DICTIONARY.weapon.weaponRange.find((type) => type.attackType === weaponBehavior.attackType);\n\n  if (type && range) {\n    return `${type.value}${range.value}`;\n  } else {\n    return \"simpleM\";\n  }\n}\n\n/**\n * Gets the weapons's properties (Finesse, Reach, Heavy etc.)\n * @param {obj} data Item data\n */\nfunction getProperties(data) {\n  let weaponBehavior = data.definition.weaponBehaviors[0];\n  let result = {};\n  DICTIONARY.weapon.properties.forEach((property) => {\n    if (weaponBehavior.properties && Array.isArray(weaponBehavior.properties)) {\n      result[property.value] = weaponBehavior.properties.find((prop) => prop.name === property.name) !== undefined;\n    }\n  });\n  return result;\n}\n\n\n/**\n * Gets the range(s) of a given weapon\n */\nfunction getRange(data) {\n  // range: { value: null, long: null, units: '' },\n  let weaponBehavior = data.definition.weaponBehaviors[0];\n  return {\n    value: weaponBehavior.range ? weaponBehavior.range : 5,\n    long: weaponBehavior.longRange ? weaponBehavior.longRange : 5,\n    units: \"ft.\",\n  };\n}\n\n/**\n * Gets the ability which the to hit modifier is baed on\n * Melee: STR\n * Ranged: DEX\n * Finesse: STR || DEX\n * Thrown: STR, unless Finesse, then STR || DEX\n * @param {obj} weaponProperties weapon properties\n * @param {obj} weaponRange weapon range information\n * @param {obj} abilities character abilities (scores)\n */\nfunction getAbility(weaponProperties, weaponRange, abilities) {\n  // finesse weapons can choose freely, so we choose the higher one\n  if (weaponProperties.fin) {\n    return abilities.str.value > abilities.dex.value ? \"str\" : \"dex\";\n  }\n\n  // thrown, but not finesse weapon: STR\n  if (weaponProperties.thr) {\n    return \"str\";\n  }\n\n  // if it's a ranged weapon, and hot a reach weapon (long = 10 (?))\n  if (weaponRange.long !== 5 && !weaponProperties.rch) {\n    return \"dex\";\n  }\n\n  // the default is STR\n  return \"str\";\n}\n\n/**\n *\n * @param {obj} data item data\n * @param {obj} weaponProperties weapon properties\n * /* damage: { parts: [], versatile: '' }, * /\n */\nfunction getDamage(data, magicalDamageBonus) {\n  let weaponBehavior = data.definition.weaponBehaviors[0];\n  let versatile = weaponBehavior.properties.find((property) => property.name === \"Versatile\");\n  if (versatile && versatile.notes) {\n    versatile = utils.parseDiceString(versatile.notes + `+${magicalDamageBonus}`).diceString;\n  } else {\n    versatile = \"\";\n  }\n\n  let parts = [];\n\n  // first damage part\n  // blowguns and other weapons rely on ammunition that provides the damage parts\n  if (weaponBehavior.damage && weaponBehavior.damage.diceString && weaponBehavior.damageType) {\n    parts.push([\n      utils.parseDiceString(weaponBehavior.damage.diceString + `+${magicalDamageBonus}`).diceString,\n      weaponBehavior.damageType.toLowerCase(),\n    ]);\n  }\n\n  // additional damage parts\n  data.definition.grantedModifiers\n    .filter((mod) => mod.type === \"damage\")\n    .forEach((mod) => {\n      if (mod.dice) {\n        parts.push([mod.dice.diceString, mod.subType]);\n      } else if (mod.value) {\n        parts.push([`${mod.value}`, mod.subType]);\n      }\n    });\n\n  let result = {\n    // label: utils.parseDiceString(parts.map(part => part[0]).join(' + ')).diceString,\n    parts: parts,\n    versatile: versatile,\n  };\n\n  return result;\n}\n\nexport default function parseStaff(data, character) {\n  let template = JSON.parse(utils.getTemplate(\"weapon\"));\n  let staff = {\n    name: data.definition.name,\n    type: \"weapon\",\n    data: template,\n    flags: {\n      ddbimporter: {\n        dndbeyond: {\n          type: data.definition.type,\n        },\n      },\n    },\n  };\n\n  staff.data.weaponType = getWeaponType(data);\n  staff.data.properties = getProperties(data);\n  staff.data.proficient = getWeaponProficient(data, staff.data.weaponType, character.flags.ddbimporter.dndbeyond.proficienciesIncludingEffects);\n  staff.data.description = {\n    value: data.definition.description,\n    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,\n    unidentified: data.definition.type,\n  };\n\n  staff.data.source = utils.parseSource(data.definition);\n  staff.data.quantity = getQuantity(data);\n  staff.data.weight = getSingleItemWeight(data);\n  staff.data.equipped = getEquipped(data);\n  staff.data.rarity = getItemRarity(data);\n  staff.data.identified = true;\n  staff.data.activation = { type: \"action\", cost: 1, condition: \"\" };\n  staff.data.range = getRange(data);\n  staff.data.ability = getAbility(staff.data.properties, staff.data.range, character.flags.ddbimporter.dndbeyond.effectAbilities);\n  staff.data.actionType = staff.data.range.long === 5 ? \"mwak\" : \"rwak\";\n  staff.data.attackBonus = getMagicalBonus(data);\n  staff.data.damage = getDamage(data, getMagicalBonus(data));\n\n  return staff;\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport utils from \"../../utils.js\";\nimport { getItemRarity, getEquipped, getUses, getSingleItemWeight, getQuantity } from \"./common.js\";\n\n/**\n * Gets the DND5E weapontype (simpleM, martialR etc.) as string\n * Supported Types only: Simple/Martial Melee/Ranged and Ammunition (Firearms in D&DBeyond)\n * @param {obj} data item data\n */\nfunction getArmorType(data, character, flags) {\n  // get the generic armor type\n  const nameEntry = DICTIONARY.equipment.armorType.find((type) => type.name === data.definition.type);\n  const idEntry = DICTIONARY.equipment.armorType.find((type) => type.id === data.definition.armorTypeId);\n\n  // get the armor class\n  const baseArmorClass = data.definition.armorClass;\n  const bonusArmorClass = data.definition.grantedModifiers.reduce((prev, cur) => {\n    if (cur.type === \"bonus\" && cur.subType === \"armor-class\" && Number.isInteger(cur.value)) {\n      return prev + cur.value;\n    } else {\n      return prev;\n    }\n  }, 0);\n\n  // console.warn(\"datadefinition\",data.definition)\n  // console.warn(\"baseArmorClass\",baseArmorClass)\n  // console.warn(\"bonusArmorClass\",bonusArmorClass)\n\n  // get the max dex modifier (Medium Armor: 2, Heavy: 0)\n  let maxDexModifier;\n  switch (data.definition.type) {\n    case \"Heavy Armor\":\n      maxDexModifier = 0;\n      break;\n    case \"Medium Armor\":\n      maxDexModifier = flags.maxMediumArmorDex;\n      break;\n    default:\n      maxDexModifier = null;\n  }\n\n  const itemDexMaxAdjustment = utils.getModifierSum(utils.filterModifiers(data.definition.grantedModifiers, \"set\", \"ac-max-dex-modifier\"), character);\n  if (maxDexModifier !== null && Number.isInteger(itemDexMaxAdjustment) && itemDexMaxAdjustment > maxDexModifier) {\n    maxDexModifier = itemDexMaxAdjustment;\n  }\n\n  return {\n    type: nameEntry !== undefined ? nameEntry.value : idEntry !== undefined ? idEntry.value : \"medium\",\n    value: baseArmorClass + bonusArmorClass,\n    dex: maxDexModifier,\n  };\n}\n\n/**\n * Gets the strength requirement to wear this armor, if any\n * @param {obj} data Item data\n */\nfunction getStrength(data) {\n  return data.definition.strengthRequirement !== null ? data.definition.strengthRequirement : 0;\n}\n\n/**\n * Wearing this armor can give a disadvantage on stealth checks\n */\nfunction getStealthPenalty(data) {\n  return data.definition.stealthCheck === 2;\n}\n\n/**\n * Checks the proficiency of the character with this specific weapon\n * @param {obj} data Item data\n * @param {array} proficiencies The character's proficiencies as an array of `{ name: 'PROFICIENCYNAME' }` objects\n */\nfunction getProficient(data, proficiencies) {\n  // Proficiency in armor category (Light Armor, Shield)\n  if (proficiencies.find((proficiency) => proficiency.name === data.definition.type) !== -1) return true;\n  // Specific proficiency\n  if (proficiencies.find((proficiency) => proficiency.name === data.definition.baseArmorName) !== -1) return true;\n  return false;\n}\n\nexport default function parseArmor(data, character, flags) {\n  let armor = {\n    name: data.definition.name,\n    type: \"equipment\",\n    data: JSON.parse(utils.getTemplate(\"equipment\")),\n    flags: {\n      ddbimporter: {\n        dndbeyond: {\n          type: data.definition.type,\n        },\n      },\n    },\n  };\n\n  armor.data.armor = getArmorType(data, character, flags);\n  armor.data.strength = getStrength(data);\n  armor.data.stealth = getStealthPenalty(data);\n  armor.data.proficient = getProficient(data, character.flags.ddbimporter.dndbeyond.proficienciesIncludingEffects);\n  armor.data.description = {\n    value: data.definition.description,\n    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,\n    unidentified: data.definition.type,\n  };\n\n  armor.data.source = utils.parseSource(data.definition);\n  armor.data.quantity = getQuantity(data);\n  armor.data.weight = getSingleItemWeight(data);\n  armor.data.equipped = getEquipped(data);\n  armor.data.rarity = getItemRarity(data);\n  armor.data.identified = true;\n  armor.data.uses = getUses(data);\n\n  return armor;\n}\n","import utils from \"../../utils.js\";\nimport { getItemRarity, getEquipped, getUses, getSingleItemWeight, getQuantity } from \"./common.js\";\n\nexport default function parseWonderous(data) {\n  /**\n   * MAIN parseEquipment\n   */\n  let item = {\n    name: data.definition.name,\n    type: \"equipment\",\n    data: JSON.parse(utils.getTemplate(\"equipment\")),\n    flags: {\n      ddbimporter: {\n        dndbeyond: {\n          type: data.definition.type,\n        },\n      },\n    },\n  };\n\n  //\n  // \"armor\": {\n  // \"type\": \"trinket\",\n  // \"value\": 10,\n  // \"dex\": null\n  // }\n  item.data.armor = {\n    type: \"trinket\",\n    value: 10,\n    dex: null,\n  };\n\n  /* \"strength\": 0 */\n  item.data.strength = 0;\n\n  /* \"stealth\": false,*/\n  item.data.stealth = false;\n  item.data.proficient = true;\n  item.data.description = {\n    value: data.definition.description,\n    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,\n    unidentified: data.definition.type,\n  };\n\n  item.data.source = utils.parseSource(data.definition);\n  item.data.quantity = getQuantity(data);\n  item.data.weight = getSingleItemWeight(data);\n  item.data.equipped = getEquipped(data);\n  item.data.rarity = getItemRarity(data);\n  item.data.identified = true;\n  item.data.uses = getUses(data);\n\n  return item;\n}\n","import utils from \"../../utils.js\";\nimport { getItemRarity, getEquipped, getConsumableUses, getSingleItemWeight, getQuantity } from \"./common.js\";\n\n\nfunction getActionType(data) {\n  if (data.definition.tags.includes(\"Healing\")) {\n    return \"heal\";\n  } else if (data.definition.tags.includes(\"Damage\")) {\n    // ranged spell attack. This is a good guess\n    return \"rsak\";\n  } else {\n    return \"other\";\n  }\n}\n\nfunction getDamage(data, actionType) {\n  let damage = { parts: [], versatile: \"\" };\n  // is this a damage potion\n  switch (actionType) {\n    case \"heal\": {\n      // healing potion\n      // we only get the first matching modifier\n      const healingModifier = data.definition.grantedModifiers.find(\n        (mod) => mod.type === \"bonus\" && mod.subType === \"hit-points\"\n      );\n      if (healingModifier && healingModifier.dice) {\n        damage.parts = [[healingModifier.dice.diceString + \"[healing] \", \"healing\"]];\n      } else if (healingModifier && healingModifier.fixedValue) {\n        damage.parts = [[healingModifier.fixedValue + \"[healing] \", \"healing\"]];\n      }\n      break;\n    }\n    case \"rsak\": {\n      // damage potion\n      const damageModifier = data.definition.grantedModifiers.find((mod) => mod.type === \"damage\" && mod.dice);\n      if (damageModifier && damageModifier.dice) {\n        damage.parts = [[damageModifier.dice.diceString + `[${damageModifier.subType}] `, damageModifier.subType]];\n      } else if (damageModifier && damageModifier.fixedValue) {\n        damage.parts = [[damageModifier.fixedValue + `[${damageModifier.subType}] `, damageModifier.subType]];\n      }\n      break;\n    }\n    // no default\n  }\n  return damage;\n}\n\nfunction getDuration(data) {\n  let duration = {\n    value: null,\n    units: \"\",\n  };\n\n  if (data.definition.duration) {\n    if (data.definition.duration.durationUnit !== null) {\n      duration.units = data.definition.duration.durationUnit.toLowerCase();\n    } else {\n      duration.units = data.definition.duration.durationType.toLowerCase().substring(0, 4);\n    }\n    if (data.definition.duration.durationInterval) duration.value = data.definition.duration.durationInterval;\n  } else {\n    const durationArray = [\n      { foundryUnit: \"day\", descriptionMatches: [\"day\", \"days\"] },\n      { foundryUnit: \"hour\", descriptionMatches: [\"hour\", \"hours\"] },\n      { foundryUnit: \"inst\", descriptionMatches: [\"instant\", \"instantaneous\"] },\n      { foundryUnit: \"minute\", descriptionMatches: [\"minute\", \"minutes\"] },\n      { foundryUnit: \"month\", descriptionMatches: [\"month\", \"months\"] },\n      { foundryUnit: \"perm\", descriptionMatches: [\"permanent\"] },\n      { foundryUnit: \"round\", descriptionMatches: [\"round\", \"rounds\"] },\n      // { foundryUnit: \"spec\", descriptionMatches: [null] },\n      { foundryUnit: \"turn\", descriptionMatches: [\"turn\", \"turns\"] },\n      { foundryUnit: \"year\", descriptionMatches: [\"year\", \"years\"] },\n    ];\n    // attempt to parse duration\n    const descriptionUnits = durationArray.map((unit) => unit.descriptionMatches).flat().join(\"|\");\n    const durationExpression = new RegExp(`(\\\\d*)(?:\\\\s)(${descriptionUnits})`);\n    const durationMatch = data.definition.description.match(durationExpression);\n\n    if (durationMatch) {\n      duration.units = durationArray.find((duration) => duration.descriptionMatches.includes(durationMatch[2])).foundryUnit;\n      duration.value = durationMatch[1];\n    }\n  }\n  return duration;\n}\n\n\nexport default function parsePotion(data, itemType) {\n  let potion = {\n    name: data.definition.name,\n    type: \"consumable\",\n    data: JSON.parse(utils.getTemplate(\"consumable\")),\n    flags: {\n      ddbimporter: {\n        dndbeyond: {\n          type: itemType,\n        },\n      },\n    },\n  };\n\n  potion.data.consumableType = \"potion\";\n  potion.data.uses = getConsumableUses(data);\n  potion.data.description = {\n    value: data.definition.description,\n    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,\n    unidentified: data.definition.type,\n  };\n  potion.data.source = utils.parseSource(data.definition);\n  potion.data.quantity = getQuantity(data);\n  potion.data.weight = getSingleItemWeight(data);\n  potion.data.equipped = getEquipped(data);\n  potion.data.rarity = getItemRarity(data);\n  potion.data.identified = true;\n  potion.data.activation = { type: \"action\", cost: 1, condition: \"\" };\n  potion.data.duration = getDuration(data);\n  potion.data.actionType = getActionType(data);\n  potion.data.damage = getDamage(data, getActionType(data));\n\n  return potion;\n}\n","import utils from \"../../utils.js\";\nimport { getItemRarity, getEquipped, getConsumableUses, getSingleItemWeight, getQuantity } from \"./common.js\";\n\n\nexport default function parseScroll(data) {\n  let scroll = {\n    name: data.definition.name,\n    type: \"consumable\",\n    data: JSON.parse(utils.getTemplate(\"consumable\")),\n    flags: {\n      ddbimporter: {\n        dndbeyond: {\n          type: data.definition.type,\n        },\n      },\n    },\n  };\n\n  scroll.data.consumableType = \"scroll\";\n  scroll.data.uses = getConsumableUses(data);\n  scroll.data.description = {\n    value: data.definition.description,\n    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,\n    unidentified: data.definition.type,\n  };\n\n  scroll.data.source = utils.parseSource(data.definition);\n  scroll.data.quantity = getQuantity(data);\n  scroll.data.weight = getSingleItemWeight(data);\n  scroll.data.equipped = getEquipped(data);\n  scroll.data.rarity = getItemRarity(data);\n  scroll.data.identified = true;\n  scroll.data.activation = { type: \"action\", cost: 1, condition: \"\" };\n  scroll.data.actionType = \"other\";\n\n  return scroll;\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport utils from \"../../utils.js\";\nimport { getItemRarity, getEquipped, getUses, getSingleItemWeight, getQuantity } from \"./common.js\";\n\nfunction isHalfProficiencyRoundedUp(data, ab) {\n  const longAbility = DICTIONARY.character.abilities\n    .filter((ability) => ab === ability.value)\n    .map((ability) => ability.long)[0];\n  const roundUp = utils.filterBaseModifiers(data, \"half-proficiency-round-up\", `${longAbility}-ability-checks`);\n  return Array.isArray(roundUp) && roundUp.length;\n}\n\nfunction getProficiency(data, toolName, ability) {\n  const modifiers = [\n    utils.getChosenClassModifiers(data, true),\n    utils.getModifiers(data, \"race\", true),\n    utils.getModifiers(data, \"background\", true),\n    utils.getModifiers(data, \"feat\", true),\n    utils.getActiveItemModifiers(data, true),\n  ]\n    .flat()\n    .filter((modifier) => modifier.friendlySubtypeName === toolName)\n    .map((mod) => mod.type);\n\n  const halfProficiency =\n    utils.getChosenClassModifiers(data).find(\n      (modifier) =>\n        // Jack of All trades/half-rounded down\n        (modifier.type === \"half-proficiency\" && modifier.subType === \"ability-checks\") ||\n        // e.g. champion for specific ability checks\n        isHalfProficiencyRoundedUp(data, ability)\n    ) !== undefined\n      ? 0.5\n      : 0;\n\n  const proficient = modifiers.includes(\"expertise\") ? 2 : modifiers.includes(\"proficiency\") ? 1 : halfProficiency;\n\n  return proficient;\n}\n\nexport default function parseTool(ddb, data, itemType) {\n  /**\n   * MAIN parseTool\n   */\n  let tool = {\n    name: data.definition.name,\n    type: \"tool\",\n    data: JSON.parse(utils.getTemplate(\"tool\")),\n    flags: {\n      ddbimporter: {\n        dndbeyond: {\n          type: itemType,\n        },\n      },\n    },\n  };\n\n  tool.data.ability = DICTIONARY.character.proficiencies\n    .filter((prof) => prof.name === tool.name)\n    .map((prof) => prof.ability);\n\n  if (!tool.data.ability) tool.data.ability = \"dex\";\n\n  tool.data.description = {\n    value: data.definition.description,\n    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,\n    unidentified: data.definition.type,\n  };\n\n  tool.data.proficient = (ddb) ? getProficiency(ddb, tool.name, tool.data.ability) : 0;\n  tool.data.source = utils.parseSource(data.definition);\n  tool.data.quantity = getQuantity(data);\n  tool.data.weight = getSingleItemWeight(data);\n  tool.data.equipped = getEquipped(data);\n  tool.data.rarity = getItemRarity(data);\n  tool.data.identified = true;\n  tool.data.uses = getUses(data);\n\n  return tool;\n}\n","import utils from \"../../utils.js\";\nimport { getItemRarity, getEquipped, getConsumableUses, getSingleItemWeight, getQuantity } from \"./common.js\";\n\nfunction getItemType(data) {\n  let result = {\n    type: \"loot\"\n  };\n\n  const foundryTypes = [\"weapon\", \"equipment\", \"consumable\", \"tool\", \"loot\", \"class\", \"spell\", \"feat\", \"backpack\"];\n\n  const itemTypes =\n    data.definition.tags && Array.isArray(data.definition.tags)\n      ? [data.definition.type.toLowerCase(), ...data.definition.tags.map((t) => t.toLowerCase())]\n      : [data.definition.type.toLowerCase()];\n\n  let itemType = itemTypes\n    .map((itemType) => {\n      if (itemType === \"container\") return \"backpack\";\n      if (itemType === \"consumable\") return \"consumable\";\n      return foundryTypes.find((t) => t.indexOf(itemType) !== -1 || itemType.indexOf(t) !== -1);\n    })\n    .reduce(\n      (itemType, currentType) => (currentType !== undefined && itemType === undefined ? currentType : itemType),\n      undefined\n    );\n\n  if (!itemType) {\n    const isConsumable =\n      data.definition.type === \"Gear\" &&\n      data.definition.subType === \"Adventuring Gear\" &&\n      data.definition.tags.includes('Utility') &&\n      ((data.definition.tags.includes('Damage') &&\n      data.definition.tags.includes('Combat')) ||\n      data.definition.tags.includes('Healing'));\n    if (isConsumable) itemType = \"consumable\";\n  }\n\n  if (itemType) {\n    result.type = itemType;\n    if (itemType === \"consumable\") {\n      if (data.definition.name.includes('vial') || data.definition.name.includes('flask')) {\n        result.consumableType = \"potion\";\n      } else {\n        result.consumableType = \"trinket\";\n      }\n    }\n  }\n\n  return result;\n}\n\nexport default function parseLoot(data, itemType) {\n  const type = getItemType(data);\n\n  let loot = {\n    name: data.definition.name,\n    type: type.type,\n    data: JSON.parse(utils.getTemplate(\"loot\")), // was: tool\n    flags: {\n      ddbimporter: {\n        dndbeyond: {\n          type: itemType,\n        },\n      },\n    },\n  };\n\n  if (type.consumableType) {\n    loot.data.consumableType = type.consumableType;\n    loot.data.uses = getConsumableUses(data);\n  }\n\n  loot.data.description = {\n    value: data.definition.description,\n    chat: data.definition.snippet ? data.definition.snippet : data.definition.description,\n    unidentified: data.definition.type,\n  };\n\n  loot.data.source = utils.parseSource(data.definition);\n  loot.data.quantity = getQuantity(data);\n  loot.data.weight = getSingleItemWeight(data);\n  loot.data.equipped = getEquipped(data);\n  loot.data.rarity = getItemRarity(data);\n  loot.data.identified = true;\n\n  return loot;\n}\n","import utils from \"../../utils.js\";\nimport { getItemRarity, getEquipped, getSingleItemWeight, getQuantity } from \"./common.js\";\n\nexport default function parseCustomItem(data) {\n  let customItem = {\n    name: data.definition.name,\n    type: \"loot\",\n    data: JSON.parse(utils.getTemplate(\"loot\")),\n    flags: {\n      ddbimporter: {\n        id: data.id,\n        custom: true,\n        dndbeyond: {\n          type: \"Custom Item\",\n        },\n      },\n    },\n  };\n\n  let description = data.definition.description && data.definition.description !== \"null\"\n    ? data.definition.description\n    : \"\";\n  description = data.definition.notes\n    ? description + `<p><blockquote>${data.definition.notes}</blockquote></p>`\n    : description;\n\n  customItem.data.description = {\n    value: description,\n    chat: description,\n    unidentified: description,\n  };\n\n  customItem.data.source = \"Custom item\";\n  customItem.data.quantity = getQuantity(data);\n  customItem.data.weight = getSingleItemWeight(data);\n  customItem.data.price = data.definition.cost ? data.definition.cost : 0;\n  customItem.data.equipped = getEquipped(data);\n  customItem.data.identified = true;\n  customItem.data.rarity = getItemRarity(data);\n\n  return customItem;\n}\n","//\n// Attempts to parse information from ddb about items to build a magicitems\n// compatible set of metadata.\n//\n// https://gitlab.com/riccisi/foundryvtt-magic-items/\n//\n// Wand of Entangle Target example\n//\n// flags\": {\n// \"magicitems\": {\n//       \"enabled\": true,\n//       \"charges\": \"7\",\n//       \"chargeType\": \"c1\",\n//       \"destroy\": true,\n//       \"destroyCheck\": \"d1\",\n//       \"rechargeable\": true,\n//       \"recharge\": \"1d6+1\",\n//       \"rechargeType\": \"t2\",\n//       \"rechargeUnit\": \"r2\",\n//       \"spells\": {\n//           \"0\": {\n//               \"id\": \"af8QUpphSZMoi2yb\",\n//               \"name\": \"Entangle\",\n//               \"pack\": \"world.spellsdndbeyond\",\n//               \"img\": \"iconizer/Spell_Nature_StrangleVines.png\",\n//               \"baseLevel\": \"1\",\n//               \"level\": \"1\",\n//               \"consumption\": \"1\",\n//               \"upcast\": \"1\",\n//               \"upcastCost\": \"1\"\n//           }\n//       }\n// \"feats\": {},\n// \"tables\": {},\n// \"equipped\": true,\n// \"attuned\": true,\n// \"destroyFlavorText\": \"reaches 0 charges: it crumbles into ashes and is destroyed.\",\n// \"sorting\": \"l\"\n\n// }\n//\n//\n//\nimport DICTIONARY from \"../../dictionary.js\";\nimport utils from \"../../utils.js\";\n\nconst MAGICITEMS = {};\nMAGICITEMS.DAILY = \"r1\";\nMAGICITEMS.SHORT_REST = \"r4\";\nMAGICITEMS.LONG_REST = \"r5\";\nMAGICITEMS.CHARGE_TYPE_WHOLE_ITEM = \"c1\";\nMAGICITEMS.CHARGE_TYPE_PER_SPELL = \"c2\";\nMAGICITEMS.NUMERIC_RECHARGE = \"t1\";\nMAGICITEMS.FORMULA_RECHARGE = \"t2\";\nMAGICITEMS.DestroyCheckAlways = \"d1\";\nMAGICITEMS.DestroyCheck1D20 = \"d2\";\n\nfunction getRechargeFormula(description, maxCharges) {\n  if (description === \"\") {\n    return maxCharges;\n  }\n\n  let chargeMatchFormula = /regains (\\dd\\d* \\+ \\d) expended charges/i;\n  let chargeMatchFixed = /regains (\\d*) /i;\n  let chargeMatchLastDitch = /(\\dd\\d* \\+ \\d)/i;\n  let chargeNextDawn = /can't be used this way again until the next/i;\n\n  let matchFormula = chargeMatchFormula.exec(description);\n  let matchFixed = chargeMatchFixed.exec(description);\n  let matchLastDitch = chargeMatchLastDitch.exec(description);\n\n  let match = maxCharges;\n  if (matchFormula && matchFormula[1]) {\n    match = matchFormula[1];\n  } else if (matchFixed && matchFixed[1]) {\n    match = matchFixed[1];\n  } else if (matchLastDitch && matchLastDitch[1]) {\n    match = matchLastDitch[1];\n  } else if (description.search(chargeNextDawn) !== -1) {\n    match = maxCharges;\n  }\n\n  return match;\n}\n\nfunction getPerSpell(useDescription, itemDescription) {\n  if (useDescription === \"\") {\n    // some times 1 use per day items, like circlet of blasting have nothing in\n    // the limited use description, fall back to this\n    let limitedUse = /can't be used this way again until the next/i;\n    if (itemDescription.search(limitedUse) !== -1) {\n      return 1;\n    }\n    return false;\n  }\n\n  let perSpell = /each ([A-z]*|\\n*) per/i;\n  let match = perSpell.exec(useDescription);\n  if (match) {\n    match = DICTIONARY.magicitems.nums.find((num) => num.id == match[1]).value;\n  } else {\n    match = false;\n  }\n  return match;\n}\n\nfunction checkDestroy(description) {\n  let destroy = /expend the .* last charge/i;\n  if (description.search(destroy) !== -1) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction checkD20Destroy(description) {\n  let destroy = /roll a d20.*destroyed/i;\n  if (description.search(destroy) !== -1) {\n    return MAGICITEMS.DestroyCheck1D20;\n  } else {\n    return MAGICITEMS.DestroyCheckAlways;\n  }\n}\n\n// returns the default magicitem flags\nfunction buildMagicItemSpell(chargeType, itemSpell) {\n  let consumption = chargeType == MAGICITEMS.CHARGE_TYPE_PER_SPELL ? 1 : itemSpell.data.level;\n  let castLevel = itemSpell.data.level;\n  let upcast = itemSpell.data.level;\n\n  // Do we have charge use data on spell?\n  if (itemSpell.flags.ddbimporter.dndbeyond.spellLimitedUse) {\n    const limitedUse = itemSpell.flags.ddbimporter.dndbeyond.spellLimitedUse;\n\n    if (\n      chargeType == MAGICITEMS.CHARGE_TYPE_WHOLE_ITEM &&\n      !!limitedUse.minNumberConsumed &&\n      itemSpell.data.level !== 0\n    ) {\n      consumption = limitedUse.minNumberConsumed;\n      if (limitedUse.maxNumberConsumed) {\n        upcast = itemSpell.data.level - limitedUse.minNumberConsumed + limitedUse.maxNumberConsumed;\n      }\n    }\n\n    if (itemSpell.flags.ddbimporter.dndbeyond.castAtLevel) {\n      castLevel = itemSpell.flags.ddbimporter.dndbeyond.castAtLevel;\n    }\n  }\n  const spellName = hasProperty(itemSpell, \"flags.ddbimporter.originalName\")\n    ? itemSpell.flags.ddbimporter.originalName\n    : itemSpell.name;\n\n  return {\n    id: \"\",\n    name: spellName,\n    img: \"\",\n    pack: \"\",\n    baseLevel: itemSpell.data.level,\n    level: castLevel,\n    consumption: consumption,\n    upcast: upcast,\n    upcastCost: 1,\n  };\n}\n\nfunction getItemSpells(itemId, chargeType, itemSpells) {\n  let spells = {};\n\n  for (let spellIndex = 0, i = 0; i < itemSpells.length; i++) {\n    if (itemSpells[i].flags.ddbimporter.dndbeyond.lookupId === itemId) {\n      spells[spellIndex] = buildMagicItemSpell(chargeType, itemSpells[i]);\n      spellIndex++;\n    }\n  }\n\n  return spells;\n}\n\nfunction createDefaultItem() {\n  return {\n    enabled: true,\n    charges: 0,\n    chargeType: MAGICITEMS.CHARGE_TYPE_WHOLE_ITEM, // c1 charge whole item, c2 charge per spells\n    rechargeable: false,\n    recharge: 0, // recharge amount/formula\n    rechargeType: MAGICITEMS.FORMULA_RECHARGE, // t1 fixed amount, t2 formula\n    rechargeUnit: \"\", // r1 daily, r2 dawn, r3 sunset, r4vshort rest, r5 long rest\n    destroy: false, // destroy on depleted?\n    destroyCheck: MAGICITEMS.DestroyCheckAlways, // d1 always, 1d20\n    spells: {},\n    feats: {},\n    tables: {},\n    equipped: true,\n    attuned: false,\n    destroyFlavorText: (utils.isModuleInstalledAndActive(\"magicitems\"))\n      ? game.i18n.localize(\"MAGICITEMS.MagicItemDestroy\")\n      : \"reaches 0 charges: it crumbles into ashes and is destroyed.\",\n    sorting: \"l\"\n  };\n}\n\nfunction capitalize(word) {\n  return word.charAt(0).toUpperCase() + word.slice(1);\n}\n\nfunction getResetType(description) {\n  let resetType = null;\n\n  const chargeMatchFormula = /expended charges (?:\\w) at (\\w)/i;\n  const usedAgainFormula = /(?:until|when) you (?:take|finish) a (short|long|short or long) rest/i;\n  const chargeNextDawnFormula = /can't be used this way again until the next (dawn|dusk)/i;\n\n  const chargeMatch = chargeMatchFormula.exec(description);\n  const untilMatch = usedAgainFormula.exec(description);\n  const dawnMatch = chargeNextDawnFormula.exec(description);\n\n  if (chargeMatch && chargeMatch[1]) {\n    resetType = capitalize(`${chargeMatch[1]}Rest`);\n  } else if (untilMatch && untilMatch[1]) {\n    switch (untilMatch[1]) {\n      case \"short or long\":\n        resetType = \"ShortRest\";\n        break;\n      default:\n        resetType = capitalize(`${untilMatch[1]}Rest`);\n    }\n  } else if (dawnMatch && dawnMatch[1]) {\n    resetType = capitalize(`${dawnMatch[1]}Rest`);\n  }\n\n  return resetType;\n}\n\nexport function parseMagicItem(data, itemSpells, characterItem = true) {\n  // this builds metadata for the magicitems module to use\n  // https://gitlab.com/riccisi/foundryvtt-magic-items/\n\n  if (data.definition.magic) {\n    // default magicitem data\n    let magicItem = createDefaultItem();\n    magicItem.equipped = data.definition.canEquip;\n\n    if (!characterItem) {\n      const maxUses = \"has (\\\\d*) charges\";\n      const maxUsesMatches = maxUses.exec(data.definition.description);\n      const limitedUse = {\n        maxUses: (maxUsesMatches && maxUsesMatches[1]) ? maxUsesMatches[1] : null,\n        numberUsed: 0,\n        resetType: getResetType(data.definition.description),\n        resetTypeDescription: data.definition.description,\n      };\n\n      if (limitedUse.maxUses || limitedUse.resetType) data.limitedUse = limitedUse;\n    }\n\n    if (data.limitedUse) {\n      // if the item is x per spell\n      let perSpell = getPerSpell(data.limitedUse.resetTypeDescription, data.definition.description);\n      if (perSpell) {\n        magicItem.charges = perSpell;\n        magicItem.recharge = perSpell;\n        magicItem.rechargeUnit = MAGICITEMS.DAILY;\n        magicItem.rechargeable = true;\n        magicItem.rechargeType = MAGICITEMS.NUMERIC_RECHARGE;\n        magicItem.chargeType = MAGICITEMS.CHARGE_TYPE_PER_SPELL;\n      } else {\n        magicItem.charges = data.limitedUse.maxUses;\n        magicItem.recharge = getRechargeFormula(data.limitedUse.resetTypeDescription, magicItem.charges);\n\n        if (data.limitedUse.resetType) {\n          magicItem.rechargeUnit = DICTIONARY.magicitems.rechargeUnits.find(\n            (reset) => reset.id == data.limitedUse.resetType\n          ).value;\n        }\n        magicItem.rechargeable = true;\n      }\n\n      magicItem.destroy = checkDestroy(data.limitedUse.resetTypeDescription);\n      magicItem.destroyCheck = checkD20Destroy(data.limitedUse.resetTypeDescription);\n    }\n\n    magicItem.spells = getItemSpells(data.definition.id, magicItem.chargeType, itemSpells);\n\n    return magicItem;\n  } else {\n    return {\n      enabled: false,\n    };\n  }\n}\n\n","// import DICTIONARY from \"../../dictionary.js\";\n// import logger from \"../../logger.js\";\n\nfunction prepItem(item) {\n  if (item.name.startsWith(\"Potion of\")) {\n    if (!item.data.duration) item.data.duration = { units: \"\", value: null };\n    if (!item.data.target) item.data.target = { value: null, width: null, units: \"\", type: \"creature\" };\n    if (!item.data.range) item.data.range = { value: null, long: null, units: \"\", type: \"touch\" };\n  }\n}\n\n/**\n * Some items we need to fix up or massage because they are modified\n * in interesting ways\n * @param {*} ddb\n * @param {*} items\n */\nexport function fixItems(items) {\n  items.forEach((item) => {\n    prepItem(item);\n    const name = item.flags.ddbimporter.originalName || item.name;\n    switch (name) {\n      case \"Potion of Healing\":\n        item.data.damage = { parts: [[\"2d4 + 2\", \"healing\"]], versatile: \"\", value: \"\" };\n        item.data.uses = { value: 1, max: 1, per: \"charges\", autoDestroy: true, autoUse: true };\n        item.data[\"duration\"][\"value\"] = 0;\n        item.data.actionType = \"heal\";\n        item.data[\"target\"][\"type\"] = \"creature\";\n        item.data[\"range\"][\"type\"] = \"touch\";\n        break;\n      case \"Potion of Healing (Greater)\":\n      case \"Potion of Greater Healing\":\n        item.data.damage = { parts: [[\"4d4 + 4\", \"healing\"]], versatile: \"\", value: \"\" };\n        item.data.uses = { value: 1, max: 1, per: \"charges\", autoDestroy: true, autoUse: true };\n        item.data[\"duration\"][\"value\"] = 0;\n        item.data.actionType = \"heal\";\n        item.data[\"target\"][\"type\"] = \"creature\";\n        item.data[\"range\"][\"type\"] = \"touch\";\n        item.flags[\"ddbimporter\"][\"dndbeyond\"][\"alternativeNames\"] = [\"Potion of Greater Healing\"];\n        break;\n      case \"Potion of Healing (Superior)\":\n      case \"Potion of Superior Healing\":\n        item.data.damage = { parts: [[\"8d4 + 8\", \"healing\"]], versatile: \"\", value: \"\" };\n        item.data.uses = { value: 1, max: 1, per: \"charges\", autoDestroy: true, autoUse: true };\n        item.data[\"duration\"][\"value\"] = 0;\n        item.data.actionType = \"heal\";\n        item.data[\"target\"][\"type\"] = \"creature\";\n        item.data[\"range\"][\"type\"] = \"touch\";\n        item.flags[\"ddbimporter\"][\"dndbeyond\"][\"alternativeNames\"] = [\n          \"Potion of Superior Healing\",\n          \"potion of superior healing\",\n        ];\n        break;\n      case \"Potion of Healing (Supreme)\":\n      case \"Potion of Supreme Healing\":\n        item.data.damage = { parts: [[\"10d4 + 20\", \"healing\"]], versatile: \"\", value: \"\" };\n        item.data.uses = { value: 1, max: 1, per: \"charges\", autoDestroy: true, autoUse: true };\n        item.data[\"duration\"][\"value\"] = 0;\n        item.data.actionType = \"heal\";\n        item.data[\"target\"][\"type\"] = \"creature\";\n        item.data[\"range\"][\"type\"] = \"touch\";\n        item.flags[\"ddbimporter\"][\"dndbeyond\"][\"alternativeNames\"] = [\"Potion of Supreme Healing\"];\n        break;\n      case \"Iron Bands of Binding\":\n        item.data.activation = { type: \"action\", cost: 1, condition: \"\" };\n        item.data.uses = { value: 1, max: \"1\", per: \"day\" };\n        item.data.range = { value: 60, long: null, units: \"ft\" };\n        item.data.ability = \"dex\";\n        item.data.actionType = \"rwak\";\n        item.data.save = { ability: \"str\", dc: 20, scaling: \"flat\" };\n        item.data.target = { value: 1, width: null, units: \"any\", type: \"creature\" };\n        break;\n      case \"Far Realm Shard\": {\n        item.data.activation.type = \"special\";\n        item.data.actionType = \"save\";\n        item.data.damage = { parts: [[\"3d6[psychic]\", \"psychic\"]], versatile: \"\", value: \"\" };\n        item.data.save = {\n          ability: \"cha\",\n          dc: null,\n          scaling: \"spell\",\n        };\n        break;\n      }\n      case \"Acid (vial)\": {\n        item.data.activation = { type: \"action\", cost: 1, condition: \"\" };\n        item.data.target = { value: 1, width: null, units: \"any\", type: \"creature\" };\n        item.data.range = { value: 20, long: null, units: \"ft\" };\n        item.data.ability = \"dex\";\n        item.data.actionType = \"rwak\";\n        item.data.chatFlavor = \"improvised weapon\";\n        item.data.damage = { parts: [[\"2d6[acid]\", \"acid\"]], versatile: \"\", value: \"\" };\n        break;\n      }\n      case \"Bead of Force\": {\n        item.data.activation = { type: \"action\", cost: 1, condition: \"\" };\n        item.data.target = { value: 10, width: null, units: \"ft\", type: \"radius\" };\n        item.data.range = { value: 60, long: null, units: \"ft\" };\n        item.data.ability = \"dex\";\n        item.data.duration = { units: \"minute\", value: 1 };\n        item.data.uses = { value: 1, max: \"1\", per: \"\" };\n        item.data.actionType = \"rwak\";\n        item.data.chatFlavor = \"improvised weapon\";\n        item.data.damage = { parts: [[\"5d4[force]\", \"force\"]], versatile: \"\", value: \"\" };\n        item.data.save = {\n          ability: \"dex\",\n          dc: 15,\n          scaling: \"flat\",\n        };\n        break;\n      }\n      case \"Alchemist's Fire (flask)\":\n      case \"Alchemist's Fire\": {\n        item.data.activation = { type: \"action\", cost: 1, condition: \"\" };\n        item.data.target = { value: 1, width: null, units: \"any\", type: \"creature\" };\n        item.data.range = { value: 20, long: null, units: \"ft\" };\n        item.data.ability = \"dex\";\n        item.data.actionType = \"rwak\";\n        item.data.chatFlavor = \"improvised weapon\";\n        item.data.damage = { parts: [[\"1d4[fire]\", \"fire\"]], versatile: \"\", value: \"\" };\n        item.data.save = {\n          ability: \"dex\",\n          dc: 10,\n          scaling: \"flat\",\n        };\n        break;\n      }\n      case \"Bomb\": {\n        item.type = \"consumable\";\n        item.data.activation = { type: \"action\", cost: 1, condition: \"\" };\n        item.data.target = { value: 5, width: null, units: \"ft\", type: \"radius\" };\n        item.data.range = { value: 60, long: null, units: \"ft\" };\n        item.data.ability = \"dex\";\n        item.data.actionType = \"rwak\";\n        item.data.chatFlavor = \"improvised weapon\";\n        item.data.damage = { parts: [[\"3d6[fire]\", \"fire\"]], versatile: \"\", value: \"\" };\n        item.data.save = {\n          ability: \"dex\",\n          dc: 12,\n          scaling: \"flat\",\n        };\n        break;\n      }\n      case \"Grenade, Fragmentation\": {\n        item.type = \"consumable\";\n        item.data.activation = { type: \"action\", cost: 1, condition: \"\" };\n        item.data.target = { value: 20, width: null, units: \"ft\", type: \"radius\" };\n        item.data.range = { value: 60, long: null, units: \"ft\" };\n        item.data.ability = \"dex\";\n        item.data.actionType = \"rwak\";\n        item.data.chatFlavor = \"improvised weapon\";\n        item.data.damage = { parts: [[\"5d6[piercing]\", \"piercing\"]], versatile: \"\", value: \"\" };\n        item.data.save = {\n          ability: \"dex\",\n          dc: 15,\n          scaling: \"flat\",\n        };\n        break;\n      }\n      // no default\n    }\n  });\n}\n","import utils from \"../../utils.js\";\nimport logger from \"../../logger.js\";\n\nimport { generateEffects } from \"../../effects/effects.js\";\n\n// function isInfused(ddb, item) {\n//   return ddb.infusions.item.some((mapping) =>\n//     mapping.itemId === item.flags.ddbimporter.definitionId &&\n//     mapping.inventoryMappingId === item.flags.ddbimporter.id &&\n//     mapping.itemTypeId === item.flags.ddbimporter.definitionEntityTypeId\n//   );\n// }\n\n// function getInfusionId(item, infusionMap) {\n//   const infusionInMap = infusionMap.find((mapping) =>\n//     mapping.itemId === item.flags.ddbimporter.definitionId &&\n//     mapping.inventoryMappingId === item.flags.ddbimporter.id &&\n//     mapping.itemTypeId === item.flags.ddbimporter.definitionEntityTypeId\n//   );\n\n//   if (infusionInMap) {\n//     return infusionInMap.definitionKey.replace(\"infusion:\", \"\");\n//   } else {\n//     return undefined;\n//   }\n// }\n\n\nfunction getInfusionItemMap(ddb, item) {\n  if (!ddb.infusions?.item) return undefined;\n  return ddb.infusions.item.find((mapping) =>\n    mapping.itemId === item.flags.ddbimporter.definitionId &&\n    mapping.inventoryMappingId === item.flags.ddbimporter.id &&\n    mapping.itemTypeId === item.flags.ddbimporter.definitionEntityTypeId\n  );\n}\n\nfunction getInfusionDetail(ddb, definitionKey) {\n  if (!ddb.infusions?.infusions?.definitionData) return undefined;\n  return ddb.infusions.infusions.definitionData.find(\n    (infusion) => infusion.definitionKey === definitionKey\n  );\n}\n\n\nfunction getInfusionModifiers(infusionItemMap, infusionDetail) {\n  let modifiers = [];\n\n  switch (infusionDetail.modifierDataType) {\n    case \"class-level\":\n    case \"damage-type-choice\": {\n      const damageMods = infusionDetail.modifierData.find(\n        (data) => data.id === infusionItemMap.modifierGroupId\n      );\n      if (damageMods) modifiers = damageMods.modifiers;\n      break;\n    }\n    case \"granted\":\n    default: {\n      modifiers = infusionDetail.modifierData.map((data) => data.modifiers).flat();\n    }\n  }\n\n  // logger.debug(`${infusionDetail.name} ${infusionDetail.modifierDataType}`, modifiers);\n\n  return modifiers;\n}\n\nfunction addMagicBonus(character, item, modifiers) {\n  const filteredModifiers = utils.filterModifiers(modifiers, \"bonus\", \"magic\");\n  const magicBonus = utils.getModifierSum(filteredModifiers, character);\n\n  if (magicBonus && magicBonus !== 0 && magicBonus !== \"\") {\n    item.data.damage.parts[0][0] += ` + ${magicBonus}`;\n    item.data.attackBonus += magicBonus;\n    setProperty(item, \"data.properties.mgc\", true);\n    // to do add infusion description to item\n  }\n  return item;\n}\n\nexport function getInfusionActionData(ddb) {\n  if (!ddb.infusions?.item) return [];\n  const generatedInfusionMap = ddb.infusions.item.map((mapping) => {\n    return getInfusionDetail(ddb, mapping.definitionKey);\n  });\n\n  const infusionActions = generatedInfusionMap\n    .filter((infusionDetail) => infusionDetail.type === \"augment\" && infusionDetail.actions.length > 0)\n    .map((infusionDetail) => {\n      const actions = infusionDetail.actions.map((action) => {\n        const itemLookup = ddb.infusions.item.find((mapping) => mapping.definitionKey === infusionDetail.definitionKey);\n        if (!action.name) {\n          const itemLookup = ddb.infusions.item.find((mapping) => mapping.definitionKey === infusionDetail.definitionKey);\n          const item = ddb.character.inventory.find((item) => item.id === itemLookup.inventoryMappingId);\n          const itemName = item?.definition?.name ? `${item.definition.name} : ` : ``;\n          action.name = `${itemName}[Infusion] ${infusionDetail.name}`;\n        }\n        action.infusionFlags = {\n          maps: [JSON.parse(JSON.stringify(itemLookup))],\n          applied: [JSON.parse(JSON.stringify(infusionDetail))],\n          infused: true,\n        };\n        return action;\n      });\n      return actions;\n    })\n    .flat();\n\n  logger.debug(`Infusions Actions Map`, generatedInfusionMap);\n  logger.debug(`Generated Infusions Actions`, infusionActions);\n  return infusionActions;\n}\n\nexport function parseInfusion(ddb, character, foundryItem, ddbItem, compendiumItem) {\n  // get item mapping\n  const infusionItemMap = getInfusionItemMap(ddb, foundryItem);\n  foundryItem.flags.infusions = { maps: [], applied: [], infused: false };\n  if (infusionItemMap) {\n    logger.debug(`Infusion detected for ${foundryItem.name}`);\n    // console.warn(ddb);\n    // console.warn(ddbItem);\n    // console.warn(foundryItem);\n    const infusionDetail = getInfusionDetail(ddb, infusionItemMap.definitionKey);\n\n    // get modifiers && generate effects\n    const ddbInfusionItem = JSON.parse(JSON.stringify(ddbItem));\n    ddbInfusionItem.definition.grantedModifiers = getInfusionModifiers(infusionItemMap, infusionDetail);\n\n    foundryItem = generateEffects(ddb, character, ddbInfusionItem, foundryItem, compendiumItem, \"infusion\");\n    // magic bonuses can't be added as effects as it's real hard to pin to one item\n    foundryItem = addMagicBonus(character, foundryItem, ddbInfusionItem.definition.grantedModifiers);\n\n    // add infusion flags\n    foundryItem.flags.infusions.infused = true;\n    foundryItem.flags.infusions.applied.push(infusionDetail);\n    foundryItem.flags.infusions.maps.push(infusionItemMap);\n\n    // set magic properties\n    setProperty(foundryItem, \"data.properties.mgc\", true);\n\n    // Update Item description\n    foundryItem.data.description.value += `<div class=\"infusion-description\"><p><b>Infusion: ${infusionDetail.name}</b></p><p>${infusionDetail.description}</p></div>`;\n    foundryItem.data.description.chat += `<div class=\"infusion-description\"><p><b>Infusion: ${infusionDetail.name}</b></p><p>${infusionDetail.snippet ? infusionDetail.snippet : infusionDetail.description}</p></div>`;\n\n    // adjust name for infused item\n    foundryItem.name += \" [Infusion]\";\n    // if item is loot, lets move it to equipment/trinket so effects will apply\n    if (foundryItem.type === \"loot\") {\n      foundryItem.type = \"equipment\";\n      foundryItem.data.armor = {\n        type: \"trinket\",\n        value: 10,\n        dex: null,\n      };\n      // infusions will over ride the can equip status, so just check for equipped\n      foundryItem.data.equipped = ddbItem.equipped;\n    }\n\n    // check to see if we need to fiddle attack modifiers on infused weapons\n    if (foundryItem.type === \"weapon\") {\n      const intSwap = utils.filterBaseModifiers(ddb, \"bonus\", \"magic-item-attack-with-intelligence\").length > 0;\n      if (intSwap) {\n        const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;\n        const mockAbility = foundryItem.data.ability === null\n          ? foundryItem.data.properties.fin ? \"dex\" : \"str\"\n          : foundryItem.data.ability;\n        if (characterAbilities.int.value > characterAbilities[mockAbility].value) {\n          foundryItem.data.ability = \"int\";\n        }\n      }\n    }\n  }\n  return foundryItem;\n\n}\n","import DICTIONARY from \"../../dictionary.js\";\n// type: weapon\nimport parseWeapon from \"./weapon.js\";\nimport parseAmmunition from \"./ammunition.js\";\nimport parseStaff from \"./staves.js\";\n\n// type: armor\nimport parseArmor from \"./armor.js\";\n\n// tyoe: wonderous item\nimport parseWonderous from \"./wonderous.js\";\n\n// type: consumables\nimport parsePotion from \"./potion.js\";\nimport parseScroll from \"./scroll.js\";\n\n// type: tool\nimport parseTool from \"./tool.js\";\n\n// other loot\nimport parseLoot from \"./loot.js\";\nimport parseCustomItem from \"./custom.js\";\nimport utils from \"../../utils.js\";\n\n// magicitems support\nimport { parseMagicItem } from \"./magicify.js\";\nimport { getAttunement, getBaseItem } from \"./common.js\";\nimport logger from \"../../logger.js\";\n\nimport { fixItems } from \"./special.js\";\n\n// effects support\nimport { generateEffects } from \"../../effects/effects.js\";\nimport { generateBaseACItemEffect } from \"../../effects/acEffects.js\";\nimport { parseInfusion } from \"./infusions.js\";\n\n// tables\nimport { generateTable } from \"../../muncher/table.js\";\n\n/**\n * We get extra damage to a weapon attack here, for example Improved\n * Divine Smite\n * @param {*} data\n * @param {*} restrictions (array)\n */\nfunction getExtraDamage(ddb, restrictions) {\n  return utils.filterBaseModifiers(ddb, \"damage\", null, restrictions).map((mod) => {\n    if (mod.dice) {\n      return [mod.dice.diceString, mod.subType];\n    } else if (mod.value) {\n      return [mod.value, mod.subType];\n    } else {\n      return [null, null];\n    }\n  });\n}\n\nfunction isMartialArtists(classes) {\n  return classes.some((cls) => cls.classFeatures.some((feature) => feature.definition.name === \"Martial Arts\"));\n}\n\nfunction getWarlockFeatures(ddb, weapon) {\n  // Some features, notably hexblade abilities we scrape out here\n  const warlockFeatures = ddb.character.characterValues\n    .filter(\n      (characterValue) =>\n        characterValue.value &&\n        characterValue.valueId == weapon.id &&\n        DICTIONARY.character.characterValuesLookup.some(\n          (entry) => entry.typeId == characterValue.typeId\n        )\n    )\n    .map(\n      (characterValue) =>\n        DICTIONARY.character.characterValuesLookup.find(\n          (entry) => entry.typeId == characterValue.typeId\n        ).name\n    );\n\n  // Any Pact Weapon Features\n  const pactFeatures = ddb.character.options.class\n    .filter(\n      (option) =>\n        warlockFeatures.includes(\"pactWeapon\") &&\n        option.definition.name &&\n        DICTIONARY.character.pactFeatures.includes(option.definition.name)\n    )\n    .map((option) => option.definition.name);\n\n  const features = warlockFeatures.concat(pactFeatures);\n  return features;\n}\n\nfunction getMonkFeatures(ddb, weapon) {\n  const kenseiWeapon = utils.getChosenClassModifiers(ddb).some((mod) =>\n    mod.friendlySubtypeName === weapon.definition.type &&\n    mod.type === \"kensei\"\n  );\n\n  const monkWeapon = utils.getChosenClassModifiers(ddb).some((mod) =>\n    mod.friendlySubtypeName === weapon.definition.type &&\n    mod.type == \"monk-weapon\"\n  ) || (weapon.definition.isMonkWeapon && isMartialArtists(ddb.character.classes));\n\n  let features = [];\n\n  if (kenseiWeapon) features.push(\"kenseiWeapon\");\n  if (monkWeapon) features.push(\"monkWeapon\");\n\n  return features;\n}\n\n\nfunction getMartialArtsDie(ddb) {\n  let result = {\n    diceCount: null,\n    diceMultiplier: null,\n    diceString: null,\n    diceValue: null,\n    fixedValue: null,\n  };\n\n  const die = ddb.character.classes\n    // is a martial artist\n    .filter((cls) => cls.classFeatures.some((feature) => feature.definition.name === \"Martial Arts\"))\n    // get class features\n    .map((cls) => cls.classFeatures)\n    .flat()\n    // filter relevant features, those that are martial arts and have a levelscaling hd\n    .filter((feature) => feature.definition.name === \"Martial Arts\" && feature.levelScale && feature.levelScale.dice)\n    // get this dice object\n    .map((feature) => feature.levelScale.dice);\n\n  if (die && die.length > 0) {\n    result = die[0];\n  }\n\n  return result;\n\n}\n\nfunction getClassFeatures(ddb, weapon) {\n  const warlockFeatures = getWarlockFeatures(ddb, weapon);\n  const monkFeatures = getMonkFeatures(ddb, weapon);\n  return warlockFeatures.concat(monkFeatures);\n}\n\nfunction getItemFlags(ddb, data, character) {\n  let flags = {\n    damage: {\n      parts: [],\n    },\n    // Some features, notably hexblade abilities we scrape out here\n    classFeatures: getClassFeatures(ddb, data),\n    martialArtsDie: getMartialArtsDie(ddb),\n    maxMediumArmorDex: Math.max(...utils.filterBaseModifiers(ddb, \"set\", \"ac-max-dex-armored-modifier\").map((mod) => mod.value), 2),\n    magicItemAttackInt: utils.filterBaseModifiers(ddb, \"bonus\", \"magic-item-attack-with-intelligence\").length > 0,\n  };\n\n  if (flags.classFeatures.includes(\"Lifedrinker\")) {\n    flags.damage.parts.push([\"@mod\", \"necrotic\"]);\n  }\n  // const addItemEffects = game.settings.get(\"ddb-importer\", \"character-update-policy-add-item-effects\");\n  const addCharacterEffects = game.settings.get(\"ddb-importer\", \"character-update-policy-add-character-effects\");\n\n  // for melee attacks get extras\n  if (data.definition.attackType === 1) {\n    // get improved divine smite etc for melee attacks\n    const extraDamage = getExtraDamage(ddb, [\"Melee Weapon Attacks\"]);\n\n    if (!!extraDamage.length > 0) {\n      flags.damage.parts = flags.damage.parts.concat(extraDamage);\n    }\n    // do we have great weapon fighting?\n    if (utils.hasChosenCharacterOption(ddb, \"Great Weapon Fighting\")) {\n      flags.classFeatures.push(\"greatWeaponFighting\");\n    }\n    // do we have dueling fighting style?\n    if (utils.hasChosenCharacterOption(ddb, \"Dueling\") && !addCharacterEffects) {\n      flags.classFeatures.push(\"Dueling\");\n    }\n    // do we have dueling fighting style?\n    if (utils.hasChosenCharacterOption(ddb, \"Two-Weapon Fighting\")) {\n      flags.classFeatures.push(\"Two-Weapon Fighting\");\n    }\n    if (utils.getCustomValue(data, character, 18)) {\n      flags.classFeatures.push(\"OffHand\");\n    }\n  }\n  // ranged fighting style is added as a global modifier elsewhere\n  // as is defensive style\n\n  return flags;\n}\n\nfunction getItemFromGearTypeIdOne(ddb, data) {\n  let item = {};\n\n  switch (data.definition.subType) {\n    case \"Potion\":\n      item = parsePotion(data, data.definition.subType);\n      break;\n    case \"Tool\":\n      item = parseTool(ddb, data, data.definition.subType);\n      break;\n    case \"Ammunition\":\n      item = parseAmmunition(data, data.definition.subType);\n      break;\n    default:\n      item = parseLoot(data, data.definition.subType);\n  }\n  return item;\n}\n\nfunction otherGear(ddb, data) {\n  let item = {};\n\n  switch (data.definition.gearTypeId) {\n    case 1:\n      item = getItemFromGearTypeIdOne(ddb, data);\n      break;\n    case 4:\n      item = parseLoot(data, \"Mount\");\n      break;\n    case 5:\n      item = parsePotion(data, \"Poison\");\n      break;\n    case 6:\n      item = parsePotion(data, \"Potion\");\n      break;\n    case 11:\n      item = parseTool(ddb, data, \"Tool\");\n      break;\n    case 12:\n    case 17:\n      item = parseLoot(data, \"Vehicle\");\n      break;\n    case 16:\n      item = parseLoot(data, \"Equipment Pack\");\n      break;\n    case 18:\n      // Change to parseGemstone (consummable) ?\n      item = parseLoot(data, \"Gemstone\");\n      break;\n    default:\n      logger.warn(\"Other Gear type missing from \" + data.definition.name);\n  }\n  return item;\n}\n\nfunction addCustomValues(ddbItem, foundryItem, character) {\n  // to hit override requires a lot of crunching\n  // const toHitOverride = utils.getCustomValue(item, character, 13);\n  const toHitBonus = utils.getCustomValue(ddbItem, character, 12);\n  const damageBonus = utils.getCustomValue(ddbItem, character, 10);\n  // const displayAsAttack = utils.getCustomValue(item, character, 16);\n  const costOverride = utils.getCustomValue(ddbItem, character, 19);\n  const weightOverride = utils.getCustomValue(ddbItem, character, 22);\n  // dual wield 18\n  // silvered\n  const silvered = utils.getCustomValue(ddbItem, character, 20);\n  // adamantine\n  const adamantine = utils.getCustomValue(ddbItem, character, 21);\n  // off-hand\n  // const offHand = utils.getCustomValue(ddbItem, character, 18);\n\n  if (toHitBonus) foundryItem.data.attackBonus += toHitBonus;\n  if (damageBonus && foundryItem.data?.damage?.parts && foundryItem.data?.damage?.parts.length !== 0) {\n    foundryItem.data.damage.parts[0][0] = foundryItem.data.damage.parts[0][0].concat(` +${damageBonus}`);\n  } else if (damageBonus && foundryItem.data?.damage?.parts) {\n    const part = [`+${damageBonus}`, \"\"];\n    foundryItem.data.damage.parts.push(part);\n  }\n  if (costOverride) foundryItem.data.cost = costOverride;\n  if (weightOverride) foundryItem.data.weight = weightOverride;\n  if (silvered) foundryItem.data.properties['sil'] = true;\n  if (adamantine) foundryItem.data.properties['ada'] = true;\n}\n\nfunction addExtraDDBFlags(data, item) {\n  item.flags.ddbimporter['id'] = data.id;\n  item.flags.ddbimporter['entityTypeId'] = data.entityTypeId;\n\n  if (data.definition.avatarUrl) item.flags.ddbimporter.dndbeyond['avatarUrl'] = data.definition.avatarUrl.split('?')[0];\n  if (data.definition.largeAvatarUrl) item.flags.ddbimporter.dndbeyond['largeAvatarUrl'] = data.definition.largeAvatarUrl.split('?')[0];\n  if (data.definition.filterType) {\n    const filter = DICTIONARY.items.find((i) => i.filterType === data.definition.filterType);\n    if (filter) item.flags.ddbimporter.dndbeyond['filterType'] = filter.filterType;\n  }\n\n  // container info\n  if (data.containerEntityId) item.flags.ddbimporter['containerEntityId'] = data.containerEntityId;\n  if (data.containerEntityTypeId) item.flags.ddbimporter['containerEntityTypeId'] = data.containerEntityTypeId;\n  return item;\n}\n\n// the filter type \"Other Gear\" represents the equipment while the other filters represents the magic items in ddb\nfunction parseItem(ddb, data, character, flags) {\n  try {\n    // is it a weapon?\n    let item = {};\n    if (data.definition.filterType) {\n      switch (data.definition.filterType) {\n        case \"Weapon\": {\n          if (data.definition.type === \"Ammunition\" || data.definition.subType === \"Ammunition\") {\n            item = parseAmmunition(data, \"Ammunition\");\n          } else {\n            item = parseWeapon(data, character, flags);\n          }\n          break;\n        }\n        case \"Armor\":\n          item = parseArmor(data, character, flags);\n          break;\n        case \"Wondrous item\":\n        case \"Ring\":\n        case \"Wand\":\n        case \"Rod\":\n          item = parseWonderous(data);\n          break;\n        case \"Staff\":\n          item = parseStaff(data, character);\n          break;\n        case \"Potion\":\n          item = parsePotion(data, data.definition.type);\n          break;\n        case \"Scroll\":\n          item = parseScroll(data);\n          break;\n        case \"Other Gear\":\n          item = otherGear(ddb, data);\n          break;\n        default:\n          logger.warn(\"Item filterType not implemented for \" + data.definition.name);\n          break;\n      }\n    } else {\n      // try parsing it as a custom item\n      item = parseCustomItem(data);\n    }\n    item.data.baseItem = getBaseItem(data);\n    item.data.attunement = getAttunement(data);\n    if (data.definition.cost) item.data.price = data.definition.cost;\n\n    item = addExtraDDBFlags(data, item);\n\n    return item;\n  } catch (err) {\n    logger.warn(\n      `Unable to parse item: ${data.definition.name}, ${data.definition.type}/${data.definition.filterType}. ${err.message}`,\n      \"character\"\n    );\n    logger.error(err.stack);\n    return { // return empty strut\n      name: data.definition.name,\n      flags: {\n        ddbimporter: {\n          dndbeyond: {\n          },\n        },\n      },\n    };\n  }\n}\n\nfunction enrichFlags(data, item) {\n  if (data.definition.magic) {\n    setProperty(item, \"data.properties.mgc\", true);\n  }\n  if (utils.isModuleInstalledAndActive(\"betterrolls5e\")) {\n    if (item.data.uses?.max && !item.flags?.betterRolls5e) {\n      item.flags['betterRolls5e'] = {\n        quickCharges: {\n          value: {\n            use: true,\n            resource: true\n          },\n          altValue: {\n            use: true,\n            resource: true\n          }\n        },\n      };\n    }\n  }\n  if (data.definition?.entityTypeId) item.flags.ddbimporter['definitionEntityTypeId'] = data.definition.entityTypeId;\n  if (data.definition?.id) item.flags.ddbimporter['definitionId'] = data.definition.id;\n  if (data.entityTypeId) item.flags.ddbimporter['entityTypeId'] = data.entityTypeId;\n  if (data.id) item.flags.ddbimporter['id'] = data.id;\n  if (data.definition?.tags) item.flags.ddbimporter.dndbeyond['tags'] = data.definition.tags;\n  if (data.definition?.sources) item.flags.ddbimporter.dndbeyond['sources'] = data.definition.sources;\n  if (data.definition?.stackable) item.flags.ddbimporter.dndbeyond['stackable'] = data.definition.stackable;\n}\n\nexport default function getInventory(ddb, character, itemSpells) {\n  let items = [];\n  // first, check custom name, price or weight\n  ddb.character.characterValues.forEach((cv) => {\n    // try to find a matching item based on the characterValues (an array of custom adjustements to different parts of the character)\n    let item = ddb.character.inventory.find((item) => item.id === cv.valueId);\n    if (item) {\n      // check if this property is in the list of supported ones, based on our DICT\n      let property = DICTIONARY.item.characterValues.find((entry) => entry.typeId === cv.typeId);\n      // overwrite the name, weight or price with the custom value\n      if (property && cv.value.length !== 0) item.definition[property.value] = cv.value;\n    }\n  });\n\n  // now parse all items\n\n  const customItems = ddb.character.customItems\n    ? ddb.character.customItems.map((customItem) => ({\n      id: customItem.id,\n      definition: customItem,\n    }))\n    : [];\n\n  const daeInstalled = utils.isModuleInstalledAndActive(\"dae\");\n  const compendiumItem = character.flags.ddbimporter.compendium;\n  const addEffects = (compendiumItem)\n    ? game.settings.get(\"ddb-importer\", \"munching-policy-add-effects\")\n    : game.settings.get(\"ddb-importer\", \"character-update-policy-add-item-effects\");\n  const generateArmorACEffect = (compendiumItem)\n    ? game.settings.get(\"ddb-importer\", \"munching-policy-add-ac-armor-effects\")\n    : false;\n\n  for (let ddbItem of ddb.character.inventory.concat(customItems)) {\n    const originalName = ddbItem.definition.name;\n    ddbItem.definition.name = utils.getName(ddbItem, character);\n    const flags = getItemFlags(ddb, ddbItem, character);\n\n    const updateExisting = compendiumItem\n      ? game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\")\n      : false;\n    ddbItem.definition.description = generateTable(ddbItem.definition.name, ddbItem.definition.description, updateExisting);\n\n    let item = Object.assign({}, parseItem(ddb, ddbItem, character, flags));\n    addCustomValues(ddbItem, item, character);\n    enrichFlags(ddbItem, item);\n\n    if (item) {\n      item.flags.magicitems = parseMagicItem(ddbItem, itemSpells);\n      item.flags.ddbimporter.originalName = originalName;\n      item.flags.ddbimporter.version = CONFIG.DDBI.version;\n      if (!item.effects) item.effects = [];\n      if (!item.name || item.name === \"\") item.name = \"Item\";\n\n      if (daeInstalled && addEffects) item = generateEffects(ddb, character, ddbItem, item, compendiumItem, \"item\");\n      // if this is a piece of armor and not generating effects don't generate ac\n      if (item.type === \"equipment\" && item.data.armor?.type && ![\"trinket\", \"clothing\"].includes(item.data.armor.type)) {\n        if (daeInstalled && generateArmorACEffect) {\n          item = generateBaseACItemEffect(ddb, character, ddbItem, item, compendiumItem);\n        }\n      } else {\n        // always generate other item ac effects\n        item = generateBaseACItemEffect(ddb, character, ddbItem, item, compendiumItem);\n      }\n\n      if (!compendiumItem) item = parseInfusion(ddb, character, item, ddbItem, compendiumItem);\n      items.push(item);\n    }\n  }\n\n  fixItems(items);\n  return items;\n}\n","// Main module class\nimport { updateCompendium, srdFiddling, daeFiddling } from \"./import.js\";\nimport { munchNote, getCampaignId, download } from \"./utils.js\";\nimport getInventory from \"../parser/inventory/index.js\";\nimport utils from \"../utils.js\";\nimport { getCobalt } from \"../lib/Secrets.js\";\nimport logger from \"../logger.js\";\nimport { createCompendiumFolderStructure } from \"./compendiumFolders.js\";\n\nasync function getCharacterInventory(items) {\n  return items.map((item) => {\n    return {\n      chargesUsed: 0,\n      definitionId: 0,\n      definitionTypeId: 0,\n      displayAsAttack: null,\n      entityTypeId: 0,\n      equipped: false,\n      id: 0,\n      isAttuned: false,\n      quantity: item.bundleSize ? item.bundleSize : 1,\n      definition: item,\n    };\n  });\n}\n\nasync function generateImportItems(items) {\n  const mockCharacter = {\n    data: JSON.parse(utils.getTemplate(\"character\")),\n    type: \"character\",\n    name: \"\",\n    flags: {\n      ddbimporter: {\n        compendium: true,\n        dndbeyond: {\n          effectAbilities: [],\n          totalLevels: 0,\n          proficiencies: [],\n          proficienciesIncludingEffects: [],\n          characterValues: [],\n        },\n      },\n    },\n  };\n  const mockDDB = {\n    character: {\n      classes: [],\n      race: {\n        racialTraits: [],\n      },\n      characterValues: [],\n      inventory: items,\n      customItems: null,\n      options: {\n        class: [],\n        race: [],\n        feat: [],\n      },\n      modifiers: {\n        race: [],\n        class: [],\n        background: [],\n        feat: [],\n        item: [],\n        condition: [],\n      },\n      feats: [],\n    }\n  };\n  let itemSpells = []; // here we need to parse each available spell and build a mock spell parser\n  const inventory = getInventory(mockDDB, mockCharacter, itemSpells);\n  const results = {\n    items: inventory,\n    itemSpellNames: itemSpells, // this needs to be a list of spells to find\n  };\n  return results;\n}\n\nfunction getItemData(sourceFilter) {\n  const cobaltCookie = getCobalt();\n  const campaignId = getCampaignId();\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };\n  const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n  const enableSources = game.settings.get(\"ddb-importer\", \"munching-policy-use-source-filter\");\n  const sources = enableSources\n    ? game.settings.get(\"ddb-importer\", \"munching-policy-muncher-sources\").flat()\n    : [];\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/proxy/items`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body), // body data type must match \"Content-Type\" header\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (debugJson) {\n          download(JSON.stringify(data), `items-raw.json`, \"application/json\");\n        }\n        if (!data.success) {\n          munchNote(`Failure: ${data.message}`);\n          reject(data.message);\n        }\n        return data;\n      })\n      .then((data) => {\n        if (sources.length == 0 || !sourceFilter) return data.data;\n        return data.data.filter((item) =>\n          item.sources.some((source) => sources.includes(source.sourceId))\n        );\n      })\n      .then((data) => getCharacterInventory(data))\n      .then((items) => generateImportItems(items))\n      .then((data) => resolve(data))\n      .catch((error) => reject(error));\n  });\n}\n\nexport async function addMagicItemSpells(items, spells, updateBool) {\n  if (spells.length === 0) return;\n  const itemSpells = await updateCompendium(\"itemspells\", { itemspells: spells }, updateBool);\n  // scan the inventory for each item with spells and copy the imported data over\n  items.forEach((item) => {\n    if (item.flags.magicitems.spells) {\n      for (let [i, spell] of Object.entries(item.flags.magicitems.spells)) {\n        const itemSpell = itemSpells.find((item) => item.name === spell.name);\n        if (itemSpell) {\n          for (const [key, value] of Object.entries(itemSpell)) {\n            item.flags.magicitems.spells[i][key] = value;\n          }\n        }\n      }\n    }\n  });\n}\n\nexport async function parseItems(ids = null) {\n  const updateBool = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n  const magicItemsInstalled = !!game.modules.get(\"magicitems\");\n  const uploadDirectory = game.settings.get(\"ddb-importer\", \"other-image-upload-directory\").replace(/^\\/|\\/$/g, \"\");\n\n  // to speed up file checking we pregenerate existing files now.\n  logger.info(\"Checking for existing files...\");\n  await utils.generateCurrentFiles(uploadDirectory);\n  logger.info(\"Check complete, getting ItemData.\");\n\n  const addToCompendiumFolder = game.settings.get(\"ddb-importer\", \"munching-policy-use-compendium-folders\");\n  const compendiumFoldersInstalled = utils.isModuleInstalledAndActive(\"compendium-folders\");\n  if (addToCompendiumFolder && compendiumFoldersInstalled) {\n    munchNote(`Checking compendium folders..`, true);\n    await createCompendiumFolderStructure(\"items\");\n  }\n\n  munchNote(\"Downloading item data..\");\n\n  // disable source filter if ids provided\n  const sourceFilter = !(ids !== null && ids.length > 0);\n  const results = await getItemData(sourceFilter);\n  let items = results.items;\n\n  munchNote(\"Parsing item data..\");\n\n  // Items Spell addition is currently not done, parsing out spells needs to be addded\n  // let itemSpells = results.value.itemSpells;\n  let itemSpells = null;\n\n  // store all spells in the folder specific for Dynamic Items\n  if (magicItemsInstalled && itemSpells && Array.isArray(itemSpells)) {\n    await addMagicItemSpells(items, itemSpells, updateBool);\n  }\n\n  const srdItems = await srdFiddling(items, \"inventory\");\n  const filteredItems = (ids !== null && ids.length > 0)\n    ? srdItems.filter((s) => s.flags?.ddbimporter?.definitionId && ids.includes(String(s.flags.ddbimporter.definitionId)))\n    : srdItems;\n  const finalItems = await daeFiddling(filteredItems);\n\n  const finalCount = finalItems.length;\n  munchNote(`Importing ${finalCount} items!`, true);\n\n  return new Promise((resolve) => {\n    resolve(updateCompendium(\"inventory\", { inventory: finalItems }, updateBool));\n  });\n}\n\n\n","// Main module class\nimport { srdFiddling, getCompendiumItems, removeItems } from \"./import.js\";\nimport { munchNote, download } from \"./utils.js\";\nimport logger from \"../logger.js\";\nimport { addNPC, generateIconMap, copyExistingMonsterImages, checkMonsterCompendium } from \"./importMonster.js\";\nimport { parseMonsters } from \"./monster/monster.js\";\nimport utils from \"../utils.js\";\nimport { getCobalt } from \"../lib/Secrets.js\";\nimport { createCompendiumFolderStructure } from \"./compendiumFolders.js\";\nimport { resetEquipment } from \"./monster/ac.js\";\n\nasync function getMonsterData(ids) {\n  const cobaltCookie = getCobalt();\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n\n  const body = {\n    cobalt: cobaltCookie,\n    betaKey: betaKey,\n  };\n\n  if (ids && ids.length > 0) {\n    body.ids = [...new Set(ids)];\n  } else {\n    const searchTerm = $(\"#monster-munch-filter\")[0].value;\n    const enableSources = game.settings.get(\"ddb-importer\", \"munching-policy-use-source-filter\");\n    const sources = enableSources\n      ? game.settings.get(\"ddb-importer\", \"munching-policy-muncher-sources\").flat()\n      : [];\n    body.sources = sources;\n    body.search = $(\"#monster-munch-filter\")[0].value;\n    body.homebrew = body.sources.length > 0 ? false : game.settings.get(\"ddb-importer\", \"munching-policy-monster-homebrew\");\n    body.homebrewOnly = body.sources.length > 0 ? false : game.settings.get(\"ddb-importer\", \"munching-policy-monster-homebrew-only\");\n    body.searchTerm = encodeURIComponent(searchTerm);\n    body.exactMatch = game.settings.get(\"ddb-importer\", \"munching-policy-monster-exact-match\");\n  }\n\n  const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n\n  const url = ids && ids.length > 0\n    ? `${parsingApi}/proxy/monsters/ids`\n    : `${parsingApi}/proxy/monster`;\n\n  return new Promise((resolve, reject) => {\n    fetch(url, {\n      method: \"POST\",\n      mode: \"cors\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body), // body data type must match \"Content-Type\" header\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (!data.success) {\n          munchNote(`API Failure: ${data.message}`);\n          reject(data.message);\n        }\n        if (debugJson) {\n          download(JSON.stringify(data), `monsters-raw.json`, \"application/json\");\n        }\n        return data;\n      })\n      .then((data) => {\n        munchNote(`Retrieved ${data.data.length} monsters, starting parse...`, true, false);\n        logger.info(`Retrieved ${data.data.length} monsters`);\n        const parsedMonsters = parseMonsters(data.data);\n        return parsedMonsters;\n      })\n      .then((data) => {\n        munchNote(\n          `Parsed ${data.actors.length} monsters, failed ${data.failedMonsterNames.length} monsters`,\n          false,\n          true\n        );\n        if (data.failedMonsterNames && data.failedMonsterNames.length !== 0)\n          logger.error(`Failed to parse ${data.failedMonsterNames}`);\n        resolve(data.actors);\n      })\n      .catch((error) => reject(error));\n  });\n}\n\nexport async function parseCritters(ids = null) {\n  checkMonsterCompendium();\n  resetEquipment();\n  const updateBool = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n  const updateImages = game.settings.get(\"ddb-importer\", \"munching-policy-update-images\");\n  const uploadDirectory = game.settings.get(\"ddb-importer\", \"other-image-upload-directory\").replace(/^\\/|\\/$/g, \"\");\n\n  // to speed up file checking we pregenerate existing files now.\n  logger.info(\"Checking for existing files...\");\n  await utils.generateCurrentFiles(uploadDirectory);\n  logger.info(\"Check complete getting monster data...\");\n  let monsters = await getMonsterData(ids);\n\n  if (!updateBool || !updateImages) {\n    munchNote(`Calculating which monsters to update...`, true);\n    const existingMonsters = await getCompendiumItems(monsters, \"npc\");\n    const existingMonstersTotal = existingMonsters.length + 1;\n    if (!updateBool) {\n      logger.debug(\"Removing existing monsters from import list\");\n      logger.debug(`Matched ${existingMonstersTotal}`);\n      munchNote(`Removing ${existingMonstersTotal} from update...`);\n      monsters = await removeItems(monsters, existingMonsters);\n    }\n    if (!updateImages) {\n      logger.debug(\"Copying monster images across...\");\n      munchNote(`Copying images for ${existingMonstersTotal} monsters...`);\n      monsters = copyExistingMonsterImages(monsters, existingMonsters);\n    }\n  }\n  munchNote(\"\");\n  munchNote(`Fiddling with the SRD data...`, true);\n  const finalMonsters = await srdFiddling(monsters, \"monsters\");\n\n  // let features = [];\n  // let cr = [];\n  // console.warn(finalMonsters);\n  // finalMonsters.forEach((monster) => {\n  //   cr.push({name: monster.name, cr: monster.data.details.cr, type: monster.data.details.type });\n  // monster.items.forEach((feature) => {\n  //   features.push({ name: feature.name, monster: monster.name, srdImage: feature.img});\n  // })\n  // });\n  // download(JSON.stringify(features), `monster-features.json`, \"application/json\");\n  // download(JSON.stringify(cr), `monster-details.json`, \"application/json\");\n  // return 0;\n\n  munchNote(`Generating Icon Map..`, true);\n  await generateIconMap(finalMonsters);\n\n\n  const addToCompendiumFolder = game.settings.get(\"ddb-importer\", \"munching-policy-use-compendium-folders\");\n  const compendiumFoldersInstalled = utils.isModuleInstalledAndActive(\"compendium-folders\");\n  if (addToCompendiumFolder && compendiumFoldersInstalled) {\n    munchNote(`Checking compendium folders..`, true);\n    await createCompendiumFolderStructure(\"monsters\");\n    munchNote(\"\", true);\n  }\n\n  let monstersParsed = [];\n  let currentMonster = 1;\n  const monsterCount = finalMonsters.length;\n  munchNote(`Importing ${monsterCount} monsters!`, true);\n  for (const monster of finalMonsters) {\n    munchNote(`Importing ${monster.name} (${currentMonster}/${monsterCount})`, false, true);\n    logger.debug(`Importing ${monster.name}`);\n    // eslint-disable-next-line no-await-in-loop\n    const munched = await addNPC(monster);\n    monstersParsed.push(munched);\n    currentMonster += 1;\n  }\n  munchNote(\"\", false, true);\n  resetEquipment();\n\n  if (ids !== null) {\n    return Promise.all(monstersParsed);\n  }\n  return monsterCount;\n}\n","import logger from \"../../logger.js\";\nimport utils from \"../../utils.js\";\nimport { updateCompendium, srdFiddling, getImagePath } from \"../import.js\";\nimport { munchNote, getCompendiumType, getCompendiumLabel } from \"../utils.js\";\n\nconst FEATURE_DUP = [\n  \"Breath Weapon\",\n];\n\nconst RACE_TEMPLATE = {\n  \"name\": \"\",\n  \"type\": \"feat\",\n  \"data\": {\n    \"description\": {\n      \"value\": \"\",\n      \"chat\": \"\",\n      \"unidentified\": \"\"\n    },\n    \"source\": \"\",\n  },\n  \"sort\": 2600000,\n  \"flags\": {\n    \"ddbimporter\": {},\n    \"obsidian\": {\n      \"source\": {\n        \"type\": \"race\"\n      }\n    },\n  },\n  \"img\": null\n};\n\nfunction buildBase(data) {\n  let result = JSON.parse(JSON.stringify(RACE_TEMPLATE));\n\n  result.name = (data.fullName) ? data.fullName : data.name;\n  result.data.description.value += `${data.description}\\n\\n`;\n\n  result.flags.ddbimporter = {\n    entityRaceId: data.entityRaceId,\n    version: CONFIG.DDBI.version,\n  };\n\n  if (data.moreDetailsUrl) {\n    result.flags.ddbimporter['moreDetailsUrl'] = data.moreDetailsUrl;\n  }\n\n  result.data.source = utils.parseSource(data);\n\n  if (data.isSubRace && data.baseRaceName) result.data.requirements = data.baseRaceName;\n\n  return result;\n}\n\n\nasync function buildRace(race, compendiumRacialTraits) {\n  let result = buildBase(race);\n\n  let avatarUrl;\n  let largeAvatarUrl;\n  let portraitAvatarUrl;\n\n  if (race.portraitAvatarUrl) {\n    portraitAvatarUrl = await getImagePath(race.portraitAvatarUrl, \"race-portrait\", race.fullName);\n    result.img = portraitAvatarUrl;\n    result.flags.ddbimporter['portraitAvatarUrl'] = race.portraitAvatarUrl;\n  }\n\n  if (race.avatarUrl) {\n    avatarUrl = await getImagePath(race.avatarUrl, \"race-avatar\", race.fullName);\n    result.flags.ddbimporter['avatarUrl'] = race.avatarUrl;\n    if (!result.img) {\n      result.img = avatarUrl;\n    }\n  }\n\n  if (race.largeAvatarUrl) {\n    largeAvatarUrl = await getImagePath(race.largeAvatarUrl, \"race-large\", race.fullName);\n    // eslint-disable-next-line require-atomic-updates\n    result.flags.ddbimporter['largeAvatarUrl'] = race.largeAvatarUrl;\n    if (!result.img) {\n      // eslint-disable-next-line require-atomic-updates\n      result.img = largeAvatarUrl;\n    }\n  }\n\n  const image = (avatarUrl) ? `<img src=\"${avatarUrl}\">\\n\\n` : (largeAvatarUrl) ? `<img src=\"${largeAvatarUrl}\">\\n\\n` : \"\";\n  // eslint-disable-next-line require-atomic-updates\n  result.data.description.value += image;\n\n  const compendiumLabel = getCompendiumLabel(\"traits\");\n\n  race.racialTraits.forEach((f) => {\n    const feature = f.definition;\n    const featureMatch = compendiumRacialTraits.find((match) => feature.name === match.name && match.flags?.ddbimporter?.entityRaceId && match.flags.ddbimporter.entityRaceId === feature.entityRaceId);\n    const title = (featureMatch) ? `<p><b>${feature.name}</b> @Compendium[${compendiumLabel}.${featureMatch._id}]{${feature.name}}</p>` : `<p><b>${feature.name}</b></p>`;\n    result.data.description.value += `${title}\\n${feature.description}\\n\\n`;\n  });\n\n  return result;\n}\n\nasync function getRacialTraitsLookup(racialTraits, fail = true) {\n  const compendium = getCompendiumType(\"traits\", fail);\n  if (compendium) {\n    const index = await compendium.getIndex({ fields: [\"name\", \"flags.ddbimporter.entityRaceId\"] });\n    const traitIndex = await index.filter((i) => racialTraits.some((orig) => i.name === orig.name));\n    return traitIndex;\n  } else {\n    return [];\n  }\n}\n\nexport async function getDDBRace(ddb) {\n  const compendiumRacialTraits = await getRacialTraitsLookup(ddb.character.race.racialTraits.map((r) => r.definition), false);\n  const builtRace = await buildRace(ddb.character.race, compendiumRacialTraits);\n  delete builtRace.sort;\n  return builtRace;\n}\n\nfunction getRacialTrait(trait, fullName) {\n  logger.debug(\"Race trait build started\");\n\n  let result = buildBase(trait);\n\n  const duplicateFeature = FEATURE_DUP.includes(result.name);\n  result.name = (duplicateFeature) ? `${result.name} (${fullName})` : result.name;\n\n  result.flags.ddbimporter['spellListIds'] = trait.spellListIds;\n  result.flags.ddbimporter['definitionKey'] = trait.definitionKey;\n  result.flags.ddbimporter['race'] = fullName;\n  result.data.requirements = fullName;\n\n  return result;\n}\n\nconst NO_TRAITS = [\n  \"Speed\",\n  \"Ability Score Increase\",\n  \"Size\",\n  \"Feat\",\n  \"Languages\",\n];\n\nexport async function getRaces(data) {\n  logger.debug(\"get races started\");\n  const updateBool = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n\n  let results = [];\n  let races = [];\n  let racialFeatures = [];\n\n  data.forEach((race) => {\n    logger.debug(`${race.fullName} features parsing started...`);\n    race.racialTraits.forEach((trait) => {\n      logger.debug(`${trait.definition.name} trait starting...`);\n      if (!trait.definition.hideInSheet && !NO_TRAITS.includes(trait.definition.name)) {\n        const parsedTrait = getRacialTrait(trait.definition, race.fullName);\n        racialFeatures.push(parsedTrait);\n        results.push({ race: race.fullName, trait: trait.definition.name });\n      }\n    });\n  });\n\n  const fiddledRacialFeatures = await srdFiddling(racialFeatures, \"traits\");\n  munchNote(`Importing ${fiddledRacialFeatures.length} traits!`, true);\n  await updateCompendium(\"traits\", { traits: fiddledRacialFeatures }, updateBool);\n\n  const compendiumRacialTraits = await getRacialTraitsLookup(fiddledRacialFeatures);\n\n  await Promise.allSettled(data.map(async (race) => {\n    logger.debug(`${race.fullName} race parsing started...`);\n    const builtRace = await buildRace(race, compendiumRacialTraits);\n    races.push(builtRace);\n  }));\n\n  const fiddledRaces = await srdFiddling(races, \"races\");\n  munchNote(`Importing ${fiddledRaces.length} races!`, true);\n\n  await updateCompendium(\"races\", { races: fiddledRaces }, updateBool);\n\n  return results;\n}\n","// Main module class\nimport { munchNote, getCampaignId, download } from \"./utils.js\";\nimport { getRaces } from \"./races/races.js\";\nimport { getCobalt } from \"../lib/Secrets.js\";\n\nfunction getRaceData() {\n  const cobaltCookie = getCobalt();\n  const campaignId = getCampaignId();\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };\n  const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/proxy/races`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (debugJson) {\n          download(JSON.stringify(data), `races-raw.json`, \"application/json\");\n        }\n        if (!data.success) {\n          munchNote(`Failure: ${data.message}`);\n          reject(data.message);\n        }\n        return data;\n      })\n      .then((data) => getRaces(data.data))\n      .then((data) => resolve(data))\n      .catch((error) => reject(error));\n  });\n}\n\nexport async function parseRaces() {\n  const results = await getRaceData();\n\n  // download(JSON.stringify(results), `races-icon.json`, \"application/json\");\n\n  return results;\n}\n\n\n","import logger from \"../../logger.js\";\nimport utils from \"../../utils.js\";\nimport { updateCompendium, srdFiddling, daeFiddling } from \"../import.js\";\nimport { munchNote } from \"../utils.js\";\n\nconst FEAT_TEMPLATE = {\n  \"name\": \"\",\n  \"type\": \"feat\",\n  \"data\": {\n    \"description\": {\n      \"value\": \"\",\n      \"chat\": \"\",\n      \"unidentified\": \"\"\n    },\n    \"source\": \"\",\n  },\n  \"sort\": 2600000,\n  \"flags\": {\n    \"ddbimporter\": {},\n    \"obsidian\": {\n      \"source\": {\n        \"type\": \"feat\"\n      }\n    },\n  },\n  \"img\": null\n};\n\nfunction buildBase(data) {\n  let result = JSON.parse(JSON.stringify(FEAT_TEMPLATE));\n\n  result.name = data.name;\n  result.data.description.value += `${data.description}\\n\\n`;\n  result.data.description.chat += `${data.snippet}\\n\\n`;\n\n  result.flags.ddbimporter = {\n    featId: data.id,\n    version: CONFIG.DDBI.version,\n  };\n\n  result.flags.ddbimporter['prerequisites'] = data.prerequisites;\n  if (data.prerequisites.length > 0) {\n    const requirements = data.prerequisites.map((requirement) => requirement.description);\n    result.data.requirements = requirements.join(\", \");\n    result.data.description.value += `<h3>Requirements</h3>\\n\\n${requirements.join(\"\\n\\n\")}\\n\\n`;\n  }\n\n  result.data.source = utils.parseSource(data);\n\n  return result;\n}\n\n\nasync function buildFeat(feat,) {\n  let result = buildBase(feat);\n\n  return result;\n}\n\n\nexport async function getFeats(data) {\n  logger.debug(\"get feats started\");\n  const updateBool = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n\n  let feats = [];\n\n  data.forEach((feat) => {\n    logger.debug(`${feat.name} feat parsing started...`);\n    const parsedFeat = buildFeat(feat);\n    feats.push(parsedFeat);\n  });\n\n  const fiddledFeats = await srdFiddling(feats, \"feats\");\n  const finalFeats = await daeFiddling(fiddledFeats);\n\n  munchNote(`Importing ${finalFeats.length} feats!`, true);\n  await updateCompendium(\"feats\", { feats: finalFeats }, updateBool);\n\n  return finalFeats;\n}\n","// Main module class\nimport { munchNote, getCampaignId, download } from \"./utils.js\";\nimport { getFeats } from \"./feats/feats.js\";\nimport { getCobalt } from \"../lib/Secrets.js\";\n\nfunction getFeatData() {\n  const cobaltCookie = getCobalt();\n  const campaignId = getCampaignId();\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };\n  const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/proxy/feats`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (debugJson) {\n          download(JSON.stringify(data), `feats-raw.json`, \"application/json\");\n        }\n        if (!data.success) {\n          munchNote(`Failure: ${data.message}`);\n          reject(data.message);\n        }\n        return data;\n      })\n      .then((data) => getFeats(data.data))\n      .then((data) => resolve(data))\n      .catch((error) => reject(error));\n  });\n}\n\nexport async function parseFeats() {\n  const results = await getFeatData();\n\n  return results;\n}\n\n\n","import utils from \"../../utils.js\";\nimport logger from \"../../logger.js\";\nimport DICTIONARY from \"../../dictionary.js\";\nimport { getImagePath } from \"../import.js\";\nimport { generateTable } from \"../table.js\";\nimport { getCompendiumLabel } from \"../utils.js\";\n\nconst CLASS_TEMPLATE = {\n  \"name\": \"\",\n  \"type\": \"feat\",\n  \"data\": {\n    \"description\": {\n      \"value\": \"\",\n      \"chat\": \"\",\n      \"unidentified\": \"\"\n    },\n    \"source\": \"\",\n  },\n  \"sort\": 2600000,\n  \"flags\": {\n    \"ddbimporter\": {},\n    \"obsidian\": {\n      \"source\": {\n        \"type\": \"class\",\n        \"text\": \"\"\n      }\n    },\n  },\n  \"img\": null\n};\n\nexport const NO_TRAITS = [\n  \"Speed\",\n  \"Ability Score Increase\",\n  \"Ability Score Improvement\",\n  \"Size\",\n  \"Feat\",\n  \"Languages\",\n  \"Hit Points\",\n  \"Proficiencies\",\n];\n\nexport const FEATURE_DUP = [\n  \"Expertise\",\n  \"Fighting Style\",\n  \"Land's Stride\",\n  \"Otherworldly Patron\",\n  \"Pact Magic\",\n  \"Potent Spellcasting\",\n  \"Timeless Body\",\n  \"Unarmored Defense\",\n  \"Circle Spells\",\n  \"Divine Strike\",\n  \"Evasion\",\n  \"Channel Divinity\",\n  \"Expanded Spell List\",\n  \"Oath Spells\",\n  \"Psionic Power\",\n  \"Psychic Blades\",\n  \"Spellcasting\",\n  \"Primal Companion\",\n  \"Domain Spells\",\n  \"Bonus Cantrip\",\n  \"Bonus Cantrips\",\n  \"Bonus Proficiencies\",\n  \"Bonus Proficiency\",\n  \"Extra Attack\",\n  \"Tool Proficiency\",\n];\n\nfunction buildBase(data) {\n  let result = JSON.parse(JSON.stringify(CLASS_TEMPLATE));\n  const updateExisting = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n\n  result.name = data.name;\n  const tableDescription = generateTable(data.name, data.description, updateExisting);\n  result.data.description.value += `${tableDescription}\\n\\n`;\n\n  result.flags.ddbimporter = {\n    id: data.id,\n    data: data,\n    version: CONFIG.DDBI.version,\n  };\n\n  if (data.moreDetailsUrl) {\n    result.flags.ddbimporter['moreDetailsUrl'] = data.moreDetailsUrl;\n  }\n\n  result.data.source = utils.parseSource(data);\n\n  return result;\n}\nexport function getClassFeature(feature, klass, subClassName = \"\") {\n  logger.debug(\"Class feature build started\");\n\n  let result = buildBase(feature);\n  result.flags.obsidian.source.text = klass.name;\n\n  const duplicateFeature = FEATURE_DUP.includes(feature.name);\n  result.name = (duplicateFeature) ? `${feature.name} (${klass.name})` : feature.name;\n\n  result.flags.ddbimporter['featureId'] = feature.id;\n  result.flags.ddbimporter['requiredLevel'] = feature.requiredLevel;\n  result.flags.ddbimporter['prerequisite'] = feature.prerequisite;\n  result.flags.ddbimporter['class'] = klass.name;\n  result.flags.ddbimporter['classId'] = klass.id;\n  result.flags.ddbimporter['subClass'] = subClassName;\n  const requiredLevel = feature.requiredLevel ? ` ${feature.requiredLevel}` : \"\";\n  result.data.requirements = `${klass.name}${requiredLevel}`;\n\n  return result;\n}\n\nexport async function buildBaseClass(klass) {\n  let result = buildBase(klass);\n  logger.debug(`Parsing ${klass.name}`);\n  result.flags.obsidian.source.text = klass.name;\n  result.type = \"class\";\n\n  let avatarUrl;\n  let largeAvatarUrl;\n  let portraitAvatarUrl;\n\n  if (klass.portraitAvatarUrl) {\n    portraitAvatarUrl = await getImagePath(klass.portraitAvatarUrl, \"class-portrait\", klass.fullName);\n    result.img = portraitAvatarUrl;\n    result.flags.ddbimporter['portraitAvatarUrl'] = klass.portraitAvatarUrl;\n  }\n\n  if (klass.avatarUrl) {\n    avatarUrl = await getImagePath(klass.avatarUrl, \"class-avatar\", klass.fullName);\n    result.flags.ddbimporter['avatarUrl'] = klass.avatarUrl;\n    if (!result.img) {\n      result.img = avatarUrl;\n    }\n  }\n\n  if (klass.largeAvatarUrl) {\n    largeAvatarUrl = await getImagePath(klass.largeAvatarUrl, \"class-large\", klass.fullName);\n    // eslint-disable-next-line require-atomic-updates\n    result.flags.ddbimporter['largeAvatarUrl'] = klass.largeAvatarUrl;\n    if (!result.img) {\n      // eslint-disable-next-line require-atomic-updates\n      result.img = largeAvatarUrl;\n    }\n  }\n\n  const image = (avatarUrl) ? `<img class=\"ddb-class-image\" src=\"${avatarUrl}\">\\n\\n` : `<img class=\"ddb-class-image\" src=\"${largeAvatarUrl}\">\\n\\n`;\n\n  // eslint-disable-next-line require-atomic-updates\n  result.data.description.value += image;\n\n  // eslint-disable-next-line require-atomic-updates\n  result.flags.ddbimporter['parentClassId'] = klass.parentClassId;\n  // eslint-disable-next-line require-atomic-updates\n  result.flags.ddbimporter['hitDice'] = klass.hitDice;\n  // eslint-disable-next-line require-atomic-updates\n  result.flags.ddbimporter['spellCastingAbilityId'] = klass.spellCastingAbilityId;\n  // eslint-disable-next-line require-atomic-updates\n  result.flags.ddbimporter['canCastSpells'] = klass.canCastSpells;\n\n  // setup data\n  // eslint-disable-next-line require-atomic-updates\n  result.data.levels = 1;\n  // eslint-disable-next-line require-atomic-updates\n  result.data.hitDice = `d${klass.hitDice}`;\n\n  let spellcasting = {};\n  if (klass.canCastSpells) {\n    const spellProgression = DICTIONARY.spell.progression.find((cls) => cls.name == klass.name);\n    const spellCastingAbility = klass.spellCastingAbilityId\n      ? DICTIONARY.character.abilities.find((a) => a.id == klass.spellCastingAbilityId).value\n      : null;\n    if (spellProgression) {\n      spellcasting = {\n        progression: spellProgression.value,\n        ability: spellCastingAbility,\n      };\n    }\n  }\n  // eslint-disable-next-line require-atomic-updates\n  result.data.spellcasting = spellcasting;\n\n  // this can be used with the add class response\n  // const classSkillSubType = `choose-a-${klass.name.toLowerCase()}-skill`;\n  // const skillCount = .filter((mod) => mod.subType === classSkillSubType && mod.type === \"proficiency\"));\n\n  const proficiencyOption = klass.classFeatures.find((feature) =>\n    feature.name === \"Proficiencies\" &&\n    feature.requiredLevel === 1\n  );\n\n  let dom = new DocumentFragment();\n  $.parseHTML(proficiencyOption.description).forEach((element) => {\n    dom.appendChild(element);\n  });\n\n  // Choose any three\n  // Skills: Choose two from Arcana, Animal Handling, Insight, Medicine, Nature, Perception, Religion, and Survival\n  const allSkillRegex = /Skills: Choose any (\\w+)(.*)($|\\.$|\\w+:)/;\n  const allMatch = dom.textContent.match(allSkillRegex);\n  const skillRegex = /Skills: Choose (\\w+) from (.*)($|The|\\.$|\\w+:)/;\n  const skillMatch = dom.textContent.match(skillRegex);\n\n  if (allMatch) {\n    const skills = DICTIONARY.character.skills.map((skill) => skill.name);\n    const numberSkills = DICTIONARY.numbers.find((num) => allMatch[1].toLowerCase() === num.natural);\n    // eslint-disable-next-line require-atomic-updates\n    result.data.skills = {\n      number: numberSkills ? numberSkills.num : 2,\n      choices: skills,\n      value: [],\n    };\n  } else if (skillMatch) {\n    const skillNames = skillMatch[2].replace('and', ',').split(',').map((skill) => skill.trim());\n    const skills = skillNames.filter((name) => DICTIONARY.character.skills.some((skill) => skill.label.toLowerCase() === name.toLowerCase()))\n      .map((name) => {\n        const dictSkill = DICTIONARY.character.skills.find((skill) => skill.label.toLowerCase() === name.toLowerCase());\n        return dictSkill.name;\n      });\n    const numberSkills = DICTIONARY.numbers.find((num) => skillMatch[1].toLowerCase() === num.natural);\n    // eslint-disable-next-line require-atomic-updates\n    result.data.skills = {\n      number: numberSkills ? numberSkills.num : 2,\n      choices: skills,\n      value: [],\n    };\n  }\n\n  // \"moreDetailsUrl\": \"/characters/classes/rogue\",\n\n  if (klass.equipmentDescription) {\n    // eslint-disable-next-line require-atomic-updates\n    result.data.description.value += `<p><b>Starting Equipment</b></p>\\n${klass.equipmentDescription}\\n\\n`;\n  }\n\n  return result;\n}\n\nexport async function buildClassFeatures(klass, compendiumClassFeatures) {\n  logger.debug(`Parsing ${klass.name} features`);\n  let description = \"<h3>Class Features</h3>\\n\\n\";\n  let classFeatures = [];\n\n  const compendiumLabel = getCompendiumLabel(\"features\");\n\n  klass.classFeatures.forEach((feature) => {\n    const classFeaturesAdded = classFeatures.some((f) => f === feature.name);\n\n    // sort by level?\n    if (!classFeaturesAdded) {\n      const featureMatch = compendiumClassFeatures.find((match) => feature.name.trim().toLowerCase() == match.name.trim().toLowerCase() && match.flags.ddbimporter && match.flags.ddbimporter.classId == klass.id);\n      const title = (featureMatch) ? `<p><b>${feature.name}</b> @Compendium[${compendiumLabel}.${featureMatch._id}]{${feature.name}}</p>` : `<p><b>${feature.name}</b></p>`;\n\n      // eslint-disable-next-line require-atomic-updates\n      description += `${title}\\n${feature.description}\\n\\n`;\n      classFeatures.push(feature.name);\n    }\n\n  });\n\n  return description;\n}\n","import logger from \"../../logger.js\";\nimport { buildBaseClass, getClassFeature, buildClassFeatures, NO_TRAITS } from \"./shared.js\";\nimport { updateCompendium, srdFiddling } from \"../import.js\";\nimport { munchNote, getCompendiumType } from \"../utils.js\";\n\n\nasync function buildClass(klass, compendiumClassFeatures) {\n  let result = await buildBaseClass(klass);\n  result.data.description.value += await buildClassFeatures(klass, compendiumClassFeatures);\n  return result;\n}\n\nexport async function getClasses(data) {\n  let results = [];\n  logger.debug(\"get clases started\");\n  const updateBool = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n\n  let klasses = [];\n  let classFeatures = [];\n\n  data.forEach((klass) => {\n    logger.debug(`${klass.name} feature parsing started...`);\n    klass.classFeatures.forEach((feature) => {\n      const existingFeature = classFeatures.some((f) => f.name === feature.name);\n      logger.debug(`${feature.name} feature starting...`);\n      if (!NO_TRAITS.includes(feature.name) && !existingFeature) {\n        const parsedFeature = getClassFeature(feature, klass);\n        classFeatures.push(parsedFeature);\n        results.push({ class: klass.name, subClass: \"\", feature: feature.name });\n      }\n    });\n  });\n\n  const fiddledClassFeatures = await srdFiddling(classFeatures, \"features\");\n  munchNote(`Importing ${fiddledClassFeatures.length} features!`, true);\n  await updateCompendium(\"features\", { features: fiddledClassFeatures }, updateBool);\n\n  const compendium = getCompendiumType(\"features\");\n  const index = await compendium.getIndex();\n  const firstPassFeatures = await index.filter((i) => fiddledClassFeatures.some((orig) => i.name === orig.name));\n  let compendiumClassFeatures = [];\n\n  await Promise.all(firstPassFeatures.map(async (f) => {\n    const feature = await compendium.getDocument(f._id);\n    compendiumClassFeatures.push(feature.toJSON());\n  }));\n\n  await Promise.all(data.map(async (klass) => {\n    logger.debug(`${klass.name} class parsing started...`);\n    const builtClass = await buildClass(klass, compendiumClassFeatures);\n    klasses.push(builtClass);\n  }));\n\n  const fiddledClasses = await srdFiddling(klasses, \"classes\");\n  munchNote(`Importing ${fiddledClasses.length} classes!`, true);\n\n  await updateCompendium(\"classes\", { classes: fiddledClasses }, updateBool);\n\n  // return fiddledClasses.concat(fiddledClassFeatures);\n  return results;\n}\n","import logger from \"../../logger.js\";\nimport { DDB_CONFIG } from \"../../ddbConfig.js\";\n\nimport { buildBaseClass, getClassFeature, buildClassFeatures, NO_TRAITS } from \"./shared.js\";\nimport { updateCompendium, srdFiddling, getImagePath } from \"../import.js\";\nimport { munchNote, getCompendiumType } from \"../utils.js\";\n\nasync function buildSubClassBase(klass, subClass) {\n  delete klass['_id'];\n\n  let avatarUrl;\n  let largeAvatarUrl;\n  let portraitAvatarUrl;\n\n  if (subClass.portraitAvatarUrl) {\n    portraitAvatarUrl = await getImagePath(subClass.portraitAvatarUrl, \"class-portrait\", subClass.fullName);\n    // eslint-disable-next-line require-atomic-updates\n    klass.img = portraitAvatarUrl;\n    // eslint-disable-next-line require-atomic-updates\n    klass.flags.ddbimporter['portraitAvatarUrl'] = subClass.portraitAvatarUrl;\n  }\n\n  if (subClass.avatarUrl) {\n    avatarUrl = await getImagePath(subClass.avatarUrl, \"class-avatar\", subClass.fullName);\n    // eslint-disable-next-line require-atomic-updates\n    klass.flags.ddbimporter['avatarUrl'] = subClass.avatarUrl;\n    if (!klass.img) {\n      // eslint-disable-next-line require-atomic-updates\n      klass.img = avatarUrl;\n    }\n  }\n\n  if (subClass.largeAvatarUrl) {\n    largeAvatarUrl = await getImagePath(subClass.largeAvatarUrl, \"class-large\", subClass.fullName);\n    // eslint-disable-next-line require-atomic-updates\n    klass.flags.ddbimporter['largeAvatarUrl'] = subClass.largeAvatarUrl;\n    if (!klass.img) {\n      // eslint-disable-next-line require-atomic-updates\n      klass.img = largeAvatarUrl;\n    }\n  }\n\n  // eslint-disable-next-line require-atomic-updates\n  klass.flags.ddbimporter['parentClassId'] = subClass.parentClassId;\n  // eslint-disable-next-line require-atomic-updates\n  klass.flags.ddbimporter['spellCastingAbilityId'] = subClass.spellCastingAbilityId;\n  // eslint-disable-next-line require-atomic-updates\n  klass.flags.ddbimporter['canCastSpells'] = subClass.canCastSpells;\n  // eslint-disable-next-line require-atomic-updates\n  klass.flags.ddbimporter['moreDetailsUrl'] = subClass.moreDetailsUrl;\n\n  if (avatarUrl || largeAvatarUrl) {\n    const imageMatch = /$<img class=\"ddb-class-image\"(.*)$/;\n    const image = (avatarUrl)\n      ? `<img class=\"ddb-class-image\" src=\"${avatarUrl}\">\\n\\n`\n      : `<img class=\"ddb-class-image\" src=\"${largeAvatarUrl}\">\\n\\n`;\n    klass.data.description.value.replace(imageMatch, image);\n  }\n\n  // eslint-disable-next-line require-atomic-updates\n  klass.name += ` (${subClass.name})`;\n  // eslint-disable-next-line require-atomic-updates\n  klass.data.description.value += `<h3>${subClass.name}</h3>\\n${subClass.description}\\n\\n`;\n\n  // spell caster now?\n  // if canCastSpells but now canCastSpells then set to third\n  if (klass.data.spellcasting === \"\" && subClass.canCastSpells) {\n    // eslint-disable-next-line require-atomic-updates\n    klass.data.spellcasting = \"third\";\n  }\n\n  return klass;\n\n}\n\nasync function buildSubClass(klass, subclass, compendiumSubClassFeatures) {\n  let baseClass = await buildBaseClass(klass.flags.ddbimporter.data);\n  let result = await buildSubClassBase(baseClass, subclass);\n  result.data.description.value += await buildClassFeatures(subclass, compendiumSubClassFeatures);\n  return result;\n}\n\nexport async function getSubClasses(data) {\n  logger.debug(\"get subclasses started\");\n  const updateBool = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n\n  let subClasses = [];\n  let classFeatures = [];\n  let results = [];\n\n  data.forEach((subClass) => {\n    const classMatch = DDB_CONFIG.classConfigurations.find((k) => k.id === subClass.parentClassId);\n    logger.debug(`${subClass.name} feature parsing started...`);\n    subClass.classFeatures.forEach((feature) => {\n      const existingFeature = classFeatures.some((f) => f.name === feature.name);\n      logger.debug(`${feature.name} feature starting...`);\n      if (!NO_TRAITS.includes(feature.name.trim()) && !existingFeature) {\n        const parsedFeature = getClassFeature(feature, subClass, subClass.name);\n        classFeatures.push(parsedFeature);\n        results.push({ class: classMatch.name, subClass: subClass.name, feature: feature.name });\n      }\n    });\n  });\n\n  const fiddledClassFeatures = await srdFiddling(classFeatures, \"features\");\n  munchNote(`Importing ${fiddledClassFeatures.length} features!`, true);\n  await updateCompendium(\"features\", { features: fiddledClassFeatures }, updateBool);\n\n  const compendium = getCompendiumType(\"features\");\n  const index = await compendium.getIndex();\n  const firstPassFeatures = await index.filter((i) => fiddledClassFeatures.some((orig) => i.name === orig.name));\n\n  let compendiumClassFeatures = [];\n\n  await Promise.allSettled(firstPassFeatures.map(async (f) => {\n    const feature = await compendium.getDocument(f._id);\n    compendiumClassFeatures.push(feature.toJSON());\n  }));\n\n  // get base class\n  const classCompendium = getCompendiumType(\"class\");\n  // const classIndex = await classCompendium.getIndex();\n  const content = await classCompendium.getDocuments();\n\n  await Promise.all(data.map(async (subClass) => {\n    const classMatch = content.find((i) => i.data.flags.ddbimporter['id'] == subClass.parentClassId);\n    const builtClass = await buildSubClass(classMatch.data, subClass, compendiumClassFeatures);\n    subClasses.push(builtClass);\n  }));\n\n  const fiddledClasses = await srdFiddling(subClasses, \"classes\");\n  munchNote(`Importing ${fiddledClasses.length} subclasses!`, true);\n\n  await updateCompendium(\"classes\", { classes: fiddledClasses }, updateBool);\n\n  // return fiddledClasses.concat(fiddledClassFeatures);\n  return results;\n}\n","import logger from \"../../logger.js\";\nimport { DDB_CONFIG } from \"../../ddbConfig.js\";\n\nimport { getClassFeature, NO_TRAITS } from \"./shared.js\";\nimport { updateCompendium, srdFiddling } from \"../import.js\";\nimport { munchNote } from \"../utils.js\";\n\nexport async function getClassOptions(data, className) {\n  logger.debug(\"get options started\");\n  const updateBool = game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\");\n  let results = [];\n\n  let classFeatures = [];\n  const classMatch = DDB_CONFIG.classConfigurations.find((k) => k.name === className);\n\n  const klass = {\n    name: className,\n    id: classMatch.id,\n  };\n\n  data.forEach((feature) => {\n    const existingFeature = classFeatures.some((f) => f.name === feature.name);\n    logger.debug(`${feature.name} feature starting...`);\n    if (!NO_TRAITS.includes(feature.name.trim()) && !existingFeature) {\n      const parsedFeature = getClassFeature(feature, klass);\n      classFeatures.push(parsedFeature);\n      results.push({ class: className, subClass: \"\", feature: feature.name });\n    }\n  });\n\n  const fiddledClassFeatures = await srdFiddling(classFeatures, \"features\");\n  munchNote(`Importing ${fiddledClassFeatures.length} options!`, true);\n  await updateCompendium(\"features\", { features: fiddledClassFeatures }, updateBool);\n\n  // return fiddledClassFeatures;\n  return results;\n}\n","// Main module class\nimport { getClasses } from \"./classes/classes.js\";\nimport { munchNote, getCampaignId, download } from \"./utils.js\";\nimport { getSubClasses } from \"./classes/subclasses.js\";\nimport { getClassOptions } from \"./classes/options.js\";\nimport { getCobalt } from \"../lib/Secrets.js\";\n\nfunction getSubClassesData(className) {\n  const cobaltCookie = getCobalt();\n  const campaignId = getCampaignId();\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey, className: className };\n  const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/proxy/subclass`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (debugJson) {\n          download(JSON.stringify(data), `subclass-${className}-raw.json`, \"application/json\");\n        }\n        if (!data.success) {\n          munchNote(`Failure: ${data.message}`);\n          reject(data.message);\n        }\n        return data;\n      })\n      .then((data) => getSubClasses(data.data))\n      .then((data) => resolve(data))\n      .catch((error) => reject(error));\n  });\n}\n\nfunction getClassOptionsData(className) {\n  const cobaltCookie = getCobalt();\n  const campaignId = getCampaignId();\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey, className: className };\n  const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/proxy/v5/classes/options`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (debugJson) {\n          download(JSON.stringify(data), `subclass-${className}-raw.json`, \"application/json\");\n        }\n        if (!data.success) {\n          munchNote(`Failure: ${data.message}`);\n          reject(data.message);\n        }\n        return data;\n      })\n      .then((data) => getClassOptions(data.data, className))\n      .then((data) => resolve(data))\n      .catch((error) => reject(error));\n  });\n}\n\nfunction getClassesData() {\n  const cobaltCookie = getCobalt();\n  const campaignId = getCampaignId();\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };\n  const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/proxy/classes`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (debugJson) {\n          download(JSON.stringify(data), `classes-raw.json`, \"application/json\");\n        }\n        if (!data.success) {\n          munchNote(`Failure: ${data.message}`);\n          reject(data.message);\n        }\n        return data;\n      })\n      .then((data) => getClasses(data.data))\n      .then((data) => resolve(data))\n      .catch((error) => reject(error));\n  });\n}\n\nexport async function parseClasses() {\n  const classesResults = await getClassesData();\n\n  const subClassResults = await Promise.all([\n    getSubClassesData(\"Cleric\"),\n    getSubClassesData(\"Druid\"),\n    getSubClassesData(\"Sorcerer\"),\n    getSubClassesData(\"Warlock\"),\n    getSubClassesData(\"Wizard\"),\n    getSubClassesData(\"Paladin\"),\n    getSubClassesData(\"Ranger\"),\n    getSubClassesData(\"Bard\"),\n    getSubClassesData(\"Barbarian\"),\n    getSubClassesData(\"Fighter\"),\n    getSubClassesData(\"Artificer\"),\n    getSubClassesData(\"Rogue\"),\n    getSubClassesData(\"Monk\"),\n    getSubClassesData(\"Blood Hunter\"),\n  ]);\n\n  const classOptionsResults = await Promise.all([\n    getClassOptionsData(\"Cleric\"),\n    getClassOptionsData(\"Druid\"),\n    getClassOptionsData(\"Sorcerer\"),\n    getClassOptionsData(\"Warlock\"),\n    getClassOptionsData(\"Wizard\"),\n    getClassOptionsData(\"Paladin\"),\n    getClassOptionsData(\"Ranger\"),\n    getClassOptionsData(\"Bard\"),\n    getClassOptionsData(\"Barbarian\"),\n    getClassOptionsData(\"Fighter\"),\n    getClassOptionsData(\"Rogue\"),\n    getClassOptionsData(\"Monk\"),\n    getClassOptionsData(\"Blood Hunter\"),\n    getClassOptionsData(\"Artificer\"),\n  ]);\n\n  const results = classesResults.concat(subClassResults.flat(), classOptionsResults.flat());\n\n  // download(JSON.stringify(results), `classes-icon.json`, \"application/json\");\n\n  return results;\n}\n\n\n","// Main module class\nimport { getImagePath } from \"./import.js\";\nimport { munchNote, download } from \"./utils.js\";\nimport logger from \"../logger.js\";\nimport { getCobalt } from \"../lib/Secrets.js\";\n\nasync function getFrameData() {\n  const cobaltCookie = getCobalt();\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n\n  const body = {\n    cobalt: cobaltCookie,\n    betaKey: betaKey,\n  };\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/proxy/frames`, {\n      method: \"POST\",\n      mode: \"cors\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body), // body data type must match \"Content-Type\" header\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (!data.success) {\n          munchNote(`API Failure: ${data.message}`);\n          reject(data.message);\n        }\n        if (debugJson) {\n          download(JSON.stringify(data), `frames-raw.json`, \"application/json\");\n        }\n        return data;\n      })\n      .then((data) => {\n        munchNote(`Retrieved ${data.data.length} frames, starting parse...`, true, false);\n        logger.info(`Retrieved ${data.data.length} frames`);\n        resolve(data.data);\n      })\n      .catch((error) => reject(error));\n  });\n}\n\nexport async function parseFrames() {\n  const frames = await getFrameData();\n  logger.debug(\"Importing frames\", frames);\n\n  munchNote(`Fetching DDB Frames`);\n  frames.forEach(async (frame) => {\n    await getImagePath(frame.frameAvatarUrl, 'frame', `DDB ${frame.name}`, true);\n  });\n\n  munchNote(\"\");\n\n  return frames.length;\n}\n","import logger from \"../logger.js\";\n\nfunction occurrences(string, subString, allowOverlapping) {\n  string += \"\";\n  subString += \"\";\n  if (subString.length <= 0) return (string.length + 1);\n\n  let n = 0,\n    pos = 0,\n    step = allowOverlapping ? 1 : subString.length;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    pos = string.indexOf(subString, pos);\n    if (pos >= 0) {\n      ++n;\n      pos += step;\n    } else break;\n  }\n  return n;\n}\n\nfunction checkBase64(string) {\n  let count = occurrences(JSON.stringify(string), \"base64\");\n\n  return count > 0;\n}\n\nexport function checkScenes() {\n  let fixedScenes = [];\n  let badScenes = [];\n  game.scenes.forEach((scene) => {\n    if (checkBase64(scene.data.thumb)) {\n      logger.warn(`Scene ${scene.name} has base 64 thumb data - fixing!`);\n      scene.createThumbnail().then((data) => {\n        scene.update({ thumb: data.thumb }, { diff: false });\n        ui.notifications.info(`Regenerated thumbnail image for ${scene.name} background image`);\n      });\n      fixedScenes.push(scene.name);\n    }\n    if (checkBase64(scene.data.img)) {\n      logger.warn(`Scene ${scene.name} has base 64 Image data!`);\n      ui.notifications.warn(`${scene.name} has a base64 encoded scene image - please fix`);\n      badScenes.push(scene.name);\n    } else if (checkBase64(scene) && !checkBase64(scene.data.thumb)) {\n      logger.warn(`Scene ${scene.name} has unknown location base 64 data!`);\n      logger.warn(scene);\n      badScenes.push(scene.name);\n    }\n  });\n  if (badScenes.length > 0) logger.warn(\"Please fix the following scenes with base64 data:\", badScenes);\n  return {\n    fixedScenes,\n    badScenes,\n  };\n}\n\nexport function base64Check() {\n  return checkScenes();\n}\n","import { DDB_CONFIG } from \"../ddbConfig.js\";\nimport { munchNote, getCampaignId, download, getCompendium, getCompendiumLabel } from \"./utils.js\";\nimport { getCobalt } from \"../lib/Secrets.js\";\n\nfunction getVehicleData() {\n  const cobaltCookie = getCobalt();\n  const campaignId = getCampaignId();\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const body = { cobalt: cobaltCookie, campaignId: campaignId, betaKey: betaKey };\n  const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/proxy/vehicles`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body),\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (debugJson) {\n          download(JSON.stringify(data), `vehicles-raw.json`, \"application/json\");\n        }\n        if (!data.success) {\n          munchNote(`Failure: ${data.message}`);\n          reject(data.message);\n        }\n        return data;\n      })\n      .then((data) => resolve(data.data))\n      .catch((error) => reject(error));\n  });\n}\n\n\nasync function getMonsterMap () {\n  // ddb://monsters\n  const monsterCompendiumLabel = getCompendiumLabel(\"monster\");\n  const monsterCompendium = await getCompendium(monsterCompendiumLabel);\n  const monsterIndices = [\"name\", \"flags.ddbimporter.id\"];\n  const monsterIndex = await monsterCompendium.getIndex({ fields: monsterIndices });\n\n  const results = monsterIndex\n    .filter((monster) => monster.flags?.ddbimporter?.id)\n    .map((monster) => {\n      return {\n        id: monster.flags.ddbimporter.id,\n        _id: monster._id,\n        compendium: monsterCompendiumLabel,\n        name: monster.name,\n        documentName: monster.name,\n      };\n    });\n\n  return Promise.all(results);\n}\n\nasync function getSpellMap() {\n  // ddb://spells\n  // mm 2176\n  const spellCompendiumLabel = await game.settings.get(\"ddb-importer\", \"entity-spell-compendium\");\n  const spellCompendium = await game.packs.find((pack) => pack.collection === spellCompendiumLabel);\n  const spellIndices = [\"name\", \"flags.ddbimporter.definitionId\"];\n  const spellIndex = await spellCompendium.getIndex({ fields: spellIndices });\n\n  const results = spellIndex\n    .filter((spell) => spell.flags?.ddbimporter?.definitionId)\n    .map((spell) => {\n      return {\n        id: spell.flags.ddbimporter.definitionId,\n        _id: spell._id,\n        compendium: spellCompendiumLabel,\n        name: spell.name,\n        documentName: spell.name,\n      };\n    });\n\n  return Promise.all(results);\n}\n\nasync function getItemMap() {\n  // ddb://magicitems\n  const itemCompendiumLabel = await game.settings.get(\"ddb-importer\", \"entity-item-compendium\");\n  const itemCompendium = await game.packs.find((pack) => pack.collection === itemCompendiumLabel);\n  const itemIndices = [\"name\", \"flags.ddbimporter.definitionId\"];\n  const itemIndex = await itemCompendium.getIndex({ fields: itemIndices });\n\n  const results = itemIndex\n    .filter((item) => item.flags?.ddbimporter?.definitionId)\n    .map((item) => {\n      return {\n        id: item.flags.ddbimporter.definitionId,\n        _id: item._id,\n        compendium: itemCompendiumLabel,\n        name: item.name,\n        documentName: item.name,\n      };\n    });\n\n  return Promise.all(results);\n}\n\nexport async function generateAdventureConfig(full = true) {\n  const customProxy = game.settings.get(\"ddb-importer\", \"custom-proxy\");\n\n  const result = {\n    cobalt: getCobalt(),\n    campaignId: getCampaignId(),\n    generateTokens: true,\n    version: game.modules.get(\"ddb-importer\").data.version,\n    lookups: {\n      monsters: [],\n      items: [],\n      spells: [],\n      skills: [],\n      senses: [],\n      conditions: [],\n      actions: [],\n      weaponproperties: [],\n      vehicles: [],\n    }\n  };\n\n  // @Compendium[${compendiumLabel}.${featureMatch._id}]{${feature.name}}\n\n  if (full) {\n    result.lookups.monsters = await getMonsterMap();\n    result.lookups.spells = await getSpellMap();\n    result.lookups.items = await getItemMap();\n  }\n\n  const rulesCompendium = \"dnd5e.rules\";\n  const srdCompendium = await getCompendium(rulesCompendium);\n  const srdIndex = await srdCompendium.getIndex();\n\n  const skillEntry = srdIndex.find((i) => i.name === \"Using Each Ability\");\n  result.lookups.skills = DDB_CONFIG.abilitySkills.map((skill) => {\n    return {\n      id: skill.id,\n      _id: skillEntry.id,\n      name: skill.name,\n      compendium: rulesCompendium,\n      documentName: skillEntry.name,\n    };\n  });\n  result.lookups.senses = DDB_CONFIG.senses.filter((sense) => srdIndex.some((i) => i.name === sense.name))\n    .map((sense) => {\n      const entry = srdIndex.find((i) => i.name === sense.name);\n      return {\n        id: sense.id,\n        _id: entry.id,\n        name: sense.name,\n        compendium: rulesCompendium,\n        documentName: entry.name,\n      };\n    });\n\n  result.lookups.conditions = DDB_CONFIG.conditions.filter((condition) => srdIndex.some((i) => i.name.trim() === condition.definition.name.trim()))\n    .map((condition) => {\n      const entry = srdIndex.find((i) => i.name.trim() === condition.definition.name.trim());\n      return {\n        id: condition.definition.id,\n        _id: entry.id,\n        name: condition.definition.name,\n        compendium: rulesCompendium,\n        slug: condition.definition.slug,\n        documentName: entry.name,\n      };\n    });\n\n  const actionEntry = srdIndex.find((i) => i.name === \"Actions in Combat\");\n  result.lookups.actions = DDB_CONFIG.basicActions.map((action) => {\n    return {\n      id: action.id,\n      _id: actionEntry.id,\n      name: action.name,\n      compendium: rulesCompendium,\n      documentName: actionEntry.name,\n    };\n  });\n\n  const weaponPropertiesEntry = srdIndex.find((i) => i.name === \"Weapons\");\n  result.lookups.weaponproperties = DDB_CONFIG.weaponProperties.map((prop) => {\n    return {\n      id: prop.id,\n      _id: weaponPropertiesEntry.id,\n      name: prop.name,\n      compendium: rulesCompendium,\n      documentName: weaponPropertiesEntry.name,\n    };\n  });\n\n  // vehicles\n  if (!customProxy) {\n    const vehicleData = await getVehicleData();\n\n    result.lookups.vehicles = vehicleData.map((v) => {\n      return {\n        id: v.id,\n        url: v.url,\n        name: v.name,\n      };\n    });\n  }\n\n  return result;\n\n}\n\nexport async function downloadAdventureConfig() {\n  const fullConfig = game.settings.get(\"ddb-importer\", \"adventure-muncher-full-config\");\n  const result = await generateAdventureConfig(fullConfig);\n  download(JSON.stringify(result, null, 4), `adventure-config.json`, \"application/json\");\n  return result;\n}\n","import logger from \"../../logger.js\";\nimport utils from \"../../utils.js\";\nimport { DirectoryPicker } from \"../../lib/DirectoryPicker.js\";\nimport { checkMonsterCompendium } from \"../importMonster.js\";\nimport { parseCritters } from \"../monsters.js\";\nimport { parseSpells } from \"../spells.js\";\nimport { parseItems } from \"../items.js\";\nimport { getPatreonTiers, getCompendiumType } from \"../utils.js\";\nimport AdventureMunch from \"./adventure.js\";\n\nconst COMPENDIUM_MAP = {\n  \"spells\": \"spells\",\n  \"magicitems\": \"items\",\n  \"weapons\": \"items\",\n  \"armor\": \"items\",\n  \"adventuring-gear\": \"items\",\n  \"monsters\": \"monsters\",\n};\n\nconst DDB_MAP = {\n  \"spells\": \"spells\",\n  \"magicitems\": \"magic-items\",\n  \"weapons\": \"equipment\",\n  \"armor\": \"equipment\",\n  \"adventuring-gear\": \"equipment\",\n  \"monsters\": \"monsters\",\n};\n\nexport default class Helpers {\n\n\n  static getImportFilePaths(path, adventure, misc) {\n    const adventurePath = (adventure.name).replace(/[^a-z0-9]/gi, '_');\n    const targetPath = path.replace(/[\\\\/][^\\\\/]+$/, '');\n    const filename = path.replace(/^.*[\\\\/]/, '').replace(/\\?(.*)/, '');\n    const baseUploadPath = misc\n      ? game.settings.get(\"ddb-importer\", \"adventure-misc-path\")\n      : game.settings.get(\"ddb-importer\", \"adventure-upload-path\");\n    const parsedBaseUploadPath = DirectoryPicker.parse(baseUploadPath);\n    const uploadPath = misc\n      ? `${parsedBaseUploadPath.current}/${targetPath}`\n      : `${parsedBaseUploadPath.current}/${adventurePath}/${targetPath}`;\n    const returnFilePath = misc\n      ? `${targetPath}/${filename}`\n      : `${adventurePath}/${targetPath}/${filename}`;\n    return {\n      adventurePath,\n      targetPath,\n      filename,\n      baseUploadPath,\n      parsedBaseUploadPath,\n      uploadPath,\n      returnFilePath,\n    };\n  }\n\n  static unPad(match, p1) {\n    if (isNaN(parseInt(p1))) {\n      return p1;\n    } else {\n      return parseInt(p1);\n    }\n  }\n\n  static async importRawFile(path, content, mimeType, adventure, misc) {\n    try {\n      if (path[0] === \"*\") {\n        // this file was flagged as core data, just replace name.\n        return path.replace(/\\*/g, \"\");\n      } else if (path.startsWith(\"icons/\") || path.startsWith(\"systems/dnd5e/icons/\") || path.startsWith(\"ddb://\")) {\n        // these are core icons, ignore\n        // or are ddb:// paths that will be replaced by muncher\n        return path;\n      } else {\n        const paths = Helpers.getImportFilePaths(path, adventure, misc);\n\n        if (!CONFIG.DDBI.ADVENTURE.TEMPORARY.import[path]) {\n          await DirectoryPicker.verifyPath(paths.parsedBaseUploadPath, `${paths.uploadPath}`);\n          const fileData = new File([content], paths.filename, { type: mimeType });\n          await Helpers.UploadFile(paths.parsedBaseUploadPath.activeSource, `${paths.uploadPath}`, fileData, { bucket: paths.parsedBaseUploadPath.bucket });\n          // eslint-disable-next-line require-atomic-updates\n          CONFIG.DDBI.ADVENTURE.TEMPORARY.import[path] = true;\n        } else {\n          logger.debug(`File already imported ${path}`);\n        }\n\n        const returnPath = await utils.getFileUrl(paths.baseUploadPath, paths.returnFilePath);\n        return `${returnPath}`;\n      }\n    } catch (err) {\n      logger.error(`Error importing image file ${path} : ${err.message}`);\n    }\n\n    return path;\n  }\n\n  /**\n   * Imports binary file, by extracting from zip file and uploading to path.\n   *\n   * @param  {string} path - Path to image within zip file\n   * @param  {object} zip - Zip file\n   * @returns {string} - Path to file within VTT\n   */\n  static async importImage(path, zip, adventure, misc = false) {\n    try {\n      if (path[0] === \"*\") {\n        // this file was flagged as core data, just replace name.\n        return path.replace(/\\*/g, \"\");\n      } else if (path.startsWith(\"icons/\") || path.startsWith(\"systems/dnd5e/icons/\") || path.startsWith(\"ddb://\")) {\n        // these are core icons, ignore\n        // or are ddb:// paths that will be replaced by muncher\n        return path;\n      } else {\n        const paths = Helpers.getImportFilePaths(path, adventure, misc);\n\n        if (!CONFIG.DDBI.ADVENTURE.TEMPORARY.import[path]) {\n          await DirectoryPicker.verifyPath(paths.parsedBaseUploadPath, `${paths.uploadPath}`);\n          const img = await zip.file(path).async(\"uint8array\");\n          const fileData = new File([img], paths.filename);\n          await Helpers.UploadFile(paths.parsedBaseUploadPath.activeSource, `${paths.uploadPath}`, fileData, { bucket: paths.parsedBaseUploadPath.bucket });\n          // eslint-disable-next-line require-atomic-updates\n          CONFIG.DDBI.ADVENTURE.TEMPORARY.import[path] = true;\n        } else {\n          logger.debug(`File already imported ${path}`);\n        }\n\n        const returnPath = await utils.getFileUrl(paths.baseUploadPath, paths.returnFilePath);\n        return `${returnPath}`;\n      }\n    } catch (err) {\n      logger.error(`Error importing image file ${path} : ${err.message}`);\n    }\n\n    return path;\n  }\n\n  /**\n   * Async for each loop\n   *\n   * @param  {array} array - Array to loop through\n   * @param  {function} callback - Function to apply to each array item loop\n   */\n  static async asyncForEach(array, callback) {\n    for (let index = 0; index < array.length; index += 1) {\n      // eslint-disable-next-line callback-return, no-await-in-loop\n      await callback(array[index], index, array);\n    }\n  }\n\n  /**\n   * Attempts to find a compendium pack by name, if not found, create a new one based on item type\n   * @param  {string} type - Type of compendium\n   * @param  {string} name - Name of compendium\n   * @returns {object} - Compendium pack\n   */\n  static async getCompendiumPack(type, name) {\n    let pack = game.packs.find((p) => {\n      return p.metadata.label === name;\n    });\n\n    if (!pack) {\n      pack = await Compendium.create({ entity: type, label: name }, { keepId: true });\n    }\n\n    return pack;\n  }\n\n  /**\n   * Find an entity by the import key.\n   * @param  {string} type - Entity type to search for\n   * @param  {string} id - Entity Id\n   * @returns {object} - Entity Object Data\n   */\n  static findEntityByImportId(type, id) {\n    return game.data[type].find((item) => item._id === id);\n    // item.flags.importid === id\n  }\n\n\n  /**\n   * Async replace for all matching patterns\n   *\n   * @param  {string} str - Original string to replace values in\n   * @param  {string} regex - regex for matching\n   * @param  {function} asyncFn - async function to run on each match\n   * @returns {string}\n   */\n  static async replaceAsync(str, regex, asyncFn) {\n    const promises = [];\n    str.replace(regex, (match, ...args) => {\n      const promise = asyncFn(match, ...args);\n      promises.push(promise);\n    });\n    const data = await Promise.all(promises);\n    return str.replace(regex, () => data.shift());\n  }\n\n  /**\n   * Returns the difference between object 1 and 2\n   * @param  {object} obj1\n   * @param  {object} obj2\n   * @returns {object}\n   */\n  static diff(obj1, obj2) {\n    var result = {};\n    for (const key in obj1) {\n      if (obj2[key] != obj1[key]) result[key] = obj2[key];\n      // eslint-disable-next-line valid-typeof\n      if (typeof obj2[key] == 'array' && typeof obj1[key] == 'array')\n        result[key] = this.diff(obj1[key], obj2[key]);\n      if (typeof obj2[key] == 'object' && typeof obj1[key] == 'object')\n        result[key] = this.diff(obj1[key], obj2[key]);\n    }\n    return result;\n  }\n\n  /**\n   * Read data from a user provided File object\n   * @param {File} file           A File object\n   * @return {Promise.<String>}   A Promise which resolves to the loaded text data\n   */\n  static readBlobFromFile(file) {\n    const reader = new FileReader();\n    return new Promise((resolve, reject) => {\n      reader.onload = () => {\n        resolve(reader.result);\n      };\n      reader.onerror = () => {\n        reader.abort();\n        reject();\n      };\n      reader.readAsBinaryString(file);\n    });\n  }\n\n  static async importFolder(parentFolder, folders, adventure, folderList) {\n    await this.asyncForEach(folders, async (f) => {\n      let folderData = f;\n\n      let newFolder = game.folders.find((folder) => {\n        return (folder.data._id === folderData._id || folder.data.flags.importid === folderData._id) && folder.data.type === folderData.type;\n      });\n\n      if (!newFolder) {\n        if (folderData.parent !== null) {\n          folderData.parent = CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[folderData.parent];\n        } else if (adventure?.options?.folders) {\n          folderData.parent = CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[\"null\"];\n        } else {\n          folderData.parent = CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[folderData.type];\n        }\n\n        newFolder = await Folder.create(folderData, { keepId: true });\n        logger.debug(`Created new folder ${newFolder.data._id} with data:`, folderData, newFolder);\n      }\n\n      // eslint-disable-next-line require-atomic-updates\n      CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[folderData.flags.importid] = newFolder.data._id;\n\n      let childFolders = folderList.filter((folder) => {\n        return folder.parent === folderData._id;\n      });\n\n      if (childFolders.length > 0) {\n        await this.importFolder(newFolder, childFolders, adventure, folderList);\n      }\n    });\n  }\n\n  /**\n   * Replaces matchAll as it's not yet available in Electron App\n   * @param   {string} regex  RegEx to use\n   * @param   {string} string String to match on\n   * @returns {Array}\n   */\n  static reMatchAll(regexp, string) {\n    const matches = string.match(new RegExp(regexp, \"gm\"));\n    if (matches) {\n      let start = 0;\n      return matches.map((group0) => {\n        const match = group0.match(regexp);\n        match.index = string.indexOf(group0, start);\n        start = match.index;\n        return match;\n      });\n    }\n    return matches;\n  }\n\n  /**\n   * Uploads a file to Foundry without the UI Notification\n   * @param  {string} source\n   * @param  {string} path\n   * @param  {blog} file\n   * @param  {object} options\n   */\n  static async UploadFile(source, path, file, options) {\n    if (typeof ForgeVTT !== \"undefined\" && ForgeVTT?.usingTheForge) {\n      return Helpers.ForgeUploadFile(path, file);\n    }\n\n    const fd = new FormData();\n    fd.set(\"source\", source);\n    fd.set(\"target\", path);\n    fd.set(\"upload\", file);\n    Object.entries(options).forEach((o) => fd.set(...o));\n\n    const request = await fetch(FilePicker.uploadURL, { method: \"POST\", body: fd });\n    if (request.status === 413) {\n      return ui.notifications.error(game.i18n.localize(\"FILES.ErrorTooLarge\"));\n    } else if (request.status !== 200) {\n      return ui.notifications.error(game.i18n.localize(\"FILES.ErrorSomethingWrong\"));\n    }\n    return undefined;\n  }\n\n  /**\n   * Uploads a file to Forge Asset Library without the UI Notification\n   * @param  {string} source\n   * @param  {string} path\n   * @param  {blog} file\n   * @param  {object} options\n   */\n  static async ForgeUploadFile(path, file) {\n    const fd = new FormData();\n    fd.append(\"file\", file);\n    fd.append(\"path\", `${path}/${file.name}`);\n\n    const response = await ForgeAPI.call(\"assets/upload\", fd);\n    if (!response || response.error) {\n      ui.notifications.error(response ? response.error : \"An unknown error occured accessing The Forge API\");\n      return false;\n    } else {\n      return { path: response.url };\n    }\n  }\n\n  /**\n   * Browse files using FilePicker\n   * @param  {string} source\n   * @param  {string} target\n   * @param  {object} options={}\n   */\n  static async BrowseFiles(source, target, options = {}) {\n    if (typeof ForgeVTT !== \"undefined\" && ForgeVTT?.usingTheForge) {\n      if (target.startsWith(ForgeVTT.ASSETS_LIBRARY_URL_PREFIX)) source = \"forgevtt\";\n\n      if (source === \"forgevtt\") {\n        return Helpers.BrowseForgeFiles(source, target, options);\n      }\n    }\n\n    return FilePicker.browse(source, target, options);\n  }\n\n  /**\n   * Browse files using Forge API\n   * @param  {string} source\n   * @param  {string} target\n   * @param  {object} options={}\n   */\n  static async BrowseForgeFiles(source, target, options = {}) {\n    if (target.startsWith(ForgeVTT.ASSETS_LIBRARY_URL_PREFIX)) {\n      if (options.wildcard)\n        options.wildcard = target;\n      target = target.slice(ForgeVTT.ASSETS_LIBRARY_URL_PREFIX.length);\n      target = target.split(\"/\").slice(1, -1).join(\"/\"); // Remove userid from url to get target path\n    }\n\n    const response = await ForgeAPI.call('assets/browse', { path: decodeURIComponent(target), options });\n    if (!response || response.error) {\n      ui.notifications.error(response ? response.error : \"An unknown error occured accessing The Forge API\");\n      return { target, dirs: [], files: [], gridSize: null, private: false, privateDirs: [], extensions: options.extensions };\n    }\n    // Should be decodeURIComponent but FilePicker's _onPick needs to do encodeURIComponent too, but on each separate path.\n    response.target = decodeURI(response.folder);\n    delete response.folder;\n    response.dirs = response.dirs.map((d) => d.path.slice(0, -1));\n    response.files = response.files.map((f) => f.url);\n    // 0.5.6 specific\n    response.private = true;\n    response.privateDirs = [];\n    response.gridSize = null;\n    response.extensions = options.extensions;\n    return response;\n  }\n\n  static async loadMissingDocuments(type, docIds) {\n    return new Promise((resolve) => {\n      if (docIds && docIds.length > 0) {\n        switch (type) {\n          case \"item\":\n            logger.debug(`Importing missing ${type}s from DDB`, docIds);\n            AdventureMunch._progressNote(`Importing ${docIds.length} missing ${type}s from DDB`);\n            resolve(parseItems(docIds));\n            break;\n          case \"monster\": {\n            try {\n              const tier = game.settings.get(\"ddb-importer\", \"patreon-tier\");\n              const tiers = getPatreonTiers(tier);\n              if (tiers.all) {\n                logger.debug(`Importing missing ${type}s from DDB`, docIds);\n                AdventureMunch._progressNote(`Importing ${docIds.length} missing ${type}s from DDB`);\n                resolve(parseCritters(docIds));\n              } else {\n                logger.warn(`Unable to import missing ${type}s from DDB - link to patreon or use your own proxy`, docIds);\n                ui.notifications.warn(`Unable to import missing ${type}s from DDB - link to patreon or use your own proxy`, { permanent: true });\n                resolve([]);\n              }\n            } catch (err) {\n              if (err instanceof SyntaxError) {\n                ui.notifications.error(\"Error fetching monsters, likely cause outdated ddb-proxy\", { permanent: true });\n              } else {\n                throw err;\n              }\n            }\n            break;\n          }\n          case \"spell\":\n            logger.debug(`Importing missing ${type}s from DDB`);\n            AdventureMunch._progressNote(`Missing spells detected, importing from DDB`);\n            // we actually want all spells, because monsters don't just use spells from a single source\n            resolve(parseSpells());\n            break;\n          // no default\n        }\n      } else {\n        resolve([]);\n      }\n    });\n  }\n\n  static async getCompendiumIndex(type) {\n    return new Promise((resolve) => {\n      const compendium = getCompendiumType(type);\n      const fields = (type === \"monster\")\n        ? [\"flags.ddbimporter.id\"]\n        : [\"flags.ddbimporter.definitionId\"];\n\n      const compendiumIndex = compendium.getIndex({ fields: fields });\n      resolve(compendiumIndex);\n    });\n  }\n\n  static async checkForMissingDocuments(type, ids) {\n    const index = await Helpers.getCompendiumIndex(type);\n    // console.warn(`${type} index`, index);\n\n    return new Promise((resolve) => {\n      const missingIds = ids.filter((id) => {\n        switch (type) {\n          case \"monster\":\n            return !index.some((i) => i.flags?.ddbimporter?.id && String(i.flags.ddbimporter.id) == String(id));\n          case \"spell\":\n          case \"item\":\n            return !index.some((i) => i.flags?.ddbimporter?.definitionId && String(i.flags.ddbimporter.definitionId) == String(id));\n          default:\n            return false;\n        }\n      });\n      const missingDocuments = Helpers.loadMissingDocuments(type, missingIds);\n      // console.warn(`${type} missing`, missingDocuments);\n      resolve(missingDocuments);\n    });\n  }\n\n  static async linkExistingActorTokens(tokens) {\n    const monsterIndex = await Helpers.getCompendiumIndex(\"monster\");\n\n    const newTokens = tokens.map((token) => {\n      const monsterHit = monsterIndex.find((monster) =>\n        monster.flags?.ddbimporter?.id && token.flags.ddbActorFlags?.id &&\n        monster.flags.ddbimporter.id === token.flags.ddbActorFlags.id);\n      if (monsterHit) {\n        token.flags.compendiumActorId = monsterHit._id;\n      }\n      return token;\n    });\n\n    return newTokens;\n  }\n\n  static foundryCompendiumReplace(text) {\n    // replace the ddb:// entries with known compendium look ups if we have them\n    // ddb://spells\n    // ddb://magicitems || weapons || adventuring-gear || armor\n    // ddb://monsters\n\n    let doc = utils.htmlToDoc(text);\n\n    const lookups = CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups.lookups;\n\n    for (const lookupKey in COMPENDIUM_MAP) {\n      const compendiumLinks = doc.querySelectorAll(`a[href*=\"ddb://${lookupKey}/\"]`);\n      logger.debug(`replacing ${lookupKey} references`, compendiumLinks);\n\n      const lookupRegExp = new RegExp(`ddb://${lookupKey}/([0-9]*)`);\n      compendiumLinks.forEach((node) => {\n        const lookupMatch = node.outerHTML.match(lookupRegExp);\n        const lookupValue = lookups[COMPENDIUM_MAP[lookupKey]];\n\n        if (lookupValue) {\n          const lookupEntry = lookupValue.find((e) => e.id == lookupMatch[1]);\n          if (lookupEntry) {\n            const documentRef = lookupEntry.documentName ? lookupEntry.documentName : lookupEntry._id;\n            doc.body.innerHTML = doc.body.innerHTML.replace(node.outerHTML, `@Compendium[${lookupEntry.compendium}.${documentRef}]{${node.textContent}}`);\n          } else {\n            logger.warn(`NO Lookup Compendium Entry for ${node.outerHTML}`);\n          }\n        }\n      });\n    }\n\n    // vehicles - not yet handled, links to DDB\n    const compendiumLinks = doc.querySelectorAll(\"a[href*=\\\"ddb://vehicles/\\\"]\");\n    const lookupRegExp = /ddb:\\/\\/vehicles\\/([0-9]*)/g;\n    compendiumLinks.forEach((node) => {\n      const target = node.outerHTML;\n      const lookupMatch = node.outerHTML.match(lookupRegExp);\n      const lookupValue = lookups[\"vehicles\"];\n      if (lookupMatch) {\n        const lookupEntry = lookupValue.find((e) => e.id == lookupMatch[1]);\n        if (lookupEntry) {\n          node.setAttribute(\"href\", `https://www.dndbeyond.com${lookupEntry.url}`);\n          doc.body.innerHTML = doc.body.innerHTML.replace(target, node.outerHTML);\n        } else {\n          logger.warn(`NO Vehicle Lookup Entry for ${node.outerHTML}`);\n        }\n      } else {\n        logger.warn(`NO Vehicle Lookup Match for ${node.outerHTML}`);\n      }\n    });\n\n    // final replace in case of failure\n    // there is a chance that the adventure references items or monsters we don't have access to\n    // in this case attempt to link to DDB instead of compendium doc\n    for (const lookupKey in COMPENDIUM_MAP) {\n      const compendiumLinks = doc.querySelectorAll(`a[href*=\"ddb://${lookupKey}/\"]`);\n      logger.debug(`final replace for missing ${lookupKey} references`, compendiumLinks);\n\n      compendiumLinks.forEach((node) => {\n        const target = node.outerHTML;\n        const ddbStub = DDB_MAP[lookupKey];\n        const ddbNameGuess = node.textContent.toLowerCase().replace(\" \", \"-\").replace(/[^0-9a-z-]/gi, '');\n        logger.warn(`No Compendium Entry for ${node.outerHTML} attempting to guess a link to DDB`);\n\n        node.setAttribute(\"href\", `https://www.dndbeyond.com/${ddbStub}/${ddbNameGuess}`);\n        doc.body.innerHTML = doc.body.innerHTML.replace(target, node.outerHTML);\n      });\n    }\n\n    return doc.body.innerHTML;\n  }\n\n  static async linkDDBActors(tokens) {\n    const linkedExistingTokens = await Helpers.linkExistingActorTokens(tokens);\n    const newTokens = linkedExistingTokens\n      .filter((token) => token.flags.ddbActorFlags?.id && token.flags.compendiumActorId);\n\n    return Promise.all(newTokens);\n  }\n\n  static async generateTokenActors(scene) {\n    const monsterCompendium = checkMonsterCompendium();\n\n    const tokens = await Helpers.linkDDBActors(scene.tokens);\n\n    const neededActors = tokens\n      .map((token) => {\n        return { name: token.name, ddbId: token.flags.ddbActorFlags.id, actorId: token.actorId, compendiumId: token.flags.compendiumActorId, folderId: token.flags.actorFolderId };\n      })\n      .filter((obj, pos, arr) => {\n        // we only need to create 1 actor per actorId\n        return arr.map((mapObj) => mapObj[\"actorId\"]).indexOf(obj[\"actorId\"]) === pos;\n      });\n\n    logger.debug(\"Trying to import actors from compendium\", neededActors);\n    await Helpers.asyncForEach(neededActors, async (actor) => {\n      let worldActor = game.actors.get(actor.actorId);\n      if (!worldActor) {\n        logger.info(`Importing actor ${actor.name} with DDB ID ${actor.ddbId} from ${monsterCompendium.metadata.name} with id ${actor.compendiumId}`);\n        try {\n          worldActor = await game.actors.importFromCompendium(monsterCompendium, actor.compendiumId, { _id: actor.actorId, folder: actor.folderId }, { keepId: true });\n        } catch (err) {\n          logger.error(err);\n          logger.warn(`Unable to import actor ${actor.name} with id ${actor.compendiumId} from DDB Compendium`);\n          logger.debug(`Failed on: game.actors.importFromCompendium(monsterCompendium, \"${actor.compendiumId}\", { _id: \"${actor.actorId}\", folder: \"${actor.folderId}\" }, { keepId: true });`);\n        }\n      }\n    });\n\n    logger.debug(\"Actors transferred from compendium to world.\");\n\n  }\n\n  // check the document for version data and for update info to see if we can replace it\n  static extractDocumentVersionData(newDoc, existingDoc, ddbIVersion) {\n    if (!existingDoc) existingDoc = {};\n    // do we have versioned metadata?\n    setProperty(newDoc, \"flags.ddb.versions.importer\", {});\n    if (newDoc?.flags?.ddb?.versions?.ddbMetaData?.lastUpdate) {\n      // check old data, it might not exist\n      const oldDDBMetaDataVersions = existingDoc.data?.flags?.ddb?.versions?.ddbMetaData?.lastUpdate\n        ? existingDoc.data.flags.ddb.versions.ddbMetaData\n        : {\n          lastUpdate: \"0.0.1\",\n          drawings: \"0.0.1\",\n          notes: \"0.0.1\",\n          tokens: \"0.0.1\",\n          walls: \"0.0.1\",\n          lights: \"0.0.1\",\n          foundry: \"0.8.9\",\n        };\n      const oldDDBImporterVersion = existingDoc.data?.flags?.ddb?.versions?.ddbImporter\n        ? existingDoc.data.flags.ddb.versions.ddbImporter\n        : \"2.0.1\";\n      const oldAdventureMuncherVersion = existingDoc.data?.flags?.ddb?.versions?.adventureMuncher\n        ? existingDoc.data.flags.ddb.versions.adventureMuncher\n        : \"0.3.0\";\n      const foundryVersion = game.version ? game.version : game.data.version;\n      const oldVersions = { ddbImporter: oldDDBImporterVersion, ddbMetaData: oldDDBMetaDataVersions, adventureMuncher: oldAdventureMuncherVersion };\n\n      const documentVersions = newDoc.flags.ddb.versions;\n      const documentFoundryVersion = documentVersions[\"ddbMetaData\"][\"foundry\"] !== undefined ? documentVersions[\"ddbMetaData\"][\"foundry\"] : \"0.8.9\";\n      const importerVersionChanged = isNewerVersion(ddbIVersion, oldVersions[\"ddbImporter\"]);\n      const metaVersionChanged = isNewerVersion(documentVersions[\"ddbMetaData\"][\"lastUpdate\"], oldVersions[\"ddbMetaData\"][\"lastUpdate\"]);\n      const muncherVersionChanged = isNewerVersion(documentVersions[\"adventureMuncher\"], oldVersions[\"adventureMuncher\"]);\n      const foundryVersionNewer = isNewerVersion(documentFoundryVersion, foundryVersion);\n\n      let versionUpdates = {};\n\n      if (metaVersionChanged || muncherVersionChanged || foundryVersionNewer) {\n        versionUpdates.oldVersions = oldVersions;\n        versionUpdates.importerVersionChanged = importerVersionChanged;\n        versionUpdates.metaVersionChanged = metaVersionChanged;\n        versionUpdates.muncherVersionChanged = muncherVersionChanged;\n        versionUpdates.foundryVersionNewer = foundryVersionNewer;\n        versionUpdates.drawingVersionChanged = isNewerVersion(documentVersions[\"ddbMetaData\"][\"drawings\"], oldVersions[\"ddbMetaData\"][\"drawings\"]);\n        versionUpdates.noteVersionChanged = isNewerVersion(documentVersions[\"ddbMetaData\"][\"notes\"], oldVersions[\"ddbMetaData\"][\"notes\"]);\n        versionUpdates.tokenVersionChanged = isNewerVersion(documentVersions[\"ddbMetaData\"][\"tokens\"], oldVersions[\"ddbMetaData\"][\"tokens\"]);\n        versionUpdates.wallVersionChanged = isNewerVersion(documentVersions[\"ddbMetaData\"][\"walls\"], oldVersions[\"ddbMetaData\"][\"walls\"]);\n        versionUpdates.lightVersionChanged = isNewerVersion(documentVersions[\"ddbMetaData\"][\"lights\"], oldVersions[\"ddbMetaData\"][\"lights\"]);\n      }\n      setProperty(newDoc, \"flags.ddb.versions.importer\", versionUpdates);\n    }\n    return newDoc;\n  }\n\n  static getImportType(type) {\n    const typeName = type[0].toUpperCase() + type.slice(1);\n    let importType = typeName;\n\n    switch (type) {\n      case \"journal\":\n        importType = \"JournalEntry\";\n        break;\n      case \"table\":\n        importType = \"RollTable\";\n        break;\n      default:\n        importType = typeName;\n        break;\n    }\n\n    return importType;\n  }\n\n  static folderExists(folder, zip) {\n    const files = Object.values(zip.files).filter((file) => {\n      return file.dir && file.name.toLowerCase().includes(folder);\n    });\n\n    return files.length > 0;\n  }\n\n  static getFiles(folder, zip) {\n    const files = Object.values(zip.files).filter((file) => {\n      return !file.dir && file.name.split('.').pop() === 'json' && file.name.includes(`${folder}/`);\n    });\n\n    return files;\n  }\n\n\n}\n","import Helpers from \"./common.js\";\nimport logger from \"../../logger.js\";\nimport { generateAdventureConfig } from \"../adventure.js\";\nimport { DirectoryPicker } from \"../../lib/DirectoryPicker.js\";\n\nexport default class AdventureMunch extends FormApplication {\n  /** @override */\n  constructor(object = {}, options = {}) {\n    super(object, options);\n    this._itemsToRevisit = [];\n    const importPathData = game.settings.get(\"ddb-importer\", \"adventure-import-path\");\n    this._importPathData = DirectoryPicker.parse(importPathData);\n  }\n\n  /** @override */\n  static get defaultOptions() {\n    this.pattern = /(@[a-z]*)(\\[)([a-z0-9]*|[a-z0-9.]*)(\\])(\\{)(.*?)(\\})/gmi;\n    this.altpattern = /((data-entity)=\\\\?[\"']?([a-zA-Z]*)\\\\?[\"']?|(data-pack)=\\\\?[\"']?([[\\S.]*)\\\\?[\"']?) data-id=\\\\?[\"']?([a-zA-Z0-9]*)\\\\?[\"']?.*?>(.*?)<\\/a>/gmi;\n\n    return mergeObject(super.defaultOptions, {\n      id: \"ddb-adventure-import\",\n      classes: [\"ddb-adventure-import\"],\n      title: \"Adventure Munch\",\n      template: \"modules/ddb-importer/handlebars/adventure/import.hbs\",\n      width: 350,\n    });\n  }\n\n  /** @override */\n  // eslint-disable-next-line class-methods-use-this\n  async getData() {\n    let data;\n    let files = [];\n\n    try {\n      // const parsedDirectory = DirectoryPicker.parse(this._importPathData);\n      const verifiedDirectory = await DirectoryPicker.verifyPath(this._importPathData);\n      if (verifiedDirectory) {\n        const options = { bucket: this._importPathData.bucket, extensions: [\".fvttadv\", \".FVTTADV\", \".zip\"], wildcard: false };\n        data = await Helpers.BrowseFiles(this._importPathData.activeSource, this._importPathData.current, options);\n        files = data.files.map((file) => {\n          const filename = decodeURIComponent(file).replace(/^.*[\\\\/]/, '');\n\n          return { path: decodeURIComponent(file), name: filename };\n        });\n      }\n    } catch (err) {\n      logger.error(err);\n      logger.warn(`Unable to verify import path, this may be due to permissions on the server. You may be able to ignore this message.`);\n    }\n\n    return {\n      data,\n      files,\n      cssClass: \"ddb-importer-window\"\n    };\n\n  }\n\n  static async _createFolders(adventure, folders) {\n    if (folders) {\n      const maintainFolders = adventure?.options?.folders;\n      let itemFolder = null;\n      if (!maintainFolders) {\n        const importTypes = [\"Scene\", \"Actor\", \"Item\", \"JournalEntry\", \"RollTable\"];\n        await Helpers.asyncForEach(importTypes, async (importType) => {\n          itemFolder = game.folders.find((folder) => {\n            return folder.data.name === adventure.name && folder.data.type === importType;\n          });\n\n          if (!itemFolder) {\n            logger.debug(`Creating folder ${adventure.name} - ${importType}`);\n\n            // eslint-disable-next-line require-atomic-updates\n            itemFolder = await Folder.create({\n              color: adventure.folderColour ? adventure.folderColour : \"#FF0000\",\n              name: adventure.name,\n              parent: null,\n              type: importType\n            }, { keepId: true });\n          }\n\n          CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[importType] = itemFolder.data._id;\n        });\n      } else {\n        CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[\"null\"] = null;\n        CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups = null;\n      }\n\n      // the folder list could be out of order, we need to create all folders with parent null first\n      const firstLevelFolders = folders.filter((folder) => folder.parent === null);\n      await Helpers.importFolder(itemFolder, firstLevelFolders, adventure, folders);\n    }\n  }\n\n  /** @override */\n  activateListeners(html) {\n    super.activateListeners(html);\n\n    html.find(\".dialog-button\").on(\"click\", this._dialogButton.bind(this));\n  }\n\n  static async _checkForMissingData(adventure, folders) {\n    await AdventureMunch._createFolders(adventure, folders);\n\n    if (adventure.required?.spells && adventure.required.spells.length > 0) {\n      logger.debug(`${adventure.name} - spells required`, adventure.required.spells);\n      AdventureMunch._progressNote(`Checking for missing spells from DDB`);\n      await Helpers.checkForMissingDocuments(\"spell\", adventure.required.spells);\n    }\n    if (adventure.required?.items && adventure.required.items.length > 0) {\n      logger.debug(`${adventure.name} - items required`, adventure.required.items);\n      AdventureMunch._progressNote(`Checking for missing items from DDB`);\n      await Helpers.checkForMissingDocuments(\"item\", adventure.required.items);\n    }\n    if (adventure.required?.monsters && adventure.required.monsters.length > 0) {\n      logger.debug(`${adventure.name} - monsters required`, adventure.required.monsters);\n      AdventureMunch._progressNote(`Checking for missing monsters from DDB`);\n      await Helpers.checkForMissingDocuments(\"monster\", adventure.required.monsters);\n    }\n  }\n\n  async _importFiles(adventure, zip) {\n    if (Helpers.folderExists(\"scene\", zip)) {\n      logger.debug(`${adventure.name} - Loading scenes`);\n      await this._checkForDataUpdates(\"scene\", zip, adventure);\n    }\n    if (Helpers.folderExists(\"actor\", zip)) {\n      logger.debug(`${adventure.name} - Loading actors`);\n      await this._importFile(\"actor\", zip, adventure);\n    }\n    if (Helpers.folderExists(\"item\", zip)) {\n      logger.debug(`${adventure.name} - Loading item`);\n      await this._importFile(\"item\", zip, adventure);\n    }\n    if (Helpers.folderExists(\"journal\", zip)) {\n      logger.debug(`${adventure.name} - Loading journal`);\n      await this._importFile(\"journal\", zip, adventure);\n    }\n    if (Helpers.folderExists(\"table\", zip)) {\n      logger.debug(`${adventure.name} - Loading table`);\n      await this._importFile(\"table\", zip, adventure);\n    }\n    if (Helpers.folderExists(\"playlist\", zip)) {\n      logger.debug(`${adventure.name} - Loading playlist`);\n      await this._importFile(\"playlist\", zip, adventure);\n    }\n    if (Helpers.folderExists(\"compendium\", zip)) {\n      logger.debug(`${adventure.name} - Loading compendium`);\n      await this._importCompendium(\"compendium\", zip, adventure);\n    }\n    if (Helpers.folderExists(\"macro\", zip)) {\n      logger.debug(`${adventure.name} - Loading macro`);\n      await this._importFile(\"macro\", zip, adventure);\n    }\n  }\n\n  static _renderCompleteDialog(title, adventure) {\n    new Dialog(\n      {\n        title: title,\n        content: { adventure },\n        buttons: { two: { label: \"OK\" } },\n      },\n      {\n        classes: [\"dialog\", \"adventure-import-export\"],\n        template: \"modules/ddb-importer/handlebars/adventure/import-complete.hbs\",\n      }\n    ).render(true);\n  }\n\n  async _revisitItems(adventure) {\n    try {\n      if (this._itemsToRevisit.length > 0) {\n        let totalCount = this._itemsToRevisit.length;\n        let currentCount = 0;\n\n        await Helpers.asyncForEach(this._itemsToRevisit, async (item) => {\n          const toTimer = setTimeout(() => {\n            logger.warn(`Reference update timed out.`);\n            AdventureMunch._renderCompleteDialog(`Successful Import of ${adventure.name}`, adventure);\n            this.close();\n          }, 60000);\n          try {\n            const obj = await fromUuid(item);\n            // let rawData;\n            let updatedData = {};\n            switch (obj.documentName) {\n              case \"Scene\": {\n                const scene = JSON.parse(JSON.stringify(obj.data));\n                // this is a scene we need to update links to all items\n                logger.info(`Updating ${scene.name}, ${scene.tokens.length} tokens`);\n                let deadTokenIds = [];\n                await Helpers.asyncForEach(scene.tokens, async (token) => {\n                  if (token.actorId) {\n                    const sceneToken = scene.flags.ddb.tokens.find((t) => t._id === token._id);\n                    delete sceneToken.scale;\n                    const worldActor = game.actors.get(token.actorId);\n                    if (worldActor) {\n                      const tokenData = await worldActor.getTokenData();\n                      delete tokenData.y;\n                      delete tokenData.x;\n                      const jsonTokenData = JSON.parse(JSON.stringify(tokenData));\n                      const updateData = mergeObject(jsonTokenData, sceneToken);\n                      logger.debug(`${token.name} token data for id ${token.actorId}`, updateData);\n                      await obj.updateEmbeddedDocuments(\"Token\", [updateData], { keepId: true });\n                    } else {\n                      deadTokenIds.push(token._id);\n                    }\n                  } else {\n                    deadTokenIds.push(token._id);\n                  }\n                });\n                // remove a token from the scene if we have not been able to link it\n                if (deadTokenIds.length > 0) {\n                  logger.warn(`Removing ${scene.name} tokens with no world actors`, deadTokenIds);\n                  await obj.deleteEmbeddedDocuments(\"Token\", deadTokenIds);\n                }\n\n                // In 0.8.x the thumbs don't seem to be generated.\n                // This code would embed the thumbnail.\n                // Consider writing this out.\n                if (!obj.data.thumb) {\n                  const thumbData = await obj.createThumbnail();\n                  updatedData[\"thumb\"] = thumbData.thumb;\n                }\n                await obj.update(updatedData);\n                break;\n              }\n              // no default\n            }\n          } catch (err) {\n            logger.warn(`Error updating references for object ${item}`, err);\n          }\n          currentCount += 1;\n          AdventureMunch._updateProgress(totalCount, currentCount, \"References\");\n          clearTimeout(toTimer);\n        });\n      }\n    } catch (err) {\n      // eslint-disable-next-line no-undef\n      logger.warn(`Error during reference update for object ${item}`, err);\n    }\n  }\n\n  async _dialogButton(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    const a = event.currentTarget;\n    const action = a.dataset.button;\n\n    if (action === \"import\") {\n      let importFilename;\n      try {\n        $(\".import-progress\").toggleClass(\"import-hidden\");\n        $(\".ddb-overlay\").toggleClass(\"import-invalid\");\n\n        const form = $(\"form.ddb-importer-window\")[0];\n\n        let zip;\n        if (form.data.files.length) {\n          importFilename = form.data.files[0].name;\n          zip = await Helpers.readBlobFromFile(form.data.files[0]).then(JSZip.loadAsync);\n        } else {\n          const selectedFile = $(\"#import-file\").val();\n          importFilename = selectedFile;\n          zip = await fetch(`/${selectedFile}`)\n            .then((response) => {\n              if (response.status === 200 || response.status === 0) {\n                return Promise.resolve(response.blob());\n              } else {\n                return Promise.reject(new Error(response.statusText));\n              }\n            })\n            .then(JSZip.loadAsync);\n        }\n\n        const adventure = JSON.parse(await zip.file(\"adventure.json\").async(\"text\"));\n        let folders;\n        try {\n          folders = JSON.parse(await zip.file(\"folders.json\").async(\"text\"));\n        } catch (err) {\n          logger.warn(`Folder structure file not found.`);\n        }\n\n        if (adventure.system !== game.data.system.data.name) {\n          ui.notifications.error(`Invalid system for Adventure ${adventure.name}.  Expects ${adventure.system}`);\n          throw new Error(`Invalid system for Adventure ${adventure.name}.  Expects ${adventure.system}`);\n        }\n\n        CONFIG.DDBI.ADVENTURE.TEMPORARY = {\n          folders: {},\n          import: {},\n          actors: {},\n          sceneTokens: {},\n        };\n\n        await AdventureMunch._checkForMissingData(adventure, folders);\n\n        // now we have imported all missing data, generate the lookup data\n        CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups = await generateAdventureConfig();\n        logger.debug(\"Lookups loaded\", CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups.lookups);\n\n        await this._importFiles(adventure, zip);\n        await this._revisitItems(adventure);\n\n        $(\".ddb-overlay\").toggleClass(\"import-invalid\");\n\n        AdventureMunch._renderCompleteDialog(`Successful Import of ${adventure.name}`, adventure);\n\n        // eslint-disable-next-line require-atomic-updates\n        CONFIG.DDBI.ADVENTURE.TEMPORARY = {};\n        this.close();\n      } catch (err) {\n        $(\".ddb-overlay\").toggleClass(\"import-invalid\");\n        ui.notifications.error(`There was an error importing ${importFilename}`);\n        logger.error(`Error importing file ${importFilename}`, err);\n        this.close();\n      }\n    }\n  }\n\n  async _importCompendium(type, zip, adventure) {\n    let totalCount = 0;\n    let currentCount = 0;\n    const typeName = type[0].toUpperCase() + type.slice(1);\n    const dataFiles = Helpers.getFiles(type, zip);\n    logger.info(`Importing ${adventure.name} - ${typeName} (${dataFiles.length} items)`);\n    totalCount = dataFiles.length;\n\n    await Helpers.asyncForEach(dataFiles, async (file) => {\n      const rawData = await zip.file(file.name).async(\"text\");\n      const data = JSON.parse(rawData);\n\n      let pack = await Helpers.getCompendiumPack(data.info.entity, data.info.label);\n      await pack.getIndex();\n\n      totalCount += data.items.length;\n      await Helpers.asyncForEach(data.items, async (item) => {\n        let obj;\n        let entry = pack.index.find((e) => e.name === item.name);\n\n        item.flags.importid = item._id;\n\n        if (item.img) {\n          // eslint-disable-next-line require-atomic-updates\n          item.img = await Helpers.importImage(item.img, zip, adventure);\n        }\n        if (item.thumb) {\n          // eslint-disable-next-line require-atomic-updates\n          item.thumb = await Helpers.importImage(item.thumb, zip, adventure);\n        }\n        if (item?.token?.img) {\n          // eslint-disable-next-line require-atomic-updates\n          item.token.img = await Helpers.importImage(item.token.img, zip, adventure);\n        }\n\n        if (item?.items?.length) {\n          await Helpers.asyncForEach(data.items, async (i) => {\n            if (i.img) {\n              // eslint-disable-next-line require-atomic-updates\n              i.img = await Helpers.importImage(i.img, zip, adventure);\n            }\n          });\n        }\n\n        switch (data.info.entity) {\n          case \"Item\":\n            obj = new Item(item, { temporary: true });\n            break;\n          case \"Actor\":\n            obj = new Actor(item, { temporary: true });\n            break;\n          case \"Scene\":\n            obj = new Scene(item, { temporary: true });\n            break;\n          case \"JournalEntry\":\n            obj = new JournalEntry(item, { temporary: true });\n            break;\n          case \"Macro\":\n            obj = new Macro(item, { temporary: true });\n            break;\n          case \"RollTable\":\n            await Helpers.asyncForEach(item.results, async (result) => {\n              // eslint-disable-next-line require-atomic-updates\n              result.img = await Helpers.importImage(result.img, zip, adventure);\n            });\n            obj = new RollTable(item, { temporary: true });\n            break;\n          case \"Playlist\":\n            await Helpers.asyncForEach(item.sounds, async (sound) => {\n              // eslint-disable-next-line require-atomic-updates\n              sound.path = await Helpers.importImage(sound.path, zip, adventure);\n            });\n            obj = new Playlist(item, { temporary: true });\n            break;\n          // no default\n        }\n\n        if (!entry) {\n          let compendiumItem = await pack.importDocument(obj);\n\n          if (JSON.stringify(item).match(this.pattern) || JSON.stringify(item).match(this.altpattern)) {\n            this._itemsToRevisit.push(`Compendium.${pack.metadata.package}.${pack.metadata.name}.${compendiumItem.data._id}`);\n          }\n        }\n        currentCount += 1;\n        AdventureMunch._updateProgress(totalCount, currentCount, typeName);\n      });\n      currentCount += 1;\n      AdventureMunch._updateProgress(totalCount, currentCount, typeName);\n    });\n  }\n\n  // import a scene file\n  async _importRenderedSceneFile(adventure, typeName, data, zip, needRevisit, overwriteIds, overwriteEntity) {\n    if (!Helpers.findEntityByImportId(\"scenes\", data._id) || overwriteEntity) {\n      await Helpers.asyncForEach(data.tokens, async (token) => {\n        // eslint-disable-next-line require-atomic-updates\n        if (token.img) token.img = await Helpers.importImage(token.img, zip, adventure);\n      });\n\n      await Helpers.asyncForEach(data.sounds, async (sound) => {\n        // eslint-disable-next-line require-atomic-updates\n        sound.path = await Helpers.importImage(sound.path, zip, adventure);\n      });\n\n      await Helpers.asyncForEach(data.notes, async (note) => {\n        // eslint-disable-next-line require-atomic-updates\n        note.icon = await Helpers.importImage(note.icon, zip, adventure, true);\n      });\n\n      await Helpers.asyncForEach(data.tiles, async (tile) => {\n        // eslint-disable-next-line require-atomic-updates\n        tile.img = await Helpers.importImage(tile.img, zip, adventure);\n      });\n\n      if (overwriteEntity) await Scene.deleteDocuments([data._id]);\n      const scene = await Scene.create(data, { keepId: true });\n      this._itemsToRevisit.push(`Scene.${scene.data._id}`);\n    }\n  }\n\n  async _importRenderedFile(adventure, typeName, data, zip, needRevisit, overwriteIds) {\n    const overwriteEntity = overwriteIds.includes(data._id);\n    switch (typeName) {\n      case \"Scene\": {\n        await this._importRenderedSceneFile(adventure, typeName, data, zip, needRevisit, overwriteIds, overwriteEntity);\n        break;\n      }\n      case \"Actor\":\n        if (!Helpers.findEntityByImportId(\"actors\", data._id)) {\n          let actor = await Actor.create(data, { keepId: true });\n          await actor.update({ [`data.token.actorId`]: actor.data._id });\n          if (needRevisit) {\n            this._itemsToRevisit.push(`Actor.${actor.data._id}`);\n          }\n        }\n        break;\n      case \"Item\":\n        if (!Helpers.findEntityByImportId(\"items\", data._id)) {\n          let item = await Item.create(data, { keepId: true });\n          if (needRevisit) {\n            this._itemsToRevisit.push(`Item.${item.data._id}`);\n          }\n        }\n        break;\n      case \"JournalEntry\":\n        if (!Helpers.findEntityByImportId(\"journal\", data._id)) {\n          let journal = await JournalEntry.create(data, { keepId: true });\n          if (needRevisit) {\n            this._itemsToRevisit.push(`JournalEntry.${journal.data._id}`);\n          }\n        }\n        break;\n      case \"RollTable\":\n        if (!Helpers.findEntityByImportId(\"tables\", data._id)) {\n          let rolltable = await RollTable.create(data, { keepId: true });\n          if (needRevisit) {\n            this._itemsToRevisit.push(`RollTable.${rolltable.data._id}`);\n          }\n        }\n        break;\n      case \"Playlist\":\n        if (!Helpers.findEntityByImportId(\"playlists\", data._id)) {\n          data.name = `${adventure.name}.${data.name}`;\n          await Playlist.create(data, { keepId: true });\n        }\n        break;\n      case \"Macro\":\n        if (!Helpers.findEntityByImportId(\"macros\", data._id)) {\n          let macro = await Macro.create(data, { keepId: true });\n          if (needRevisit) {\n            this._itemsToRevisit.push(`Macro.${macro.data._id}`);\n          }\n        }\n        break;\n      // no default\n    }\n  }\n\n  async _checkForDataUpdates(type, zip, adventure) {\n    const importType = Helpers.getImportType(type);\n    const dataFiles = Helpers.getFiles(type, zip);\n\n    logger.info(`Checking ${adventure.name} - ${importType} (${dataFiles.length} for updates)`);\n\n    let fileData = [];\n    let hasVersions = false;\n    const moduleInfo = game.modules.get(\"ddb-importer\").data;\n    const installedVersion = moduleInfo.version;\n\n    await Helpers.asyncForEach(dataFiles, async (file) => {\n      const raw = await zip.file(file.name).async(\"text\");\n      const json = JSON.parse(raw);\n      if (!hasVersions && json?.flags?.ddb?.versions) {\n        hasVersions = true;\n      }\n      switch (importType) {\n        case \"Scene\": {\n          const existingScene = await game.scenes.find((item) => item.data._id === json._id);\n          const scene = Helpers.extractDocumentVersionData(json, existingScene, installedVersion);\n          const sceneVersions = scene.flags?.ddb?.versions?.importer;\n          if (existingScene) {\n            if (sceneVersions && (sceneVersions.metaVersionChanged || sceneVersions.muncherVersionChanged || sceneVersions.foundryVersionNewer)) {\n              fileData.push(scene);\n            }\n          } else if (sceneVersions && sceneVersions.foundryVersionNewer) {\n            fileData.push(scene);\n          }\n          break;\n        }\n        // no default\n      }\n    });\n\n    return new Promise((resolve) => {\n      if (hasVersions && fileData.length > 0) {\n        new Dialog(\n          {\n            title: `${importType} updates`,\n            content: {\n              \"dataType\": type,\n              \"dataTypeDisplay\": importType,\n              \"fileData\": fileData,\n              \"cssClass\": \"import-data-updates\"\n            },\n            buttons: {\n              confirm: {\n                label: \"Confirm\",\n                callback: async () => {\n                  const formData = $('.import-data-updates').serializeArray();\n                  let ids = [];\n                  let dataType = \"\";\n                  for (let i = 0; i < formData.length; i++) {\n                    const key = formData[i].name;\n                    if (key.startsWith(\"new_\")) {\n                      ids.push(key.substr(4));\n                    } else if (key === \"type\") {\n                      dataType = formData[i].value;\n                    }\n                  }\n                  resolve(this._importFile(dataType, zip, adventure, ids));\n                }\n              },\n            },\n            default: \"confirm\",\n            close: async () => {\n              resolve(this._importFile(type, zip, adventure));\n            },\n          },\n          {\n            width: 700,\n            classes: [\"dialog\", \"adventure-import-updates\"],\n            template: \"modules/ddb-importer/handlebars/adventure/import-updates.hbs\",\n          }\n        ).render(true);\n      } else {\n        resolve(this._importFile(type, zip, adventure));\n      }\n    });\n\n  }\n\n  async _importFile(type, zip, adventure, overwriteIds = []) {\n    let totalCount = 0;\n    let currentCount = 0;\n\n    logger.info(`IDs to overwrite of type ${type}: ${JSON.stringify(overwriteIds)}`);\n\n    const importType = Helpers.getImportType(type);\n    const dataFiles = Helpers.getFiles(type, zip);\n\n    logger.info(`Importing ${adventure.name} - ${importType} (${dataFiles.length} items)`);\n\n    totalCount = dataFiles.length;\n\n    await Helpers.asyncForEach(dataFiles, async (file) => {\n      const rawdata = await zip.file(file.name).async(\"text\");\n      const data = JSON.parse(rawdata);\n\n      let needRevisit = false;\n\n      // let pattern = /(\\@[a-z]*)(\\[)([a-z0-9]*|[a-z0-9\\.]*)(\\])/gmi\n      if (rawdata.match(this.pattern) || rawdata.match(this.altpattern)) {\n        needRevisit = true;\n      }\n\n      if (data.img) {\n        // eslint-disable-next-line require-atomic-updates\n        data.img = await Helpers.importImage(data.img, zip, adventure);\n      }\n      if (data.thumb) {\n        // eslint-disable-next-line require-atomic-updates\n        data.thumb = await Helpers.importImage(data.thumb, zip, adventure);\n      }\n      if (data?.token?.img) {\n        if (data?.token?.randomImg) {\n          const imgFilepaths = data.token.img.split(\"/\");\n          const imgFilename = (imgFilepaths.reverse())[0];\n          const imgFilepath = data.token.img.replace(imgFilename, \"\");\n\n          const filesToUpload = Object.values(zip.files).filter((file) => {\n            return !file.dir && file.name.includes(imgFilepath);\n          });\n\n          let adventurePath = (adventure.name).replace(/[^a-z0-9]/gi, '_');\n\n          data.token.img = `${this._importPathData.current}/${adventurePath}/${data.token.img}`;\n\n          if (filesToUpload.length > 0) {\n            totalCount += filesToUpload.length;\n\n            await Helpers.asyncForEach(filesToUpload, async (file) => {\n              await Helpers.importImage(file.name, zip, adventure);\n              currentCount += 1;\n              AdventureMunch._updateProgress(totalCount, currentCount, importType);\n            });\n          }\n\n        } else {\n          // eslint-disable-next-line require-atomic-updates\n          data.token.img = await Helpers.importImage(data.token.img, zip, adventure);\n        }\n      }\n\n      if (data?.items?.length) {\n        await Helpers.asyncForEach(data.items, async (item) => {\n          if (item.img) {\n            // eslint-disable-next-line require-atomic-updates\n            item.img = await Helpers.importImage(item.img, zip, adventure);\n          }\n        });\n      }\n\n      if (importType === \"Scene\") {\n        if (data.tokens) {\n          await Helpers.generateTokenActors(data);\n        }\n      } else if (importType === \"Playlist\") {\n        await Helpers.asyncForEach(data.sounds, async (sound) => {\n          if (sound.path) {\n            // eslint-disable-next-line require-atomic-updates\n            sound.path = await Helpers.importImage(sound.path, zip, adventure);\n          }\n        });\n      } else if (importType === \"RollTable\") {\n        await Helpers.asyncForEach(data.results, async (result) => {\n          if (result.img) {\n            // eslint-disable-next-line require-atomic-updates\n            result.img = await Helpers.importImage(result.img, zip, adventure);\n          }\n          if (result.resultId) {\n            needRevisit = true;\n          }\n          logger.debug(`Updating DDB links for ${data.name}`);\n          // eslint-disable-next-line require-atomic-updates\n          data.text = Helpers.foundryCompendiumReplace(data.text);\n        });\n      } else if (importType === \"JournalEntry\" && data.content) {\n        const journalImages = Helpers.reMatchAll(/(src|href)=\"(?!http(?:s*):\\/\\/)([\\w0-9\\-._~%!$&'()*+,;=:@/]*)\"/, data.content);\n        if (journalImages) {\n          await Helpers.asyncForEach(journalImages, async (result) => {\n            const path = await Helpers.importImage(result[2], zip, adventure);\n            data.content = data.content.replace(result[0], `${result[1]}=\"${path}\"`);\n          });\n        }\n        logger.debug(`Updating DDB links for ${data.name}`);\n        data.content = Helpers.foundryCompendiumReplace(data.content);\n      }\n\n      data.flags.importid = data._id;\n      setProperty(data.flags, \"ddbimporter.version\", CONFIG.DDBI.version);\n\n      if (importType !== \"Playlist\" && importType !== \"Compendium\") {\n        if (CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[data.folder]) {\n          logger.debug(`Adding data to subfolder importkey = ${data.folder}, folder = ${CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[data.folder]}`);\n          data.folder = CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[data.folder];\n        } else {\n          logger.debug(`Adding data to subfolder importkey = ${data.folder}, folder = ${CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[\"null\"]}`);\n          if (adventure?.options?.folders) {\n            data.folder = CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[\"null\"];\n          } else {\n            data.folder = CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[importType];\n          }\n        }\n      }\n\n      await this._importRenderedFile(adventure, importType, data, zip, needRevisit, overwriteIds);\n\n      currentCount += 1;\n      AdventureMunch._updateProgress(totalCount, currentCount, importType);\n    });\n\n\n  }\n\n  static _updateProgress(total, count, type) {\n    const localizedType = `dbb-importer.label.${type}`;\n    $(\".import-progress-bar\")\n      .width(`${Math.trunc((count / total) * 100)}%`)\n      .html(`<span>${game.i18n.localize(\"dbb-importer.label.Working\")} (${game.i18n.localize(localizedType)})...</span>`);\n  }\n\n  static _progressNote(note) {\n    $(\".import-progress-bar\")\n      .html(`<span>${game.i18n.localize(\"dbb-importer.label.Working\")} (${note})...</span>`);\n  }\n}\n","import logger from \"../../logger.js\";\nimport Helpers from \"./common.js\";\n\nconst STUBS = {\n  1: `<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\" style=\"shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd\"\n  viewBox=\"0 0 512 512\" width=\"512\" height=\"512\">\n    <g>\n      <circle style=\"fill:#ffffff;stroke:#010101;stroke-width:30;stroke-miterlimit:10;\" cx=\"250\" cy=\"250\" r=\"220\">\n      </circle>\n      <text font-family='-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"' font-size=\"300\" font-weight=\"400\" fill=\"black\" x=\"50%\" y=\"52%\" text-anchor=\"middle\" stroke=\"#000000\" dy=\".3em\">REPLACEME</text>\n    </g>\n  </svg>`,\n  2: `<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\" style=\"shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd\"\n  viewBox=\"0 0 512 512\" width=\"512\" height=\"512\">\n    <g>\n      <circle style=\"fill:#ffffff;stroke:#010101;stroke-width:30;stroke-miterlimit:10;\" cx=\"250\" cy=\"250\" r=\"220\">\n      </circle>\n      <text font-family='-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"' font-size=\"230\" font-weight=\"400\" fill=\"black\" x=\"50%\" y=\"52%\" text-anchor=\"middle\" stroke=\"#000000\" dy=\".3em\">REPLACEME</text>\n    </g>\n  </svg>`,\n  3: `<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\" style=\"shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd\"\n  viewBox=\"0 0 512 512\" width=\"512\" height=\"512\">\n    <g>\n      <circle style=\"fill:#ffffff;stroke:#010101;stroke-width:30;stroke-miterlimit:10;\" cx=\"250\" cy=\"250\" r=\"220\">\n      </circle>\n      <text font-family='-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"' font-size=\"170\" font-weight=\"400\" fill=\"black\" x=\"50%\" y=\"52%\" text-anchor=\"middle\" stroke=\"#000000\" dy=\".3em\">REPLACEME</text>\n    </g>\n  </svg>`,\n  4: `<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\" style=\"shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd\"\n  viewBox=\"0 0 512 512\" width=\"512\" height=\"512\">\n    <g>\n      <circle style=\"fill:#ffffff;stroke:#010101;stroke-width:30;stroke-miterlimit:10;\" cx=\"250\" cy=\"250\" r=\"220\">\n      </circle>\n      <text font-family='-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"' font-size=\"140\" font-weight=\"400\" fill=\"black\" x=\"50%\" y=\"52%\" text-anchor=\"middle\" stroke=\"#000000\" dy=\".3em\">REPLACEME</text>\n    </g>\n  </svg>`,\n};\n\nexport async function generateIcon(adventure, title) {\n  // default path\n  let iconPath = \"icons/svg/book.svg\";\n  let stub = title.trim().split(\".\")[0].split(\" \")[0];\n  stub = stub.replace(/(\\d+)/, Helpers.unPad);\n  if (stub.length <= 4) {\n    iconPath = `assets/icons/${stub}.svg`;\n    logger.info(stub);\n    let content = STUBS[stub.length];\n    content = content.replace(\"REPLACEME\", stub);\n    const uploadPath = await Helpers.importRawFile(iconPath, content, \"text/plain\", adventure, true);\n    return uploadPath;\n  }\n  return iconPath;\n}\n","import Helpers from \"./common.js\";\nimport logger from \"../../logger.js\";\nimport { generateAdventureConfig } from \"../adventure.js\";\nimport utils from \"../../utils.js\";\nimport { DDB_CONFIG } from \"../../ddbConfig.js\";\nimport { generateIcon } from \"./icons.js\";\n\nconst MR_PRIMATES_THIRD_PARTY_REPO = \"MrPrimate/ddb-third-party-scenes\";\nconst RAW_BASE_URL = `https://raw.githubusercontent.com/${MR_PRIMATES_THIRD_PARTY_REPO}`;\nconst RAW_MODULES_URL = `${RAW_BASE_URL}/main/modules.json`;\n\nexport default class ThirdPartyMunch extends FormApplication {\n  /** @override */\n  constructor(object = {}, options = {}) {\n    super(object, options);\n    this._itemsToRevisit = [];\n    this._adventure = {};\n    this._scenePackage = {};\n    this._packageName = \"\";\n    this._description = \"\";\n  }\n\n  /** @override */\n  static get defaultOptions() {\n    this.pattern = /(@[a-z]*)(\\[)([a-z0-9]*|[a-z0-9.]*)(\\])(\\{)(.*?)(\\})/gmi;\n    this.altpattern = /((data-entity)=\\\\?[\"']?([a-zA-Z]*)\\\\?[\"']?|(data-pack)=\\\\?[\"']?([[\\S.]*)\\\\?[\"']?) data-id=\\\\?[\"']?([a-zA-Z0-9]*)\\\\?[\"']?.*?>(.*?)<\\/a>/gmi;\n\n    return mergeObject(super.defaultOptions, {\n      id: \"ddb-adventure-import\",\n      classes: [\"ddb-adventure-import\"],\n      title: \"Third Party Munch\",\n      template: \"modules/ddb-importer/handlebars/adventure/import-third.hbs\",\n      width: 350,\n      height: \"auto\",\n    });\n  }\n\n  /** @override */\n  // eslint-disable-next-line class-methods-use-this\n  async getData() {\n    let data;\n    let packages = [];\n\n    try {\n      data = await $.getJSON(RAW_MODULES_URL);\n      this._defaultRepoData = data;\n      for (const [key, value] of Object.entries(data.packages)) {\n        logger.debug(`${key}: ${value}`);\n        packages.push(value);\n      }\n      const partialScenes = game.settings.get(\"ddb-importer\", \"third-party-scenes-partial\");\n      packages = packages\n        .filter((p) => p.released || partialScenes)\n        .sort((a, b) => a.name.localeCompare(b.last_nom));\n      logger.debug(\"_defaultRepoData\", this._defaultRepoData);\n    } catch (err) {\n      logger.error(err);\n      logger.warn(`Unable to generate package list.`);\n    }\n\n    return {\n      data,\n      packages,\n      cssClass: \"ddb-importer-third-party-window\"\n    };\n\n  }\n\n  /** @override */\n  activateListeners(html) {\n    super.activateListeners(html);\n\n    html.find(\".dialog-button\").on(\"click\", this._dialogButton.bind(this));\n    html.find(\"#select-package\").on(\"change\", this._selectPackage.bind(this, null, html));\n  }\n\n  async _selectPackage(event, html) {\n    const packageSelectionElement = html.find(\"#select-package\");\n\n    // get selected campaign from html selection\n    const packageSelection = packageSelectionElement[0].selectedOptions[0]\n      ? packageSelectionElement[0].selectedOptions[0].value\n      : undefined;\n\n    const moduleMessage = html.find(\"#ddb-message\");\n\n    if (packageSelection) {\n      const missingModules = [this._defaultRepoData.packages[packageSelection].module].filter((module) => {\n        return !utils.isModuleInstalledAndActive(module);\n      });\n\n      this._packageName = packageSelectionElement[0].selectedOptions[0].text;\n      this._description = this._defaultRepoData.packages[packageSelection].description;\n\n\n      let message = \"\";\n      if (missingModules.length > 0) {\n        const missingModulesString = missingModules.join(\", \");\n        message += `<p>You need to install the modules: ${missingModulesString}</p>`;\n      }\n\n      const missingBooks = this._defaultRepoData.packages[packageSelection].books.filter((book) => {\n        const matchingJournals = game.journal.some((j) => j.data.flags.ddb?.bookCode === book);\n        if (matchingJournals) {\n          logger.info(`Found journals for ${book}`);\n          return false;\n        } else {\n          logger.warn(`Missing journals for ${book}`);\n          return true;\n        }\n      });\n\n      if (missingBooks.length > 0) {\n        const bookString = missingBooks.map((bookCode) => ThirdPartyMunch._getDDBBookName(bookCode)).join(\", \");\n        message += `<p>You need to use Adventure Muncher to load the following books first: ${bookString}</p>`;\n      }\n\n      if (this._description && this.description !== \"\") {\n        message += `<p><b>Details</b>: ${this._description}</p>`;\n      }\n\n      if (message !== \"\") {\n        moduleMessage[0].innerHTML = message;\n        $(\".ddb-message\").removeClass(\"import-hidden\");\n      }\n\n      if (missingBooks.length === 0 && missingModules.length === 0) {\n        $(\".dialog-button\").prop('disabled', false);\n      }\n\n    } else {\n      moduleMessage[0].innerHTML = \"\";\n      $(\".ddb-message\").addClass(\"import-hidden\");\n    }\n    $('#ddb-adventure-import').css(\"height\", \"auto\");\n  }\n\n  static async _createFolders(adventure, folders) {\n    if (folders) {\n      let itemFolder = null;\n      CONFIG.DDBI.ADVENTURE.TEMPORARY.folders[\"null\"] = null;\n      CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups = null;\n\n      // the folder list could be out of order, we need to create all folders with parent null first\n      const firstLevelFolders = folders.filter((folder) => folder.parent === null);\n      await Helpers.importFolder(itemFolder, firstLevelFolders, adventure, folders);\n    }\n  }\n\n  static async _checkForMissingData(adventure, folders) {\n    await ThirdPartyMunch._createFolders(adventure, folders);\n    // console.warn(\"_checkForMissingData\", adventure);\n\n    if (adventure.required?.spells && adventure.required.spells.length > 0) {\n      logger.debug(`${adventure.name} - spells required`, adventure.required.spells);\n      ThirdPartyMunch._progressNote(`Checking for missing spells from DDB`);\n      await Helpers.checkForMissingDocuments(\"spell\", adventure.required.spells);\n    }\n    if (adventure.required?.items && adventure.required.items.length > 0) {\n      logger.debug(`${adventure.name} - items required`, adventure.required.items);\n      ThirdPartyMunch._progressNote(`Checking for missing items from DDB`);\n      await Helpers.checkForMissingDocuments(\"item\", adventure.required.items);\n    }\n    if (adventure.required?.monsters && adventure.required.monsters.length > 0) {\n      logger.debug(`${adventure.name} - monsters required`, adventure.required.monsters);\n      ThirdPartyMunch._progressNote(`Checking for missing monsters from DDB`);\n      await Helpers.checkForMissingDocuments(\"monster\", adventure.required.monsters);\n    }\n  }\n\n  static _renderCompleteDialog(title, adventure) {\n    new Dialog(\n      {\n        title: title,\n        content: { adventure },\n        buttons: { two: { label: \"OK\" } },\n      },\n      {\n        classes: [\"dialog\", \"adventure-import-export\"],\n        template: \"modules/ddb-importer/handlebars/adventure/import-complete.hbs\",\n      }\n    ).render(true);\n  }\n\n  static async _fixupScenes(scenes) {\n    try {\n      if (scenes.length > 0) {\n        let totalCount = scenes.length;\n        let currentCount = 0;\n\n        await Helpers.asyncForEach(scenes, async (obj) => {\n          try {\n            let updatedData = {};\n            switch (obj.documentName) {\n              case \"Scene\": {\n                // In 0.8.x the thumbs don't seem to be auto generated anymore\n                // This code would embed the thumbnail.\n                // Remove once/if resolved\n                if (!obj.data.thumb) {\n                  const thumbData = await obj.createThumbnail();\n                  updatedData[\"thumb\"] = thumbData.thumb;\n                }\n                await obj.update(updatedData);\n                break;\n              }\n              // no default\n            }\n          } catch (err) {\n            logger.warn(`Error updating references for scene ${obj}`, err);\n          }\n          currentCount += 1;\n          ThirdPartyMunch._updateProgress(totalCount, currentCount, \"References\");\n        });\n      }\n    } catch (err) {\n      // eslint-disable-next-line no-undef\n      logger.warn(`Error during reference update for object ${item}`, err);\n    }\n  }\n\n  static async _createFolder(label, type) {\n    const folderData = {\n      \"name\": label,\n      \"type\": type,\n      \"parent\": null,\n      \"sorting\": \"m\",\n    };\n    const newFolder = await Folder.create(folderData);\n    logger.debug(`Created new folder ${newFolder.data._id} with data:`, folderData, newFolder);\n    return newFolder;\n  }\n\n  static async _findFolder(label, type) {\n    const folder = game.folders.find((f) =>\n      f.type === type &&\n      f.parentFolder === undefined &&\n      f.name === label\n    );\n\n    return folder ? folder : ThirdPartyMunch._createFolder(label, type);\n  }\n\n  static _getDDBBookName(bookCode) {\n    const selection = DDB_CONFIG.sources.find((source) => bookCode.toLowerCase() === source.name.toLowerCase());\n    return selection.description;\n  }\n\n  static _generateMockAdventure(scene) {\n    const monsters = scene.flags?.ddbimporter?.export?.actors && scene.flags?.ddb?.tokens\n      ? scene.flags.ddb.tokens\n        .filter((token) => token.flags?.ddbActorFlags?.id)\n        .map((token) => token.flags.ddbActorFlags.id)\n      : [];\n    return {\n      id: randomID(),\n      name: ThirdPartyMunch._getDDBBookName(scene.flags.ddb.bookCode),\n      description: \"\",\n      system: \"dnd5e\",\n      modules: [],\n      version: \"2.5\",\n      options: {\n        folders: true\n      },\n      folderColour: \"FF0000\",\n      required: {\n        monsters,\n      }\n    };\n  }\n\n  static _generateActorId(token) {\n    const ddbId = token.flags.ddbActorFlags.id;\n    const folderId = token.flags.actorFolderId;\n    const key = `${ddbId}-${folderId}`;\n    if (CONFIG.DDBI.ADVENTURE.TEMPORARY.mockActors[key]) {\n      return CONFIG.DDBI.ADVENTURE.TEMPORARY.mockActors[key];\n    } else {\n      const existingActor = game.actors.find((actor) => actor.data.folder == folderId && actor.data.flags.ddbimporter.id == ddbId);\n      const actorId = existingActor ? existingActor.id : randomID();\n      CONFIG.DDBI.ADVENTURE.TEMPORARY.mockActors[key] = actorId;\n      return actorId;\n    }\n  }\n\n  static async _linkSceneTokens(scene) {\n    logger.info(`Updating ${scene.name}, ${scene.tokens.length} tokens`);\n    const tokens = await Promise.all(scene.tokens.map(async (token) => {\n      if (token.actorId) {\n        const worldActor = game.actors.get(token.actorId);\n        if (worldActor) {\n          // we merge the override data provided by the token to the actor to get\n          // world specific things like img paths and scales etc\n          const sceneToken = scene.flags.ddb.tokens.find((t) => t._id === token._id);\n          delete sceneToken.scale;\n          const tokenData = await worldActor.getTokenData();\n          delete tokenData.y;\n          delete tokenData.x;\n          const jsonTokenData = JSON.parse(JSON.stringify(tokenData));\n          const newToken = mergeObject(jsonTokenData, sceneToken);\n          logger.debug(`${token.name} token data for id ${token.actorId}`, newToken);\n          return newToken;\n        }\n      }\n      return token;\n    }));\n    return tokens;\n  }\n\n  static async _linkSceneNotes(scene, adventure) {\n    const journalNotes = game.journal.filter((journal) => journal.data?.flags?.ddb?.bookCode === scene.flags.ddb.bookCode);\n\n    const notes = await Promise.all([scene]\n      .filter((scene) => scene.flags?.ddb?.notes)\n      .map((scene) => scene.flags.ddb.notes)\n      .flat()\n      .map(async (note) => {\n        const noteJournal = journalNotes.find((journal) => {\n          const contentChunkIdMatch = note.flags.ddb.contentChunkId\n            ? journal.data.flags.ddb && note.flags.ddb &&\n              journal.data.flags.ddb.contentChunkId == note.flags.ddb.contentChunkId\n            : false;\n\n          const noContentChunk = !note.flags.ddb.contentChunkId &&\n            note.flags.ddb.originalLink && note.flags.ddb.ddbId && note.flags.ddb.parentId &&\n            note.flags.ddb.slug && note.flags.ddb.linkName;\n          const originMatch = noContentChunk\n            ? journal.data.flags.ddb.slug == note.flags.ddb.slug &&\n              journal.data.flags.ddb.ddbId == note.flags.ddbId &&\n              journal.data.flags.ddb.parentId == note.flags.ddb.parentId &&\n              journal.data.flags.ddb.cobaltId == note.flags.ddb.cobaltId &&\n              journal.data.flags.ddb.originalLink == note.flags.ddb.originalLink &&\n              journal.data.flags.ddb.linkName == note.flags.ddb.linkName\n            : false;\n          const journalNameMatch = !contentChunkIdMatch && !originMatch\n            ? journal.name.trim() == note.label.trim()\n            : false;\n          return contentChunkIdMatch || originMatch || journalNameMatch;\n\n        });\n        if (noteJournal) {\n          logger.info(`Found note \"${note.label}\"\" matched to Journal with ID \"${noteJournal.id}\" (${noteJournal.name})`);\n          note.flags.ddb.journalId = noteJournal.id;\n          // eslint-disable-next-line require-atomic-updates\n          note.icon = await generateIcon(adventure, note.label);\n        }\n        return note;\n      }));\n\n    const positionedNotes = [];\n    notes.forEach((note) => {\n      if (note.flags?.ddb?.journalId) {\n        note.positions.forEach((position) => {\n          logger.info(`Matching ${note.label} to position ${position.x}/${position.y}`);\n          const noteId = randomID();\n          const n = {\n            \"_id\": noteId,\n            \"flags\": {\n              \"ddb\": note.flags.ddb,\n              \"importid\": noteId,\n            },\n            \"entryId\": note.flags.ddb.journalId,\n            \"x\": position.x,\n            \"y\": position.y,\n            \"icon\": note.icon, // \"assets/icons/1.svg\",\n            \"iconSize\": note.iconSize ? note.iconSize : 40,\n            \"iconTint\": \"\",\n            \"text\": \"\",\n            \"fontFamily\": note.fontFamily ? note.fontFamily : \"Signika\",\n            \"fontSize\": note.fontSize ? note.fontSize : 48,\n            \"textAnchor\": 1,\n            \"textColor\": note.textColor ? note.textColor : \"\",\n          };\n          positionedNotes.push(n);\n        });\n      }\n    });\n\n    return positionedNotes;\n  }\n\n  async _dialogButton(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    const a = event.currentTarget;\n    const action = a.dataset.button;\n    const packageName = this._packageName;\n\n    if (action === \"import\") {\n      $(\".import-progress\").toggleClass(\"import-hidden\");\n      $(\".ddb-overlay\").toggleClass(\"import-invalid\");\n      const selectedPackage = $(\"#select-package\").val();\n      const packageURL = `${RAW_BASE_URL}/main/${selectedPackage}/module.json`;\n\n      this._scenePackage = await fetch(packageURL)\n        .then((response) => {\n          if (response.status === 200 || response.status === 0) {\n            return Promise.resolve(response.json());\n          } else {\n            return Promise.reject(new Error(response.statusText));\n          }\n        });\n\n      // check for valid json object?\n\n      logger.debug(\"_scenePackage\", this._scenePackage);\n\n      CONFIG.DDBI.ADVENTURE.TEMPORARY = {\n        folders: {},\n        import: {},\n        actors: {},\n        sceneTokens: {},\n        mockActors: {},\n      };\n\n      // We need to check for potential Scene Folders and Create if missing\n      const compendiumLabels = [...new Set(this._scenePackage.scenes\n        .filter((scene) => scene.flags?.ddbimporter?.export?.compendium)\n        .map((scene) => {\n          const compendiumId = scene.flags.ddbimporter.export.compendium;\n          const compendium = game.packs.get(compendiumId);\n          return compendium.metadata.label;\n        }))].map((label) => {\n        return ThirdPartyMunch._findFolder(label, \"Scene\");\n      });\n\n      await Promise.all(compendiumLabels);\n\n      const adventureLabels = [...new Set(this._scenePackage.scenes\n        .filter((scene) => scene.flags?.ddb?.bookCode)\n        .map((scene) => {\n          return ThirdPartyMunch._getDDBBookName(scene.flags.ddb.bookCode);\n        }))].map((label) => {\n        return ThirdPartyMunch._findFolder(label, \"Actor\");\n      });\n      await Promise.all(adventureLabels);\n\n      logger.debug(\"Competed folder creation\");\n\n      // import any missing monsters into the compendium\n      // add tokens to scene\n      // add notes to scene\n      const adjustedScenes = await Promise.all(this._scenePackage.scenes\n        .filter((scene) => scene.flags?.ddbimporter?.export?.actors && scene.flags?.ddb?.tokens)\n        .map(async (scene) => {\n          const mockScene = JSON.parse(JSON.stringify(scene));\n          if (mockScene.flags?.ddbimporter?.export?.actors && mockScene.flags?.ddb?.tokens) {\n            const mockAdventure = ThirdPartyMunch._generateMockAdventure(mockScene);\n            await ThirdPartyMunch._checkForMissingData(mockAdventure, []);\n            const bookName = ThirdPartyMunch._getDDBBookName(mockScene.flags.ddb.bookCode);\n            const actorFolder = await ThirdPartyMunch._findFolder(bookName, \"Actor\");\n            mockScene.tokens = mockScene.flags.ddb.tokens.map((token) => {\n              token.flags.actorFolderId = actorFolder.id;\n              token.actorId = ThirdPartyMunch._generateActorId(token);\n              return token;\n            });\n            mockScene.notes = await ThirdPartyMunch._linkSceneNotes(mockScene, mockAdventure);\n          }\n          return mockScene;\n        }));\n\n      logger.debug(\"adjustedScenes\", JSON.parse(JSON.stringify(adjustedScenes)));\n\n      logger.debug(\"About to generate Token Actors\");\n      // load token actors into world\n      await Helpers.asyncForEach(adjustedScenes, async(scene) => {\n        logger.debug(`Generating scene actors for ${scene.name}`);\n        await Helpers.generateTokenActors(scene);\n        logger.debug(`Finished scene actors for ${scene.name}`);\n      });\n\n      // link tokens on scene to imported actors\n      const tokenAdjustedScenes = await Promise.all(adjustedScenes\n        .map(async (scene) => {\n          logger.debug(`Updating scene tokens for ${scene.name}`);\n          const newScene = JSON.parse(JSON.stringify(scene));\n          newScene.tokens = await ThirdPartyMunch._linkSceneTokens(scene);\n          return newScene;\n        })\n      );\n\n      logger.debug(\"tokenAdjustedScenes\", tokenAdjustedScenes);\n\n      CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups = await generateAdventureConfig();\n      logger.debug(\"Lookups loaded\", CONFIG.DDBI.ADVENTURE.TEMPORARY.lookups.lookups);\n\n      const scenes = await Promise.all(tokenAdjustedScenes\n        .filter((scene) => scene.flags?.ddbimporter?.export?.compendium)\n        // does the scene match a compendium scene\n        .filter(async (scene) => {\n          const compendium = game.packs.get(scene.flags.ddbimporter.export.compendium);\n          const compendiumScene = compendium.index.find((s) => s.name === scene.name);\n          if (compendiumScene) return true;\n          else return false;\n        })\n        .map(async (scene) => {\n          const compendiumId = scene.flags.ddbimporter.export.compendium;\n          const compendium = game.packs.get(compendiumId);\n          const folder = await ThirdPartyMunch._findFolder(compendium.metadata.label, \"Scene\");\n          const compendiumScene = compendium.index.find((s) => s.name === scene.name);\n          // eslint-disable-next-line require-atomic-updates\n          scene.folder = folder.id;\n\n          const existingScene = game.scenes.find((s) => s.name === scene.name && s.data.folder === folder.id);\n\n          // if scene already exists, update\n          if (existingScene) {\n            logger.info(`Updating ${scene.name}`, scene);\n            await existingScene.update(scene);\n            return existingScene;\n          } else {\n            const worldScene = await game.scenes.importFromCompendium(compendium, compendiumScene._id, scene, { keepId: true });\n            logger.info(`Scene: ${scene.name} folder:`, folder);\n            logger.debug(\"worldScene:\", worldScene);\n            return worldScene;\n          }\n        }));\n\n      // logger.debug(\"finalScenes\", scenes);\n\n      const toTimer = setTimeout(() => {\n        logger.warn(`Reference update timed out.`);\n        ThirdPartyMunch._renderCompleteDialog(`Un-Successful Import of ${packageName}`, { name: packageName });\n        this.close();\n      }, 60000);\n\n      // clearup remaining scene things\n      await ThirdPartyMunch._fixupScenes(scenes);\n      clearTimeout(toTimer);\n\n      $(\".ddb-overlay\").toggleClass(\"import-invalid\");\n\n      ThirdPartyMunch._renderCompleteDialog(`Successful Import of ${packageName}`, { name: packageName });\n\n      // eslint-disable-next-line require-atomic-updates\n      CONFIG.DDBI.ADVENTURE.TEMPORARY = {};\n      this.close();\n    }\n  }\n\n  static _updateProgress(total, count, type) {\n    const localizedType = `dbb-importer.label.${type}`;\n    $(\".import-progress-bar\")\n      .width(`${Math.trunc((count / total) * 100)}%`)\n      .html(`<span>${game.i18n.localize(\"dbb-importer.label.Working\")} (${game.i18n.localize(localizedType)})...</span>`);\n  }\n\n  static _progressNote(note) {\n    $(\".import-progress-bar\")\n      .html(`<span>${game.i18n.localize(\"dbb-importer.label.Working\")} (${note})...</span>`);\n  }\n}\n","// import logger from \"../logger.js\";\nimport utils from \"../utils.js\";\nimport logger from \"../logger.js\";\nimport { getPatreonTiers } from \"./utils.js\";\nimport { getCobalt } from \"../lib/Secrets.js\";\nimport { getSourcesLookups } from \"./ddb.js\";\nimport { spellEffectModules } from \"../effects/specialSpells.js\";\n\nexport function setRecommendedCharacterActiveEffectSettings(html) {\n  $(html).find(\"#character-import-policy-dae-copy\").prop(\"checked\", false);\n  game.settings.set(\"ddb-importer\", \"character-update-policy-dae-copy\", false);\n  $(html).find(\"#character-import-policy-dae-effect-copy\").prop(\"checked\", !spellEffectModules().hasCore);\n  game.settings.set(\"ddb-importer\", \"character-update-policy-dae-effect-copy\", !spellEffectModules().hasCore);\n  $(html).find(\"#character-import-policy-add-spell-effects\").prop(\"checked\", spellEffectModules().hasCore);\n  game.settings.set(\"ddb-importer\", \"character-update-policy-add-spell-effects\", spellEffectModules().hasCore);\n  $(html).find(\"#character-import-policy-dae-effect-copy\").prop(\"checked\", false);\n  game.settings.set(\"ddb-importer\", \"character-update-policy-dae-effect-copy\", false);\n  $(html).find(\"#character-import-policy-add-item-effects\").prop(\"checked\", true);\n  game.settings.set(\"ddb-importer\", \"character-update-policy-add-item-effects\", true);\n  $(html).find(\"#character-import-policy-add-character-effects\").prop(\"checked\", true);\n  game.settings.set(\"ddb-importer\", \"character-update-policy-add-character-effects\", true);\n  $(html).find(\"#character-import-policy-generate-ac-feature-effects\").prop(\"checked\", true);\n  game.settings.set(\"ddb-importer\", \"character-update-policy-generate-ac-feature-effects\", true);\n  $(html).find(\"#character-import-policy-active-effect-copy\").prop(\"checked\", false);\n  game.settings.set(\"ddb-importer\", \"character-update-policy-active-effect-copy\", false);\n\n  [\"class\", \"race\", \"background\", \"feat\"].forEach((type) => {\n    $(html).find(`#character-import-policy-effect-${type}-spell-bonus`).prop(\"checked\", true);\n    game.settings.set(\"ddb-importer\", `character-update-policy-effect-${type}-spell-bonus`, true);\n    $(html).find(`#character-import-policy-effect-${type}-speed`).prop(\"checked\", false);\n    game.settings.set(\"ddb-importer\", `character-update-policy-effect-${type}-speed`, false);\n    $(html).find(`#character-import-policy-effect-${type}-senses`).prop(\"checked\", false);\n    game.settings.set(\"ddb-importer\", `character-update-policy-effect-${type}-senses`, false);\n    $(html).find(`#character-import-policy-effect-${type}-hp`).prop(\"checked\", false);\n    game.settings.set(\"ddb-importer\", `character-update-policy-effect-${type}-hp`, false);\n    $(html).find(`#character-import-policy-effect-${type}-damages`).prop(\"checked\", false);\n    game.settings.set(\"ddb-importer\", `character-update-policy-effect-${type}-damages`, false);\n  });\n}\n\nfunction getInstalledIcon(name) {\n  return spellEffectModules()[name] ? \"<i class='fas fa-check-circle' style='color: green'></i>\" : \"<i class='fas fa-times-circle' style='color: red'></i> \";\n}\n\nexport function getCharacterImportSettings() {\n  const importPolicies = [\n    {\n      name: \"name\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-name\"),\n      description: \"Name\",\n    },\n    {\n      name: \"hp\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-hp\"),\n      description: \"HP\",\n    },\n    {\n      name: \"hit-die\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-hit-die\"),\n      description: \"Hit Die\",\n    },\n    {\n      name: \"class\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-class\"),\n      description: \"Classes\",\n    },\n    {\n      name: \"feat\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-feat\"),\n      description: \"Features\",\n    },\n    {\n      name: \"weapon\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-weapon\"),\n      description: \"Weapons\",\n    },\n    {\n      name: \"equipment\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-equipment\"),\n      description: \"Other Equipment\",\n    },\n    {\n      name: \"currency\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-currency\"),\n      description: \"Currency\",\n    },\n    {\n      name: \"spell\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-spell\"),\n      description: \"Spells\",\n    },\n    {\n      name: \"image\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-image\"),\n      description: \"Image\",\n    },\n    {\n      name: \"bio\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-bio\"),\n      description: \"Bio\",\n    },\n  ];\n\n  const spellEffectModulesAvailable = spellEffectModules();\n  const daeInstalled = spellEffectModulesAvailable.daeInstalled;\n  const daeSRDInstalled = utils.isModuleInstalledAndActive(\"Dynamic-Effects-SRD\");\n  const midiSRDInstalled = utils.isModuleInstalledAndActive(\"midi-srd\");\n  const daeSRDContentAvailable = daeSRDInstalled || midiSRDInstalled;\n  const spellEffectText = `Generate active effects for spells. These require DAE${getInstalledIcon(\"daeInstalled\")}, Midi-QOL${getInstalledIcon(\"midiQolInstalled\")}, Advanced Macros${getInstalledIcon(\"advancedMacrosInstalled\")}, Item Macro${getInstalledIcon(\"itemMacroInstalled\")}, About Time${getInstalledIcon(\"aboutTime\")}, Times Up${getInstalledIcon(\"timesUp\")}, and Convinient Effects${getInstalledIcon(\"convinientEffectsInstalled\")} as a minimum. Also recommened is Active Auras${getInstalledIcon(\"activeAurasInstalled\")}, Active Token Effects${getInstalledIcon(\"atlInstalled\")}, Token Magic FX${getInstalledIcon(\"tokenMagicInstalled\")}, and Automated Animations${getInstalledIcon(\"autoAnimationsInstalled\")}`;\n\n  // const importExtras = game.settings.get(\"ddb-importer\", \"character-update-policy-import-extras\");\n\n  const importConfig = [\n    {\n      name: \"use-inbuilt-icons\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-use-inbuilt-icons\"),\n      description: \"Use icons from the inbuilt dictionary. (High coverage of items, feats, and spells).\",\n      enabled: true,\n    },\n    {\n      name: \"use-srd-icons\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-use-srd-icons\"),\n      description: \"Use icons from the SRD compendium. (This can take a while).\",\n      enabled: true,\n    },\n    {\n      name: \"use-ddb-spell-icons\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-use-ddb-spell-icons\"),\n      description: \"Use spell school icons from D&DBeyond.\",\n      enabled: true,\n    },\n    {\n      name: \"use-ddb-item-icons\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-use-ddb-item-icons\"),\n      description: \"Use equipment icons from D&DBeyond (where they exist).\",\n      enabled: true,\n    },\n    {\n      name: \"use-ddb-generic-item-icons\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-use-ddb-generic-item-icons\"),\n      description: \"Use D&D Beyond generic item type images, if available (final fallback)\",\n      enabled: true,\n    },\n    {\n      name: \"use-full-description\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-use-full-description\"),\n      description: \"For actions use full description and snippets, else use snippets only.\",\n      enabled: true,\n    },\n    {\n      name: \"use-actions-as-features\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-use-actions-as-features\"),\n      description:\n        \"Import D&D Beyond Actions as Features, not weapons.\",\n      enabled: true,\n    },\n    {\n      name: \"use-action-and-feature\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-use-action-and-feature\"),\n      description:\n        \"[CAUTION] If a feature is marked as an action, import both the action and the feature. This might lead to some weird behaviour.\",\n      enabled: true,\n    },\n    {\n      name: \"ignore-non-ddb-items\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-ignore-non-ddb-items\"),\n      description:\n        \"Ignore items on character sheet that have not been imported from D&D Beyond. This will remove items that have been removed from the DDB character since the last import, but will keep items added to the character within Foundry.\",\n      enabled: true,\n    },\n  ];\n\n  const advancedImportConfig = [\n    {\n      name: \"use-override\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-use-override\"),\n      title: \"Replace Items using those in your Override compendium\",\n      description:\n        \"Use existing items from <i>ddb-import Override compendium</i>, rather than parsing from DDB. This is useful if you want to place customised items into the compendium for use by characters.\",\n      enabled: true,\n    },\n    {\n      name: \"use-existing\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-use-existing\"),\n      title: \"[Caution] Replace Items using ddb-importer compendiums\",\n      description:\n        \"Use existing items from <i>ddb-import compendiums</i>, rather than parsing from DDB. This is useful if you have customised the items in the compendium, although you will lose any custom effects applied by this module e.g. Improved Divine Smite. Please consider marking the item you wish to keep as ignored by import instead.\",\n      enabled: true,\n    },\n    {\n      name: \"use-srd\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-use-srd\"),\n      title: \"[Caution] Replace Items using SRD compendiums\",\n      description:\n        \"Use the <i>SRD compendiums</i>, rather than DDB. Importing using SRD will not include features like fighting style and divine smite in damage calculations. Please consider marking the item you wish to keep as ignored by import instead.\",\n      enabled: true,\n    },\n  ];\n\n  const effectImportConfig = [\n    {\n      name: \"add-item-effects\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-add-item-effects\") && daeInstalled,\n      title: \"Generate Active Effects for Equipment\",\n      description:\n        \"Dynamically generate active effects for a characters equipment, doesn't include AC effects on armor, but will for things like the Ring of Protection.\",\n      enabled: daeInstalled,\n    },\n    {\n      name: \"add-spell-effects\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-add-spell-effects\") && spellEffectModulesAvailable.hasCore,\n      title: \"Generate Active Effects for Spells\",\n      description: spellEffectText,\n      enabled: daeInstalled,\n    },\n    {\n      name: \"add-character-effects\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-add-character-effects\") && daeInstalled,\n      title: \"Generate Active Effects for Character Features/Racial Traits/Feats/Backgrounds\",\n      description:\n        \"Dynamically generate active effects for a character. Some effects are always generated, some are optional (see below).\",\n      enabled: daeInstalled,\n    },\n    {\n      name: \"generate-ac-feature-effects\",\n      isChecked:\n        game.settings.get(\"ddb-importer\", \"character-update-policy-generate-ac-feature-effects\") && daeInstalled,\n      title: \"Generate DAE Active Effects ACs for Character Features & Racial Traits\",\n      description:\n        \"Use extras in DAE to Dynamically add AC values as dynamic effects to items, this might not work as expected for some AC calculations. If unticked some ac bonuses will still be generated.\",\n      enabled: daeInstalled,\n    },\n    {\n      name: \"dae-effect-copy\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-dae-effect-copy\") && daeSRDContentAvailable,\n      title: \"Copy Active Effect from DAE Compendiums\",\n      description:\n        \"<i>Transfer</i> the <i>Dynamic Active Effects Compendiums</i> effect for matching items/features/spells (requires DAE SRD and/or Midi SRD module). This may result in odd character AC's, HP etc. especially if the generate item and character effect options above are unticked. Please try importing the character with this option disabled before logging a bug. This will overwrite effects generated with the above options.\",\n      enabled: daeInstalled && daeSRDContentAvailable,\n    },\n    // {\n    //   name: \"dae-copy\",\n    //   isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-dae-copy\") && daeSRDContentAvailable,\n    //   title: \"[Caution] Replace Items using DAE compendiums\",\n    //   description:\n    //     \"Replace parsed item with <i>Dynamic Active Effects Compendiums</i> for matching items/features/spells (requires DAE SRD and/or Midi SRD module). This will remove any effects applied directly to your character/not via features/items. This may result in odd character AC's, HP etc. especially if the generate options above are unticked. Please try importing the character with this option disabled before logging a bug.\",\n    //   enabled: daeInstalled && daeSRDContentAvailable,\n    // },\n    {\n      name: \"active-effect-copy\",\n      isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-active-effect-copy\"),\n      title: \"Retain Active Effects\",\n      description:\n        \"Retain existing Active Effects, this will try and transfer any existing effects on the actor such as custom effects, effects from conditions or existing spells. Untick this option if you experience <i>odd</i> behaviour, especially around AC.\",\n      enabled: true,\n    },\n  ];\n\n  // dae migration function no longer sound\n  if (game.settings.get(\"ddb-importer\", \"character-update-policy-dae-copy\")) {\n    game.settings.set(\"ddb-importer\", \"character-update-policy-dae-copy\", false);\n    game.settings.set(\"ddb-importer\", \"character-update-policy-dae-effect-copy\", true);\n  }\n\n  const effectSelectionConfig = {\n    class: [\n      {\n        name: \"effect-class-spell-bonus\",\n        title: \"Spell Bonuses\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-class-spell-bonus\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-class-speed\",\n        title: \"Movement\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-class-speed\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-class-senses\",\n        title: \"Senses\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-class-senses\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-class-hp\",\n        title: \"HP\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-class-hp\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-class-damages\",\n        title: \"Imm/Res/Vuln\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-class-damages\"),\n        enabled: true,\n      },\n    ],\n    race: [\n      {\n        name: \"effect-race-spell-bonus\",\n        title: \"Spell Bonuses\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-race-spell-bonus\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-race-speed\",\n        title: \"Movement\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-race-speed\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-race-senses\",\n        title: \"Senses\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-race-senses\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-race-hp\",\n        title: \"HP\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-race-hp\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-race-damages\",\n        title: \"Imm/Res/Vuln\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-race-damages\"),\n        enabled: true,\n      },\n    ],\n    background: [\n      {\n        name: \"effect-background-spell-bonus\",\n        title: \"Spell Bonuses\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-background-spell-bonus\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-background-speed\",\n        title: \"Movement\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-background-speed\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-background-senses\",\n        title: \"Senses\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-background-senses\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-background-hp\",\n        title: \"HP\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-background-hp\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-background-damages\",\n        title: \"Imm/Res/Vuln\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-background-damages\"),\n        enabled: true,\n      },\n    ],\n    feat: [\n      {\n        name: \"effect-feat-spell-bonus\",\n        title: \"Spell Bonuses\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-feat-spell-bonus\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-feat-speed\",\n        title: \"Movement\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-feat-speed\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-feat-senses\",\n        title: \"Senses\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-feat-senses\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-feat-hp\",\n        title: \"HP\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-feat-hp\"),\n        enabled: true,\n      },\n      {\n        name: \"effect-feat-damages\",\n        title: \"Imm/Res/Vuln\",\n        isChecked: game.settings.get(\"ddb-importer\", \"character-update-policy-effect-feat-damages\"),\n        enabled: true,\n      },\n    ],\n  };\n\n  const syncConfig = [\n    {\n      name: \"action-use\",\n      isChecked: game.settings.get(\"ddb-importer\", \"sync-policy-action-use\"),\n      description: \"Action Uses\",\n      enabled: true,\n    },\n    {\n      name: \"currency\",\n      isChecked: game.settings.get(\"ddb-importer\", \"sync-policy-currency\"),\n      description: \"Currency\",\n      enabled: true,\n    },\n    {\n      name: \"deathsaves\",\n      isChecked: game.settings.get(\"ddb-importer\", \"sync-policy-deathsaves\"),\n      description: \"Death Saves\",\n      enabled: true,\n    },\n    {\n      name: \"equipment\",\n      isChecked: game.settings.get(\"ddb-importer\", \"sync-policy-equipment\"),\n      description: \"Equipment\",\n      enabled: true,\n    },\n    {\n      name: \"condition\",\n      isChecked: game.settings.get(\"ddb-importer\", \"sync-policy-condition\"),\n      description: \"Exhaustion\",\n      enabled: true,\n    },\n    {\n      name: \"hitdice\",\n      isChecked: game.settings.get(\"ddb-importer\", \"sync-policy-hitdice\"),\n      description: \"Hit Dice/Short Rest\",\n      enabled: true,\n    },\n    {\n      name: \"hitpoints\",\n      isChecked: game.settings.get(\"ddb-importer\", \"sync-policy-hitpoints\"),\n      description: \"Hit Points\",\n      enabled: true,\n    },\n    {\n      name: \"inspiration\",\n      isChecked: game.settings.get(\"ddb-importer\", \"sync-policy-inspiration\"),\n      description: \"Inspiration\",\n      enabled: true,\n    },\n    {\n      name: \"spells-prepared\",\n      isChecked: game.settings.get(\"ddb-importer\", \"sync-policy-spells-prepared\"),\n      description: \"Spells Prepared\",\n      enabled: true,\n    },\n    {\n      name: \"spells-slots\",\n      isChecked: game.settings.get(\"ddb-importer\", \"sync-policy-spells-slots\"),\n      description: \"Spell Slots\",\n      enabled: true,\n    },\n    {\n      name: \"spells-sync\",\n      isChecked: game.settings.get(\"ddb-importer\", \"sync-policy-spells-sync\"),\n      description: \"Spells Known\",\n      enabled: false,\n    },\n    {\n      name: \"xp\",\n      isChecked: game.settings.get(\"ddb-importer\", \"sync-policy-xp\"),\n      description: \"XP\",\n      enabled: true,\n    },\n  ];\n\n  const extrasConfig = [\n    // {\n    //   name: \"update-existing\",\n    //   isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\"),\n    //   description: \"Update existing things.\",\n    //   enabled: true,\n    // },\n    // {\n    //   name: \"use-srd\",\n    //   isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-use-srd\"),\n    //   description: \"Use SRD compendium things instead of importing.\",\n    //   enabled: true,\n    // },\n    // {\n    //   name: \"use-inbuilt-icons\",\n    //   isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-use-inbuilt-icons\"),\n    //   description: \"Use icons from the inbuilt dictionary. (High coverage of items, feats, and spells).\",\n    //   enabled: true,\n    // },\n    // {\n    //   name: \"use-srd-icons\",\n    //   isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-use-srd-icons\"),\n    //   description: \"Use icons from the SRD compendiums.\",\n    //   enabled: true,\n    // },\n    // {\n    //   name: \"download-images\",\n    //   isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-download-images\"),\n    //   description: \"Download D&D Beyond images (takes longer and needs space).\",\n    //   enabled: true,\n    // },\n    // {\n    //   name: \"remote-images\",\n    //   isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-remote-images\"),\n    //   description: \"Use D&D Beyond remote images (a lot quicker)\",\n    //   enabled: true,\n    // },\n    // {\n    //   name: \"use-dae-effects\",\n    //   isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-use-dae-effects\"),\n    //   description: \"Copy effects from DAE (items and spells only). (Requires DAE and SRD module)\",\n    //   enabled: daeInstalled,\n    // },\n    // {\n    //   name: \"hide-description\",\n    //   isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-hide-description\"),\n    //   description: \"Hide description from players?\",\n    //   enabled: true,\n    // },\n    // {\n    //   name: \"monster-items\",\n    //   isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-monster-items\"),\n    //   description: \"[Experimental] Load items from DDB compendium instead of parsing action/attack?\",\n    //   enabled: true,\n    // },\n    // {\n    //   name: \"update-images\",\n    //   isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-update-images\"),\n    //   description: \"Update images on existing items?\",\n    //   enabled: true,\n    // },\n    // {\n    //   name: \"dae-copy\",\n    //   isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-dae-copy\"),\n    //   description: \"Use Dynamic Active Effects Compendiums for matching items/features (requires DAE and SRD module).\",\n    //   enabled: daeInstalled,\n    // },\n  ];\n\n  const uploadDir = game.settings.get(\"ddb-importer\", \"image-upload-directory\");\n  const badDirs = [\"[data]\", \"[data] \", \"\", null];\n  const dataDirSet = !badDirs.includes(uploadDir);\n  const tier = game.settings.get(\"ddb-importer\", \"patreon-tier\");\n  const tiers = getPatreonTiers(tier);\n\n  const result = {\n    importPolicies: importPolicies,\n    importConfig: importConfig,\n    extrasConfig: extrasConfig,\n    advancedImportConfig: advancedImportConfig,\n    effectImportConfig: effectImportConfig,\n    effectSelectionConfig: effectSelectionConfig,\n    dataDirSet: dataDirSet,\n    syncConfig: syncConfig,\n    tiers: tiers,\n  };\n\n  return result;\n}\n\nexport function updateActorSettings(html, event) {\n  const selection = event.currentTarget.dataset.section;\n  const checked = event.currentTarget.checked;\n\n  logger.debug(`Updating munching-policy-${selection} to ${checked}`);\n  game.settings.set(\"ddb-importer\", \"character-update-policy-\" + selection, checked);\n\n  if (selection === \"dae-copy\" && checked) {\n    $(html).find(\"#character-import-policy-dae-effect-copy\").prop(\"checked\", false);\n    game.settings.set(\"ddb-importer\", \"character-update-policy-dae-effect-copy\", false);\n  } else if (selection === \"dae-effect-copy\" && checked) {\n    $(html).find(\"#character-import-policy-dae-copy\").prop(\"checked\", false);\n    game.settings.set(\"ddb-importer\", \"character-update-policy-dae-copy\", false);\n    $(html).find(\"#character-import-policy-add-item-effects\").prop(\"checked\", true);\n    game.settings.set(\"ddb-importer\", \"character-update-policy-add-item-effects\", true);\n    $(html).find(\"#character-import-policy-add-character-effects\").prop(\"checked\", true);\n    game.settings.set(\"ddb-importer\", \"character-update-policy-add-character-effects\", true);\n  }\n}\n\nfunction getCompendiumFolderLookups(type) {\n  const compendiumFolderSetting = game.settings.settings.get(`ddb-importer.munching-selection-compendium-folders-${type}`);\n  const settingValue = game.settings.get(\"ddb-importer\", `munching-selection-compendium-folders-${type}`);\n\n  let selections = [];\n  for (const [key, value] of Object.entries(compendiumFolderSetting.choices)) {\n    selections.push({\n      key: key,\n      label: value,\n      selected: key === settingValue,\n    });\n  }\n\n  return selections;\n}\n\nexport function getMuncherSettings(includeHomebrew = true) {\n  const cobalt = getCobalt() != \"\";\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\") != \"\";\n  const tier = game.settings.get(\"ddb-importer\", \"patreon-tier\");\n  const tiers = getPatreonTiers(tier);\n  const spellEffectModulesAvailable = spellEffectModules();\n  const daeInstalled = spellEffectModulesAvailable.daeInstalled;\n  const daeSRDInstalled = utils.isModuleInstalledAndActive(\"Dynamic-Effects-SRD\");\n  const midiSRDInstalled = utils.isModuleInstalledAndActive(\"midi-srd\");\n  const daeSRDContentAvailable = daeSRDInstalled || midiSRDInstalled;\n  const compendiumFolderAdd = game.settings.get(\"ddb-importer\", \"munching-policy-use-compendium-folders\");\n  const compendiumFoldersInstalled = utils.isModuleInstalledAndActive(\"compendium-folders\");\n  const compendiumFolderMonsterStyles = getCompendiumFolderLookups(\"monster\");\n  const compendiumFolderSpellStyles = getCompendiumFolderLookups(\"spell\");\n  const compendiumFolderItemStyles = getCompendiumFolderLookups(\"item\");\n  const spellEffectText = `Create active effects. These require DAE${getInstalledIcon(\"daeInstalled\")}, Midi-QOL${getInstalledIcon(\"midiQolInstalled\")}, Advanced Macros${getInstalledIcon(\"advancedMacrosInstalled\")}, Item Macro${getInstalledIcon(\"itemMacroInstalled\")}, About Time${getInstalledIcon(\"aboutTime\")}, Times Up${getInstalledIcon(\"timesUp\")}, and Convinient Effects${getInstalledIcon(\"convinientEffectsInstalled\")} as a minimum. Also recommened is Active Auras${getInstalledIcon(\"activeAurasInstalled\")}, Active Token Effects${getInstalledIcon(\"atlInstalled\")}, Token Magic FX${getInstalledIcon(\"tokenMagicInstalled\")}, and Automated Animations${getInstalledIcon(\"autoAnimationsInstalled\")}. Copying from MidiSRD will override these spells.`;\n\n\n  const itemConfig = [\n    {\n      name: \"use-ddb-item-icons\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-use-ddb-item-icons\"),\n      description: \"Use D&D Beyond item images, if available\",\n      enabled: true,\n    },\n    {\n      name: \"use-ddb-generic-item-icons\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-use-ddb-generic-item-icons\"),\n      description: \"Use D&D Beyond generic item type images, if available (final fallback)\",\n      enabled: true,\n    },\n    {\n      name: \"add-effects\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-add-effects\"),\n      description: \"Dynamically generate DAE effects (equipment only). (Requires DAE)\",\n      enabled: daeInstalled,\n    },\n    {\n      name: \"add-ac-armor-effects\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-add-ac-armor-effects\"),\n      description: \"[Caution] Dynamically generate DAE AC effects on armor equipment. (Requires DAE). Probably not required.\",\n      enabled: daeInstalled,\n    },\n  ];\n\n  const spellConfig = [\n    {\n      name: \"use-ddb-spell-icons\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-use-ddb-spell-icons\"),\n      description: \"If no other icon, use the D&DBeyond spell school icon.\",\n      enabled: true,\n    },\n    {\n      name: \"add-spell-effects\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-add-spell-effects\"),\n      description: spellEffectText,\n      enabled: spellEffectModulesAvailable.hasCore,\n    },\n  ];\n\n  const enableSources = game.settings.get(\"ddb-importer\", \"munching-policy-use-source-filter\");\n  const sourceArray = enableSources\n    ? game.settings.get(\"ddb-importer\", \"munching-policy-muncher-sources\").flat()\n    : [];\n  const sourcesSelected = enableSources && sourceArray.length > 0;\n  const sourceNames = getSourcesLookups(sourceArray).filter((source) => source.selected).map((source) => source.label);\n  const homebrewDescription = sourcesSelected\n    ? \"Include homebrew? SOURCES SELECTED! You can't import homebrew with a source filter selected\"\n    : \"Include homebrew?\";\n  const sourceDescription = `Importing from the following sources only: ${sourceNames.join(\", \")}`;\n\n  const basicMonsterConfig = [\n    {\n      name: \"hide-description\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-hide-description\"),\n      description: \"Hide monster action description from players?\",\n      enabled: true,\n    },\n    {\n      name: \"monster-items\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-monster-items\"),\n      description: \"[Experimental] Load items from DDB compendium instead of parsing action/attack?\",\n      enabled: true,\n    },\n    {\n      name: \"monster-use-item-ac\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-monster-use-item-ac\"),\n      description: \"[Experimental] Attempt to use items instead of setting a flat AC?\",\n      enabled: true,\n    },\n    {\n      name: \"update-images\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-update-images\"),\n      description: \"Update Monster images on existing items?\",\n      enabled: true,\n    },\n    {\n      name: \"use-full-token-image\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-use-full-token-image\"),\n      description: \"Use avatar image for token rather than token image\",\n      enabled: true,\n    },\n    {\n      name: \"use-token-avatar-image\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-use-token-avatar-image\"),\n      description: \"Use token image for avatar rather than avatar image\",\n      enabled: true,\n    },\n    {\n      name: \"monster-use-vision\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-monster-use-vision\"),\n      description: \"Should imported monster have vision set?\",\n      enabled: true,\n    },\n    {\n      name: \"dae-copy\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-dae-copy\"),\n      description: \"Use Dynamic Active Effects Compendiums for matching items/features (requires DAE and SRD module).\",\n      enabled: daeInstalled && daeSRDContentAvailable,\n    }\n  ];\n\n  const homebrewMonsterConfig = includeHomebrew\n    ? [\n      {\n        name: \"monster-homebrew\",\n        isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-monster-homebrew\") && !sourcesSelected,\n        description: homebrewDescription,\n        enabled: tiers.homebrew && !sourcesSelected,\n      },\n      {\n        name: \"monster-homebrew-only\",\n        isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-monster-homebrew-only\") && !sourcesSelected,\n        description: \"Homebrew monsters only? (Otherwise both)\",\n        enabled: tiers.homebrew && !sourcesSelected,\n      },\n      {\n        name: \"monster-exact-match\",\n        isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-monster-exact-match\"),\n        description: \"Exact name match?\",\n        enabled: tiers.homebrew,\n      }\n    ]\n    : [];\n\n  const monsterConfig = basicMonsterConfig.concat(homebrewMonsterConfig);\n\n  const genericConfig = [\n    {\n      name: \"update-existing\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-update-existing\"),\n      description: \"Update existing things.\",\n      enabled: true,\n    },\n    {\n      name: \"use-inbuilt-icons\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-use-inbuilt-icons\"),\n      description: \"Use icons from the inbuilt dictionary. (High coverage, recommended, fast).\",\n      enabled: true,\n    },\n    {\n      name: \"use-srd-icons\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-use-srd-icons\"),\n      description: \"Use icons from the SRD compendiums.\",\n      enabled: true,\n    },\n    {\n      name: \"download-images\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-download-images\"),\n      description: \"Download D&D Beyond images (takes longer and needs space).\",\n      enabled: true,\n    },\n    {\n      name: \"remote-images\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-remote-images\"),\n      description: \"Use D&D Beyond remote images (a lot quicker)\",\n      enabled: true,\n    },\n    {\n      name: \"use-dae-effects\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-use-dae-effects\"),\n      description: \"Copy effects from DAE (items and spells only). (Requires DAE and SRD or Midi content module). Will replace dynamically generated effects.\",\n      enabled: daeInstalled && daeSRDContentAvailable,\n    },\n    {\n      name: \"use-compendium-folders\",\n      isChecked: compendiumFoldersInstalled ? compendiumFolderAdd : false,\n      description: \"Generate compendium folders. You can migrate an existing import in the Tools tab.\",\n      enabled: compendiumFoldersInstalled,\n    },\n    {\n      name: \"use-srd\",\n      isChecked: game.settings.get(\"ddb-importer\", \"munching-policy-use-srd\"),\n      description:\n        \"[CAUTION] Use SRD compendium things instead of importing. This is not recommended, and may break adventure munching functionality.\",\n      enabled: true,\n    },\n    {\n      name: \"use-source-filter\",\n      isChecked: enableSources,\n      description: \"Restrict import to specific source book(s)? (DDB sets this as the <i>first</i> book a monster appears in).\",\n      enabled: tiers.homebrew,\n    }\n  ];\n\n  const resultData = {\n    cobalt,\n    genericConfig,\n    monsterConfig,\n    spellConfig,\n    itemConfig,\n    beta: betaKey && cobalt,\n    tiers,\n    compendiumFoldersInstalled,\n    compendiumFolderMonsterStyles,\n    compendiumFolderItemStyles,\n    compendiumFolderSpellStyles,\n    sourcesSelected,\n    sourceDescription,\n    enableSources,\n    version: CONFIG.DDBI.version,\n  };\n\n  // console.warn(resultData);\n\n  return resultData;\n}\n\nexport function updateMuncherSettings(html, event, dialog) {\n  const selection = event.currentTarget.dataset.section;\n  const checked = event.currentTarget.checked;\n\n  logger.debug(`Updating munching-policy-${selection} to ${checked}`);\n\n  game.settings.set(\"ddb-importer\", \"munching-policy-\" + selection, checked);\n\n  switch (selection) {\n    case \"use-full-token-image\": {\n      if (checked) {\n        game.settings.set(\"ddb-importer\", \"munching-policy-use-token-avatar-image\", false);\n        $(\"#munching-policy-use-token-avatar-image\").prop(\"checked\", false);\n      }\n      break;\n    }\n    case \"use-token-avatar-image\": {\n      if (checked) {\n        game.settings.set(\"ddb-importer\", \"munching-policy-use-full-token-image\", false);\n        $(\"#munching-policy-use-full-token-image\").prop(\"checked\", false);\n      }\n      break;\n    }\n    case \"monster-homebrew\": {\n      if (!checked) {\n        game.settings.set(\"ddb-importer\", \"munching-policy-monster-homebrew-only\", false);\n        $(\"#munching-policy-monster-homebrew-only\").prop(\"checked\", false);\n      }\n      break;\n    }\n    case \"monster-homebrew-only\": {\n      if (checked) {\n        game.settings.set(\"ddb-importer\", \"munching-policy-monster-homebrew\", true);\n        $(\"#munching-policy-monster-homebrew\").prop(\"checked\", true);\n      }\n      break;\n    }\n    case \"remote-images\": {\n      if (checked) {\n        game.settings.set(\"ddb-importer\", \"munching-policy-download-images\", false);\n        $(\"#munching-generic-policy-download-images\").prop(\"checked\", false);\n      }\n      break;\n    }\n    case \"download-images\": {\n      if (checked) {\n        game.settings.set(\"ddb-importer\", \"munching-policy-remote-images\", false);\n        $(\"#munching-generic-policy-remote-images\").prop(\"checked\", false);\n      }\n      break;\n    }\n    case \"use-source-filter\": {\n      $(\"#munch-source-select\").prop(\"disabled\", !checked);\n      $(\"#munch-source-div\").toggleClass(\"ddbimporter-hidden\");\n      dialog.render(true);\n      break;\n    }\n    // no default\n  }\n}\n","// Main module class\nimport logger from \"../logger.js\";\nimport { parseItems } from \"./items.js\";\nimport { parseSpells } from \"./spells.js\";\nimport { parseCritters } from \"./monsters.js\";\nimport { parseRaces } from \"./races.js\";\nimport { parseFeats } from \"./feats.js\";\nimport { parseClasses } from \"./classes.js\";\nimport { parseFrames } from \"./frames.js\";\nimport { getPatreonTiers, munchNote } from \"./utils.js\";\nimport { DDB_CONFIG } from \"../ddbConfig.js\";\nimport { getCobalt } from \"../lib/Secrets.js\";\nimport { base64Check } from \"../lib/Base64Check.js\";\nimport { downloadAdventureConfig } from \"./adventure.js\";\nimport AdventureMunch from \"./adventure/adventure.js\";\nimport ThirdPartyMunch from \"./adventure/thirdParty.js\";\nimport { updateMuncherSettings, getMuncherSettings } from \"./settings.js\";\nimport { migrateExistingCompendium } from \"./compendiumFolders.js\";\n\n\nexport function getSourcesLookups(selected) {\n  const selections = DDB_CONFIG.sources\n    .filter((source) => source.isReleased && source.sourceCategoryId !== 9 && source.sourceCategoryId !== 3)\n    .map((source) => {\n      const details = {\n        id: source.id,\n        acronym: source.name,\n        label: source.description,\n        selected: selected.includes(source.id),\n      };\n      return details;\n    });\n\n  return selections;\n}\n\nexport class DDBSources extends FormApplication {\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    options.id = \"ddb-importer-sources\";\n    options.template = \"modules/ddb-importer/handlebars/sources.hbs\";\n    options.width = 500;\n    return options;\n  }\n\n  get title() { // eslint-disable-line class-methods-use-this\n    // improve localisation\n    // game.i18n.localize(\"\")\n    return \"Monster Muncher Sauce Selection\";\n  }\n\n  activateListeners(html) {\n    super.activateListeners(html);\n\n    html.find(\"#toggle-sources\").click(async (event) => {\n      event.preventDefault();\n      if ($('.munching-sources input:checked').length && $('.munching-sources input').not(':checked').length) {\n        $('.munching-sources input').prop('checked', false);\n      } else {\n        $('.munching-sources input').each(function() {\n          // eslint-disable-next-line no-invalid-this\n          $(this).prop('checked', !$(this).prop('checked'));\n        });\n      }\n    });\n  }\n\n  /** @override */\n  async getData() { // eslint-disable-line class-methods-use-this\n    const existingSelection = game.settings.get(\"ddb-importer\", \"munching-policy-muncher-sources\").flat();\n    const sources = getSourcesLookups(existingSelection);\n\n    return {\n      sources: sources.sort((a, b) => {\n        return (a.label > b.label) ? 1 : ((b.label > a.label) ? -1 : 0);\n      }),\n    };\n  }\n\n  /** @override */\n  // eslint-disable-next-line no-unused-vars\n  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this\n    event.preventDefault();\n    let sources = [];\n    for (const [key, value] of Object.entries(formData)) {\n      if (value) sources.push(parseInt(key));\n    }\n    await game.settings.set(\"ddb-importer\", \"munching-policy-muncher-sources\", sources);\n    // eslint-disable-next-line no-use-before-define\n    new DDBMuncher().render(true);\n  }\n}\n\nexport default class DDBMuncher extends Application {\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    options.id = \"ddb-importer-monsters\";\n    options.template = \"modules/ddb-importer/handlebars/munch.hbs\";\n    options.resizable = false;\n    options.height = \"auto\";\n    options.width = 800;\n    options.title = \"MrPrimate's Muncher\";\n    options.classes = [\"ddb-muncher\", \"sheet\"];\n    options.tabs = [{ navSelector: \".tabs\", contentSelector: \"div\", initial: \"settings\" }];\n    return options;\n  }\n\n  static startMunch() {\n    munchNote(`Downloading monsters...`, true);\n    $('button[id^=\"munch-\"]').prop('disabled', true);\n    $('button[id^=\"adventure-config-start\"]').prop('disabled', true);\n    DDBMuncher.parseCritters();\n  }\n\n  activateListeners(html) {\n    super.activateListeners(html);\n    html.find(\"#munch-monsters-start\").click(async () => {\n      DDBMuncher.startMunch();\n    });\n    html.find(\"#munch-source-select\").click(async () => {\n      new DDBSources().render(true);\n    });\n\n    html.find(\"#munch-spells-start\").click(async () => {\n      munchNote(`Downloading spells...`, true);\n      $('button[id^=\"munch-\"]').prop('disabled', true);\n      DDBMuncher.parseSpells();\n    });\n    html.find(\"#munch-items-start\").click(async () => {\n      munchNote(`Downloading items...`, true);\n      $('button[id^=\"munch-\"]').prop('disabled', true);\n      DDBMuncher.parseItems();\n    });\n    html.find(\"#munch-races-start\").click(async () => {\n      munchNote(`Downloading races...`, true);\n      $('button[id^=\"munch-\"]').prop('disabled', true);\n      DDBMuncher.parseRaces();\n    });\n    html.find(\"#munch-feats-start\").click(async () => {\n      munchNote(`Downloading feats...`, true);\n      $('button[id^=\"munch-\"]').prop('disabled', true);\n      DDBMuncher.parseFeats();\n    });\n    html.find(\"#munch-classes-start\").click(async () => {\n      munchNote(`Downloading classes...`, true);\n      $('button[id^=\"munch-\"]').prop('disabled', true);\n      DDBMuncher.parseClasses();\n    });\n    html.find(\"#munch-frames-start\").click(async () => {\n      munchNote(`Downloading frames...`, true);\n      $('button[id^=\"munch-\"]').prop('disabled', true);\n      DDBMuncher.parseFrames();\n    });\n    html.find(\"#munch-adventure-config-start\").click(async () => {\n      munchNote(`Generating config file...`, true);\n      $('button[id^=\"munch-\"]').prop('disabled', true);\n      DDBMuncher.generateAdventureConfig();\n    });\n    html.find(\"#munch-adventure-import-start\").click(async () => {\n      new AdventureMunch().render(true);\n    });\n    html.find(\"#munch-adventure-third-party-start\").click(async () => {\n      new ThirdPartyMunch().render(true);\n    });\n    html.find(\"#munch-migrate-compendium-monster\").click(async () => {\n      munchNote(`Migrating monster compendium...`, true);\n      $('button[id^=\"munch-\"]').prop('disabled', true);\n      DDBMuncher.migrateCompendiumFolders(\"monsters\");\n    });\n    html.find(\"#munch-migrate-compendium-spell\").click(async () => {\n      munchNote(`Migrating spell compendium...`, true);\n      $('button[id^=\"munch-\"]').prop('disabled', true);\n      DDBMuncher.migrateCompendiumFolders(\"spells\");\n    });\n    html.find(\"#munch-migrate-compendium-item\").click(async () => {\n      munchNote(`Migrating item compendium...`, true);\n      $('button[id^=\"munch-\"]').prop('disabled', true);\n      DDBMuncher.migrateCompendiumFolders(\"items\");\n    });\n    html.find(\"#munch-fix-base64\").click(async () => {\n      munchNote(`Checking Scenes for base64 data...`, true);\n      $('button[id^=\"munch-\"]').prop('disabled', true);\n      DDBMuncher.base64Check();\n    });\n\n    // watch the change of the import-policy-selector checkboxes\n    $(html)\n      .find(\n        [\n          '.munching-generic-config input[type=\"checkbox\"]',\n          '.munching-spell-config input[type=\"checkbox\"]',\n          '.munching-item-config input[type=\"checkbox\"]',\n          '.munching-monster-config input[type=\"checkbox\"]',\n        ].join(\",\")\n      )\n      .on(\"change\", (event) => {\n        updateMuncherSettings(html, event, this);\n      });\n\n\n    html.find(\"#monster-munch-filter\").on(\"keyup\", (event) => {\n      event.preventDefault();\n      if (event.key !== \"Enter\") return; // Use `.key` instead.\n      DDBMuncher.startMunch();\n    });\n\n    // compendium style migrations\n    html.find(\"#compendium-folder-style-monster\").on(\"change\", async () => {\n      const style = html.find(\"#compendium-folder-style-monster\");\n      const importStyle = style[0].selectedOptions[0] ? style[0].selectedOptions[0].value : \"TYPE\";\n      game.settings.set(\"ddb-importer\", \"munching-selection-compendium-folders-monster\", importStyle);\n    });\n    html.find(\"#compendium-folder-style-spell\").on(\"change\", async () => {\n      const style = html.find(\"#compendium-folder-style-spell\");\n      const importStyle = style[0].selectedOptions[0] ? style[0].selectedOptions[0].value : \"SCHOOL\";\n      game.settings.set(\"ddb-importer\", \"munching-selection-compendium-folders-spell\", importStyle);\n    });\n    html.find(\"#compendium-folder-style-item\").on(\"change\", async () => {\n      const style = html.find(\"#compendium-folder-style-item\");\n      const importStyle = style[0].selectedOptions[0] ? style[0].selectedOptions[0].value : \"TYPE\";\n      game.settings.set(\"ddb-importer\", \"munching-selection-compendium-folders-item\", importStyle);\n    });\n\n    this.close();\n  }\n\n  static enableButtons() {\n    const cobalt = getCobalt() != \"\";\n    const tier = game.settings.get(\"ddb-importer\", \"patreon-tier\");\n    const tiers = getPatreonTiers(tier);\n\n    if (cobalt) {\n      $('button[id^=\"munch-spells-start\"]').prop('disabled', false);\n      $('button[id^=\"munch-items-start\"]').prop('disabled', false);\n      $('button[id^=\"munch-adventure-config-start\"]').prop('disabled', false);\n      $('button[id^=\"munch-adventure-import-start\"]').prop('disabled', false);\n      $('button[id^=\"munch-adventure-third-party-start\"]').prop('disabled', false);\n      $('button[id^=\"munch-migrate-compendium-monster\"]').prop('disabled', false);\n      $('button[id^=\"munch-migrate-compendium-spell\"]').prop('disabled', false);\n      $('button[id^=\"munch-migrate-compendium-item\"]').prop('disabled', false);\n      $('button[id^=\"munch-fix-base64\"]').prop('disabled', false);\n\n      if (tiers.all) {\n        $('button[id^=\"munch-monsters-start\"]').prop('disabled', false);\n      }\n      if (tiers.supporter) {\n        $('button[id^=\"munch-races-start\"]').prop('disabled', false);\n        $('button[id^=\"munch-feats-start\"]').prop('disabled', false);\n        $('button[id^=\"munch-source-select\"]').prop('disabled', false);\n        $('button[id^=\"munch-frames-start\"]').prop('disabled', false);\n      }\n      if (tiers.experimentalMid) {\n        $('button[id^=\"munch-classes-start\"]').prop('disabled', false);\n      }\n    }\n  }\n\n  static async parseCritters() {\n    try {\n      logger.info(\"Munching monsters!\");\n      const result = await parseCritters();\n      munchNote(`Finished importing ${result} monsters!`, true);\n      munchNote(\"\");\n      DDBMuncher.enableButtons();\n    } catch (error) {\n      logger.error(error);\n      logger.error(error.stack);\n    }\n\n  }\n\n  static async parseSpells() {\n    try {\n      logger.info(\"Munching spells!\");\n      await parseSpells();\n      munchNote(`Finished importing spells!`, true);\n      munchNote(\"\");\n      DDBMuncher.enableButtons();\n    } catch (error) {\n      logger.error(error);\n      logger.error(error.stack);\n    }\n  }\n\n  static async parseItems() {\n    try {\n      logger.info(\"Munching items!\");\n      await parseItems();\n      munchNote(`Finished importing items!`, true);\n      munchNote(\"\");\n      DDBMuncher.enableButtons();\n    } catch (error) {\n      logger.error(error);\n      logger.error(error.stack);\n    }\n  }\n\n  static async parseRaces() {\n    try {\n      logger.info(\"Munching races!\");\n      const result = await parseRaces();\n      munchNote(`Finished importing ${result.length} races and features!`, true);\n      munchNote(\"\");\n      DDBMuncher.enableButtons();\n    } catch (error) {\n      logger.error(error);\n      logger.error(error.stack);\n    }\n  }\n\n  static async parseFeats() {\n    try {\n      logger.info(\"Munching feats!\");\n      const result = await parseFeats();\n      munchNote(`Finished importing ${result.length} feats!`, true);\n      munchNote(\"\");\n      DDBMuncher.enableButtons();\n    } catch (error) {\n      logger.error(error);\n      logger.error(error.stack);\n    }\n  }\n\n\n  static async parseClasses() {\n    try {\n      logger.info(\"Munching classes!\");\n      const result = await parseClasses();\n      munchNote(`Finished importing ${result.length} classes and features!`, true);\n      munchNote(\"\");\n      DDBMuncher.enableButtons();\n    } catch (error) {\n      logger.error(error);\n      logger.error(error.stack);\n    }\n  }\n\n  static async parseFrames() {\n    try {\n      logger.info(\"Munching frames!\");\n      const result = await parseFrames();\n      munchNote(`Finished importing ${result.length} frames!`, true);\n      munchNote(\"\");\n      DDBMuncher.enableButtons();\n    } catch (error) {\n      logger.error(error);\n      logger.error(error.stack);\n    }\n  }\n\n  static async generateAdventureConfig() {\n    try {\n      logger.info(\"Generating adventure config!\");\n      await downloadAdventureConfig();\n      munchNote(`Downloading config file`, true);\n      munchNote(\"\");\n      DDBMuncher.enableButtons();\n    } catch (error) {\n      logger.error(error);\n      logger.error(error.stack);\n    }\n  }\n\n  static async migrateCompendiumFolders(type) {\n    logger.info(`Migrating ${type} compendium`);\n    await migrateExistingCompendium(type);\n    munchNote(`Migrating complete.`, true);\n    DDBMuncher.enableButtons();\n  }\n\n  static async base64Check() {\n    logger.info(\"Checking base64 in scenes\");\n    const results = base64Check();\n    let notifyString = `Check complete.`;\n    if (results.fixedScenes.length === 0 && results.badScenes.length === 0) {\n      notifyString += \" No problems found.\";\n    } else {\n      if (results.fixedScenes.length > 0) notifyString += ` Fixing ${results.fixedScenes.length} scenes (wait untill uploads complete).`;\n      if (results.badScenes.length > 0) notifyString += ` Found ${results.badScenes.length} scenes that I couldn't fix.`;\n    }\n    munchNote(notifyString, true);\n    DDBMuncher.enableButtons();\n  }\n\n  getData() { // eslint-disable-line class-methods-use-this\n    const resultData = getMuncherSettings();\n    return resultData;\n  }\n}\n","import { DirectoryPicker } from \"./DirectoryPicker.js\";\nimport { setPatreonTier, getPatreonTiers, BAD_DIRS, getPatreonValidity, getCampaignId } from \"../muncher/utils.js\";\nimport DDBMuncher from \"../muncher/ddb.js\";\nimport { getCobalt, setCobalt, moveCobaltToLocal, moveCobaltToSettings, checkCobalt } from \"./Secrets.js\";\nimport logger from \"../logger.js\";\n\nconst POPUPS = {\n  json: null,\n  web: null,\n};\n\nfunction renderPopup(type, url) {\n  if (POPUPS[type] && !POPUPS[type].close) {\n    POPUPS[type].focus();\n    POPUPS[type].location.href = url;\n  } else {\n    const ratio = window.innerWidth / window.innerHeight;\n    const width = Math.round(window.innerWidth * 0.5);\n    const height = Math.round(window.innerWidth * 0.5 * ratio);\n    POPUPS[type] = window.open(\n      url,\n      \"ddb_sheet_popup\",\n      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`\n    );\n  }\n  return true;\n}\n\nexport function isSetupComplete(needsCobalt = true) {\n  const uploadDir = game.settings.get(\"ddb-importer\", \"image-upload-directory\");\n  const dataDirSet = !BAD_DIRS.includes(uploadDir);\n  const cobalt = getCobalt() != \"\";\n  const setupComplete = dataDirSet && (cobalt || !needsCobalt);\n  return setupComplete;\n}\n\nasync function linkToPatreon() {\n\n  const proxy = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const patreonId = \"oXQUxnRAbV6mq2DXlsXY2uDYQpU-Ea2ds0G_5hIdi0Bou33ZRJgvV8Ub3zsEQcHp\";\n  const patreonAuthUrl = `${proxy}/patreon/auth`;\n  const patreonScopes = encodeURI(\"identity identity[email]\");\n\n  const socketOptions = {\n    transports: ['websocket', 'polling', 'flashsocket'],\n    // reconnection: false,\n    // reconnectionAttempts: 10,\n  };\n  const socket = io(`${proxy}/`, socketOptions);\n\n  socket.on(\"connect\", () => {\n    logger.debug(\"DDB Muncher socketID\", socket.id);\n    const serverDetails = {\n      id: socket.id,\n      world: game.world.data.title,\n      userId: game.userId,\n    };\n    socket.emit(\"register\", serverDetails);\n\n  });\n\n  socket.on('registered', (data) => {\n    logger.info(`Foundry instance registered with DDB Muncher Proxy`);\n    logger.debug(data);\n    renderPopup(\"web\", `https://www.patreon.com/oauth2/authorize?response_type=code&client_id=${patreonId}&redirect_uri=${patreonAuthUrl}&state=${data.userHash}&scope=${patreonScopes}`);\n  });\n\n  socket.on('auth', (data) => {\n    logger.debug(`Response from auth socket!`, data);\n\n    POPUPS[\"web\"].close();\n\n    game.settings.set(\"ddb-importer\", \"beta-key\", data.key);\n    game.settings.set(\"ddb-importer\", \"patreon-user\", data.email);\n    game.settings.set(\"ddb-importer\", \"patreon-tier\", data.tier);\n\n    $('#ddb-patreon-user').text(data.email);\n    $('#ddb-patreon-tier').text(data.tier);\n    $('#ddb-patreon-valid').text(\"True\");\n    $('#ddb-beta-key').val(data.key);\n\n    socket.disconnect();\n  });\n\n  socket.on('error', (data) => {\n    logger.error(`Error Response from socket!`, data);\n    socket.disconnect();\n  });\n}\n\nfunction getDDBCampaigns(cobalt = null) {\n  const cobaltCookie = cobalt ? cobalt : getCobalt();\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const body = { cobalt: cobaltCookie, betaKey: betaKey };\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/proxy/campaigns`, {\n      method: \"POST\",\n      cache: \"no-cache\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body), // body data type must match \"Content-Type\" header\n    })\n      .then((response) => response.json())\n      .then((data) => resolve(data.data))\n      .catch((error) => {\n        logger.error(`Cobalt cookie check error`);\n        logger.error(error);\n        logger.error(error.stack);\n        reject(error);\n      });\n  });\n\n}\n\nasync function checkCobaltCookie(value) {\n  const cookieStatus = await checkCobalt(\"\", value);\n  if (value !== \"\" && !cookieStatus.success) {\n    $('#munching-task-setup').text(`Your Cobalt Cookie is invalid, please check that you pasted the right information.`);\n    $('#ddb-importer-settings').css(\"height\", \"auto\");\n    throw new Error(`Your Cobalt Cookie is invalid, please check that you pasted the right information.`);\n  }\n  return cookieStatus;\n}\n\nasync function refreshCampaigns(cobalt = null) {\n  await checkCobaltCookie(cobalt);\n  CONFIG.DDBI.CAMPAIGNS = await getDDBCampaigns(cobalt);\n  return CONFIG.DDBI.CAMPAIGNS;\n}\n\nexport async function getAvailableCampaigns() {\n  if (CONFIG.DDBI.CAMPAIGNS) return CONFIG.DDBI.CAMPAIGNS;\n  const campaignId = getCampaignId();\n  // eslint-disable-next-line require-atomic-updates\n  CONFIG.DDBI.CAMPAIGNS = await getDDBCampaigns();\n\n  if (!CONFIG.DDBI.CAMPAIGNS) return [];\n\n  CONFIG.DDBI.CAMPAIGNS.forEach((campaign) => {\n    const selected = campaign.id == campaignId;\n    campaign.selected = selected;\n  });\n  return CONFIG.DDBI.CAMPAIGNS;\n}\n\nasync function setCobaltCookie(value, local) {\n  await checkCobaltCookie(value);\n  await setCobalt(value);\n  await game.settings.set(\"ddb-importer\", \"cobalt-cookie-local\", local);\n  const runCookieMigrate = local != game.settings.get(\"ddb-importer\", \"cobalt-cookie-local\");\n  if (runCookieMigrate && local) {\n    moveCobaltToLocal();\n  } else if (runCookieMigrate && !local) {\n    moveCobaltToSettings();\n  }\n\n}\n\nexport class DDBKeyChange extends FormApplication {\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    options.id = \"ddb-importer-key-change\";\n    options.template = \"modules/ddb-importer/handlebars/key-change.hbs\";\n    options.width = 500;\n    return options;\n  }\n\n  get title() { // eslint-disable-line class-methods-use-this\n    // improve localisation\n    // game.i18n.localize(\"\")\n    return \"DDB Importer Key Expiry\";\n  }\n\n  activateListeners(html) {\n    super.activateListeners(html);\n    html.find(\"#patreon-button\").click(async (event) => {\n      event.preventDefault();\n      linkToPatreon();\n    });\n  }\n\n  /** @override */\n  async getData() { // eslint-disable-line class-methods-use-this\n    const key = game.settings.get(\"ddb-importer\", \"beta-key\");\n    const setupConfig = {\n      \"beta-key\": key,\n    };\n    const patreonUser = game.settings.get(\"ddb-importer\", \"patreon-user\");\n    const check = await getPatreonValidity(key);\n\n    return {\n      success: (check && check.success) ? check.success : false,\n      message: (check && check.message) ? check.message : \"Unable to check patreon key status\",\n      setupConfig: setupConfig,\n      patreonLinked: patreonUser && patreonUser != \"\",\n      patreonUser: patreonUser,\n    };\n  }\n\n  /** @override */\n  // eslint-disable-next-line no-unused-vars\n  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this\n    event.preventDefault();\n    const currentKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n    if (currentKey !== formData['beta-key']) {\n      await game.settings.set(\"ddb-importer\", \"beta-key\", formData['beta-key']);\n      await setPatreonTier();\n    }\n\n    const callMuncher = game.settings.get(\"ddb-importer\", \"settings-call-muncher\");\n\n    if (callMuncher) {\n      game.settings.set(\"ddb-importer\", \"settings-call-muncher\", false);\n      new DDBMuncher().render(true);\n    }\n\n  }\n}\n\nexport async function isValidKey() {\n  let validKey = false;\n\n  const key = game.settings.get(\"ddb-importer\", \"beta-key\");\n  if (key === \"\") {\n    validKey = true;\n  } else {\n    const check = await getPatreonValidity(key);\n    if (check.success && check.data) {\n      validKey = true;\n    } else {\n      validKey = false;\n      game.settings.set(\"ddb-importer\", \"settings-call-muncher\", true);\n      new DDBKeyChange().render(true);\n    }\n  }\n  return validKey;\n}\n\nexport class DDBCookie extends FormApplication {\n\n  constructor(options, actor = null, localCobalt = false) {\n    super(options);\n    this.localCobalt = localCobalt;\n    this.actor = actor;\n  }\n\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    options.id = \"ddb-importer-cobalt-change\";\n    options.template = \"modules/ddb-importer/handlebars/cobalt.hbs\";\n    options.width = 500;\n    return options;\n  }\n\n  get title() { // eslint-disable-line class-methods-use-this\n    // improve localisation\n    // game.i18n.localize(\"\")\n    return \"DDB Importer Cobalt Cookie\";\n  }\n\n  /** @override */\n  async getData() {\n    const keyPostFix = this.localCobalt && this.actor ? this.actor.id : null;\n    const cobalt = getCobalt(keyPostFix);\n    const cobaltStatus = cobalt == \"\" ? { success: true } : await checkCobalt();\n    const expired = !cobaltStatus.success;\n\n    return {\n      expired: expired,\n      cobaltCookie: cobalt,\n      localCobalt: this.localCobalt && this.actor,\n      actor: this.actor,\n    };\n  }\n\n  /** @override */\n  async _updateObject(event, formData) {\n    event.preventDefault();\n    const keyPostFix = this.localCobalt && this.actor ? this.actor.id : null;\n    await setCobalt(formData['cobalt-cookie'], keyPostFix);\n\n    const cobaltStatus = await checkCobalt();\n    if (!cobaltStatus.success) {\n      new DDBCookie().render(true);\n    } else {\n      const callMuncher = game.settings.get(\"ddb-importer\", \"settings-call-muncher\");\n\n      if (callMuncher) {\n        game.settings.set(\"ddb-importer\", \"settings-call-muncher\", false);\n        new DDBMuncher().render(true);\n      }\n    }\n  }\n}\n\n\n// eslint-disable-next-line no-unused-vars\nHooks.on(\"renderDDBSetup\", (app, html, user) => {\n  DirectoryPicker.processHtml(html);\n});\n\n// eslint-disable-next-line no-unused-vars\nHooks.on(\"renderma\", (app, html, user) => {\n  DirectoryPicker.processHtml(html);\n});\n\nexport class DDBSetup extends FormApplication {\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    options.id = \"ddb-importer-settings\";\n    options.template = \"modules/ddb-importer/handlebars/settings.hbs\";\n    options.width = 500;\n    return options;\n  }\n\n  get title() { // eslint-disable-line class-methods-use-this\n    // improve localisation\n    // game.i18n.localize(\"\")\n    return \"DDB Importer Settings\";\n  }\n\n  /** @override */\n  async getData() { // eslint-disable-line class-methods-use-this\n    const cobalt = getCobalt();\n    const isCobalt = cobalt != \"\";\n    const cobaltStatus = await checkCobalt(\"\", cobalt);\n    const cobaltLocal = game.settings.get(\"ddb-importer\", \"cobalt-cookie-local\");\n    const hasKey = game.settings.get(\"ddb-importer\", \"beta-key\") != \"\";\n    const key = game.settings.get(\"ddb-importer\", \"beta-key\");\n    const campaignId = getCampaignId();\n    const tier = game.settings.get(\"ddb-importer\", \"patreon-tier\");\n    const uploadDir = game.settings.get(\"ddb-importer\", \"image-upload-directory\");\n    const otherUploadDir = game.settings.get(\"ddb-importer\", \"other-image-upload-directory\");\n    const frameUploadDir = game.settings.get(\"ddb-importer\", \"frame-image-upload-directory\");\n    const dataDirSet = !BAD_DIRS.includes(uploadDir) && !BAD_DIRS.includes(otherUploadDir);\n    const patreonUser = game.settings.get(\"ddb-importer\", \"patreon-user\");\n    const validKeyObject = hasKey ? await getPatreonValidity(key) : false;\n    const validKey = validKeyObject && validKeyObject.success && validKeyObject.data;\n    const availableCampaigns = isCobalt && cobaltStatus.success ? await getAvailableCampaigns() : [];\n\n    availableCampaigns.forEach((campaign) => {\n      const selected = campaign.id == campaignId;\n      campaign.selected = selected;\n    });\n\n    const setupConfig = {\n      \"image-upload-directory\": uploadDir,\n      \"other-image-upload-directory\": otherUploadDir,\n      \"frame-image-upload-directory\": frameUploadDir,\n      \"cobalt-cookie\": cobalt,\n      \"available-campaigns\": availableCampaigns,\n      \"campaign-id\": campaignId,\n      \"beta-key\": key,\n    };\n\n    const setupComplete = dataDirSet && isCobalt;\n\n    return {\n      cobalt: isCobalt,\n      cobaltLocal: cobaltLocal,\n      setupConfig: setupConfig,\n      setupComplete: setupComplete,\n      tier: tier,\n      patreonLinked: patreonUser && patreonUser != \"\",\n      patreonUser: patreonUser,\n      validKey: validKey,\n    };\n  }\n\n  activateListeners(html) {\n    super.activateListeners(html);\n    html.find(\"#patreon-button\").click(async (event) => {\n      event.preventDefault();\n      linkToPatreon();\n    });\n    html.find(\"#campaign-button\").click(async (event) => {\n      event.preventDefault();\n      const cookie = html.find(\"#cobalt-cookie-input\");\n      const campaigns = await refreshCampaigns(cookie[0].value);\n      let campaignList = `<option value=\"\">Select campaign:</option>`;\n      campaigns.forEach((campaign) => {\n        campaignList += `<option value=\"${campaign.id}\">${campaign.name} (${campaign.dmUsername}) - ${campaign.id}</option>\\n`;\n      });\n      const list = html.find(\"#campaign-select\");\n      list[0].innerHTML = campaignList;\n    });\n    html.find(\"#check-cobalt-button\").click(async (event) => {\n      event.preventDefault();\n      const cookie = html.find(\"#cobalt-cookie-input\");\n      if (cookie[0].value === undefined) throw new Error(\"undefined\");\n      const cobaltStatus = await checkCobalt(\"\", cookie[0].value);\n      const button = html.find(\"#check-cobalt-button\");\n      if (cobaltStatus.success) {\n        button[0].innerHTML = \"Check Cobalt Cookie - Success!\";\n      } else {\n        button[0].innerHTML = \"Check Cobalt Cookie - Failure!\";\n      }\n    });\n\n\n  }\n\n  /** @override */\n  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this\n    event.preventDefault();\n    const imageDir = formData['image-upload-directory'];\n    const campaignSelect = formData['campaign-select'];\n    // console.warn(formData);\n    const campaignId = campaignSelect == 0 ? \"\" : campaignSelect;\n    const cobaltCookie = formData['cobalt-cookie'];\n    const cobaltCookieLocal = formData['cobalt-cookie-local'];\n    const otherImageDir = formData['other-image-upload-directory'];\n    const frameImageDir = formData['frame-image-upload-directory'];\n    const currentKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n\n    if (currentKey !== formData['beta-key']) {\n      await game.settings.set(\"ddb-importer\", \"beta-key\", formData['beta-key']);\n      await setPatreonTier();\n    }\n\n    await game.settings.set(\"ddb-importer\", \"image-upload-directory\", imageDir);\n    await game.settings.set(\"ddb-importer\", \"other-image-upload-directory\", otherImageDir);\n    await game.settings.set(\"ddb-importer\", \"frame-image-upload-directory\", frameImageDir);\n    await game.settings.set(\"ddb-importer\", \"campaign-id\", campaignId);\n\n    await setCobaltCookie(cobaltCookie, cobaltCookieLocal);\n\n    const imageDirSet = !BAD_DIRS.includes(imageDir);\n    const otherImageDirSet = !BAD_DIRS.includes(otherImageDir);\n\n    const callMuncher = game.settings.get(\"ddb-importer\", \"settings-call-muncher\");\n\n    if (!imageDirSet || !otherImageDirSet || !frameImageDir) {\n      $('#munching-task-setup').text(`Please set the image upload directory(s) to something other than the root.`);\n      $('#ddb-importer-settings').css(\"height\", \"auto\");\n      throw new Error(`Please set the image upload directory to something other than the root.`);\n    } else if (callMuncher && cobaltCookie === \"\") {\n      $('#munching-task-setup').text(`To use Muncher you need to set a Cobalt Cookie value!`);\n      $('#ddb-importer-settings').css(\"height\", \"auto\");\n      throw new Error(`To use Muncher you need to set a Cobalt Cookie value!`);\n    } else {\n      DirectoryPicker.verifyPath(DirectoryPicker.parse(imageDir));\n      DirectoryPicker.verifyPath(DirectoryPicker.parse(otherImageDir));\n      DirectoryPicker.verifyPath(DirectoryPicker.parse(frameImageDir));\n\n      if (callMuncher) {\n        game.settings.set(\"ddb-importer\", \"settings-call-muncher\", false);\n        new DDBMuncher().render(true);\n      }\n    }\n  }\n}\n\nfunction getCompendiumLookups(type, selected) {\n  const excludedCompendiumPackages = [\n    \"dnd5e\", \"dae\", \"midiqol\", \"magicitems\",\n  ];\n\n  const selections = game.packs\n    .filter((pack) =>\n      pack.documentClass.documentName === type &&\n    !excludedCompendiumPackages.includes(pack.metadata.package)\n    )\n    .reduce((choices, pack) => {\n      choices[pack.collection] = {\n        label: `[${pack.metadata.package}] ${pack.metadata.label}`,\n        selected: pack.collection === selected,\n      };\n      return choices;\n    }, {});\n\n  return selections;\n}\n\n\nexport class DDBCompendiumSetup extends FormApplication {\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    options.id = \"ddb-importer-settings-compendium\";\n    options.template = \"modules/ddb-importer/handlebars/compendium.hbs\";\n    options.width = 500;\n    return options;\n  }\n\n  get title() { // eslint-disable-line class-methods-use-this\n    // improve localisation\n    // game.i18n.localize(\"\")\n    return \"DDB Importer Compendium Settings\";\n  }\n\n  /** @override */\n  async getData() { // eslint-disable-line class-methods-use-this\n    const settings = [\n      {\n        name: \"auto-create-compendium\",\n        isChecked: game.settings.get(\"ddb-importer\", \"auto-create-compendium\"),\n        description: \"Create default compendiums if missing?\",\n        enabled: true,\n      },\n    ];\n\n    const compendiums = [\n      {\n        setting: \"entity-class-compendium\",\n        name: \"Classes\",\n        type: \"item\",\n        current: game.settings.get(\"ddb-importer\", \"entity-class-compendium\"),\n        compendiums: getCompendiumLookups(\"Item\", game.settings.get(\"ddb-importer\", \"entity-class-compendium\")),\n      },\n      {\n        setting: \"entity-feature-compendium\",\n        name: \"Class features\",\n        type: \"item\",\n        current: game.settings.get(\"ddb-importer\", \"entity-feature-compendium\"),\n        compendiums: getCompendiumLookups(\"Item\", game.settings.get(\"ddb-importer\", \"entity-feature-compendium\")),\n      },\n      {\n        setting: \"entity-feat-compendium\",\n        name: \"Feats\",\n        type: \"item\",\n        current: game.settings.get(\"ddb-importer\", \"entity-feat-compendium\"),\n        compendiums: getCompendiumLookups(\"Item\", game.settings.get(\"ddb-importer\", \"entity-feat-compendium\")),\n      },\n      {\n        setting: \"entity-item-compendium\",\n        name: \"Items\",\n        type: \"item\",\n        current: game.settings.get(\"ddb-importer\", \"entity-item-compendium\"),\n        compendiums: getCompendiumLookups(\"Item\", game.settings.get(\"ddb-importer\", \"entity-item-compendium\")),\n      },\n      {\n        setting: \"entity-monster-compendium\",\n        name: \"Monsters\",\n        type: \"actor\",\n        current: game.settings.get(\"ddb-importer\", \"entity-monster-compendium\"),\n        compendiums: getCompendiumLookups(\"Actor\", game.settings.get(\"ddb-importer\", \"entity-monster-compendium\")),\n      },\n      {\n        setting: \"entity-race-compendium\",\n        name: \"Races\",\n        type: \"item\",\n        current: game.settings.get(\"ddb-importer\", \"entity-race-compendium\"),\n        compendiums: getCompendiumLookups(\"Item\", game.settings.get(\"ddb-importer\", \"entity-race-compendium\")),\n      },\n      {\n        setting: \"entity-trait-compendium\",\n        name: \"Racial traits\",\n        type: \"item\",\n        current: game.settings.get(\"ddb-importer\", \"entity-trait-compendium\"),\n        compendiums: getCompendiumLookups(\"Item\", game.settings.get(\"ddb-importer\", \"entity-trait-compendium\")),\n      },\n      {\n        setting: \"entity-spell-compendium\",\n        name: \"Spells\",\n        type: \"item\",\n        current: game.settings.get(\"ddb-importer\", \"entity-spell-compendium\"),\n        compendiums: getCompendiumLookups(\"Item\", game.settings.get(\"ddb-importer\", \"entity-spell-compendium\")),\n      },\n      {\n        setting: \"entity-table-compendium\",\n        name: \"Tables\",\n        type: \"RollTable\",\n        current: game.settings.get(\"ddb-importer\", \"entity-table-compendium\"),\n        compendiums: getCompendiumLookups(\"RollTable\", game.settings.get(\"ddb-importer\", \"entity-table-compendium\")),\n      },\n      {\n        setting: \"entity-override-compendium\",\n        name: \"Override\",\n        type: \"item\",\n        current: game.settings.get(\"ddb-importer\", \"entity-override-compendium\"),\n        compendiums: getCompendiumLookups(\"Item\", game.settings.get(\"ddb-importer\", \"entity-override-compendium\")),\n      },\n    ];\n\n    return {\n      settings,\n      compendiums,\n    };\n  }\n\n  /** @override */\n  // eslint-disable-next-line no-unused-vars\n  async _updateObject(event, formData) { // eslint-disable-line class-methods-use-this\n    event.preventDefault();\n    for (const [key, value] of Object.entries(formData)) {\n      game.settings.set(\"ddb-importer\", key, value);\n    }\n  }\n}\n\n\nfunction getGMUsers() {\n  const updateUser = game.settings.get(\"ddb-importer\", \"dynamic-sync-user\");\n\n  const gmUsers = game.users\n    .filter((user) => user.isGM)\n    .reduce((choices, user) => {\n      choices.push({\n        userId: user.id,\n        userName: user.name,\n        selected: user.id === updateUser,\n      });\n      return choices;\n    }, []);\n\n  return gmUsers;\n}\n\n\nexport class DDBDynamicUpdateSetup extends FormApplication {\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    options.id = \"ddb-importer-settings-dynamic-updates\";\n    options.template = \"modules/ddb-importer/handlebars/dynamic-updates.hbs\";\n    options.width = 500;\n    return options;\n  }\n\n  get title() { // eslint-disable-line class-methods-use-this\n    // improve localisation\n    // game.i18n.localize(\"\")\n    return \"DDB Importer Dynamic Update Settings\";\n  }\n\n  /** @override */\n  async getData() { // eslint-disable-line class-methods-use-this\n    const tier = game.settings.get(\"ddb-importer\", \"patreon-tier\");\n    const tiers = getPatreonTiers(tier);\n    const enabled = tiers.experimentalMid;\n\n    const settings = [\n      {\n        name: \"dynamic-sync\",\n        isChecked: enabled && game.settings.get(\"ddb-importer\", \"dynamic-sync\"),\n        description: \"Enable Dynamic Sync?\",\n        enabled,\n      },\n      {\n        name: \"dynamic-sync-policy-currency\",\n        isChecked: enabled && game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-currency\"),\n        description: \"Currency?\",\n        enabled,\n      },\n      {\n        name: \"dynamic-sync-policy-hitpoints\",\n        isChecked: enabled && game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-hitpoints\"),\n        description: \"Hit Points?\",\n        enabled,\n      },\n      {\n        name: \"dynamic-sync-policy-hitdice\",\n        isChecked: enabled && game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-hitdice\"),\n        description: \"Hit Dice?\",\n        enabled,\n      },\n      {\n        name: \"dynamic-sync-policy-action-use\",\n        isChecked: enabled && game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-action-use\"),\n        description: \"Action usage?\",\n        enabled,\n      },\n      {\n        name: \"dynamic-sync-policy-inspiration\",\n        isChecked: enabled && game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-inspiration\"),\n        description: \"Inspiration?\",\n        enabled,\n      },\n      {\n        name: \"dynamic-sync-policy-condition\",\n        isChecked: enabled && game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-condition\"),\n        description: \"Exhaustion?\",\n        enabled,\n      },\n      {\n        name: \"dynamic-sync-policy-deathsaves\",\n        isChecked: enabled && game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-deathsaves\"),\n        description: \"Death Saves?\",\n        enabled,\n      },\n      {\n        name: \"dynamic-sync-policy-spells-prepared\",\n        isChecked: enabled && game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-spells-prepared\"),\n        description: \"Spells Prepared?\",\n        enabled,\n      },\n      {\n        name: \"dynamic-sync-policy-spells-slots\",\n        isChecked: enabled && game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-spells-slots\"),\n        description: \"Spell Slots?\",\n        enabled,\n      },\n      {\n        name: \"dynamic-sync-policy-equipment\",\n        isChecked: enabled && game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-equipment\"),\n        description: \"Equipment?\",\n        enabled,\n      },\n      {\n        name: \"dynamic-sync-policy-xp\",\n        isChecked: enabled && game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-xp\"),\n        description: \"XP?\",\n        enabled,\n      },\n    ];\n    const gmUsers = getGMUsers();\n\n    return {\n      settings,\n      gmUsers,\n    };\n  }\n\n  /** @override */\n  // eslint-disable-next-line class-methods-use-this\n  async _updateObject(event, formData) {\n    event.preventDefault();\n    const initial = game.settings.get(\"ddb-importer\", \"dynamic-sync\");\n    for (const [key, value] of Object.entries(formData)) {\n      // eslint-disable-next-line no-await-in-loop\n      await game.settings.set(\"ddb-importer\", key, value);\n    }\n    const post = game.settings.get(\"ddb-importer\", \"dynamic-sync\");\n\n    if (initial != post) {\n      logger.warn(\"RELOADING!\");\n      foundry.utils.debounce(window.location.reload(), 100);\n    }\n  }\n}\n\n","import logger from \"../../logger.js\";\n\n/**\n * UTILITY\n * Returns a string representation of friendlyTypename and friendlySubtypeName for an obj[]\n * @param {object[]} arr array of objects\n */\nfunction extractInfo(arr) {\n  return arr.map((e) => `${e.friendlyTypeName} (${e.friendlySubtypeName})`);\n}\n\n/**\n * Extracts basic character information\n * @param {object} data Character JSON\n * returns information about the classes this character chose, including\n * - {string} name\n * - {number} level\n * - {boolean} isStartingClass\n * - {object[]} modifiers (empty, will be filled later)\n * }\n */\nfunction getClassInfo(data) {\n  return data.classes.map((cls) => {\n    return {\n      name:\n        cls.subclassDefinition && cls.subclassDefinition.name\n          ? `${cls.definition.name} (${cls.subclassDefinition.name})`\n          : cls.definition.name,\n      level: cls.level,\n      isStartingClass: cls.isStartingClass,\n      modifiers: [],\n    };\n  });\n}\n\n/**\n * Gets all class features up to a certain class level\n * @param {obj} cls character.classes[] entry\n * @param {*} classLevel level requirement up to which the class features should be extracted\n */\nexport function getClassFeatures(cls, classLevel = 20) {\n  if (\n    cls.subclassDefinition &&\n    cls.subclassDefinition.classFeatures &&\n    Array.isArray(cls.subclassDefinition.classFeatures)\n  ) {\n    const subclassFeatures = cls.subclassDefinition.classFeatures.map((subclassFeature) => {\n      subclassFeature.className = cls.definition.name;\n      subclassFeature.subclassName = cls.subclassDefinition.name;\n      return subclassFeature;\n    });\n    const result = cls.classFeatures\n      .map((feature) => {\n        const f = feature.definition;\n        f.className = cls.definition.name;\n        f.subclassName = null;\n        return f;\n      })\n      .concat(subclassFeatures)\n      .filter((classFeature) => classFeature.requiredLevel <= classLevel)\n      .sort((a, b) => a.requiredLevel - b.requiredLevel);\n    return result;\n  } else {\n    const result = cls.classFeatures\n      .map((feature) => {\n        const f = feature.definition;\n        f.className = cls.definition.name;\n        f.subclassName = null;\n        return f;\n      })\n      .filter((classFeature) => classFeature.requiredLevel <= classLevel)\n      .sort((a, b) => a.requiredLevel - b.requiredLevel);\n    return result;\n  }\n}\n\n/**\n * Gets all class options chosen\n * @param {obj} optionns character.options.classes entry\n */\n// function getChosenOptionIds(options) {\n//   return options.map((option) => {\n//     return option.definition.id;\n//   });\n// }\n\n/**\n * Checks if a given class is the starting class of this character\n * @param {object} data character data\n * @param {string} className name of the class to check\n * @returns {boolean} true of the class is a starting class, false otherwise\n */\nfunction isStartingClass(data, className) {\n  return data.classes.find((cls) => cls.definition.name === className && cls.isStartingClass);\n}\n\n/**\n * Gets all class modifiers for a given character\n * This filters out all modifiers that do not have an entry in the class features passed in\n * For multiclassing characters, it checks if the given class is the starting class or a multiclass,\n *    then the `.availableToMulticlass` is queried if this modifier is enabled or not\n * @param {obj} cls character.classes[] entry\n * @param {*} classLevel level requirement up to which the class features should be extracted\n */\nfunction getClassModifiers(data, classFeatures, isStartingClass = false) {\n  const modifiers = data.modifiers.class.filter((classModifier) => {\n    // check the class from which this modifier came\n    const componentId = classModifier.componentId;\n    const feature = classFeatures.find((feature) => feature.id === componentId);\n    if (feature !== undefined) {\n      const isFeatureAvailable = classModifier.availableToMulticlass ? true : isStartingClass;\n      logger.debug(\n        `${isFeatureAvailable ? \"  [  AVAIL]\" : \"  [UNAVAIL]\"} Modifier found: ${classModifier.friendlyTypeName} (${\n          classModifier.friendlySubtypeName\n        })`\n      );\n      return isFeatureAvailable;\n    }\n    return false;\n  });\n\n  return modifiers;\n}\n\nexport function getAllClassFeatures(data) {\n  return data.classes\n    .map((cls) => {\n      return getClassFeatures(cls, cls.level);\n    })\n    .flat();\n}\n\nfunction getClassOptionModifiers(data) {\n  const classFeatures = getAllClassFeatures(data);\n\n  const modifiers = data.modifiers.class.filter((classModifier) => {\n    const componentId = classModifier.componentId;\n    const feature = classFeatures.find((feature) => feature.id === componentId);\n\n    if (feature === undefined) {\n      logger.debug(`Modifier found: ${classModifier.friendlyTypeName} (${classModifier.friendlySubtypeName})`);\n      return true;\n    }\n    return false;\n  });\n\n  return modifiers;\n}\n\n/**\n * Filters the modifiers with the utility functions above\n * @param {object} data character data\n * @returns {[object[]]} an array containing an array of filtered modifiers, grouped by class\n */\nfunction filterModifiers(data, classInfo) {\n  // get the classFeatures for all classes\n  data.classes.forEach((cls, index) => {\n    const features = getClassFeatures(cls, cls.level);\n    classInfo[index].modifiers = getClassModifiers(data, features, isStartingClass(data, cls.definition.name));\n  });\n  return classInfo;\n}\n\nexport function fixCharacterLevels(data) {\n  const classInfo = getClassInfo(data.character);\n  const filteredClassInfo = filterModifiers(data.character, classInfo);\n  let classModifiers = getClassOptionModifiers(data.character, classInfo);\n\n  filteredClassInfo.forEach((cls) => {\n    logger.debug(`${cls.isStartingClass ? \"Starting Class\" : \"Multiclass\"}: [lvl${cls.level}] ${cls.name} `);\n    logger.debug(\n      extractInfo(cls.modifiers)\n        .map((s) => `    ${s}`)\n        .join(\"\\n\")\n    );\n    classModifiers = classModifiers.concat(cls.modifiers);\n  });\n  data.character.modifiers.class = classModifiers;\n  return data;\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport logger from \"../../logger.js\";\nimport utils from \"../../utils.js\";\nimport { generateFixedACEffect } from \"../../effects/acEffects.js\";\nimport { getAllClassFeatures } from \"./filterModifiers.js\";\n\n/**\n * This excludes shields\n * @param {} data\n */\nexport function isArmored(data) {\n  return (\n    data.character.inventory.filter(\n      (item) => item.equipped && item.definition.armorClass && item.definition.armorTypeId !== 4\n    ).length >= 1\n  );\n}\n\nfunction getMinimumBaseAC(modifiers) {\n  let hasBaseArmor = modifiers.filter(\n    (modifier) => modifier.type === \"set\" && modifier.subType === \"minimum-base-armor\" && modifier.isGranted\n  );\n  let baseAC = [];\n  hasBaseArmor.forEach((base) => {\n    baseAC.push(base.value);\n  });\n  return baseAC;\n}\n\nfunction getBaseArmor(ac, armorType, name = \"Racial\") {\n  return {\n    definition: {\n      name: `Base Armor - ${name}`,\n      type: armorType,\n      armorClass: ac,\n      armorTypeId: DICTIONARY.equipment.armorType.find((id) => id.name === armorType).id,\n      grantedModifiers: [],\n      canAttune: false,\n      filterType: \"Armor\",\n    },\n    isAttuned: false,\n  };\n}\n\nfunction getEquippedAC(equippedGear) {\n  return equippedGear.reduce((prev, item) => {\n    let ac = 0;\n    // regular armor\n    if (item.definition.armorClass) {\n      ac += item.definition.armorClass;\n    }\n\n    // magical armor\n    const usingItemEffects = game.settings.get(\"ddb-importer\", \"character-update-policy-add-item-effects\");\n\n    const daeItemEffects = (usingItemEffects &&\n      item.equipped && item.definition.filterType !== \"Armor\"\n    );\n\n    if (!daeItemEffects && item.definition.grantedModifiers) {\n      let isAvailable = false;\n      // does an item need attuning\n      if (item.definition.canAttune === true) {\n        if (item.isAttuned === true) {\n          isAvailable = true;\n        }\n      } else {\n        isAvailable = true;\n      }\n\n      if (isAvailable) {\n        item.definition.grantedModifiers.forEach((modifier) => {\n          if (modifier.type === \"bonus\" && modifier.subType === \"armor-class\") {\n            // add this to armor AC\n            ac += modifier.value;\n          }\n        });\n      }\n    }\n    return prev + ac;\n  }, 0);\n}\n\n// returns an array of ac values from provided array of modifiers\nfunction getUnarmoredAC(modifiers, character) {\n  let unarmoredACValues = [];\n  let isUnarmored = modifiers.filter(\n    (modifier) => modifier.type === \"set\" && modifier.subType === \"unarmored-armor-class\" && modifier.isGranted\n  );\n  // if (isUnarmored.length === 0) {\n  //   // Some items will have an unarmoured bonus, but won't set a base, so if we are in this\n  //   // situation, we add a default base ac\n  //   isUnarmored.push({\n  //     statId: 2,\n  //     value: 0,\n  //   });\n  // }\n\n  const ignoreDex = modifiers.some((modifier) => modifier.type === \"ignore\" && modifier.subType === \"unarmored-dex-ac-bonus\");\n\n  const maxUnamoredDexMods = modifiers.filter(\n    (modifier) => modifier.type === \"set\" && modifier.subType === \"ac-max-dex-modifier\" && modifier.isGranted\n  ).map((mods) => mods.value);\n  const maxUnamoredDexMod = ignoreDex ? 0 : Math.min(...maxUnamoredDexMods, 20);\n\n  // console.log(`Max Dex: ${maxUnamoredDexMod}`);\n  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;\n\n  isUnarmored.forEach((unarmored) => {\n    let unarmoredACValue = 10;\n    // +DEX\n    // for a case of setting unarmoured ac, the dex won't detract\n    unarmoredACValue += Math.max(0, Math.min(characterAbilities.dex.mod, maxUnamoredDexMod));\n    // +WIS or +CON, if monk or barbarian, draconic resilience === null\n\n    // console.log(`Unarmoured AC Value: ${unarmoredACValue}`);\n    // console.log(unarmored);\n\n    if (unarmored.statId !== null) {\n      let ability = DICTIONARY.character.abilities.find((ability) => ability.id === unarmored.statId);\n      unarmoredACValue += characterAbilities[ability.value].mod;\n    }\n    if (unarmored.value) unarmoredACValue += unarmored.value;\n    unarmoredACValues.push(unarmoredACValue);\n  });\n  // console.warn(unarmoredACValues);\n  return unarmoredACValues;\n}\n\n// returns an array of ac values from provided array of modifiers\nfunction getArmoredACBonuses(modifiers, character) {\n  let armoredACBonuses = [];\n  const armoredBonuses = modifiers.filter(\n    (modifier) => modifier.subType === \"armored-armor-class\" && modifier.isGranted\n  );\n  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;\n\n  armoredBonuses.forEach((armoredBonus) => {\n    let armoredACBonus = 0;\n    if (armoredBonus.statId !== null) {\n      let ability = DICTIONARY.character.abilities.find((ability) => ability.id === armoredBonus.statId);\n      armoredACBonus += characterAbilities[ability.value].mod;\n    } else {\n      armoredACBonus += armoredBonus.value;\n    }\n    armoredACBonuses.push(armoredACBonus);\n  });\n  return armoredACBonuses;\n}\n\nfunction getDualWieldAC(data, modifiers) {\n  const dualWielding = data.character.characterValues.some((cv) => {\n    const equipped = data.character.inventory.some((item) => item.equipped && item.id == cv.valueId);\n    const dualWielding = cv.typeId === 18;\n    return equipped && dualWielding;\n  });\n  let dualWieldBonus = 0;\n\n  if (dualWielding) {\n    utils.filterModifiers(modifiers, \"bonus\", \"dual-wield-armor-class\", [\"\", null], true).forEach((bonus) => {\n      dualWieldBonus += bonus.value;\n    });\n  }\n\n  return dualWieldBonus;\n}\n\n// eslint-disable-next-line complexity\nfunction calculateACOptions(data, character, calculatedArmor) {\n  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;\n  let actorBase = 10 + characterAbilities.dex.mod;\n  // generated AC effects\n  let effects = [];\n  // array to assemble possible AC values\n  let armorClassValues = [];\n  // max holders\n  let maxType = \"Unarmored\";\n  let maxValue = actorBase;\n\n  // the presumption here is that you can only wear a shield and a single\n  // additional 'armor' piece. in DDB it's possible to equip multiple armor\n  // types and it works out the best AC for you\n  // we also want to handle unarmored for monks etc.\n  // we might have multiple shields \"equipped\" by accident, so work out\n  // the best one\n  for (var armor = 0; armor < calculatedArmor.armors.length; armor++) {\n    // getEquippedAC fetches any magical AC boost on the items passed\n    let armorAC = getEquippedAC([calculatedArmor.armors[armor]]);\n    let shieldMod = 0;\n\n    if (calculatedArmor.shields.length !== 0) {\n      let maxAC = armorAC;\n      for (var shield = 0; shield < calculatedArmor.shields.length; shield++) {\n        const combinedAC = getEquippedAC([calculatedArmor.armors[armor], calculatedArmor.shields[shield]]);\n        if (combinedAC > maxAC) {\n          shieldMod = combinedAC - armorAC;\n          maxAC = combinedAC;\n        }\n      }\n      armorAC = maxAC;\n    }\n\n    // Determine final AC values based on AC Type\n    // Light Armor: AC + DEX\n    // Medium Armor: AC + DEX (max 2)\n    // Heavy Armor: AC only\n    // Unarmored Defense: Dex mod already included in calculation\n\n    // sometimes the type field can be blank in DDB\n    if (!calculatedArmor.armors[armor].definition.type || calculatedArmor.armors[armor].definition.type === \"\") {\n      const armourTypeId = calculatedArmor.armors[armor].definition.armorTypeId;\n      const acType = DICTIONARY.equipment.armorType.find((a) => a.id === armourTypeId);\n      if (acType) calculatedArmor.armors[armor].definition.type = acType.name;\n    }\n    let effect = null;\n    let acValue;\n\n    switch (calculatedArmor.armors[armor].definition.type) {\n      case \"Natural Armor\": {\n        let acCalc = 0;\n        // Tortles don't get to add an unarmored ac bonus for their shell\n        const ignoreUnarmouredACBonus = utils.filterBaseModifiers(data, \"ignore\", \"unarmored-dex-ac-bonus\");\n        if (ignoreUnarmouredACBonus) {\n          acCalc = armorAC + calculatedArmor.miscACBonus;\n          // console.log(armorAC);\n          // console.log(gearAC);\n          // console.log(miscACBonus);\n        } else {\n          acCalc = armorAC + calculatedArmor.miscACBonus + calculatedArmor.unarmoredACBonus;\n        }\n        acValue = {\n          name: calculatedArmor.armors[armor].definition.name,\n          value: acCalc + calculatedArmor.gearAC,\n          type: \"Natural\",\n          acCalc,\n          shieldMod,\n        };\n        if (acCalc > actorBase) actorBase = acCalc - shieldMod;\n        effect = generateFixedACEffect(acValue.value, `AC ${calculatedArmor.armors[armor].definition.name} (Natural): ${acValue.value}`, true);\n        break;\n      }\n      case \"Unarmored Defense\": {\n        const acCalc = armorAC + calculatedArmor.miscACBonus + calculatedArmor.unarmoredACBonus;\n        acValue = {\n          name: calculatedArmor.armors[armor].definition.name,\n          value: acCalc + calculatedArmor.gearAC,\n          type: \"Unarmored Defense\",\n          acCalc,\n          shieldMod,\n        };\n        if (acCalc > actorBase) actorBase = acCalc - shieldMod;\n        effect = generateFixedACEffect(acValue.value, `AC ${calculatedArmor.armors[armor].definition.name} (Unarmored Defense): ${acValue.value}`);\n        break;\n      }\n      case \"Unarmored\": {\n        const base = armorAC + calculatedArmor.miscACBonus + calculatedArmor.unarmoredACBonus;\n        const acCalc = base + characterAbilities.dex.mod;\n        acValue = {\n          name: calculatedArmor.armors[armor].definition.name,\n          value: acCalc + calculatedArmor.gearAC,\n          type: \"Unarmored\",\n          acCalc,\n          shieldMod,\n        };\n        if (acCalc > actorBase) actorBase = acCalc - shieldMod;\n        effect = generateFixedACEffect(`${acValue.value} + @abilities.dex.mod`, `AC ${calculatedArmor.armors[armor].definition.name} (Unarmored): ${acValue.value}`, true, 15);\n        break;\n      }\n      case \"Heavy Armor\": {\n        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;\n        acValue = {\n          name: calculatedArmor.armors[armor].definition.name,\n          value: acCalc,\n          type: \"Heavy\",\n          acCalc,\n          shieldMod,\n        };\n        effect = generateFixedACEffect(acValue.value, `AC ${calculatedArmor.armors[armor].definition.name} (Heavy): ${acValue.value}`);\n        break;\n      }\n      case \"Medium Armor\": {\n        const maxDexMedium = Math.max(...utils.filterBaseModifiers(data, \"set\", \"ac-max-dex-armored-modifier\", [\"\", null], true)\n          .map((mod) => mod.value), 2);\n        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;\n        acValue = {\n          name: calculatedArmor.armors[armor].definition.name,\n          value: acCalc + Math.min(maxDexMedium, characterAbilities.dex.mod),\n          type: \"Medium\",\n          acCalc,\n          shieldMod,\n        };\n        effect = generateFixedACEffect(`${acCalc} + {@abilities.dex.mod, ${maxDexMedium}}kl`, `AC ${calculatedArmor.armors[armor].definition.name} (Medium): ${acValue.value}`);\n        break;\n      }\n      case \"Light Armor\": {\n        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;\n        acValue = {\n          name: calculatedArmor.armors[armor].definition.name,\n          value: acCalc + characterAbilities.dex.mod,\n          type: \"Light\",\n          acCalc,\n          shieldMod,\n        };\n        effect = generateFixedACEffect(`${acCalc} + @abilities.dex.mod`, `AC ${calculatedArmor.armors[armor].definition.name} (Light): ${acValue.value}`);\n        break;\n      }\n      default: {\n        const acCalc = armorAC + calculatedArmor.gearAC + calculatedArmor.miscACBonus;\n        acValue = {\n          name: calculatedArmor.armors[armor].definition.name,\n          value: acCalc + characterAbilities.dex.mod,\n          type: \"Other\",\n          acCalc,\n          shieldMod,\n        };\n        effect = generateFixedACEffect(`${acCalc} + @abilities.dex.mod`, `AC ${calculatedArmor.armors[armor].definition.name}: ${acValue.value}`, false, 22);\n        break;\n      }\n    }\n    if (effect) {\n      effect.flags.ddbimporter.itemId = calculatedArmor.armors[armor].id;\n      effect.flags.ddbimporter.entityTypeId = calculatedArmor.armors[armor].entityTypeId;\n      effects.push(effect);\n    }\n    armorClassValues.push(acValue);\n    if (acValue.value >= maxValue) {\n      maxType = acValue.type;\n      maxValue = acValue.value;\n    }\n  }\n\n  logger.debug(\"Final AC Choices:\", armorClassValues);\n  return {\n    actorBase,\n    armorClassValues,\n    effects,\n    maxType,\n    maxValue,\n  };\n}\n\nexport function getArmorClass(ddb, character) {\n  const overRideAC = ddb.character.characterValues.find((val) => val.typeId === 1);\n\n  if (overRideAC) {\n    const overRideEffect = generateFixedACEffect(overRideAC.value, `AC Override: ${overRideAC.value}`);\n    return {\n      fixed: {\n        type: \"Number\",\n        label: \"Armor Class\",\n        value: overRideAC.value,\n      },\n      base: overRideAC.value,\n      effects: [overRideEffect],\n      override: {\n        flat: overRideAC.value,\n        calc: \"default\",\n        formula: \"\",\n      },\n      auto: {\n        flat: overRideAC.value,\n        calc: \"default\",\n        formula: \"\",\n      },\n    };\n  }\n\n  // get a list of equipped armor\n  // we make a distinction so we can loop over armor\n  let equippedArmor = ddb.character.inventory.filter(\n    (item) => item.equipped && item.definition.filterType === \"Armor\"\n  );\n  let baseAC = 10;\n  // for things like fighters fighting style\n  let miscACBonus = 0;\n  // lets get equipped gear\n  const equippedGear = ddb.character.inventory.filter(\n    (item) => item.equipped && item.definition.filterType !== \"Armor\"\n  );\n  const unarmoredACBonus = utils\n    .filterBaseModifiers(ddb, \"bonus\", \"unarmored-armor-class\")\n    .reduce((prev, cur) => prev + cur.value, 0);\n\n  // lets get the AC for all our non-armored gear, we'll add this later\n  const gearAC = getEquippedAC(equippedGear);\n\n  // While not wearing armor, lets see if we have special abilities\n  if (!isArmored(ddb)) {\n    // unarmored abilities from Class/Race?\n    const unarmoredSources = [\n      utils.getChosenClassModifiers(ddb),\n      ddb.character.modifiers.race,\n      ddb.character.modifiers.feat,\n      utils.getActiveItemModifiers(ddb, true),\n    ];\n    unarmoredSources.forEach((modifiers) => {\n      const unarmoredAC = Math.max(getUnarmoredAC(modifiers, character));\n      if (unarmoredAC) {\n        // we add this as an armored type so we can get magical item bonuses\n        // e.g. ring of protection\n        equippedArmor.push(getBaseArmor(unarmoredAC, \"Unarmored Defense\", \"Unarmored defense\"));\n      }\n    });\n  } else {\n    // check for things like fighters fighting style defense\n    const armorBonusSources = [utils.getChosenClassModifiers(ddb), ddb.character.modifiers.race];\n    armorBonusSources.forEach((modifiers) => {\n      const armoredACBonuses = getArmoredACBonuses(modifiers, character);\n      miscACBonus += armoredACBonuses.reduce((a, b) => a + b, 0);\n    });\n  }\n\n  // Generic AC bonuses like Warforfed Integrated Protection\n  // item modifiers are loaded by ac calcs\n  const miscModifiers = [\n    utils.getChosenClassModifiers(ddb),\n    ddb.character.modifiers.race,\n    ddb.character.modifiers.background,\n    ddb.character.modifiers.feat,\n  ];\n\n  utils.filterModifiers(miscModifiers, \"bonus\", \"armor-class\", [\"\", null], true).forEach((bonus) => {\n    miscACBonus += bonus.value;\n  });\n\n  miscACBonus += ddb.character.characterValues.filter((value) =>\n    value.typeId === 3 || value.typeId === 2\n  ).map((val) => val.value).reduce((a, b) => a + b, 0);\n\n  miscACBonus += getDualWieldAC(ddb, miscModifiers);\n\n  // Each racial armor appears to be slightly different!\n  // We care about Tortles and Lizardfolk here as they can use shields, but their\n  // modifier is set differently\n  switch (ddb.character.race.fullName) {\n    case \"Lizardfolk\":\n      baseAC = Math.max(getUnarmoredAC(ddb.character.modifiers.race, character));\n      equippedArmor.push(getBaseArmor(baseAC, \"Natural Armor\", ddb.character.race.fullName));\n      break;\n    case \"Loxodon\":\n    case \"Tortle\":\n      baseAC = Math.max(getMinimumBaseAC(ddb.character.modifiers.race, character), getUnarmoredAC(ddb.character.modifiers.race, character));\n      equippedArmor.push(getBaseArmor(baseAC, \"Natural Armor\", ddb.character.race.fullName));\n      break;\n    default:\n      equippedArmor.push(getBaseArmor(baseAC, \"Unarmored\"));\n  }\n\n  const shields = equippedArmor.filter((shield) => shield.definition.armorTypeId === 4);\n  const armors = equippedArmor.filter((armour) => armour.definition.armorTypeId !== 4);\n\n  logger.debug(\"Calculated GearAC: \" + gearAC);\n  logger.debug(\"Unarmoured AC Bonus:\" + unarmoredACBonus);\n  logger.debug(\"Calculated MiscACBonus: \" + miscACBonus);\n  logger.debug(\"Equipped AC Options: \", equippedArmor);\n  logger.debug(\"Armors: \", armors);\n  logger.debug(\"Shields: \", shields);\n\n  const calculatedArmor = {\n    gearAC,\n    unarmoredACBonus,\n    miscACBonus,\n    equippedArmor,\n    armors,\n    shields,\n  };\n  const results = calculateACOptions(ddb, character, calculatedArmor);\n\n  logger.debug(\"Final AC Results:\", results);\n  // get the max AC we can use from our various computed values\n  // const max = Math.max(...results.armorClassValues.map((type) => type.value));\n\n  //\n  // DND5E.armorClasses = {\n  //   \"default\": {\n\n\n  // const draconic = ddb.classes[0].classFeatures[1].definition\n  const classFeatures = getAllClassFeatures(ddb.character);\n  logger.debug(\"Class features\", classFeatures);\n\n  let calc = \"default\";\n  let flat = null;\n  if (classFeatures.some((kf) =>\n    kf.className === \"Sorcerer\" &&\n    kf.subclassName === \"Draconic Bloodline\" &&\n    kf.name === \"Draconic Resilience\"\n  )) calc = \"draconic\";\n\n  if (classFeatures.some((kf) =>\n    kf.className === \"Monk\" &&\n    kf.subclassName === null &&\n    kf.name === \"Unarmored Defense\"\n  )) calc = \"unarmoredMonk\";\n\n  if (classFeatures.some((kf) =>\n    kf.className === \"Barbarian\" &&\n    kf.subclassName === null &&\n    kf.name === \"Unarmored Defense\"\n  )) calc = \"unarmoredBarb\";\n\n  const naturalACAllowed = utils.versionCompare(game.data.system.data.version, \"1.4.2\") >= 0;\n  if (naturalACAllowed && results.maxType === \"Natural\") {\n    calc = \"natural\";\n    flat = results.actorBase;\n  }\n\n  const acResults = {\n    fixed: {\n      type: \"Number\",\n      label: \"Armor Class\",\n      value: results.maxValue,\n    },\n    base: results.actorBase,\n    effects: results.effects,\n    override: {\n      flat: results.maxValue,\n      calc: \"default\",\n      formula: \"\",\n    },\n    auto: {\n      flat,\n      calc,\n      formula: \"\",\n    },\n  };\n  logger.debug(\"AC Results:\", acResults);\n\n  return acResults;\n}\n","import utils from \"../../utils.js\";\n\nexport function getSpecialTraits(data) {\n  let results = {\n    powerfulBuild: false,\n    savageAttacks: false,\n    elvenAccuracy: false,\n    halflingLucky: false,\n    initiativeAdv: false,\n    initiativeAlert: false,\n    jackOfAllTrades: false,\n    weaponCriticalThreshold: 20,\n    observantFeat: false,\n    remarkableAthlete: false,\n    reliableTalent: false,\n    diamondSoul: false,\n    meleeCriticalDamageDice: 0,\n    wildMagic: false,\n  };\n\n  // powerful build/equine build\n  results.powerfulBuild = data.character.race.racialTraits.some(\n    (trait) => trait.definition.name === \"Equine Build\" || trait.definition.name === \"Powerful Build\"\n  );\n\n  // savage attacks\n  const savageAttacks = data.character.race.racialTraits.some((trait) => trait.definition.name === \"Savage Attacks\");\n  results.savageAttacks = savageAttacks;\n  if (savageAttacks) results.meleeCriticalDamageDice += 1;\n\n  // halfling lucky\n  results.halflingLucky = data.character.race.racialTraits.some((trait) => trait.definition.name === \"Lucky\");\n\n  // elven accuracy\n  results.elvenAccuracy = data.character.feats.some((feat) => feat.definition.name === \"Elven Accuracy\");\n\n  // alert feat\n  results.initiativeAlert = data.character.feats.some((feat) => feat.definition.name === \"Alert\");\n\n  // advantage on initiative\n  results.initiativeAdv = utils.filterBaseModifiers(data, \"advantage\", \"initiative\").length > 0;\n\n  // initiative half prof\n  results.initiativeHalfProf = utils.filterBaseModifiers(data, \"half-proficiency\", \"initiative\").length > 0;\n\n  // observant\n  results.observantFeat = data.character.feats.some((feat) => feat.definition.name === \"Observant\");\n\n  // weapon critical threshold\n  // fighter improved crit\n  // remarkable athlete\n  data.character.classes.forEach((cls) => {\n    if (cls.subclassDefinition) {\n      // Improved Critical\n      const improvedCritical = cls.subclassDefinition.classFeatures.some(\n        (feature) => feature.name === \"Improved Critical\" && cls.level >= feature.requiredLevel\n      );\n      const superiorCritical = cls.subclassDefinition.classFeatures.some(\n        (feature) => feature.name === \"Superior Critical\" && cls.level >= feature.requiredLevel\n      );\n\n      if (superiorCritical) {\n        results.weaponCriticalThreshold = 18;\n      } else if (improvedCritical && results.weaponCriticalThreshold > 19) {\n        results.weaponCriticalThreshold = 19;\n      }\n\n      // Remarkable Athlete\n      results.remarkableAthlete = results.remarkableAthlete || cls.subclassDefinition.classFeatures.some(\n        (feature) => feature.name === \"Remarkable Athlete\" && cls.level >= feature.requiredLevel\n      );\n\n      // wild magic surge for 5e Helpers\n      results.wildMagic = cls.subclassDefinition.classFeatures.some(\n        (feature) => feature.name === \"Wild Magic Surge\" && cls.level >= feature.requiredLevel\n      );\n    }\n\n    // Brutal Critical\n    results.meleeCriticalDamageDice += cls.definition.classFeatures.filter(\n      (feature) => feature.name === \"Brutal Critical\" && cls.level >= feature.requiredLevel\n    ).length;\n\n    // Diamond Soul\n    results.diamondSoul = results.diamondSoul || cls.definition.classFeatures.some(\n      (feature) => feature.name === \"Diamond Soul\" && cls.level >= feature.requiredLevel\n    );\n\n    // Jack of All Trades\n    results.jackOfAllTrades = results.jackOfAllTrades || cls.definition.classFeatures.some(\n      (feature) => feature.name === \"Jack of All Trades\" && cls.level >= feature.requiredLevel\n    );\n\n    // Reliable Talent\n    results.reliableTalent = results.reliableTalent || cls.definition.classFeatures.some(\n      (feature) => feature.name === \"Reliable Talent\" && cls.level >= feature.requiredLevel\n    );\n  });\n\n  return results;\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport utils from \"../../utils.js\";\n\n// is there a spell casting ability?\nlet hasSpellCastingAbility = (spellCastingAbilityId) => {\n  return DICTIONARY.character.abilities.find((ability) => ability.id === spellCastingAbilityId) !== undefined;\n};\n\n// convert spellcasting ability id to string used by foundry\nlet convertSpellCastingAbilityId = (spellCastingAbilityId) => {\n  return DICTIONARY.character.abilities.find((ability) => ability.id === spellCastingAbilityId).value;\n};\n\nfunction getSpellCastingAbility(klass) {\n  let spellCastingAbility = undefined;\n  if (hasSpellCastingAbility(klass.definition.spellCastingAbilityId)) {\n    // check to see if class has a spell casting ability\n    spellCastingAbility = convertSpellCastingAbilityId(klass.definition.spellCastingAbilityId);\n  } else if (\n    klass.subclassDefinition &&\n    hasSpellCastingAbility(klass.subclassDefinition.spellCastingAbilityId)\n  ) {\n    // some subclasses attach a spellcasting ability, e.g. Arcane Trickster\n    spellCastingAbility = convertSpellCastingAbilityId(klass.subclassDefinition.spellCastingAbilityId);\n  }\n  return spellCastingAbility;\n}\n\nexport function getSpellCasting(data, character) {\n  let result = [];\n  data.character.classSpells.forEach((playerClass) => {\n    let classInfo = data.character.classes.find((cls) => cls.id === playerClass.characterClassId);\n    const spellCastingAbility = getSpellCastingAbility(classInfo);\n    if (spellCastingAbility !== undefined) {\n      const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;\n      let abilityModifier = utils.calculateModifier(characterAbilities[spellCastingAbility].value);\n      result.push({ label: spellCastingAbility, value: abilityModifier });\n    }\n  });\n  // we need to decide on one spellcasting ability, so we take the one with the highest modifier\n  if (result.length === 0) {\n    return \"\";\n  } else {\n    return result\n      .sort((a, b) => {\n        if (a.value > b.value) return -1;\n        if (a.value < b.value) return 1;\n        return 0;\n      })\n      .map((entry) => entry.label)[0];\n  }\n}\n\nexport function getSpellDC(data, character) {\n  if (character.data.attributes.spellcasting === \"\") {\n    return 10;\n  } else {\n    const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;\n    return 8 + characterAbilities[character.data.attributes.spellcasting].mod + character.data.attributes.prof;\n  }\n}\n\nexport function getSpellSlots(data) {\n  let spellSlots = {};\n  // get the caster information from all classes and subclasses\n  let getCasterInfo = () => {\n    return data.character.classes\n      .filter((cls) => {\n        return cls.definition.canCastSpells || (cls.subclassDefinition && cls.subclassDefinition.canCastSpells);\n      })\n      .map((cls) => {\n        // the class total level\n        let casterLevel = cls.level;\n        // class name\n        const name = cls.definition.name;\n\n        // get the casting level if the character is a multiclassed spellcaster\n        if (cls.definition.spellRules && cls.definition.spellRules.multiClassSpellSlotDivisor) {\n          casterLevel = Math.floor(casterLevel / cls.definition.spellRules.multiClassSpellSlotDivisor);\n        } else {\n          casterLevel = 0;\n        }\n        // Blood hunters are weird\n        if ([\"Blood Hunter\"].includes(name)) {\n          casterLevel = cls.level;\n        }\n\n        const cantrips =\n          cls.definition.spellRules &&\n          cls.definition.spellRules.levelCantripsKnownMaxes &&\n          Array.isArray(cls.definition.spellRules.levelCantripsKnownMaxes)\n            ? cls.definition.spellRules.levelCantripsKnownMaxes[casterLevel + 1]\n            : 0;\n\n        if ([\"Warlock\", \"Blood Hunter\"].includes(name)) {\n          // pact casting doesn't count towards multiclass spells casting\n          // we still add an entry to get cantrip info\n          const levelSpellSlots = cls.definition.spellRules.levelSpellSlots[casterLevel];\n          const maxLevel = levelSpellSlots.indexOf(Math.max(...levelSpellSlots)) + 1;\n          const maxSlots = Math.max(...levelSpellSlots);\n          const currentSlots = data.character.pactMagic.find((pact) => pact.level === maxLevel).used;\n          if ([\"Blood Hunter\"].includes(name)) {\n            spellSlots.pact = { value: maxSlots - currentSlots, max: maxSlots, override: maxSlots };\n          } else {\n            spellSlots.pact = { value: maxSlots - currentSlots, max: maxSlots };\n          }\n          return {\n            name: name,\n            casterLevel: 0,\n            slots: cls.definition.spellRules.levelSpellSlots[0],\n            cantrips: cantrips,\n          };\n        } else {\n          return {\n            name: name,\n            casterLevel: casterLevel,\n            slots: cls.definition.spellRules.levelSpellSlots[cls.level],\n            cantrips: cantrips,\n          };\n        }\n      });\n  };\n\n  let casterInfo = getCasterInfo(data);\n\n  let result = null;\n  if (casterInfo.length !== 1) {\n    const multiClassSpellSlots = [\n      [0, 0, 0, 0, 0, 0, 0, 0, 0], // 0\n      [2, 0, 0, 0, 0, 0, 0, 0, 0], // 1\n      [3, 0, 0, 0, 0, 0, 0, 0, 0], // 2\n      [4, 2, 0, 0, 0, 0, 0, 0, 0], // 3\n      [4, 3, 0, 0, 0, 0, 0, 0, 0], // 4\n      [4, 3, 2, 0, 0, 0, 0, 0, 0], // 5\n      [4, 3, 3, 0, 0, 0, 0, 0, 0], // 6\n      [4, 3, 3, 1, 0, 0, 0, 0, 0], // 7\n      [4, 3, 3, 2, 0, 0, 0, 0, 0], // 8\n      [4, 3, 3, 3, 1, 0, 0, 0, 0], // 9\n      [4, 3, 3, 3, 2, 0, 0, 0, 0], // 10\n      [4, 3, 3, 3, 2, 1, 0, 0, 0], // 11\n      [4, 3, 3, 3, 2, 1, 0, 0, 0], // 12\n      [4, 3, 3, 3, 2, 1, 1, 0, 0], // 13\n      [4, 3, 3, 3, 2, 1, 1, 0, 0], // 14\n      [4, 3, 3, 3, 2, 1, 1, 1, 0], // 15\n      [4, 3, 3, 3, 2, 1, 1, 1, 0], // 16\n      [4, 3, 3, 3, 2, 1, 1, 1, 1], // 17\n      [4, 3, 3, 3, 3, 1, 1, 1, 1], // 18\n      [4, 3, 3, 3, 3, 2, 1, 1, 1], // 19\n      [4, 3, 3, 3, 3, 2, 2, 1, 1], // 20\n    ];\n    const casterLevelTotal = casterInfo.reduce((prev, cur) => prev + cur.casterLevel, 0);\n    const cantripsTotal = casterInfo.reduce((prev, cur) => prev + cur.cantrips, 0);\n    result = [cantripsTotal, ...multiClassSpellSlots[casterLevelTotal]];\n  } else {\n    result = [casterInfo[0].cantrips, ...casterInfo[0].slots];\n  }\n\n  for (let i = 0; i < result.length; i++) {\n    const currentSlots = data.character.spellSlots.filter((slot) => slot.level === i).map((slot) => slot.used) || 0;\n    spellSlots[\"spell\" + i] = {\n      value: result[i] - currentSlots,\n      max: result[i],\n    };\n  }\n  return spellSlots;\n}\n\nexport function maxPreparedSpells(data, character) {\n  let max = 0;\n\n  data.character.classes\n    .filter((klass) => {\n      return (klass.definition.canCastSpells || (klass.subclassDefinition && klass.subclassDefinition.canCastSpells)) &&\n        (klass.definition.spellPrepareType === 1 || (klass.subclassDefinition && klass.subclassDefinition.spellPrepareType === 1));\n    })\n    .forEach((klass) => {\n      const spellCastingAbility = getSpellCastingAbility(klass);\n      if (spellCastingAbility !== undefined) {\n        const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;\n        const abilityModifier = utils.calculateModifier(characterAbilities[spellCastingAbility].value);\n        max += abilityModifier + klass.level;\n      }\n    });\n\n  return max;\n}\n","import utils from \"../../utils.js\";\n\nexport function getHitpoints(data, character) {\n  const constitutionHP = character.flags.ddbimporter.dndbeyond.effectAbilities.con.mod * character.flags.ddbimporter.dndbeyond.totalLevels;\n  let baseHitPoints = data.character.baseHitPoints || 0;\n  const bonusHitPoints = data.character.bonusHitPoints || 0;\n  const overrideHitPoints = data.character.overrideHitPoints || 0;\n  const removedHitPoints = data.character.removedHitPoints || 0;\n  const temporaryHitPoints = data.character.temporaryHitPoints || 0;\n\n  // get all hit points features\n  const bonusHitPointFeatures = utils.filterBaseModifiers(data, \"bonus\", \"hit-points-per-level\");\n  const bonusHitPointFeaturesWithEffects = utils.filterBaseModifiers(data, \"bonus\", \"hit-points-per-level\", [\"\", null], true);\n\n  // get their values\n  const bonusHitPointValues = bonusHitPointFeatures.map((bonus) => {\n    const cls = utils.findClassByFeatureId(data, bonus.componentId);\n    if (cls) {\n      return cls.level * bonus.value;\n    } else {\n      return character.flags.ddbimporter.dndbeyond.totalLevels * bonus.value;\n    }\n  });\n\n  const bonusHitPointValuesWithEffects = bonusHitPointFeaturesWithEffects.map((bonus) => {\n    const cls = utils.findClassByFeatureId(data, bonus.componentId);\n    if (cls) {\n      return cls.level * bonus.value;\n    } else {\n      return character.flags.ddbimporter.dndbeyond.totalLevels * bonus.value;\n    }\n  });\n\n  // sum up the bonus HP per class level\n  const totalBonusHitPoints = bonusHitPointValues.reduce((prev, cur) => prev + cur, 0);\n  const totalBonusHPWithEffects = bonusHitPointValuesWithEffects.reduce((prev, cur) => prev + cur, 0);\n  const bonusHPEffectDiff = totalBonusHPWithEffects - totalBonusHitPoints;\n\n  // add the result to the base hitpoints\n  baseHitPoints += totalBonusHitPoints;\n\n  const totalHitPoints = overrideHitPoints === 0\n    ? constitutionHP + baseHitPoints + bonusHitPoints\n    : overrideHitPoints;\n\n  return {\n    value: totalHitPoints - removedHitPoints + bonusHPEffectDiff,\n    min: 0,\n    max: totalHitPoints,\n    temp: temporaryHitPoints,\n    tempmax: bonusHitPoints,\n  };\n}\n\nexport function getHitDice(data) {\n  let used = data.character.classes.reduce((prev, cls) => prev + cls.hitDiceUsed, 0);\n  let total = data.character.classes.reduce((prev, cls) => prev + cls.level, 0);\n  return total - used;\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport utils from \"../../utils.js\";\nimport { isArmored } from \"./ac.js\";\n\nexport function getSpeed(data) {\n  // For all processing, we take into account the regular movement types of this character\n  let movementTypes = {};\n  for (let type in data.character.race.weightSpeeds.normal) {\n    // if (data.character.race.weightSpeeds.normal[type] !== 0) {\n    movementTypes[type] = data.character.race.weightSpeeds.normal[type];\n    // }\n  }\n\n  // get bonus speed mods\n  let restriction = [\"\", null, \"unless your speed is already higher\"];\n  // Check for equipped Heavy Armor\n  const wearingHeavy = data.character.inventory.some((item) => item.equipped && item.definition.type === \"Heavy Armor\");\n  // Accounts for Barbarian Class Feature - Fast Movement\n  if (!wearingHeavy) restriction.push(\"while you arent wearing heavy armor\");\n\n  // build base speeds\n  for (let type in movementTypes) {\n    // is there a 'inntate-speed-[type]ing' race/class modifier?\n    const innateType = DICTIONARY.character.speeds.find((s) => s.type === type).innate;\n    let innateSpeeds = data.character.modifiers.race.filter(\n      (modifier) => modifier.type === \"set\" && modifier.subType === `innate-speed-${innateType}`\n    );\n    let base = movementTypes[type];\n\n    innateSpeeds.forEach((speed) => {\n      // take the highest value\n      if (speed.value > base) {\n        base = speed.value;\n      }\n    });\n\n    // overwrite the (perhaps) changed value\n    movementTypes[type] = base;\n  }\n\n  const bonusSpeed = utils\n    .filterBaseModifiers(data, \"bonus\", \"speed\", restriction)\n    .reduce((speed, feat) => speed + feat.value, 0);\n\n  // speed bonuses\n  for (let type in movementTypes) {\n    let innateBonus = utils\n      .filterBaseModifiers(data, \"bonus\", `speed-${type}ing`, restriction)\n      .reduce((speed, feat) => speed + feat.value, 0);\n\n    // overwrite the (perhaps) changed value\n    if (movementTypes[type] !== 0) movementTypes[type] += bonusSpeed + innateBonus;\n  }\n\n  // unarmored movement for barbarians and monks\n  if (!isArmored(data)) {\n    utils.getChosenClassModifiers(data)\n      .filter((modifier) => modifier.type === \"bonus\" && modifier.subType === \"unarmored-movement\")\n      .forEach((bonusSpeed) => {\n        for (let type in movementTypes) {\n          if (movementTypes[type] !== 0) movementTypes[type] += bonusSpeed.value;\n        }\n      });\n  }\n\n  // new ranger deft explorer sets speeds, leaves value null, use walking\n  for (let type in movementTypes) {\n    const innateType = DICTIONARY.character.speeds.find((s) => s.type === type).innate;\n    // is there a 'inntate-speed-[type]ing' race/class modifier?\n    let innateSpeeds = utils\n      .filterBaseModifiers(data, \"set\", `innate-speed-${innateType}`, restriction);\n    let base = movementTypes[type];\n\n    innateSpeeds.forEach((speed) => {\n      // take the highest value\n      if (speed.value > base) {\n        base = speed.value;\n      } else if (!speed.value && movementTypes['walk']) {\n        base = movementTypes['walk'];\n      }\n    });\n\n    // overwrite the (perhaps) changed value\n    movementTypes[type] = base;\n  }\n\n\n  // is there a custom seed over-ride?\n  if (data.character.customSpeeds) {\n    data.character.customSpeeds.forEach((speed) => {\n      const type = DICTIONARY.character.speeds.find((s) => s.id === speed.movementId).type;\n      if (speed.distance) {\n        movementTypes[type] = speed.distance;\n      }\n    });\n  }\n\n  let special = \"\";\n  for (let type in movementTypes) {\n    if (type !== \"walk\") {\n      special += utils.capitalize(type) + \" \" + movementTypes[type] + \" ft, \";\n    }\n  }\n  special = special.substr(0, special.length - 2);\n\n  const movement = {\n    burrow: movementTypes['burrow'] || 0,\n    climb: movementTypes['climb'] || 0,\n    fly: movementTypes['fly'] || 0,\n    swim: movementTypes['swim'] || 0,\n    walk: movementTypes['walk'] || 0,\n    units: \"ft\",\n    hover: false,\n  };\n\n  return {\n    speed: {\n      value: movementTypes.walk + \" ft\",\n      special: special,\n    },\n    movement: movement,\n  };\n}\n","import DICTIONARY from \"../../dictionary.js\";\n\nexport function getBackground(data) {\n  if (data.character.background.hasCustomBackground === false) {\n    if (data.character.background.definition !== null) {\n      return data.character.background.definition.name || \"\";\n    } else {\n      return \"\";\n    }\n  } else {\n    return data.character.background.customBackground.name || \"\";\n  }\n}\n\nexport function getTrait(data) {\n  let result = data.character.traits.personalityTraits;\n  if (result !== null) {\n    return result;\n  } else {\n    result = \"\";\n  }\n  return result;\n}\n\nexport function getIdeal(data) {\n  let result = data.character.traits.ideals;\n  if (result !== null) {\n    return result;\n  } else {\n    result = \"\";\n  }\n  return result;\n}\n\nfunction getCharacteristics(data) {\n  let characteristicBlurb = \"\";\n  if (data.character.gender) characteristicBlurb += `Gender: ${data.character.gender}\\n`;\n  if (data.character.eyes) characteristicBlurb += `Eyes: ${data.character.eyes}\\n`;\n  if (data.character.height) characteristicBlurb += `Height: ${data.character.height}\\n`;\n  if (data.character.faith) characteristicBlurb += `Faith: ${data.character.faith}\\n`;\n  if (data.character.hair) characteristicBlurb += `Hair: ${data.character.hair}\\n`;\n  if (data.character.skin) characteristicBlurb += `Skin: ${data.character.skin}\\n`;\n  if (data.character.age) characteristicBlurb += `Age: ${data.character.age}\\n`;\n  if (data.character.weight) characteristicBlurb += `Weight: ${data.character.weight}\\n`;\n  return characteristicBlurb;\n}\n\nexport function getAppearance(data) {\n  let result = getCharacteristics(data);\n  if (result && result !== \"\") result += \"\\n\";\n  result += data.character.traits.appearance;\n  if (result !== null) {\n    return result;\n  } else {\n    result = \"\";\n  }\n  return result;\n}\n\nexport function getBond(data) {\n  let result = data.character.traits.bonds;\n  if (result !== null) {\n    return result;\n  } else {\n    result = \"\";\n  }\n  return result;\n}\n\nexport function getFlaw(data) {\n  let result = data.character.traits.flaws;\n  if (result !== null) {\n    return result;\n  } else {\n    result = \"\";\n  }\n  return result;\n}\n\n/**\n * Gets the character's alignment\n * Defaults to Neutral, if not set in DDB\n * @todo: returns .name right now, should switch to .value once the DND5E options are fully implemented\n */\nexport function getAlignment(data) {\n  let alignmentID = data.character.alignmentId || 5;\n  let alignment = DICTIONARY.character.alignments.find((alignment) => alignment.id === alignmentID); // DDBUtils.alignmentIdtoAlignment(alignmentID);\n  return alignment.name;\n}\n\nexport function getBackgroundData(data) {\n  let result = {\n    name: \"Background\",\n    description: \"\",\n    id: null,\n    entityTypeId: null,\n    featuresId: null,\n    featuresEntityTypeId: null,\n    characteristicsId: null,\n    characteristicsEntityTypeId: null,\n    definition: {\n      name: \"Background\",\n      description: \"\",\n      id: null,\n      entityTypeId: null,\n    },\n  };\n\n  let bg = null;\n  if (data.character.background.hasCustomBackground === true) {\n    bg = data.character.background.customBackground;\n  } else if (data.character.background.definition !== null) {\n    bg = data.character.background.definition;\n  } else {\n    bg = data.character.background.customBackground;\n    if (bg.id) result.id = bg.id;\n    if (bg.entityTypeId) result.entityTypeId = bg.entityTypeId;\n    return result;\n  }\n\n\n  if (bg.id) result.id = bg.id;\n  if (bg.entityTypeId) result.entityTypeId = bg.entityTypeId;\n\n  if (bg.name) {\n    result.name = `Background: ${bg.name}`;\n    result.description = `<h1>Background: ${bg.name}</h1>`;\n  }\n\n  if (bg.description) {\n    result.description += `<p>${bg.description}</p>`;\n  } else if (bg.shortDescription) {\n    result.description += bg.shortDescription.replace(\"\\r\\n\", \"\");\n  }\n  if (bg.definition) result.definition = bg.definition;\n\n  if (data.character.background.hasCustomBackground === true) {\n    if (bg.featuresBackground) {\n      result.description += `<h2>${bg.featuresBackground.name}</h2>`;\n      result.description += bg.featuresBackground.shortDescription.replace(\"\\r\\n\", \"\");\n      result.description += `<h3>${bg.featuresBackground.featureName}</h3>`;\n      result.description += bg.featuresBackground.featureDescription.replace(\"\\r\\n\", \"\");\n      result.featuresId = bg.featuresBackground.id;\n      result.id = bg.featuresBackground.id;\n      result.featuresEntityTypeId = bg.featuresBackground.entityTypeId;\n      result.definition = bg.featuresBackground;\n    }\n    if (\n      bg.characteristicsBackground &&\n      bg.featuresBackground &&\n      bg.featuresBackground.entityTypeId != bg.characteristicsBackground.entityTypeId\n    ) {\n      result.description += `<h2>${bg.characteristicsBackground.name}</h2>`;\n      result.description += bg.characteristicsBackground.shortDescription.replace(\"\\r\\n\", \"\");\n      result.description += `<h3>${bg.characteristicsBackground.featureName}</h3>`;\n      result.description += bg.characteristicsBackground.featureDescription.replace(\"\\r\\n\", \"\");\n      result.characteristicsId = bg.characteristicsBackground.id;\n      result.characteristicsEntityTypeId = bg.characteristicsBackground.entityTypeId;\n    }\n  }\n  if (bg.featureName) {\n    result.description += `<h2>${bg.featureName}</h2>`;\n    result.description += bg.featureDescription.replace(\"\\r\\n\", \"\");\n  }\n  // if (bg.skillProficienciesDescription && bg.skillProficienciesDescription !== \"\") {\n  //   result.description += `<h2>Skill Proficiencies</h2>`;\n  //   result.description += bg.skillProficienciesDescription.replace(\"\\r\\n\", \"\");\n  // }\n  // if (bg.languagesDescription && bg.languagesDescription !== \"\") {\n  //   result.description += `<h2>Languages</h2>`;\n  //   result.description += bg.languagesDescription.replace(\"\\r\\n\", \"\");\n  // }\n  // if (bg.toolProficienciesDescription && bg.toolProficienciesDescription !== \"\") {\n  //   result.description += `<h2>Tool Proficiencies</h2>`;\n  //   result.description += bg.toolProficienciesDescription.replace(\"\\r\\n\", \"\");\n  // }\n  // if (bg.equipmentDescription && bg.equipmentDescription !== \"\") {\n  //   result.description += `<h2>Starting Equipment</h2>`;\n  //   result.description += bg.equipmentDescription.replace(\"\\r\\n\", \"\");\n  // }\n  // if (bg.organization && bg.organization !== \"\") {\n  //   result.description += `<h2>Organization</h2>`;\n  //   result.description += bg.organization.replace(\"\\r\\n\", \"\");\n  // }\n  // if (bg.contractsDescription && bg.contractsDescription !== \"\") {\n  //   result.description += `<h2>Contracts</h2>`;\n  //   result.description += bg.contractsDescription.replace(\"\\r\\n\", \"\");\n  // }\n  // if (bg.spellsPreDescription && bg.spellsPreDescription !== \"\") {\n  //   result.description += `<h2>Spells</h2>`;\n  //   result.description += bg.spellsPreDescription.replace(\"\\r\\n\", \"\");\n  // }\n  // if (bg.suggestedCharacteristicsDescription && bg.suggestedCharacteristicsDescription !== \"\") {\n  //   result.description += `<h2>Suggested Characteristics</h2>`;\n  //   result.description += bg.suggestedCharacteristicsDescription.replace(\"\\r\\n\", \"\");\n  // }\n  // if (bg.personalityTraits && bg.personalityTraits.length > 0) {\n  //   result.description += `<h>Suggested Personality Traits</h2>`;\n  //   result.description += bg.personalityTraits.map((trait) => `<p>${trait}</p>`).join(\"\");\n  // }\n  // if (bg.ideals && bg.ideals.length > 0) {\n  //   result.description += `<h>Suggested Ideals</h2>`;\n  //   result.description += bg.ideals.map((trait) => `<p>${trait}</p>`);\n  // }\n  // if (bg.bonds && bg.bonds.length > 0) {\n  //   result.description += `<h>Suggested Bonds</h2>`;\n  //   result.description += bg.bonds.map((trait) => `<p>${trait}</p>`);\n  // }\n  // if (bg.flaws && bg.flaws.length > 0) {\n  //   result.description += `<h>Suggested Flaws</h2>`;\n  //   result.description += bg.flaws.map((trait) => `<p>${trait}</p>`);\n  // }\n  if (bg.spellListIds) result.spellListIds = bg.spellListIds;\n  result.definition.name = result.name;\n  result.definition.description = result.description;\n  return result;\n}\n\nexport function getBiography(data) {\n  // let format = (heading, text) => {\n  //   text = text\n  //     .split(\"\\n\")\n  //     .map((text) => `<p>${text}</p>`)\n  //     .join(\"\");\n  //   return `<h2>${heading}</h2>${text}`;\n  // };\n\n  let backstory =\n    data.character.notes.backstory !== null ? \"<h1>Backstory</h1><p>\" + data.character.notes.backstory + \"</p>\" : \"\";\n\n  // if (data.character.background.hasCustomBackground === true) {\n  //   let bg = data.character.background.customBackground;\n\n  //   let result = bg.name ? \"<h1>Background: \" + bg.name + \"</h1>\" : \"\";\n  //   result += bg.description ? \"<p>\" + bg.description + \"</p>\" : \"\";\n  //   if (bg.featuresBackground) {\n  //     result += \"<h2>\" + bg.featuresBackground.name + \"</h2>\";\n  //     result += bg.featuresBackground.shortDescription.replace(\"\\r\\n\", \"\");\n  //     result += \"<h3>\" + bg.featuresBackground.featureName + \"</h3>\";\n  //     result += bg.featuresBackground.featureDescription.replace(\"\\r\\n\", \"\");\n  //   }\n  //   if (\n  //     bg.characteristicsBackground &&\n  //     bg.featuresBackground &&\n  //     bg.featuresBackground.entityTypeId != bg.characteristicsBackground.entityTypeId\n  //   ) {\n  //     result += \"<h2>\" + bg.characteristicsBackground.name + \"</h2>\";\n  //     result += bg.characteristicsBackground.shortDescription.replace(\"\\r\\n\", \"\");\n  //     result += \"<h3>\" + bg.characteristicsBackground.featureName + \"</h3>\";\n  //     result += bg.characteristicsBackground.featureDescription.replace(\"\\r\\n\", \"\");\n  //   }\n\n  //   return {\n  //     public: result + backstory,\n  //     value: result + backstory,\n  //   };\n  // } else if (data.character.background.definition !== null) {\n  //   let bg = data.character.background.definition;\n\n  //   let result = \"<h1>Background: \" + bg.name + \"</h1>\";\n  //   result += bg.shortDescription.replace(\"\\r\\n\", \"\");\n  //   if (bg.featureName) {\n  //     result += \"<h2>\" + bg.featureName + \"</h2>\";\n  //     result += bg.featureDescription.replace(\"\\r\\n\", \"\");\n  //   }\n  //   return {\n  //     public: result + backstory,\n  //     value: result + backstory,\n  //   };\n  // } else {\n  //   return {\n  //     public: \"\" + backstory,\n  //     value: \"\" + backstory,\n  //   };\n  // }\n\n  let background = getBackgroundData(data);\n  return {\n    public: background.description + backstory,\n    value: background.description + backstory,\n  };\n}\n\nexport function getDescription(data) {\n  const result = {\n    \"gender\": data.character.gender || \"\",\n    \"age\": data.character.age || \"\",\n    \"height\": data.character.height || \"\",\n    \"weight\": data.character.weight || \"\",\n    \"eyes\": data.character.eyes || \"\",\n    \"skin\": data.character.skin || \"\",\n    \"hair\": data.character.hair || \"\",\n  };\n\n  return result;\n}\n\n\n// \"attunedItemsMax\": \"3\",\n// \"attunedItemsCount\": 0,\n// \"maxPreparedSpells\": null,\n","import utils from \"../../utils.js\";\n\n/**\n * Gets global bonuses to attacks and damage\n * Supply a list of maps that have the fvtt tyoe and ddb sub type, e,g,\n * { fvttType: \"attack\", ddbSubType: \"magic\" }\n  {\n    \"attack\": \"\",\n    \"damage\": \"\",\n  },\n * @param {*} lookupTable\n * @param {*} data\n * @param {*} character\n */\nexport function getGlobalBonusAttackModifiers(lookupTable, data, character) {\n  let result = {\n    attack: \"\",\n    damage: \"\",\n  };\n  const diceFormula = /\\d*d\\d*/;\n\n  let lookupResults = {\n    attack: {\n      sum: 0,\n      diceString: \"\",\n    },\n    damage: {\n      sum: 0,\n      diceString: \"\",\n    },\n  };\n\n  lookupTable.forEach((b) => {\n    const lookupResult = utils.getModifierSum(utils.filterBaseModifiers(data, \"bonus\", b.ddbSubType), character);\n    const lookupMatch = diceFormula.test(lookupResult);\n\n    // if a match then a dice string\n    if (lookupMatch) {\n      lookupResults[b.fvttType].diceString += lookupResult === \"\" ? lookupResult : \" + \" + lookupResult;\n    } else {\n      lookupResults[b.fvttType].sum += lookupResult;\n    }\n  });\n\n  // loop through outputs from lookups and build a response\n  [\"attack\", \"damage\"].forEach((fvttType) => {\n    if (lookupResults[fvttType].diceString === \"\") {\n      if (lookupResults[fvttType].sum !== 0) {\n        result[fvttType] = lookupResults[fvttType].sum;\n      }\n    } else {\n      result[fvttType] = lookupResults[fvttType].diceString;\n      if (lookupResults[fvttType].sum !== 0) {\n        result[fvttType] += \" + \" + lookupResults[fvttType].sum;\n      }\n    }\n  });\n\n  return result;\n}\n\n/**\n * Gets global bonuses to spell attacks and damage\n * Most likely from items such as wand of the warmage\n * supply type as 'ranged' or 'melee'\n  {\n    \"attack\": \"\",\n    \"damage\": \"\",\n  },\n * @param {*} data\n * @param {*} character\n * @param {*} type\n */\nexport function getBonusSpellAttacks(data, character, type) {\n  // I haven't found any matching global spell damage boosting mods in ddb\n  const bonusLookups = [\n    { fvttType: \"attack\", ddbSubType: \"spell-attacks\" },\n    { fvttType: \"attack\", ddbSubType: `${type}-spell-attacks` },\n    { fvttType: \"attack\", ddbSubType: \"warlock-spell-attacks\" },\n  ];\n\n  return getGlobalBonusAttackModifiers(bonusLookups, data, character);\n}\n\n/**\n * Gets global bonuses to weapon attacks and damage\n * Most likely from items such as wand of the warmage\n * supply type as 'ranged' or 'melee'\n  {\n    \"attack\": \"\",\n    \"damage\": \"\",\n  },\n * @param {*} data\n * @param {*} character\n * @param {*} type\n */\nexport function getBonusWeaponAttacks(data, character, type) {\n  // global melee damage is not a ddb type, in that it's likely to be\n  // type specific. The only class one I know of is the Paladin Improved Smite\n  // which will be handled in the weapon import later.\n  const bonusLookups = [\n    { fvttType: \"attack\", ddbSubType: `${type}-attacks` },\n    { fvttType: \"attack\", ddbSubType: \"weapon-attacks\" },\n    { fvttType: \"attack\", ddbSubType: `${type}-weapon-attacks` },\n  ];\n\n  return getGlobalBonusAttackModifiers(bonusLookups, data, character);\n}\n\n/**\n * Gets global bonuses to ability checks, saves and skills\n * These can come from Paladin auras or items etc\n  \"abilities\": {\n    \"check\": \"\",\n    \"save\": \"\",\n    \"skill\": \"\"\n  },\n * @param {*} data\n * @param {*} character\n */\nexport function getBonusAbilities(data, character) {\n  let result = {};\n  const bonusLookup = [\n    { fvttType: \"check\", ddbSubType: \"ability-checks\" },\n    { fvttType: \"save\", ddbSubType: \"saving-throws\" },\n    { fvttType: \"skill\", ddbSubType: \"skill-checks\" },\n  ];\n\n  bonusLookup.forEach((b) => {\n    const bonus = utils.getModifierSum(utils.filterBaseModifiers(data, \"bonus\", b.ddbSubType), character);\n    result[b.fvttType] = bonus === 0 ? \"\" : `${bonus}`;\n  });\n  return result;\n}\n\nexport function getBonusSpellDC(data, character) {\n  let result = {};\n  const bonusLookup = [\n    { fvttType: \"dc\", ddbSubType: \"spell-save-dc\" },\n    { fvttType: \"dc\", ddbSubType: \"warlock-spell-save-dc\" },\n  ];\n\n  bonusLookup.forEach((b) => {\n    result[b.fvttType] = utils.getModifierSum(utils.filterBaseModifiers(data, \"bonus\", b.ddbSubType), character);\n  });\n\n  return result;\n}\n","import DICTIONARY from \"../../dictionary.js\";\n// import logger from \"../../logger.js\";\nimport utils from \"../../utils.js\";\n\nfunction getOverrides(data) {\n  let result = {};\n  DICTIONARY.character.abilities.forEach((ability) => {\n    result[ability.value] = data.character.overrideStats.find((stat) => stat.id === ability.id).value || 0;\n  });\n  return result;\n}\n\nfunction getCustomSaveProficiency(data, ability) {\n  // Overwrite the proficient value with any custom set over rides\n  if (data.character.characterValues) {\n    const customProficiency = data.character.characterValues.find(\n      (value) => value.typeId === 41 && value.valueId == ability.id && value.value\n    );\n    if (customProficiency) {\n      if (customProficiency.value === 1) {\n        return 0;\n      }\n      // Foundry does not support half proficiencies or expertise here\n      return 1;\n    }\n  }\n  return undefined;\n}\n\nfunction getCustomSaveBonus(data, ability) {\n  // Get any custom skill bonuses\n  if (data.character.characterValues) {\n    const customBonus = data.character.characterValues.filter(\n      (value) => (value.typeId == 40 || value.typeId == 39) && value.valueId == ability.id\n    ).reduce((total, bonus) => {\n      return total + bonus.value;\n    }, 0);\n\n    if (customBonus) {\n      return customBonus;\n    }\n  }\n  return 0;\n}\n\n/**\n * Retrieves character abilities, including proficiency on saving throws\n * @param {obj} data JSON Import\n * @param {obj} includeExcludedEffects Include effects from dae added items?\n */\nfunction parseAbilities(data, includeExcludedEffects = false) {\n  // go through every ability\n  // console.error(`Abilities effects: ${includeExcludedEffects}`);\n\n  let result = {};\n  DICTIONARY.character.abilities.forEach((ability) => {\n    result[ability.value] = {\n      value: 0,\n      min: 3,\n      max: 20,\n      proficient: 0,\n      bonuses: {\n        check: \"\",\n        save: \"\",\n      },\n    };\n    // console.warn(ability.value);\n\n    const stat = data.character.stats.find((stat) => stat.id === ability.id).value || 0;\n    const abilityScoreMaxBonus = utils\n      .filterBaseModifiers(data, \"bonus\", \"ability-score-maximum\", [null, \"\"], includeExcludedEffects)\n      .filter((mod) => mod.statId === ability.id)\n      .reduce((prev, cur) => prev + cur.value, 0);\n    const bonus = utils\n      .filterBaseModifiers(data, \"bonus\", `${ability.long}-score`, [null, \"\", \"+2 to score maximum\", \"+4 to score maximum\", \"+2 to maximum score\", \"+4 to maximum score\"], includeExcludedEffects)\n      .filter((mod) => mod.entityId === ability.id)\n      .reduce((prev, cur) => prev + cur.value, 0);\n    const setAbilities = utils\n      .filterBaseModifiers(data, \"set\", `${ability.long}-score`, [null, \"\", \"if not already higher\"], includeExcludedEffects)\n      .map((mod) => mod.value);\n    const modRestrictions = [\n      \"Your maximum is now \",\n      \"Maximum of \",\n    ];\n    const cappedBonusExp = new RegExp(`(?:${modRestrictions.join(\"|\")})(\\\\d*)`);\n    const cappedBonus = utils\n      .filterBaseModifiers(data, \"bonus\", `${ability.long}-score`, false, includeExcludedEffects)\n      .filter((mod) =>\n        mod.entityId === ability.id && mod.restriction &&\n        modRestrictions.some((m) => mod.restriction.startsWith(m))\n      )\n      .reduce(\n        (prev, cur) => {\n          const restricted = cur.restriction ? cappedBonusExp.exec(cur.restriction) : undefined;\n          const max = restricted ? restricted[1] : 20;\n          return {\n            value: prev.value + cur.value,\n            cap: Math.max(prev.cap, max),\n          };\n        },\n        { value: 0, cap: 20 + abilityScoreMaxBonus }\n      );\n    // applied regardless of cap\n    const bonusStat = data.character.bonusStats.find((stat) => stat.id === ability.id).value || 0;\n    // over rides all other calculations if present\n    const overrideStat = data.character.overrideStats.find((stat) => stat.id === ability.id).value || 0;\n\n    // console.warn(`${ability.value} - Include active effects: ${includeExcludedEffects}`);\n    // console.log(`stat ${stat}`);\n    // console.log(`bonus ${bonus}`);\n    // console.log(`bonusStat ${bonusStat}`);\n    // console.log(`overrideStat ${overrideStat}`);\n    // console.log(`abilityScoreMaxBonus ${abilityScoreMaxBonus}`);\n    // console.log(`setAbilities ${setAbilities}`);\n    // console.log(setAbilities);\n    // console.log(`cappedBonus ${cappedBonus}`);\n    // console.log(cappedBonus);\n\n    const setAbility = Math.max(...[0, ...setAbilities]);\n    const calculatedStat = stat + bonus + cappedBonus.value;\n    // bonus gets added regardlesss of normal caps\n    const maxAdjustedStat = Math.min(cappedBonus.cap, calculatedStat) + bonusStat;\n    // some items will set the ability score if lower\n    const setAbilityState = maxAdjustedStat > setAbility ? maxAdjustedStat : setAbility;\n    // Is there a hard over ride?\n    const overRiddenStat = overrideStat === 0 ? setAbilityState : overrideStat;\n\n    // console.log(`setAbility ${setAbility}`);\n    // console.log(`calculatedStat ${calculatedStat}`);\n    // console.log(`maxAdjustedStat ${maxAdjustedStat}`);\n    // console.log(`setAbilityState ${setAbilityState}`);\n    // console.log(`overRiddenStat ${overRiddenStat}`);\n\n    const customProficiency = getCustomSaveProficiency(data, ability);\n\n    const proficient = customProficiency\n      ? customProficiency\n      : utils.filterBaseModifiers(data, \"proficiency\", `${ability.long}-saving-throws`, [null, \"\"], includeExcludedEffects).length > 0\n        ? 1\n        : 0;\n\n    // update value, mod and proficiency\n    result[ability.value].value = overRiddenStat;\n    result[ability.value].mod = utils.calculateModifier(result[ability.value].value);\n    result[ability.value].proficient = proficient;\n    result[ability.value].max = Math.max(cappedBonus.cap, overRiddenStat);\n\n  });\n\n  const character = {\n    data: {\n      abilities: result,\n    },\n  };\n\n  DICTIONARY.character.abilities.forEach((ability) => {\n\n    const checkBonusModifiers = utils\n      .filterBaseModifiers(data, \"bonus\", `${ability.long}-ability-checks`, [null, \"\"], includeExcludedEffects);\n    const checkBonus = utils.getModifierSum(checkBonusModifiers, character);\n    if (checkBonus && checkBonus !== \"\") {\n      result[ability.value].bonuses.check = checkBonus;\n    }\n\n    const saveBonusModifiers = utils\n      .filterBaseModifiers(data, \"bonus\", `${ability.long}-saving-throws`, [null, \"\"], includeExcludedEffects);\n    const modifiersSaveBonus = utils.getModifierSum(saveBonusModifiers, character);\n    const customSaveBonus = getCustomSaveBonus(data, ability);\n\n    // console.warn(\"modifiersSaveBonus\", modifiersSaveBonus);\n    // console.warn(\"customSaveBonus\", customSaveBonus);\n\n    if (modifiersSaveBonus && modifiersSaveBonus !== \"\" && parseInt(modifiersSaveBonus)) {\n      if (customSaveBonus) {\n        const totalSave = parseInt(customSaveBonus) + parseInt(modifiersSaveBonus);\n        // console.warn(\"totalSave\", totalSave);\n        result[ability.value].bonuses.save = `${totalSave}`;\n      } else {\n        result[ability.value].bonuses.save = `${modifiersSaveBonus}`;\n      }\n    } else if (modifiersSaveBonus && modifiersSaveBonus !== \"\") {\n      if (customSaveBonus) {\n        result[ability.value].bonuses.save = `${modifiersSaveBonus} + ${customSaveBonus}`;\n      } else {\n        result[ability.value].bonuses.save = `${modifiersSaveBonus}`;\n      }\n    } else if (customSaveBonus) {\n      result[ability.value].bonuses.save = `${customSaveBonus}`;\n    }\n\n  });\n\n  return result;\n}\n\n/**\n * Retrieves character abilities, including proficiency on saving throws\n * @param {obj} data JSON Import\n */\nexport function getAbilities(data) {\n  // go through every ability\n\n  const result = {\n    base: parseAbilities(data, false),\n    withEffects: parseAbilities(data, true),\n    overrides: getOverrides(data),\n  };\n  return result;\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport utils from \"../../utils.js\";\nimport logger from \"../../logger.js\";\n\nexport function getSensesMap(data) {\n  let senses = {\n    darkvision: 0,\n    blindsight: 0,\n    tremorsense: 0,\n    truesight: 0,\n    units: \"ft\",\n    special: \"\"\n  };\n\n  // custom senses\n  if (data.character.customSenses) {\n    data.character.customSenses\n      .filter((sense) => sense.distance)\n      .forEach((sense) => {\n        const s = DICTIONARY.character.senses.find((s) => s.id === sense.senseId);\n        if (s && sense.distance && Number.isInteger(sense.distance)) {\n          senses[s.name.toLowerCase()] = parseInt(sense.distance);\n        } else {\n          senses.special += `${sense.distance}; `;\n        }\n      });\n  }\n\n  // Base senses\n  for (const senseName in senses) {\n    utils.filterBaseModifiers(data, \"set-base\", senseName).forEach((sense) => {\n      if (Number.isInteger(sense.value) && sense.value > senses[senseName]) {\n        senses[senseName] = parseInt(sense.value);\n      }\n    });\n  }\n\n  // Devils Sight gives bright light to 120 foot instead of normal darkvision\n  utils\n    .filterBaseModifiers(data, \"set-base\", \"darkvision\", [\n      \"You can see normally in darkness, both magical and nonmagical\",\n    ])\n    .forEach((sense) => {\n      if (Number.isInteger(sense.value) && sense.value > senses['darkvision']) {\n        senses['darkvision'] = parseInt(sense.value);\n        senses.special += \"You can see normally in darkness, both magical and nonmagical.\";\n      }\n    });\n\n  // Magical bonuses and additional, e.g. Gloom Stalker\n  utils\n    .filterBaseModifiers(data, \"sense\", \"darkvision\", [\"\", null, \"plus 60 feet if wearer already has Darkvision\"])\n    .forEach((mod) => {\n      const hasSense = mod.subType in senses;\n      if (hasSense && mod.value && Number.isInteger(mod.value)) {\n        senses[mod.subType] += parseInt(mod.value);\n      } else {\n        senses.special += ` ${mod.value},`;\n      }\n    });\n\n  return senses;\n\n}\n\nexport function getSensesLookup(data) {\n  // const low = \"1.1.0\";\n  // const high = \"1.2.0\"\n\n  // const compareLowHigh = utils.versionCompare(low, high);\n  // const compareSame = utils.versionCompare(high, high);\n  // const compareHighLow = utils.versionCompare(high, low);\n  // console.warn(`${compareLowHigh}-${compareSame}-${compareHighLow}`);\n  // // -1-0-1\n\n  // dnd5e 1.2.0 introduced a different sense system\n  let senses;\n\n  try {\n    senses = getSensesMap(data);\n  } catch (err) {\n    logger.error(err);\n    logger.error(err.stack);\n    throw new Error(\"Sense parsing failed. You might need to update your D&D 5e system to a newer version\");\n  }\n\n  return senses;\n}\n\nexport function getSenses(data) {\n  return getSensesMap(data);\n}\n","import { getSensesLookup } from \"./senses.js\";\nimport logger from \"../../logger.js\";\n\nfunction getTokenSenses(data) {\n  // Default to the most basic token setup.\n  // everything else can be handled by the user / Token Mold\n  let tokenData = {\n    actorLink: true,\n    name: data.character.name,\n  };\n\n  const senses = getSensesLookup(data);\n  // darkvision: 0,\n  // blindsight: 0,\n  // tremorsense: 0,\n  // truesight: 0,\n\n  // These values in senses grant bright sight\n  const devilSight = senses.special.includes(\"You can see normally in darkness\");\n  let brightSights = [senses.truesight, senses.blindsight];\n  if (devilSight) brightSights.push(senses.darkvision);\n  tokenData['brightSight'] = Math.max(...brightSights);\n\n  // Darkvision\n  tokenData['dimSight'] = senses.darkvision;\n\n  return tokenData;\n}\n\nexport function getToken(data) {\n  try {\n    return getTokenSenses(data);\n  } catch (err) {\n    logger.error(err);\n    logger.error(err.stack);\n    throw new Error(\"Please update your D&D 5e system to a newer version\");\n  }\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport utils from \"../../utils.js\";\n\nexport function getDeathSaves (data) {\n  return {\n    success: data.character.deathSaves.successCount || 0,\n    failure: data.character.deathSaves.failCount || 0,\n  };\n}\n\nexport function getExhaustion(data) {\n  let condition = data.character.conditions.find((condition) => condition.id === 4);\n  let level = condition ? condition.level : 0;\n  return level;\n}\n\nlet getGenericConditionAffect = (data, condition, typeId) => {\n  const damageTypes = DICTIONARY.character.damageTypes\n    .filter((type) => type.kind === condition && type.type === typeId)\n    .map((type) => type.value);\n\n  let result = utils\n    .filterBaseModifiers(data, condition)\n    .filter((modifier) => modifier.isGranted && damageTypes.includes(modifier.subType) &&\n      (modifier.restriction === \"\" || !modifier.restriction))\n    .map((modifier) => {\n      const entry = DICTIONARY.character.damageTypes.find(\n        (type) => type.type === typeId && type.kind === modifier.type && type.value === modifier.subType\n      );\n      return entry ? entry.foundryValue || entry.value : undefined;\n    });\n\n  result = result.concat(\n    data.character.customDefenseAdjustments\n      .filter((adjustment) => adjustment.type === typeId)\n      .map((adjustment) => {\n        const entry = DICTIONARY.character.damageTypes.find(\n          (type) =>\n            (type.id === adjustment.id || type.id === adjustment.adjustmentId) &&\n            type.type === adjustment.type &&\n            type.kind === condition\n        );\n        return entry ? entry.foundryValue || entry.value : undefined;\n      })\n      .filter((adjustment) => adjustment !== undefined)\n  );\n\n  return result;\n};\n\nexport function getDamageImmunities(data) {\n  return {\n    custom: \"\",\n    value: getGenericConditionAffect(data, \"immunity\", 2),\n  };\n}\n\nexport function getDamageResistances(data) {\n  return {\n    custom: \"\",\n    value: getGenericConditionAffect(data, \"resistance\", 2),\n  };\n}\n\nexport function getDamageVulnerabilities(data) {\n  return {\n    custom: \"\",\n    value: getGenericConditionAffect(data, \"vulnerability\", 2),\n  };\n}\n\nexport function getConditionImmunities(data) {\n  // get Condition Immunities\n  return {\n    custom: \"\",\n    value: getGenericConditionAffect(data, \"immunity\", 1),\n  };\n}\n","import DICTIONARY from \"../../dictionary.js\";\n\nfunction resourceList(data) {\n  const resources = [data.character.actions.race, data.character.actions.class, data.character.actions.feat]\n    .flat()\n    .filter((action) =>\n      action.limitedUse &&\n        (action.limitedUse.maxUses || action.limitedUse.statModifierUsesId || action.limitedUse.useProficiencyBonus));\n\n  return resources;\n}\n\nfunction getSortedByUsedResourceList(data, character) {\n  // get all resources\n  const allResources = resourceList(data);\n  const resources = allResources\n    .map((action) => {\n      let maxUses = (action.limitedUse.maxUses && action.limitedUse.maxUses !== -1) ? action.limitedUse.maxUses : 0;\n\n      if (action.limitedUse.statModifierUsesId) {\n        const ability = DICTIONARY.character.abilities.find(\n          (ability) => ability.id === action.limitedUse.statModifierUsesId\n        ).value;\n\n        switch (action.limitedUse.operator) {\n          case 2: {\n            maxUses *= character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;\n            break;\n          }\n          case 1:\n          default:\n            maxUses += character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;\n        }\n      }\n\n      if (action.limitedUse.useProficiencyBonus) {\n        switch (action.limitedUse.proficiencyBonusOperator) {\n          case 2: {\n            maxUses *= character.data.attributes.prof;\n            break;\n          }\n          case 1:\n          default:\n            maxUses += character.data.attributes.prof;\n        }\n      }\n\n      return {\n        label: action.name,\n        value: maxUses - action.limitedUse.numberUsed,\n        max: maxUses,\n        sr: action.limitedUse.resetType === 1,\n        lr: action.limitedUse.resetType === 1 || action.limitedUse.resetType === 2 || action.limitedUse.resetType === 3,\n      };\n    })\n    // sort by maxUses, I guess one wants to track the most uses first, because it's used more often\n    .sort((a, b) => {\n      if (a.max > b.max) return -1;\n      if (a.max < b.max) return 1;\n      return 0;\n    });\n  return resources;\n}\n\nconst sheetResources = [\n  \"primary\",\n  \"secondary\",\n  \"tertiary\",\n  \"fourth\",\n  \"fifth\",\n  \"sixth\",\n  \"seventh\",\n  \"eighth\",\n  \"ninth\",\n  \"tenth\",\n  \"eleventh\",\n  \"twelfth\",\n  \"thirteenth\",\n  \"fourteenth\",\n  \"fifteenth\",\n  \"sixteenth\",\n  \"seventeenth\",\n  \"eighteenth\",\n  \"nineteenth\",\n  \"twentieth\",\n];\n\nexport function getResources(data, character, numberOfResources = 3) {\n  // get all resources\n  const allResources = getSortedByUsedResourceList(data, character);\n\n  let result = {};\n\n  const resourceSelectionType = hasProperty(character, \"flags.ddbimporter.resources\")\n    ? getProperty(character, \"flags.ddbimporter.resources\")\n    : { type: \"default\" };\n\n  switch (resourceSelectionType.type) {\n    case \"custom\": {\n      const customResourceSelection = getProperty(character, \"flags.ddbimporter.resources\");\n      for (let i = 0; i < sheetResources.length && i < numberOfResources; i++) {\n        const resourceLookupName = customResourceSelection[sheetResources[i]];\n\n        const resource = resourceLookupName && resourceLookupName !== \"\"\n          ? allResources.find((r) => r.label === resourceLookupName)\n          : { value: 0, max: 0, sr: false, lr: false, label: \"\" };\n        result[sheetResources[i]] = resource || { value: 0, max: 0, sr: false, lr: false, label: \"\" };\n      };\n      break;\n    }\n    case \"disable\": {\n      for (let i = 0; i < sheetResources.length && i < numberOfResources; i++) {\n        result[sheetResources[i]] = { value: 0, max: 0, sr: false, lr: false, label: \"\" };\n      };\n      break;\n    }\n    default: {\n      const usedResources = allResources.slice(0, numberOfResources);\n      for (let i = 0; i < sheetResources.length && i < numberOfResources; i++) {\n        const resource = usedResources.length > i ? usedResources[i] : { value: 0, max: 0, sr: false, lr: false, label: \"\" };\n        result[sheetResources[i]] = resource;\n      };\n      break;\n    }\n  }\n\n  return result;\n}\n\nexport function getResourceList(data, character) {\n  return getSortedByUsedResourceList(data, character);\n}\n\nfunction generateResourceSelectionFromForm(formData, type) {\n  const primary = formData.find((r) => r.name === \"primary-select\" && r.value !== \"\");\n  const secondary = formData.find((r) => r.name === \"secondary-select\" && r.value !== \"\");\n  const tertiary = formData.find((r) => r.name === \"tertiary-select\" && r.value !== \"\");\n  const ask = formData.find((r) => r.name === \"ask-resources\")?.value === \"on\";\n\n  const resourceSelection = {\n    type: type,\n    primary: type === \"custom\" && primary ? primary.value : \"\",\n    secondary: type === \"custom\" && secondary ? secondary.value : \"\",\n    tertiary: type === \"custom\" && tertiary ? tertiary.value : \"\",\n    ask,\n  };\n  return resourceSelection;\n}\n\nfunction setResourceType(ddb, character, resourceSelection) {\n  setProperty(character, \"flags.ddbimporter.resources\", resourceSelection);\n  setProperty(character, \"data.resources\", getResources(ddb, character));\n  return character;\n}\n\nfunction setDefaultResources(sortedResources, resourceSelection) {\n  if (sortedResources.length >= 1) {\n    resourceSelection.primary = sortedResources[0].label;\n  }\n  if (sortedResources.length >= 2) {\n    resourceSelection.secondary = sortedResources[1].label;\n  }\n  if (sortedResources.length >= 3) {\n    resourceSelection.tertiary = sortedResources[2].label;\n  }\n  return resourceSelection;\n}\n\nexport async function getResourcesDialog(currentActorId, ddb, character) {\n  const currentActor = game.actors.get(currentActorId);\n  return new Promise((resolve) => {\n    let currentResourceSelection = hasProperty(currentActor, \"data.flags.ddbimporter.resources.type\")\n      ? getProperty(currentActor, \"data.flags.ddbimporter.resources\")\n      : {\n        ask: true,\n        type: \"default\",\n        primary: \"\",\n        secondary: \"\",\n        tertiary: \"\",\n      };\n\n    const sortedResources = getSortedByUsedResourceList(ddb, character);\n\n    if (currentResourceSelection.type === \"default\") {\n      currentResourceSelection = setDefaultResources(sortedResources, currentResourceSelection);\n    }\n\n    if (currentResourceSelection.ask || !hasProperty(currentResourceSelection, \"ask\")) {\n      const resources = sortedResources.map((resource) => {\n        let resourceArray = [];\n        if (resource.sr) resourceArray.push(\"SR\");\n        if (resource.lr) resourceArray.push(\"LR\");\n        if (!resource.sr && !resource.lr) resourceArray.push(\"Other\");\n        resource.resetString = resourceArray.join(\", \");\n        switch (resource.label) {\n          case currentResourceSelection.primary:\n            resource.primary = true;\n            break;\n          case currentResourceSelection.secondary:\n            resource.secondary = true;\n            break;\n          case currentResourceSelection.tertiary:\n            resource.tertiary = true;\n            break;\n          // no default\n        }\n        return resource;\n      });\n\n      const dialog = new Dialog({\n        title: `Choose Resources for ${character.name}`,\n        content: {\n          \"resources\": resources,\n          \"character\": character.name,\n          \"img\": ddb.character.decorations?.avatarUrl\n            ? ddb.character.decorations.avatarUrl\n            : \"icons/svg/mystery-man.svg\",\n          \"cssClass\": \"character-resource-selection sheet\"\n        },\n        buttons: {\n          default: {\n            icon: '<i class=\"fas fa-list-ol\"></i>',\n            label: \"Default\",\n            callback: async () => {\n              const formData = $('.character-resource-selection').serializeArray();\n              let resourceSelection = generateResourceSelectionFromForm(formData, \"default\");\n              resourceSelection = setDefaultResources(resources, resourceSelection);\n              character = setResourceType(ddb, character, resourceSelection);\n              resolve(character);\n            }\n          },\n          custom: {\n            icon: '<i class=\"fas fa-sort\"></i>',\n            label: \"Use selected\",\n            callback: async () => {\n              const formData = $('.character-resource-selection').serializeArray();\n              const resourceSelection = generateResourceSelectionFromForm(formData, \"custom\");\n              character = setResourceType(ddb, character, resourceSelection);\n              resolve(character);\n            }\n          },\n          disable: {\n            icon: '<i class=\"fas fa-times\"></i>',\n            label: \"None\",\n            callback: async () => {\n              const formData = $('.character-resource-selection').serializeArray();\n              const resourceSelection = generateResourceSelectionFromForm(formData, \"disable\");\n              character = setResourceType(ddb, character, resourceSelection);\n              resolve(character);\n            }\n          }\n        },\n        default: \"default\",\n        close: () => resolve(character),\n      },\n      {\n        width: 400,\n        classes: [\"dialog\", \"character-resource-selection\"],\n        template: \"modules/ddb-importer/handlebars/resources.hbs\",\n      });\n      dialog.render(true);\n    } else {\n      character = setResourceType(ddb, character, currentResourceSelection);\n      resolve(character);\n    }\n  });\n}\n","import DICTIONARY from \"../../dictionary.js\";\n\nexport function getSize(data) {\n  let size = DICTIONARY.character.actorSizes.find(\n    (size) => size.name === data.character.race.size || size.id === data.character.race.sizeId\n  );\n  return size ? size.value : \"med\";\n}\n","import utils from \"../../utils.js\";\n\nexport function getInitiative(data, character) {\n  const initiativeBonus = utils.getModifierSum(utils.filterBaseModifiers(data, \"bonus\", \"initiative\"), character);\n  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;\n\n  // If we have the alert Feat set, lets sub 5 so it's correct\n  const initiative = character.flags.dnd5e.initiativeAlert\n    ? {\n      value: initiativeBonus - 5,\n      bonus: 5, // used by FVTT internally\n      mod: characterAbilities.dex.mod,\n    }\n    : {\n      value: initiativeBonus,\n      bonus: 0, // used by FVTT internally\n      mod: characterAbilities.dex.mod,\n    };\n\n  return initiative;\n}\n","export function getCurrency(data) {\n  return {\n    pp: data.character.currencies.pp,\n    gp: data.character.currencies.gp,\n    ep: data.character.currencies.ep,\n    sp: data.character.currencies.sp,\n    cp: data.character.currencies.cp,\n  };\n}\n","import utils from \"../../utils.js\";\nimport { getArmorClass } from \"./ac.js\";\nimport { getSpecialTraits } from \"./specialTraits.js\";\nimport { getSkills } from \"./skills.js\";\nimport { getSpellCasting, getSpellDC, getSpellSlots, maxPreparedSpells } from \"./spellCasting.js\";\nimport { getHitpoints, getHitDice } from \"./hp.js\";\nimport { getSpeed } from \"./speed.js\";\nimport {\n  getBackground,\n  getTrait,\n  getIdeal,\n  getBond,\n  getFlaw,\n  getAlignment,\n  getBiography,\n  getAppearance,\n  getDescription,\n} from \"./bio.js\";\nimport { getBonusAbilities, getBonusSpellAttacks, getBonusSpellDC, getBonusWeaponAttacks } from \"./globalBonuses.js\";\nimport {\n  getProficiencies,\n  getWeaponProficiencies,\n  getArmorProficiencies,\n  getToolProficiencies,\n  getLanguages,\n} from \"./proficiencies.js\";\nimport { getAbilities } from \"./abilities.js\";\nimport { getSenses, getSensesMap } from \"./senses.js\";\nimport { getToken } from \"./token.js\";\nimport {\n  getDeathSaves,\n  getExhaustion,\n  getDamageImmunities,\n  getDamageResistances,\n  getDamageVulnerabilities,\n  getConditionImmunities,\n} from \"./effects.js\";\nimport { getResources } from \"./resources.js\";\nimport { getSize } from \"./size.js\";\nimport { getInitiative } from \"./initiative.js\";\nimport { getCurrency } from \"./currency.js\";\n// import { fixCharacterLevels } from \"./filterModifiers.js\";\n\nexport default function getCharacter(ddb) {\n  // *************************************\n  // PARSING THE CHARACTER\n  // **************************************\n  //\n  // ddb = fixCharacterLevels(ddb);\n  let character = {\n    data: JSON.parse(utils.getTemplate(\"character\")),\n    type: \"character\",\n    effects: [],\n    name: (ddb.character.name === \"\") ? \"Hero With No Name\" : ddb.character.name,\n    // items: [],  // modified to check inventory analysis on update\n    token: getToken(ddb),\n    flags: {\n      ddbimporter: {\n        compendium: false,\n        acEffects: [],\n        baseAC: 10,\n        dndbeyond: {\n          totalLevels: ddb.character.classes.reduce((prev, cur) => prev + cur.level, 0),\n          proficiencies: getProficiencies(ddb),\n          proficienciesIncludingEffects: getProficiencies(ddb, true),\n          roUrl: ddb.character.readonlyUrl,\n          characterValues: ddb.character.characterValues,\n          templateStrings: [],\n          campaign: ddb.character.campaign,\n        },\n      },\n    },\n  };\n\n  // proficiency\n  // prettier-ignore\n  character.data.attributes.prof = Math.ceil(1 + (0.25 * character.flags.ddbimporter.dndbeyond.totalLevels));\n\n  // Get supported 5e feats and abilities\n  // We do this first so we can check for them later\n  character.flags.dnd5e = getSpecialTraits(ddb);\n\n  // character abilities\n  const abilityData = getAbilities(ddb);\n  character.data.abilities = abilityData.base;\n  character.flags.ddbimporter.dndbeyond.effectAbilities = abilityData.withEffects;\n  character.flags.ddbimporter.dndbeyond.abilityOverrides = abilityData.overrides;\n\n  // Hit Dice\n  character.data.attributes.hd = getHitDice(ddb);\n\n  // Death saves\n  character.data.attributes.death = getDeathSaves(ddb);\n\n  // exhaustion\n  character.data.attributes.exhaustion = getExhaustion(ddb);\n\n  // inspiration\n  character.data.attributes.inspiration = ddb.character.inspiration;\n\n  // armor class\n  const ac = getArmorClass(ddb, character);\n  character.data.attributes.ac = ac.auto;\n  character.flags.ddbimporter.acEffects = ac.effects;\n  character.flags.ddbimporter.baseAC = ac.base;\n  character.flags.ddbimporter.autoAC = ac.auto;\n  character.flags.ddbimporter.overrideAC = ac.override;\n\n  // hitpoints\n  character.data.attributes.hp = getHitpoints(ddb, character);\n\n  // initiative\n  character.data.attributes.init = getInitiative(ddb, character);\n\n  // speeds\n  const movement = getSpeed(ddb);\n  character.data.attributes.movement = movement['movement'];\n  character.data.attributes.senses = getSensesMap(ddb);\n\n  // spellcasting\n  character.data.attributes.spellcasting = getSpellCasting(ddb, character);\n\n  // spelldc\n  character.data.attributes.spelldc = getSpellDC(ddb, character);\n\n  // resources\n  character.data.resources = getResources(ddb, character);\n\n  // details\n  character.data.details.background = getBackground(ddb);\n\n  // known spells\n  character.data.details.maxPreparedSpells = maxPreparedSpells(ddb, character);\n\n  // xp\n  character.data.details.xp.value = ddb.character.currentXp;\n\n  // Character Traits/Ideal/Bond and Flaw\n  character.data.details.trait = getTrait(ddb);\n  character.data.details.ideal = getIdeal(ddb);\n  character.data.details.bond = getBond(ddb);\n  character.data.details.flaw = getFlaw(ddb);\n  character.data.details.appearance = getAppearance(ddb);\n\n  Object.assign(character.data.details, getDescription(ddb));\n\n  character.data.details.alignment = getAlignment(ddb);\n\n  // bio\n  character.data.details.biography = getBiography(ddb);\n  character.data.details.race = ddb.character.race.fullName;\n\n  // traits\n  character.data.traits.weaponProf = getWeaponProficiencies(ddb, character.flags.ddbimporter.dndbeyond.proficiencies);\n  character.data.traits.armorProf = getArmorProficiencies(ddb, character.flags.ddbimporter.dndbeyond.proficiencies);\n  character.data.traits.toolProf = getToolProficiencies(ddb, character.flags.ddbimporter.dndbeyond.proficiencies);\n  character.data.traits.size = getSize(ddb);\n  character.data.traits.senses = getSenses(ddb);\n  character.data.traits.languages = getLanguages(ddb);\n  character.data.traits.di = getDamageImmunities(ddb);\n  character.data.traits.dr = getDamageResistances(ddb);\n  character.data.traits.dv = getDamageVulnerabilities(ddb);\n  character.data.traits.ci = getConditionImmunities(ddb);\n\n  character.data.currency = getCurrency(ddb);\n  character.data.skills = getSkills(ddb, character);\n  character.data.spells = getSpellSlots(ddb);\n\n  // Extra global bonuses\n  // Extra bonuses\n  character.data.bonuses.abilities = getBonusAbilities(ddb, character);\n  // spell attacks\n  character.data.bonuses.rsak = getBonusSpellAttacks(ddb, character, \"ranged\");\n  character.data.bonuses.msak = getBonusSpellAttacks(ddb, character, \"melee\");\n  // spell dc\n  character.data.bonuses.spell = getBonusSpellDC(ddb, character);\n  // melee weapon attacks\n  character.data.bonuses.mwak = getBonusWeaponAttacks(ddb, character, \"melee\");\n  // ranged weapon attacks\n  // e.g. ranged fighting style\n  character.data.bonuses.rwak = getBonusWeaponAttacks(ddb, character, \"ranged\");\n\n  return character;\n}\n","// import DICTIONARY from \"../../dictionary.js\";\n// import logger from \"../../logger.js\";\nimport utils from \"../../utils.js\";\nimport { generateEffects } from \"../../effects/effects.js\";\nimport { generateBaseACItemEffect } from \"../../effects/acEffects.js\";\nimport { generateTable } from \"../../muncher/table.js\";\nimport { generateExtraEffects } from \"../../effects/specialFeats.js\";\n\nfunction generateFeatModifiers(ddb, ddbItem, choice, type) {\n  // console.warn(ddbItem);\n  // console.log(choice);\n  if (ddbItem.grantedModifiers) return ddbItem;\n  let modifierItem = JSON.parse(JSON.stringify(ddbItem));\n  const modifiers = [\n    utils.getChosenClassModifiers(ddb, true, true),\n    utils.getModifiers(ddb, \"race\", true, true),\n    utils.getModifiers(ddb, \"background\", true, true),\n    utils.getModifiers(ddb, \"feat\", true, true),\n  ].flat();\n\n  // console.warn(modifiers);\n  // console.log(ddb.character.options[type]);\n  // console.warn(\"Adding modifiers\");\n  // console.log(type);\n  // if (type === \"race\") console.log(modifiers);\n\n  if (!modifierItem.definition) modifierItem.definition = {};\n  modifierItem.definition.grantedModifiers = modifiers.filter((mod) => {\n    if (mod.componentId === ddbItem.definition?.id && mod.componentTypeId === ddbItem.definition?.entityTypeId)\n      return true;\n    if (choice && ddb.character.options[type]?.length > 0) {\n      // if it is a choice option, try and see if the mod matches\n      const choiceMatch = ddb.character.options[type].some(\n        (option) =>\n          // id match\n          choice.componentId == option.componentId && // the choice id matches the option componentID\n          option.definition.id == mod.componentId && // option id and mod id match\n          (choice.componentTypeId == option.componentTypeId || // either the choice componenttype and optiontype match or\n            choice.componentTypeId == option.definition.entityTypeId) && // the choice componentID matches the option definition entitytypeid\n          option.definition.entityTypeId == mod.componentTypeId && // mod componentId matches option entity type id\n          choice.id == mod.componentId // choice id and mod id match\n      );\n      // console.log(`choiceMatch ${choiceMatch}`);\n      if (choiceMatch) return true;\n    } else if (choice) {\n      // && choice.parentChoiceId\n      const choiceIdSplit = choice.choiceId.split(\"-\").pop();\n      if (mod.id == choiceIdSplit) return true;\n    } else if (mod.componentId === ddbItem.id || mod.componentId === ddbItem.definition?.id) {\n      if (type === \"class\") {\n        // logger.log(\"Class check - feature effect parsing\");\n        const classFeatureMatch = ddb.character.classes.some((klass) =>\n          klass.classFeatures.some(\n            (f) => f.definition.entityTypeId == mod.componentTypeId && f.definition.id == ddbItem.id\n          )\n        );\n        if (classFeatureMatch) return true;\n      } else if (type === \"feat\") {\n        const featMatch = ddb.character.feats.some(\n          (f) => f.definition.entityTypeId == mod.componentTypeId && f.definition.id == ddbItem.id\n        );\n        if (featMatch) return true;\n      } else if (type === \"race\") {\n        const traitMatch = ddb.character.race.racialTraits.some(\n          (t) =>\n            t.definition.entityTypeId == mod.componentTypeId &&\n            t.definition.id == mod.componentId &&\n            t.definition.id == ddbItem.definition.id\n        );\n        if (traitMatch) return true;\n      }\n    }\n    return false;\n  });\n  // console.warn(modifierItem);\n  return modifierItem;\n}\n\nexport function addFeatEffects(ddb, character, ddbItem, item, choice, type) {\n  // can we apply any effects to this feature\n  const daeInstalled = utils.isModuleInstalledAndActive(\"dae\");\n  const compendiumItem = character.flags.ddbimporter.compendium;\n  const addCharacterEffects = compendiumItem\n    ? game.settings.get(\"ddb-importer\", \"munching-policy-add-effects\")\n    : game.settings.get(\"ddb-importer\", \"character-update-policy-add-character-effects\");\n  const modifierItem = generateFeatModifiers(ddb, ddbItem, choice, type);\n  if (daeInstalled && addCharacterEffects) {\n    item = generateEffects(ddb, character, modifierItem, item, compendiumItem, \"feat\");\n    // console.log(item);\n  }\n\n  item = generateBaseACItemEffect(ddb, character, modifierItem, item, compendiumItem);\n\n  return item;\n}\n\nexport function removeActionFeatures(actions, features) {\n  const actionAndFeature = game.settings.get(\"ddb-importer\", \"character-update-policy-use-action-and-feature\");\n\n  actions = actions.map((action) => {\n    const featureMatch = features.find((feature) => feature.name === action.name);\n    if (featureMatch &&\n      action.effects && action.effects.length === 0 &&\n      featureMatch.effects && featureMatch.effects.length > 0\n    ) {\n      action.effects = featureMatch.effects;\n    }\n    return action;\n  });\n\n  features = features\n    .filter((feature) => actionAndFeature || !actions.some((action) => feature.name === action.name && action.flags.ddbimporter.componentId == feature.flags.ddbimporter.id))\n    .map((feature) => {\n      const actionMatch = actionAndFeature && actions.some((action) => feature.name === action.name);\n      if (actionMatch) feature.effects = [];\n      return feature;\n    });\n\n  return [actions, features];\n}\n\nexport function stripHtml(html) {\n  let tmp = document.createElement(\"DIV\");\n  tmp.innerHTML = html;\n  return tmp.textContent || tmp.innerText || \"\";\n}\n\n/**\n * Some features we need to fix up or massage because they are modified\n * in interesting ways\n * @param {*} ddb\n * @param {*} features\n */\nexport function fixFeatures(features) {\n  // eslint-disable-next-line complexity\n  features.forEach((feature) => {\n    const name = feature.flags.ddbimporter.originalName || feature.name;\n    switch (name) {\n      case \"Channel Divinity: Radiance of the Dawn\":\n        feature.data.damage = {\n          parts: [[\"2d10[radiant] + @classes.cleric.levels\", \"radiant\"]],\n          versatile: \"\",\n          value: \"\",\n        };\n        break;\n      case \"Surprise Attack\":\n        feature.data.damage = { parts: [[\"2d6\", \"\"]], versatile: \"\", value: \"\" };\n        feature.data.activation[\"type\"] = \"special\";\n        break;\n      case \"Eldritch Cannon: Force Ballista\":\n        feature.data[\"target\"][\"value\"] = 1;\n        feature.data[\"target\"][\"type\"] = \"creature\";\n        feature.data[\"range\"][\"value\"] = 120;\n        feature.data[\"range\"][\"units\"] = \"ft\";\n        feature.data.ability = \"int\";\n        feature.data.actionType = \"rsak\";\n        feature.data.chatFlavor = \"On hit pushed 5 ft away.\";\n        feature.data.damage = { parts: [[\"2d8[force]\", \"force\"]], versatile: \"\", value: \"\" };\n        break;\n      case \"Eldritch Cannon: Protector\":\n        feature.data[\"target\"][\"units\"] = \"any\";\n        feature.data[\"target\"][\"type\"] = \"ally\";\n        feature.data[\"range\"][\"value\"] = 10;\n        feature.data.ability = \"int\";\n        feature.data.actionType = \"heal\";\n        feature.data.damage = { parts: [[\"1d8 + @mod\", \"temphp\"]], versatile: \"\", value: \"\" };\n        break;\n      case \"Eldritch Cannon: Flamethrower\":\n        feature.data.damage = { parts: [[\"2d8[fire]\", \"fire\"]], versatile: \"\", value: \"\" };\n        break;\n      case \"Second Wind\":\n        feature.data.damage = {\n          parts: [[\"1d10[healing] + @classes.fighter.levels\", \"healing\"]],\n          versatile: \"\",\n          value: \"\",\n        };\n        feature.data.actionType = \"heal\";\n        feature.data[\"target\"][\"type\"] = \"self\";\n        feature.data[\"range\"][\"type\"] = \"self\";\n        break;\n      case \"Healing Hands\": {\n        feature.data.damage = {\n          parts: [[\"@details.level[healing]\", \"healing\"]],\n          versatile: \"\",\n          value: \"\",\n        };\n        feature.data.actionType = \"heal\";\n        feature.data[\"target\"][\"type\"] = \"creature\";\n        feature.data[\"range\"] = {\n          type: \"touch\",\n          value: null,\n          long: null,\n          units: \"touch\"\n        };\n        break;\n      }\n      case \"Dark Ones Blessing\":\n      case \"Dark One's Blessing\": {\n        feature.data.damage = { parts: [[\"@classes.warlock.level + @mod\", \"temphp\"]], versatile: \"\", value: \"\" };\n        feature.data.actionType = \"heal\";\n        feature.data.ability = \"cha\";\n        feature.data[\"target\"][\"type\"] = \"self\";\n        feature.data[\"range\"][\"type\"] = \"self\";\n        feature.data.activation.condition = \"Reduce a hostile creature to 0 HP\";\n        break;\n      }\n      case \"Stone's Endurance\":\n      case \"Stones Endurance\":\n        feature.data.damage = { parts: [[\"1d12 + @mod\", \"\"]], versatile: \"\", value: \"\" };\n        feature.data.actionType = \"other\";\n        feature.data.ability = \"con\";\n        feature.data[\"target\"][\"type\"] = \"self\";\n        feature.data[\"range\"][\"type\"] = \"self\";\n        break;\n      case \"Fighting Style: Interception\":\n        feature.data.damage = { parts: [[\"1d10 + @prof\", \"\"]], versatile: \"\", value: \"\" };\n        feature.data[\"target\"][\"type\"] = \"self\";\n        feature.data[\"range\"][\"type\"] = \"self\";\n        break;\n      case \"Stunning Strike\":\n        feature.data.actionType = \"save\";\n        feature.data.save = { ability: \"con\", dc: null, scaling: \"wis\" };\n        feature.data.target = { value: null, width: null, units: \"touch\", type: \"creature\" };\n        feature.data.range.units = \"ft\";\n        break;\n      case \"Divine Intervention\":\n        feature.data.damage = { parts: [[\"1d100\", \"\"]], versatile: \"\", value: \"\" };\n        feature.data.actionType = \"other\";\n        break;\n      // add a rage effect\n      case \"Starry Form: Archer\":\n        feature.data.actionType = \"rsak\";\n        feature.data[\"target\"][\"value\"] = 1;\n        feature.data[\"target\"][\"type\"] = \"creature\";\n        feature.data[\"range\"][\"units\"] = \"ft\";\n        break;\n      case \"Starry Form: Chalice\":\n        feature.data.damage.parts[0][1] = \"healing\";\n        feature.data.actionType = \"heal\";\n        feature.data[\"target\"][\"value\"] = 1;\n        feature.data[\"target\"][\"type\"] = \"ally\";\n        feature.data[\"range\"][\"value\"] = 30;\n        feature.data[\"range\"][\"units\"] = \"ft\";\n        feature.data.activation.type = \"special\";\n        break;\n      case \"Starry Form: Dragon\":\n        break;\n      case \"Rage\": {\n        feature.data.target = {\n          value: null,\n          width: null,\n          units: \"\",\n          type: \"self\",\n        };\n        feature.data.duration = {\n          value: 1,\n          units: \"minute\",\n        };\n        break;\n      }\n      case \"Sneak Attack\": {\n        feature.data.damage = { parts: [[\"(ceil(@classes.rogue.levels /2))d6\", \"\"]], versatile: \"\", value: \"\" };\n        if (!feature.flags.ddbimporter.action) {\n          feature.data.actionType = \"other\";\n          feature.data.activation = { type: \"special\", cost: 0, condition: \"\" };\n        }\n        break;\n      }\n      case \"Bardic Inspiration\": {\n        feature.data.actionType = \"util\";\n        feature.data.duration = {\n          value: 10,\n          units: \"minute\",\n        };\n        feature.data.target = {\n          value: 1,\n          width: null,\n          units: \"\",\n          type: \"creature\",\n        };\n        feature.data[\"range\"][\"value\"] = 60;\n        feature.data[\"range\"][\"units\"] = \"ft\";\n        break;\n      }\n      case \"Superiority Dice\": {\n        // feature parses as all available dice, rather than 1 per us\n        if (feature.data.damage.parts.length === 0) {\n          feature.data.damage.parts = [[\"1d6\"]];\n        } else {\n          feature.data.damage.parts[0][0] = `1d${feature.data.damage.parts[0][0].split(\"d\").pop()}`;\n        }\n        break;\n      }\n      case \"Deflect Missiles\": {\n        feature.data.damage = { parts: [[\"1d10 + @mod + @classes.monk.levels\"]], versatile: \"\", value: \"\" };\n        break;\n      }\n      case \"Polearm Master - Bonus Attack\": {\n        feature.data.actionType = \"mwak\";\n        feature.data.range = { value: 10, long: null, units: \"ft\" };\n        break;\n      }\n      case \"Healing Light\": {\n        feature.data.damage = { parts: [[\"1d6\"]], versatile: \"\", value: \"\" };\n        break;\n      }\n      case \"Arcane Propulsion Armor Gauntlet\": {\n        feature.data.damage.parts[0][0] += \" + @mod\";\n        break;\n      }\n      // no default\n    }\n\n    const tableDescription = generateTable(feature.name, feature.data.description.value, true);\n    feature.data.description.value = tableDescription;\n    feature.data.description.chat = tableDescription;\n  });\n}\n\n\nexport async function addExtraEffects(documents, character) {\n  const compendiumItem = character.flags.ddbimporter.compendium;\n  const addCharacterEffects = compendiumItem\n    ? game.settings.get(\"ddb-importer\", \"munching-policy-add-effects\")\n    : game.settings.get(\"ddb-importer\", \"character-update-policy-add-character-effects\");\n\n  if (addCharacterEffects) {\n    const results = await Promise.all(documents.map((document) => {\n      return generateExtraEffects(document);\n    }));\n    return results;\n  } else {\n    return documents;\n  }\n\n}\n","import DICTIONARY from \"../../dictionary.js\";\nimport logger from \"../../logger.js\";\nimport utils from \"../../utils.js\";\nimport parseTemplateString from \"../templateStrings.js\";\nimport { fixFeatures, stripHtml, addFeatEffects, addExtraEffects } from \"./special.js\";\nimport { getInfusionActionData } from \"../inventory/infusions.js\";\n\nfunction getResourceFlags(character, action, flags) {\n  const linkItems = utils.isModuleInstalledAndActive(\"link-item-resource-5e\");\n  const resourceType = getProperty(character, \"flags.ddbimporter.resources.type\");\n  if (resourceType !== \"disable\" && linkItems) {\n    const hasResourceLink = getProperty(flags, \"link-item-resource-5e.resource-link\");\n    Object.keys(character.data.resources).forEach((resource) => {\n      const detail = character.data.resources[resource];\n      if (action.name === detail.label) {\n        setProperty(flags, \"link-item-resource-5e.resource-link\", resource);\n        character.data.resources[resource] = { value: 0, max: 0, sr: false, lr: false, label: \"\" };\n      } else if (hasResourceLink === resource) {\n        setProperty(flags, \"link-item-resource-5e.resource-link\", undefined);\n      }\n    });\n  }\n  return flags;\n}\n\nfunction addFlagHints(ddb, character, action, feature) {\n  const klassAction = ddb.character.actions.class\n    .filter((ddbAction) => utils.findClassByFeatureId(ddb, ddbAction.componentId))\n    .find((ddbAction) => {\n      const name = utils.getName(ddbAction, character);\n      return name === feature.name;\n    });\n  const raceAction = ddb.character.actions.race\n    .some((ddbAction) => {\n      const name = utils.getName(ddbAction, character);\n      return name === feature.name;\n    });\n  const featAction = ddb.character.actions.feat\n    .some((ddbAction) => {\n      const name = utils.getName(ddbAction, character);\n      return name === feature.name;\n    });\n\n  // obsidian and klass names (used in effect enrichment)\n  if (klassAction) {\n    const klass = utils.findClassByFeatureId(ddb, klassAction.componentId);\n    setProperty(feature.flags, \"obsidian.source.type\", \"class\");\n    setProperty(feature.flags, \"obsidian.source.text\", klass.definition.name);\n    setProperty(feature.flags, \"ddbimporter.class\", klass.definition.name);\n    const subClassName = hasProperty(klass, \"subclassDefinition.name\") ? klass.subclassDefinition.name : undefined;\n    setProperty(feature.flags, \"ddbimporter.subclass\", subClassName);\n  } else if (raceAction) {\n    feature.flags.obsidian.source.type = \"race\";\n  } else if (featAction) {\n    feature.flags.obsidian.source.type = \"feat\";\n  }\n\n  // scaling details\n  let klassActionComponent = utils.findComponentByComponentId(ddb, action.id);\n  if (!klassActionComponent) klassActionComponent = utils.findComponentByComponentId(ddb, action.componentId);\n  if (klassActionComponent) {\n    setProperty(feature.flags, \"ddbimporter.dndbeyond.levelScale\", klassActionComponent.levelScale);\n    setProperty(feature.flags, \"ddbimporter.dndbeyond.levelScales\", klassActionComponent.definition?.levelScales);\n    setProperty(feature.flags, \"ddbimporter.dndbeyond.limitedUse\", klassActionComponent.definition?.limitedUse);\n  }\n\n  // better rolls\n  if (utils.isModuleInstalledAndActive(\"betterrolls5e\")) {\n    if (feature.data.uses?.max) {\n      feature.flags.betterRolls5e = {\n        \"quickCharges\": {\n          \"value\": {\n            \"use\": true,\n            \"resource\": true\n          },\n          \"altValue\": {\n            \"use\": true,\n            \"resource\": true\n          }\n        }\n      };\n    }\n  }\n\n  // resource flag hints\n  feature.flags = getResourceFlags(character, action, feature.flags);\n\n  return feature;\n}\n\n// get actions from ddb.character.customActions\nfunction getCustomActions(ddb, displayedAsAttack) {\n  const customActions = ddb.character.customActions\n    .filter((action) => action.displayAsAttack === displayedAsAttack)\n    .map((action) => {\n      action.dice = {\n        diceString: action.diceCount && action.diceType ? `${action.diceCount}d${action.diceType}` : null,\n        fixedValue: action.fixedValue,\n      };\n\n      const range = {\n        aoeType: action.aoeType,\n        aoeSize: action.aoeSize,\n        range: action.range,\n        long: action.longRange,\n      };\n      action.range = range;\n\n      if (action.statId) action.abilityModifierStatId = action.statId;\n\n      action.activation = {\n        activationTime: action.activationTime,\n        activationType: action.activationType,\n      };\n\n      return action;\n    });\n\n  return customActions;\n}\n\nfunction isMartialArtists(classes) {\n  return classes.some((cls) => cls.classFeatures.some((feature) => feature.definition.name === \"Martial Arts\"));\n}\n\nfunction getDamage(action) {\n  let damage = {};\n  const damageType = action.damageTypeId\n    ? DICTIONARY.actions.damageType.find((type) => type.id === action.damageTypeId).name\n    : null;\n\n  // when the action type is not set to melee or ranged we don't apply the mod to damage\n  const meleeOrRangedAction = action.attackTypeRange || action.rangeId;\n  const modBonus = (action.statId || action.abilityModifierStatId) && !action.isOffhand && meleeOrRangedAction ? \" + @mod\" : \"\";\n  const fixedBonus = action.dice?.fixedValue ? ` + ${action.dice.fixedValue}` : \"\";\n  const globalDamageHints = game.settings.get(\"ddb-importer\", \"use-damage-hints\");\n\n  if (action.dice) {\n    if (action.dice.diceString) {\n      const damageTag = (globalDamageHints && damageType) ? `[${damageType}]` : \"\";\n      const damageString = utils.parseDiceString(action.dice.diceString, modBonus + fixedBonus, damageTag).diceString;\n      damage = {\n        parts: [[damageString, damageType]],\n        versatile: \"\",\n      };\n    } else if (fixedBonus) {\n      damage = {\n        parts: [[fixedBonus + modBonus, damageType]],\n        versatile: \"\",\n      };\n    }\n  }\n\n  return damage;\n}\n\n/**\n * Some features have actions that use dice and mods that are defined on the character class feature\n * this attempts to parse out the damage dice and any ability modifier.\n * This relies on the parsing of templateStrings for the ability modifier detection.\n * @param {*} ddb\n * @param {*} character\n * @param {*} action\n * @param {*} feat\n */\nfunction getLevelScaleDice(ddb, character, action, feat) {\n  let parts = ddb.character.classes\n    .filter((cls) => cls.classFeatures.some((feature) =>\n      feature.definition.id == action.componentId &&\n      feature.definition.entityTypeId == action.componentTypeId &&\n      feature.levelScale?.dice?.diceString\n    ))\n    .map((cls) => {\n      const feature = cls.classFeatures.find((feature) =>\n        feature.definition.id == action.componentId &&\n        feature.definition.entityTypeId == action.componentTypeId\n      );\n      const parsedString = character.flags.ddbimporter.dndbeyond.templateStrings.find((templateString) =>\n        templateString.id == action.id &&\n        templateString.entityTypeId == action.entityTypeId\n      );\n      let part = feature.levelScale.dice.diceString;\n      if (parsedString) {\n        const modifier = parsedString.definitions.find((definition) => definition.type === \"modifier\");\n        if (modifier) {\n          feat.data.ability = modifier.subType;\n          part = `${part} + @mod`;\n        }\n      }\n      return [part, \"\"];\n    });\n\n  feat.data.damage = {\n    parts: parts,\n    versatile: \"\",\n  };\n\n  return feat;\n}\n\nfunction martialArtsDamage(ddb, action) {\n  const damageType = DICTIONARY.actions.damageType.find((type) => type.id === action.damageTypeId).name;\n  const globalDamageHints = game.settings.get(\"ddb-importer\", \"use-damage-hints\");\n\n  let damageBonus = utils.filterBaseModifiers(ddb, \"damage\", \"unarmed-attacks\").reduce((prev, cur) => prev + cur.value, 0);\n  if (damageBonus === 0) {\n    damageBonus = \"\";\n  } else {\n    damageBonus = ` + ${damageBonus}`;\n  }\n\n  // are we dealing with martial arts?\n  if (isMartialArtists(ddb.character.classes)) {\n    const die = ddb.character.classes\n      .filter((cls) => isMartialArtists([cls]))\n      .map((cls) => {\n        const feature = cls.classFeatures.find((feature) => feature.definition.name === \"Martial Arts\");\n\n        if (feature && feature.levelScale && feature.levelScale.dice && feature.levelScale.dice.diceString) {\n          if (action.dice?.diceValue > feature.levelScale.dice.diceValue) {\n            return action.dice.diceString;\n          }\n          return feature.levelScale.dice.diceString;\n        } else if (action.dice !== null) {\n          // On some races bite is considered a martial art, damage\n          // is different and on the action itself\n          return action.dice.diceString;\n        } else {\n          return \"1\";\n        }\n      });\n\n    const damageTag = (globalDamageHints && damageType) ? `[${damageType}]` : \"\";\n    const damageString = utils.parseDiceString(die, `${damageBonus} + @mod`, damageTag).diceString;\n\n    // set the weapon damage\n    return {\n      parts: [[damageString, damageType]],\n      versatile: \"\",\n    };\n  } else if (action.dice !== null) {\n    // The Lizardfolk jaws have a different base damage, its' detailed in\n    // dice so lets capture that for actions if it exists\n    const damageTag = (globalDamageHints && damageType) ? `[${damageType}]` : \"\";\n    const damageString = utils.parseDiceString(action.dice.diceString, `${damageBonus} + @mod`, damageTag).diceString;\n    return {\n      parts: [[damageString, damageType]],\n      versatile: \"\",\n    };\n  } else {\n    // default to basics\n    return {\n      parts: [[`1${damageBonus} + @mod`, damageType]],\n      versatile: \"\",\n    };\n  }\n}\n\nfunction getLimitedUse(action, character) {\n  if (\n    action.limitedUse &&\n    (action.limitedUse.maxUses || action.limitedUse.statModifierUsesId || action.limitedUse.useProficiencyBonus)\n  ) {\n    const resetType = DICTIONARY.resets.find((type) => type.id === action.limitedUse.resetType);\n    let maxUses = (action.limitedUse.maxUses && action.limitedUse.maxUses !== -1) ? action.limitedUse.maxUses : 0;\n\n    if (action.limitedUse.statModifierUsesId) {\n      const ability = DICTIONARY.character.abilities.find(\n        (ability) => ability.id === action.limitedUse.statModifierUsesId\n      ).value;\n\n      switch (action.limitedUse.operator) {\n        case 2: {\n          maxUses *= character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;\n          break;\n        }\n        case 1:\n        default:\n          maxUses += character.flags.ddbimporter.dndbeyond.effectAbilities[ability].mod;\n      }\n    }\n\n    if (action.limitedUse.useProficiencyBonus) {\n      switch (action.limitedUse.proficiencyBonusOperator) {\n        case 2: {\n          maxUses *= character.data.attributes.prof;\n          break;\n        }\n        case 1:\n        default:\n          maxUses += character.data.attributes.prof;\n      }\n    }\n\n    const finalMaxUses = (maxUses) ? parseInt(maxUses) : null;\n\n    return {\n      value: (finalMaxUses !== null && finalMaxUses != 0) ? maxUses - action.limitedUse.numberUsed : null,\n      max: (finalMaxUses != 0) ? finalMaxUses : null,\n      per: resetType ? resetType.value : \"\",\n    };\n  } else {\n    return {\n      value: null,\n      max: null,\n      per: \"\",\n    };\n  }\n}\n\nfunction getDescription(ddb, character, action) {\n  const useFull = game.settings.get(\"ddb-importer\", \"character-update-policy-use-full-description\");\n  let snippet = action.snippet ? parseTemplateString(ddb, character, action.snippet, action).text : \"\";\n  const description = action.description ? parseTemplateString(ddb, character, action.description, action).text : \"\";\n  if (stripHtml(description) === snippet) snippet = \"\";\n  const fullDescription = description !== \"\" ? description + (snippet !== \"\" ? \"<h3>Summary</h3>\" + snippet : \"\") : snippet;\n  const value = !useFull && snippet.trim() !== \"\" ? snippet : fullDescription;\n  return {\n    value: value,\n    chat: snippet,\n    unidentified: \"\",\n  };\n}\n\nfunction getActivation(action) {\n  if (action.activation) {\n    const actionType = DICTIONARY.actions.activationTypes.find((type) => type.id === action.activation.activationType);\n    const activation = !actionType\n      ? {}\n      : {\n        type: actionType.value,\n        cost: action.activation.activationTime || 1,\n        condition: \"\",\n      };\n    return activation;\n  }\n  return {};\n}\n\nfunction getResource(character, action) {\n  let consume = {\n    \"type\": \"\",\n    \"target\": \"\",\n    \"amount\": null\n  };\n\n  Object.keys(character.data.resources).forEach((resource) => {\n    const detail = character.data.resources[resource];\n    if (action.name === detail.label) {\n      consume = {\n        type: \"attribute\",\n        target: `resources.${resource}.value`,\n        amount: 1,\n      };\n    }\n  });\n\n  return consume;\n}\n\nfunction getWeaponType(action) {\n  const entry = DICTIONARY.actions.attackTypes.find((type) => type.attackSubtype === action.attackSubtype);\n  const range = DICTIONARY.weapon.weaponRange.find((type) => type.attackType === action.attackTypeRange);\n  return entry ? entry.value : range ? `simple${range.value}` : \"simpleM\";\n}\n\nfunction calculateRange(action, weapon) {\n  if (action.range && action.range.aoeType && action.range.aoeSize) {\n    weapon.data.range = { value: null, units: \"self\", long: \"\" };\n    weapon.data.target = {\n      value: action.range.aoeSize,\n      type: DICTIONARY.actions.aoeType.find((type) => type.id === action.range.aoeType)?.value,\n      units: \"ft\",\n    };\n  } else if (action.range && action.range.range) {\n    weapon.data.range = {\n      value: action.range.range,\n      units: \"ft.\",\n      long: action.range.long || \"\",\n    };\n  } else {\n    weapon.data.range = { value: 5, units: \"ft.\", long: \"\" };\n  }\n  return weapon;\n}\n\nfunction calculateSaveAttack(action, weapon) {\n  weapon.data.actionType = \"save\";\n  weapon.data.damage = getDamage(action);\n\n  const fixedDC = (action.fixedSaveDc) ? action.fixedSaveDc : null;\n  const scaling = (fixedDC) ? fixedDC : (action.abilityModifierStatId) ? DICTIONARY.character.abilities.find((stat) => stat.id === action.abilityModifierStatId).value : \"spell\";\n\n  const saveAbility = (action.saveStatId)\n    ? DICTIONARY.character.abilities.find((stat) => stat.id === action.saveStatId).value\n    : \"\";\n\n  weapon.data.save = {\n    ability: saveAbility,\n    dc: fixedDC,\n    scaling: scaling,\n  };\n  if (action.abilityModifierStatId) {\n    weapon.data.ability = DICTIONARY.character.abilities.find((stat) => stat.id === action.abilityModifierStatId).value;\n  }\n  return weapon;\n}\n\n\nfunction calculateActionAttackAbilities(ddb, character, action, weapon) {\n  let defaultAbility;\n\n  if (action.abilityModifierStatId && !([1, 2].includes(action.abilityModifierStatId) && action.isMartialArts)) {\n    defaultAbility = DICTIONARY.character.abilities.find(\n      (stat) => stat.id === action.abilityModifierStatId\n    ).value;\n    weapon.data.ability = defaultAbility;\n  } else if (action.isMartialArts) {\n    weapon.data.ability =\n      action.isMartialArts && isMartialArtists(ddb.character.classes)\n        ? character.flags.ddbimporter.dndbeyond.effectAbilities.dex.value >= character.flags.ddbimporter.dndbeyond.effectAbilities.str.value\n          ? \"dex\"\n          : \"str\"\n        : \"str\";\n  } else {\n    weapon.data.ability = \"\";\n  }\n  if (action.isMartialArts) {\n    weapon.data.damage = martialArtsDamage(ddb, action);\n    weapon.data.attackBonus = utils.filterBaseModifiers(ddb, \"bonus\", \"unarmed-attacks\").reduce((prev, cur) => prev + cur.value, 0);\n  } else {\n    weapon.data.damage = getDamage(action);\n  }\n  return weapon;\n}\n\nfunction getAttackType(ddb, character, action, weapon) {\n  // lets see if we have a save stat for things like Dragon born Breath Weapon\n  if (action.saveStatId) {\n    weapon = calculateSaveAttack(action, weapon);\n  } else if (action.actionType === 1) {\n    weapon.data.actionType = \"mwak\";\n    weapon = calculateActionAttackAbilities(ddb, character, action, weapon);\n  } else {\n    if (action.rangeId && action.rangeId === 1) {\n      weapon.data.actionType = \"mwak\";\n    } else if (action.rangeId && action.rangeId === 2) {\n      weapon.data.actionType = \"rwak\";\n    } else {\n      weapon.data.actionType = \"other\";\n    }\n    weapon = calculateActionAttackAbilities(ddb, character, action, weapon);\n  }\n  return weapon;\n}\n\nfunction getAttackAction(ddb, character, action) {\n  const actionType = game.settings.get(\"ddb-importer\", \"character-update-policy-use-actions-as-features\")\n    ? \"feat\"\n    : \"weapon\";\n  let feature = {\n    name: utils.getName(action, character),\n    type: actionType,\n    data: JSON.parse(utils.getTemplate(actionType)),\n    flags: {\n      ddbimporter: {\n        id: action.id,\n        entityTypeId: action.entityTypeId,\n        action: true,\n        componentId: action.componentId,\n        componentTypeId: action.componentTypeId,\n      },\n      infusions: { infused: false },\n      obsidian: {\n        source: {\n          type: \"other\",\n        },\n      },\n    },\n  };\n  logger.debug(`Parsing action: ${feature.name} as ${actionType}`);\n  if (action.infusionFlags) {\n    setProperty(feature, \"flags.infusions\", action.infusionFlags);\n  }\n\n  try {\n    if (action.isMartialArts) {\n      feature.flags.ddbimporter.dndbeyond = {\n        type: \"Martial Arts\",\n      };\n    }\n\n    feature.data.proficient = action.isProficient ? 1 : 0;\n    feature.data.description = getDescription(ddb, character, action);\n    feature.data.equipped = true;\n    feature.data.rarity = \"common\";\n    feature.data.identified = true;\n    feature.data.activation = getActivation(action);\n    feature = calculateRange(action, feature);\n    feature = getAttackType(ddb, character, action, feature);\n    feature.data.weaponType = getWeaponType(action);\n    feature.data.uses = getLimitedUse(action, character);\n    feature.data.consume = getResource(character, action);\n\n    feature = addFlagHints(ddb, character, action, feature);\n    feature = addFeatEffects(ddb, character, action, feature);\n\n  } catch (err) {\n    logger.warn(\n      `Unable to Import Attack Action: ${action.name}, please log a bug report. Err: ${err.message}`,\n      \"extension\"\n    );\n  }\n\n  return feature;\n}\n\n/**\n * Everyone has an Unarmed Strike\n * @param {*} ddb\n */\nfunction getUnarmedStrike(ddb, character) {\n  const unarmedStrikeMock = {\n    limitedUse: null,\n    name: \"Unarmed Strike\",\n    description: null,\n    snippet:\n      \"Instead of using a weapon to make a melee weapon attack, you can use an unarmed strike: a punch, kick, head-butt, or similar forceful blow (none of which count as weapons). On a hit, an unarmed strike deals bludgeoning damage equal to 1 + your Strength modifier. You are proficient with your unarmed strikes.\",\n    abilityModifierStatId: null,\n    attackTypeRange: 1,\n    actionType: 1,\n    attackSubtype: 3,\n    dice: null,\n    value: 1,\n    damageTypeId: 1,\n    isMartialArts: true,\n    isProficient: true,\n    displayAsAttack: true,\n    range: {\n      range: null,\n      longRange: null,\n      aoeType: null,\n      aoeSize: null,\n      hasAoeSpecialDescription: false,\n    },\n    activation: {\n      activationTime: 1,\n      activationType: 1,\n    },\n    id: \"unarmedStrike\",\n  };\n  const unarmedStrike = getAttackAction(ddb, character, unarmedStrikeMock);\n  return unarmedStrike;\n}\n\n/**\n * Try and parse attack actions - this will at the moment only really support basic melee attacks\n * @param {*} ddb\n * @param {*} character\n */\nfunction getAttackActions(ddb, character) {\n  return [\n    // do class options here have a class id, needed for optional class features\n    ddb.character.actions.class.filter((action) => utils.findClassByFeatureId(ddb, action.componentId)),\n    ddb.character.actions.race,\n    ddb.character.actions.feat,\n    getCustomActions(ddb, true),\n    getInfusionActionData(ddb),\n  ]\n    .flat()\n    .filter((action) => action.displayAsAttack)\n    .map((action) => {\n      return getAttackAction(ddb, character, action);\n    });\n}\n\n/**\n * Lets Parse remaining actions\n * @param {*} ddb\n * @param {*} items\n */\nfunction getOtherActions(ddb, character, items) {\n  const actions = [\n    // do class options here have a class id, needed for optional class features\n    ddb.character.actions.class.filter((action) => utils.findClassByFeatureId(ddb, action.componentId)),\n    ddb.character.actions.race,\n    ddb.character.actions.feat,\n    getCustomActions(ddb, false),\n    getInfusionActionData(ddb),\n  ]\n    .flat()\n    .filter((action) => action.name && action.name !== \"\")\n    .filter(\n      (action) =>\n        // lets grab other actions and add, make sure we don't get attack based ones that haven't parsed\n        !action.displayAsAttack ||\n        (action.displayAsAttack === true && !items.some((attack) => attack.name === action.name))\n    )\n    .map((action) => {\n      logger.debug(`Getting Other Action ${action.name}`);\n      let feat = {\n        name: utils.getName(action, character),\n        type: \"feat\",\n        data: JSON.parse(utils.getTemplate(\"feat\")),\n        flags: {\n          ddbimporter: {\n            id: action.id,\n            entityTypeId: action.entityTypeId,\n            componentId: action.componentId,\n            componentTypeId: action.componentTypeId,\n          },\n          infusions: { infused: false },\n          obsidian: {\n            source: {\n              type: \"other\",\n            },\n          }\n        },\n      };\n      if (action.infusionFlags) {\n        setProperty(feat, \"flags.infusions\", action.infusionFlags);\n      }\n      feat.data.activation = getActivation(action);\n      feat.data.description = getDescription(ddb, character, action);\n      feat.data.uses = getLimitedUse(action, character);\n      feat.data.consume = getResource(character, action);\n\n      feat = calculateRange(action, feat);\n      feat = getAttackType(ddb, character, action, feat);\n\n      if (!feat.data.damage?.parts) {\n        logger.debug(\"Running level scale parser\");\n        feat = getLevelScaleDice(ddb, character, action, feat);\n      }\n\n      feat = addFlagHints(ddb, character, action, feat);\n      feat = addFeatEffects(ddb, character, action, feat);\n\n      return feat;\n    });\n\n  return actions;\n}\n\nexport default async function parseActions(ddb, character) {\n  let actions = [\n    // Get Attack Actions that we know about, typically natural attacks etc\n    ...getAttackActions(ddb, character),\n    // Everyone has an Unarmed Strike\n    getUnarmedStrike(ddb, character),\n  ];\n  actions = [\n    ...actions,\n    // Try and parse other relevant actions\n    ...getOtherActions(ddb, character, actions),\n  ];\n\n  // sort alphabetically, then by action type\n  actions.sort().sort((a, b) => {\n    if (!a.data.activation.activationType) {\n      return 1;\n    } else if (!b.data.activation.activationType) {\n      return -1;\n    } else {\n      const aActionTypeID = DICTIONARY.actions.activationTypes.find(\n        (type) => type.value === a.data.activation.activationType\n      ).id;\n      const bActionTypeID = DICTIONARY.actions.activationTypes.find(\n        (type) => type.value === b.data.activation.activationType\n      ).id;\n      if (aActionTypeID > bActionTypeID) {\n        return 1;\n      } else if (aActionTypeID < bActionTypeID) {\n        return -1;\n      } else {\n        return 0;\n      }\n    }\n  });\n\n  fixFeatures(actions);\n  const results = await addExtraEffects(actions, character);\n  return results;\n}\n","import logger from \"../../logger.js\";\nimport utils from \"../../utils.js\";\nimport parseTemplateString from \"../templateStrings.js\";\nimport { fixFeatures, stripHtml, addFeatEffects, addExtraEffects } from \"./special.js\";\nimport { getBackgroundData } from \"../character/bio.js\";\n\nfunction getDescription(ddb, character, feat) {\n  // for now none actions probably always want the full text\n  // const useFull = game.settings.get(\"ddb-importer\", \"character-update-policy-use-full-description\");\n  const useFull = true;\n  let snippet = \"\";\n  let description = \"\";\n\n  if (feat.definition?.snippet) {\n    snippet = parseTemplateString(ddb, character, feat.definition.snippet, feat).text;\n  } else if (feat.snippet) {\n    snippet = parseTemplateString(ddb, character, feat.snippet, feat).text;\n  } else {\n    snippet = \"\";\n  }\n\n  if (feat.definition?.description) {\n    description = parseTemplateString(ddb, character, feat.definition.description, feat).text;\n  } else if (feat.description) {\n    description = parseTemplateString(ddb, character, feat.description, feat).text;\n  } else {\n    description = \"\";\n  }\n\n  if (stripHtml(description) === snippet) snippet = \"\";\n\n  const fullDescription = description !== \"\" ? description + (snippet !== \"\" ? \"<h3>Summary</h3>\" + snippet : \"\") : snippet;\n  const value = !useFull && snippet.trim() !== \"\" ? snippet : fullDescription;\n\n  return {\n    value: value,\n    chat: snippet,\n    unidentified: \"\",\n  };\n}\n\nfunction parseFeature(feat, ddb, character, source, type) {\n  let features = [];\n  // filter proficiencies and Ability Score Improvement\n  const name = feat.definition ? feat.definition.name : feat.name;\n  let item = {\n    name: name,\n    type: \"feat\",\n    data: JSON.parse(utils.getTemplate(\"feat\")),\n    flags: {\n      ddbimporter: {\n        id: feat.definition?.id ? feat.definition.id : feat.id,\n        type: type,\n        entityTypeId: feat.definition?.entityTypeId ? feat.definition.entityTypeId : feat.entityTypeId,\n        dndbeyond: {\n          requiredLevel: feat.requiredLevel,\n          displayOrder:\n            feat.definition && feat.definition.displayOrder ? feat.definition.displayOrder : feat.displayOrder,\n        },\n      },\n      obsidian: {\n        source: {\n          type: type,\n        },\n      },\n    },\n  };\n\n  logger.debug(`Getting Feature ${item.name}`);\n\n  const klassAction = utils.findComponentByComponentId(ddb, feat.id);\n  if (klassAction) {\n    setProperty(item.flags, \"ddbimporter.dndbeyond.levelScale\", klassAction.levelScale);\n    setProperty(item.flags, \"ddbimporter.dndbeyond.levelScales\", klassAction.definition?.levelScales);\n    setProperty(item.flags, \"ddbimporter.dndbeyond.limitedUse\", klassAction.definition?.limitedUse);\n  }\n\n  if (feat?.requiredLevel) {\n    const klass = ddb.character.classes.find((klass) => klass.definition.id === feat.classId);\n    if (klass && feat.requiredLevel > klass.level) return [];\n  }\n\n  logger.debug(`Searching for ${name} choices`);\n\n  // Add choices to the textual description of that feat\n  let choices = utils.getChoices(ddb, type, feat);\n\n  if (type === \"background\") {\n    logger.debug(`Found background ${feat.name}`);\n    logger.debug(`Found ${choices.map((c) => c.label).join(\",\")}`);\n    item.data.description = getDescription(ddb, character, feat);\n    item.data.description.value += `<h3>Choices</h3><ul>`;\n    item.data.source = source;\n    choices.forEach((choice) => {\n      let choiceItem = JSON.parse(JSON.stringify(item));\n      item = addFeatEffects(ddb, character, feat, choiceItem, choice, type);\n      item.data.description.value += `<li>${choice.label}</li>`;\n    });\n    item.data.description.value += `</ul>`;\n    features.push(item);\n  } else if (choices.length > 0) {\n    logger.debug(`Found ${choices.map((c) => c.label).join(\",\")}`);\n    choices.forEach((choice) => {\n      logger.debug(`Adding choice ${choice.label}`);\n      let choiceItem = JSON.parse(JSON.stringify(item));\n      let choiceFeat = feat.definition ? JSON.parse(JSON.stringify(feat.definition)) : JSON.parse(JSON.stringify(feat));\n\n      if (item.name === choice.label) return;\n\n      choiceItem.name = choice.label ? `${choiceItem.name}: ${choice.label}` : choiceItem.name;\n      if (choiceFeat.description) {\n        choiceFeat.description = choice.description\n          ? choiceFeat.description + \"<h3>\" + choice.label + \"</h3>\" + choice.description\n          : choiceFeat.description;\n      }\n      if (choiceFeat.snippet) {\n        choiceFeat.snippet = choice.description\n          ? choiceFeat.snippet + \"<h3>\" + choice.label + \"</h3>\" + choice.description\n          : choiceFeat.snippet;\n      }\n      choiceItem.data.description = getDescription(ddb, character, choiceFeat);\n      choiceItem.data.source = source;\n      choiceItem.flags.ddbimporter.dndbeyond.choice = {\n        label: choice.label,\n        choiceId: choice.choiceId,\n        componentId: choice.componentId,\n        componentTypeId: choice.componentTypeId,\n        parentChoiceId: choice.parentChoiceId,\n        subType: choice.subType,\n      };\n\n      choiceItem = addFeatEffects(ddb, character, feat, choiceItem, choice, type);\n      features.push(choiceItem);\n    });\n  } else {\n    item.data.description = getDescription(ddb, character, feat);\n    item.data.source = source;\n    item = addFeatEffects(ddb, character, feat, item, undefined, type);\n\n    features.push(item);\n  }\n\n  return features;\n}\n\nfunction isDuplicateFeature(items, item) {\n  return items.some((dup) => dup.name === item.name && dup.data.description.value === item.data.description.value);\n}\n\nfunction getNameMatchedFeature(items, item) {\n  return items.find((dup) => dup.name === item.name && item.flags.ddbimporter.type === dup.flags.ddbimporter.type);\n}\n\nconst SKIPPED_FEATURES = [\n  \"Hit Points\",\n  \"Languages\",\n  \"Bonus Proficiency\",\n  \"Speed\",\n];\nfunction includedFeatureNameCheck(featName) {\n  const nameAllowed = !featName.startsWith(\"Proficiencies\") &&\n    !featName.startsWith(\"Ability Score\") &&\n    !featName.startsWith(\"Size\") &&\n    !SKIPPED_FEATURES.includes(featName);\n\n  return nameAllowed;\n}\n\n\nfunction parseClassFeatures(ddb, character) {\n  // class and subclass traits\n  let classItems = [];\n  let classesFeatureList = [];\n  let subClassesFeatureList = [];\n  let processedClassesFeatureList = [];\n  const excludedFeatures = ddb.character.optionalClassFeatures\n    .filter((f) => f.affectedClassFeatureId)\n    .map((f) => f.affectedClassFeatureId);\n\n  // subclass features can often be duplicates of class features.\n  ddb.character.classes.forEach((klass) => {\n    const classFeatures = klass.definition.classFeatures.filter(\n      (feat) =>\n        includedFeatureNameCheck(feat.name) &&\n        feat.requiredLevel <= klass.level\n    );\n    const klassName = klass.definition.name;\n    const klassFeatureList = classFeatures\n      .filter((feat) => !excludedFeatures.includes(feat.id))\n      .map((feat) => {\n        let items = parseFeature(feat, ddb, character, klassName, \"class\");\n        return items.map((item) => {\n          item.flags.ddbimporter.dndbeyond.class = klassName;\n          item.flags.ddbimporter.class = klass.definition.name;\n          item.flags.ddbimporter.subclass = hasProperty(klass, \"subclassDefinition.name\")\n            ? klass.subclassDefinition.name\n            : undefined;\n          item.flags.obsidian.source.text = klassName;\n          // add feature to all features list\n          classesFeatureList.push(JSON.parse(JSON.stringify(item)));\n          return item;\n        });\n      })\n      .flat()\n      .sort((a, b) => {\n        return a.flags.ddbimporter.dndbeyond.displayOrder - b.flags.ddbimporter.dndbeyond.displayOrder;\n      });\n\n    klassFeatureList.forEach((item) => {\n      // have we already processed an identical item?\n      if (!isDuplicateFeature(processedClassesFeatureList, item)) {\n        const existingFeature = getNameMatchedFeature(classItems, item);\n        const duplicateFeature = isDuplicateFeature(classItems, item);\n        if (existingFeature && !duplicateFeature) {\n          const levelAdjustment = `<h3>${klassName}: Level ${item.flags.ddbimporter.dndbeyond.requiredLevel}</h3>${item.data.description.value}`;\n          existingFeature.data.description.value += levelAdjustment;\n        } else if (!existingFeature) {\n          classItems.push(item);\n        }\n      }\n    });\n    processedClassesFeatureList = processedClassesFeatureList.concat(classesFeatureList, klassFeatureList);\n\n    // subclasses\n    if (klass.subclassDefinition && klass.subclassDefinition.classFeatures) {\n      let subClassItems = [];\n      const subFeatures = klass.subclassDefinition.classFeatures.filter(\n        (feat) =>\n          includedFeatureNameCheck(feat.name) &&\n          feat.requiredLevel <= klass.level &&\n          !excludedFeatures.includes(feat.id)\n      );\n      const subKlassName = `${klassName} : ${klass.subclassDefinition.name}`;\n      const subKlassFeatureList = subFeatures\n        .map((feat) => {\n          let subClassItems = parseFeature(feat, ddb, character, subKlassName, \"class\");\n          return subClassItems.map((item) => {\n            item.flags.ddbimporter.dndbeyond.class = subKlassName;\n            item.flags.obsidian.source.text = klassName;\n            item.flags.ddbimporter.class = klass.definition.name;\n            item.flags.ddbimporter.subclass = hasProperty(klass, \"subclassDefinition.name\")\n              ? klass.subclassDefinition.name\n              : undefined;\n            // add feature to all features list\n            subClassesFeatureList.push(JSON.parse(JSON.stringify(item)));\n            return item;\n          });\n        })\n        .flat()\n        .sort((a, b) => {\n          return a.flags.ddbimporter.dndbeyond.displayOrder - b.flags.ddbimporter.dndbeyond.displayOrder;\n        });\n\n      // parse out duplicate features from class features\n      subKlassFeatureList.forEach((item) => {\n        if (!isDuplicateFeature(classesFeatureList, item)) {\n          const existingFeature = getNameMatchedFeature(subClassItems, item);\n          const duplicateFeature = isDuplicateFeature(subClassItems, item);\n          if (existingFeature && !duplicateFeature) {\n            const levelAdjustment = `<h3>${subKlassName}: At Level ${item.flags.ddbimporter.dndbeyond.requiredLevel}</h3>${item.data.description.value}`;\n            existingFeature.data.description.value += levelAdjustment;\n          } else if (!existingFeature) {\n            subClassItems.push(item);\n          }\n        }\n      });\n      // add features to list to indicate processed\n      processedClassesFeatureList = processedClassesFeatureList.concat(subClassesFeatureList, subKlassFeatureList);\n\n      // now we take the unique subclass features and add to class\n      subClassItems.forEach((item) => {\n        const existingFeature = getNameMatchedFeature(classItems, item);\n        const duplicateFeature = isDuplicateFeature(classItems, item);\n        if (existingFeature && !duplicateFeature) {\n          const levelAdjustment = `<h3>${subKlassName}: At Level ${item.flags.ddbimporter.dndbeyond.requiredLevel}</h3>${item.data.description.value}`;\n          existingFeature.data.description.value += levelAdjustment;\n        } else if (!existingFeature) {\n          classItems.push(item);\n        }\n      });\n    }\n  });\n  return classItems;\n}\n\nexport default async function parseFeatures(ddb, character) {\n  let items = [];\n\n  const excludedOriginFeatures = ddb.character.optionalOrigins\n    .filter((f) => f.affectedRacialTraitId)\n    .map((f) => f.affectedRacialTraitId);\n\n  // racial traits\n  logger.debug(\"Parsing racial traits\");\n  ddb.character.race.racialTraits\n    .filter(\n      (trait) => includedFeatureNameCheck(trait.definition.name) && !trait.definition.hideInSheet && !excludedOriginFeatures.includes(trait.definition.id))\n    .forEach((feat) => {\n      const source = utils.parseSource(feat.definition);\n      const features = parseFeature(feat, ddb, character, source, \"race\");\n      features.forEach((item) => {\n        const existingFeature = getNameMatchedFeature(items, item);\n        const duplicateFeature = isDuplicateFeature(items, item);\n        if (existingFeature && !duplicateFeature) {\n          existingFeature.data.description.value += `<h3>Racial Trait Addition</h3>${item.data.description.value}`;\n        } else if (!existingFeature) {\n          items.push(item);\n        }\n      });\n    });\n\n  // class and subclass traits\n  logger.debug(\"Parsing class and subclass features\");\n  let classItems = parseClassFeatures(ddb, character);\n\n  // optional class features\n  logger.debug(\"Parsing optional class features\");\n  if (ddb.classOptions) {\n    ddb.classOptions\n      .forEach((feat) => {\n        logger.debug(`Parsing Optional Feature ${feat.name}`);\n        const source = utils.parseSource(feat);\n        const feats = parseFeature(feat, ddb, character, source, \"class\");\n        feats.forEach((item) => {\n          items.push(item);\n        });\n      });\n  }\n\n  // now we loop over class features and add to list, removing any that match racial traits, e.g. Darkvision\n  logger.debug(\"Removing matching traits\");\n  classItems\n    .forEach((item) => {\n      const existingFeature = getNameMatchedFeature(items, item);\n      const duplicateFeature = isDuplicateFeature(items, item);\n      if (existingFeature && !duplicateFeature) {\n        const klassAdjustment = `<h3>${item.flags.ddbimporter.dndbeyond.class}</h3>${item.data.description.value}`;\n        existingFeature.data.description.value += klassAdjustment;\n      } else if (!existingFeature) {\n        items.push(item);\n      }\n    });\n\n  // add feats\n  logger.debug(\"Parsing feats\");\n  ddb.character.feats\n    .forEach((feat) => {\n      const source = utils.parseSource(feat.definition);\n      const feats = parseFeature(feat, ddb, character, source, \"feat\");\n      feats.forEach((item) => {\n        items.push(item);\n      });\n    });\n\n  logger.debug(\"Parsing backgrounds\");\n  const backgroundFeature = getBackgroundData(ddb);\n  const backgroundSource = utils.parseSource(backgroundFeature.definition);\n  const backgroundFeat = parseFeature(backgroundFeature, ddb, character, backgroundSource, \"background\");\n  backgroundFeat.forEach((item) => {\n    items.push(item);\n  });\n\n  logger.debug(\"Feature fixes\");\n  fixFeatures(items);\n  const results = await addExtraEffects(items, character);\n  // console.log(\"FEATURES\");\n  // console.error(\"FEATURES\",JSON.parse(JSON.stringify(results)));\n  return results;\n}\n","import DICTIONARY from \"../../dictionary.js\";\n\n// is there a spell casting ability?\nexport function hasSpellCastingAbility(spellCastingAbilityId) {\n  return DICTIONARY.character.abilities.find((ability) => ability.id === spellCastingAbilityId) !== undefined;\n}\n\n// convert spellcasting ability id to string used by foundry\nexport function convertSpellCastingAbilityId(spellCastingAbilityId) {\n  return DICTIONARY.character.abilities.find((ability) => ability.id === spellCastingAbilityId).value;\n}\n\n// search through classinfo and determine spellcasting ability\nexport function getSpellCastingAbility(classInfo) {\n  let spellCastingAbility = undefined;\n  if (hasSpellCastingAbility(classInfo.definition.spellCastingAbilityId)) {\n    spellCastingAbility = convertSpellCastingAbilityId(classInfo.definition.spellCastingAbilityId);\n  } else if (\n    classInfo.subclassDefinition &&\n    hasSpellCastingAbility(classInfo.subclassDefinition.spellCastingAbilityId)\n  ) {\n    // Arcane Trickster has spellcasting ID granted here\n    spellCastingAbility = convertSpellCastingAbilityId(classInfo.subclassDefinition.spellCastingAbilityId);\n  } else {\n    // special cases: No spellcaster, but can cast spells like totem barbarian, default to wis\n    spellCastingAbility = \"wis\";\n  }\n  return spellCastingAbility;\n}\n","import DICTIONARY from '../../dictionary.js';\nimport utils from '../../utils.js';\nimport { getSpellCastingAbility } from \"../spells/ability.js\";\n\n/**\n * Fetches the sources and pages for class and subclass\n * @param {obj} data item\n */\nlet getSources = (data) => {\n  const classSource = utils.getSourceData(data.definition);\n\n  let sources = classSource.name;\n  if (classSource.page) sources += ` (pg. ${classSource.page})`;\n\n  if (data.subclassDefinition) {\n    const subclassSource = utils.getSourceData(data.subclassDefinition);\n    if (subclassSource.name && classSource.name !== subclassSource.name) {\n      sources += `, ${subclassSource.name}`;\n    }\n    if (subclassSource.page && classSource.page !== subclassSource.page) {\n      sources += ` (pg. ${subclassSource.page})`;\n    }\n  }\n\n  return sources;\n};\n\nexport default function parseClasses(ddb) {\n  let items = [];\n\n  ddb.character.classes.forEach((characterClass) => {\n    let klass = {\n      name: characterClass.definition.name,\n      type: 'class',\n      data: JSON.parse(utils.getTemplate('class')),\n      flags: {\n        ddbimporter: {\n          id: characterClass.id,\n          definitionId: characterClass.definition.id,\n          entityTypeId: characterClass.entityTypeId,\n        },\n        obsidian: {\n          source: {\n            type: \"class\",\n            text: characterClass.definition.name,\n          }\n        },\n      },\n    };\n\n    klass.data.description = {\n      value: characterClass.definition.description,\n      chat: characterClass.definition.description,\n      unidentified: false,\n    };\n    klass.data.levels = characterClass.level;\n    klass.data.source = getSources(characterClass);\n\n    if (\n      characterClass.subclassDefinition &&\n      characterClass.subclassDefinition.name\n    ) {\n      klass.data.subclass = characterClass.subclassDefinition.name;\n\n      // update the description\n      klass.data.description.value +=\n        '<p><strong>' + klass.data.subclass + '</strong></p>';\n      klass.data.description.value +=\n        characterClass.subclassDefinition.description;\n    }\n\n    klass.data.hitDice = `d${characterClass.definition.hitDice}`;\n    klass.data.hitDiceUsed = characterClass.hitDiceUsed;\n\n    // There class object supports skills granted by the class.\n    // Lets find and add them for future compatibility.\n    // const classFeatureIds = characterClass.definition.classFeatures\n    //   .map((feature) => feature.id)\n    //   .concat((characterClass.subclassDefinition)\n    //     ? characterClass.subclassDefinition.classFeatures.map((feature) => feature.id)\n    //     : []);\n\n    const classProficiencyFeatureIds = characterClass.definition.classFeatures\n      .filter((feature) => feature.name === \"Proficiencies\")\n      .map((feature) => feature.id)\n      .concat((characterClass.subclassDefinition)\n        ? characterClass.subclassDefinition.classFeatures\n          .filter((feature) => feature.name === \"Proficiencies\")\n          .map((feature) => feature.id)\n        : []);\n\n    // const classSkillSubType = `choose-a-${characterClass.definition.name.toLowerCase()}-skill`;\n    // const skillIds = utils.getChosenClassModifiers(ddb)\n    //   .filter((mod) => mod.subType === classSkillSubType && mod.type === \"proficiency\")\n    //   .map((mod) => mod.componentId);\n\n    // \"subType\": 1,\n    // \"type\": 2,\n\n    let skillsChosen = [];\n    let skillChoices = [];\n    const choiceDefinitions = ddb.character.choices.choiceDefinitions;\n    ddb.character.choices.class.filter((choice) =>\n      classProficiencyFeatureIds.includes(choice.componentId) &&\n      choice.subType === 1 &&\n      choice.type === 2\n    ).forEach((choice) => {\n      const optionChoice = choiceDefinitions.find((selection) => selection.id === `${choice.componentTypeId}-${choice.type}`);\n      if (!optionChoice) return;\n      const option = optionChoice.options.find((option) => option.id === choice.optionValue);\n      if (!option) return;\n      const smallChosen = DICTIONARY.character.skills.find((skill) => skill.label === option.label);\n      if (smallChosen && !skillsChosen.includes(smallChosen.name)) {\n        skillsChosen.push(smallChosen.name);\n      }\n      const optionNames = optionChoice.options.filter((option) =>\n        DICTIONARY.character.skills.some((skill) => skill.label === option.label) &&\n        choice.optionIds.includes(option.id)\n      ).map((option) =>\n        DICTIONARY.character.skills.find((skill) => skill.label === option.label).name\n      );\n      optionNames.forEach((skill) => {\n        if (!skillChoices.includes(skill)) {\n          skillChoices.push(skill);\n        }\n      });\n    });\n\n    klass.data.skills = {\n      value: skillsChosen,\n      number: skillsChosen.length,\n      choices: skillChoices,\n    };\n\n    klass.data.saves = [];\n    DICTIONARY.character.abilities.forEach((ability) => {\n      const mods = utils.getChosenClassModifiers(ddb, true);\n      const save = utils.filterModifiers(mods, \"proficiency\", `${ability.long}-saving-throws`, [null, \"\"], true).length > 0;\n      if (save) klass.data.saves.push(ability.value);\n    });\n\n    const castSpells = (characterClass.definition.canCastSpells ||\n      (characterClass.subclassDefinition && characterClass.subclassDefinition.canCastSpells));\n\n    if (castSpells) {\n      const spellProgression = DICTIONARY.spell.progression.find((cls) => cls.name === characterClass.definition.name);\n      const spellCastingAbility = getSpellCastingAbility(characterClass);\n      if (spellProgression) {\n        klass.data.spellcasting = {\n          progression: spellProgression.value,\n          ability: spellCastingAbility,\n        };\n      }\n      const spellSlotDivisor = characterClass.definition.spellRules?.multiClassSpellSlotDivisor\n        ? characterClass.definition.spellRules.multiClassSpellSlotDivisor\n        : characterClass.subclassDefinition.spellRules?.multiClassSpellSlotDivisor\n          ? characterClass.subclassDefinition.spellRules?.multiClassSpellSlotDivisor\n          : undefined;\n      klass.flags.ddbimporter.spellSlotDivisor = spellSlotDivisor;\n      klass.flags.ddbimporter.spellCastingAbility = spellCastingAbility;\n    }\n\n    items.push(klass);\n  });\n\n  return items;\n}\n","/**\n * Generates some meta data for a character to use to determine what to do\n * with a spell.\n * We use this like a quick lookup table\n * @param {*} character\n */\nexport function getLookups(character) {\n  // racialTraits\n  let lookups = {\n    race: [],\n    feat: [],\n    class: [],\n    classFeature: [],\n    item: [],\n  };\n  character.race.racialTraits.forEach((trait) => {\n    lookups.race.push({\n      id: trait.definition.id,\n      name: trait.definition.name,\n    });\n  });\n\n  character.classes.forEach((playerClass) => {\n    lookups.class.push({\n      id: playerClass.definition.id,\n      name: playerClass.definition.name,\n    });\n\n    if (playerClass.subclassDefinition) {\n      lookups.class.push({\n        id: playerClass.subclassDefinition.id,\n        name: playerClass.subclassDefinition.name,\n      });\n    }\n\n    if (playerClass.classFeatures) {\n      playerClass.classFeatures.forEach((trait) => {\n        lookups.classFeature.push({\n          id: trait.definition.id,\n          name: trait.definition.name,\n          classId: trait.definition.classId,\n          componentId: trait.definition.componentId,\n        });\n      });\n    }\n  });\n\n  character.options.class.forEach((trait) => {\n    lookups.classFeature.push({\n      id: trait.definition.id,\n      name: trait.definition.name,\n      componentId: trait.componentId,\n    });\n  });\n\n  character.feats.forEach((trait) => {\n    lookups.feat.push({\n      id: trait.definition.id,\n      name: trait.definition.name,\n      componentId: trait.componentId,\n    });\n  });\n\n  character.inventory.forEach((trait) => {\n    lookups.item.push({\n      id: trait.definition.id,\n      name: trait.definition.name,\n      limitedUse: trait.limitedUse,\n      equipped: trait.equipped,\n      isAttuned: trait.isAttuned,\n      canAttune: trait.definition.canAttune,\n      canEquip: trait.definition.canEquip,\n    });\n  });\n\n  return lookups;\n}\n","import utils from \"../../utils.js\";\n\n// Import parsing functions\nimport { getLookups } from \"./metadata.js\";\nimport { fixSpells } from \"./special.js\";\nimport { parseSpell } from \"./parseSpell.js\";\nimport { getSpellCastingAbility, hasSpellCastingAbility, convertSpellCastingAbilityId } from \"./ability.js\";\nimport logger from \"../../logger.js\";\n\nexport function getCharacterSpells(ddb, character) {\n  let items = [];\n  const proficiencyModifier = character.data.attributes.prof;\n  const lookups = getLookups(ddb.character);\n\n  logger.debug(\"Character spell lookups\", lookups);\n  const characterAbilities = character.flags.ddbimporter.dndbeyond.effectAbilities;\n\n  const healingBoost = utils.filterBaseModifiers(ddb, \"bonus\", \"spell-group-healing\").reduce((a, b) => a + b.value, 0);\n\n  // each class has an entry here, each entry has spells\n  // we loop through each class and process\n  ddb.character.classSpells.forEach((playerClass) => {\n    const classInfo = ddb.character.classes.find((cls) => cls.id === playerClass.characterClassId);\n    const spellCastingAbility = getSpellCastingAbility(classInfo);\n    const abilityModifier = utils.calculateModifier(characterAbilities[spellCastingAbility].value);\n\n    logger.debug(\"Spell parsing, class info\", classInfo);\n\n    const cantripBoost =\n      utils.getChosenClassModifiers(ddb).filter(\n        (mod) =>\n          mod.type === \"bonus\" &&\n          mod.subType === `${classInfo.definition.name.toLowerCase()}-cantrip-damage` &&\n          (mod.restriction === null || mod.restriction === \"\")\n      ).length > 0;\n\n    // parse spells chosen as spellcasting (playerClass.spells)\n    playerClass.spells.forEach((spell) => {\n      if (!spell.definition) return;\n      // add some data for the parsing of the spells into the data structure\n      spell.flags = {\n        ddbimporter: {\n          dndbeyond: {\n            lookup: \"classSpell\",\n            class: classInfo.definition.name,\n            level: classInfo.level,\n            characterClassId: playerClass.characterClassId,\n            spellLevel: spell.definition.level,\n            // spellSlots: character.data.spells,\n            ability: spellCastingAbility,\n            mod: abilityModifier,\n            dc: 8 + proficiencyModifier + abilityModifier,\n            cantripBoost: cantripBoost,\n            overrideDC: false,\n            id: spell.id,\n            entityTypeId: spell.entityTypeId,\n            healingBoost: healingBoost,\n            usesSpellSlot: spell.usesSpellSlot,\n          },\n        }\n      };\n\n      // Check for duplicate spells, normally domain ones\n      // We will import spells from a different class that are the same though\n      // as they may come from with different spell casting mods\n      const duplicateSpell = items.findIndex(\n        (existingSpell) =>\n          existingSpell.name === spell.definition.name &&\n          classInfo.definition.name === existingSpell.flags.ddbimporter.dndbeyond.class\n      );\n      if (!items[duplicateSpell]) {\n        items.push(parseSpell(spell, character));\n      } else if (spell.alwaysPrepared) {\n        // if our new spell is always known we overwrite!\n        // it's probably domain\n        items[duplicateSpell] = parseSpell(spell, character);\n      } else {\n        // we'll emit a console message if it doesn't match this case for future debugging\n        logger.info(`Duplicate Spell ${spell.definition.name} detected in class ${classInfo.definition.name}.`);\n      }\n    });\n  });\n\n  // Parse any spells granted by class features, such as Barbarian Totem\n  ddb.character.spells.class.forEach((spell) => {\n    if (!spell.definition) return;\n    // If the spell has an ability attached, use that\n    let spellCastingAbility = undefined;\n    const featureId = utils.determineActualFeatureId(ddb, spell.componentId);\n    const classInfo = lookups.classFeature.find((clsFeature) => clsFeature.id == featureId);\n\n    logger.debug(\"Class spell parsing, class info\", classInfo);\n    // Sometimes there are spells here which don't have an class Info\n    // this seems to be part of the optional tasha's rules, lets not parse for now\n    // as ddb implementation is not yet finished\n    // / options.class.[].definition.id\n    if (!classInfo) {\n      logger.warn(`Unable to add ${spell.definition.name}`);\n    }\n    if (!classInfo) return;\n    let klass = utils.getClassFromOptionID(ddb, spell.componentId);\n\n    if (!klass) klass = utils.findClassByFeatureId(ddb, spell.componentId);\n\n    logger.debug(\"Class spell, class found?\", klass);\n\n    if (hasSpellCastingAbility(spell.spellCastingAbilityId)) {\n      spellCastingAbility = convertSpellCastingAbilityId(spell.spellCastingAbilityId);\n    } else if (klass) {\n      spellCastingAbility = getSpellCastingAbility(klass);\n      // force these spells to always be prepared\n      spell.alwaysPrepared = true;\n    } else {\n      // if there is no ability on spell, we default to wis\n      spellCastingAbility = \"wis\";\n    }\n\n    const abilityModifier = utils.calculateModifier(characterAbilities[spellCastingAbility].value);\n\n    // add some data for the parsing of the spells into the data structure\n    spell.flags = {\n      ddbimporter: {\n        dndbeyond: {\n          class: (klass) ? klass.definition.name : undefined,\n          lookup: \"classFeature\",\n          lookupName: classInfo.name,\n          lookupId: classInfo.id,\n          level: character.flags.ddbimporter.dndbeyond.totalLevels,\n          ability: spellCastingAbility,\n          mod: abilityModifier,\n          dc: 8 + proficiencyModifier + abilityModifier,\n          overrideDC: false,\n          id: spell.id,\n          entityTypeId: spell.entityTypeId,\n          healingBoost: healingBoost,\n          usesSpellSlot: spell.usesSpellSlot,\n        },\n      },\n    };\n\n    // Check for duplicate spells, normally domain ones\n    // We will import spells from a different class that are the same though\n    // as they may come from with different spell casting mods\n    const duplicateSpell = items.findIndex(\n      (existingSpell) =>\n        existingSpell.name === spell.definition.name &&\n        klass &&\n        klass.definition.name === existingSpell.flags.ddbimporter.dndbeyond.class &&\n        spell.usesSpellSlot && existingSpell.flags.ddbimporter.dndbeyond.usesSpellSlot\n    );\n    if (!items[duplicateSpell]) {\n      items.push(parseSpell(spell, character));\n    } else if (spell.alwaysPrepared) {\n      // if our new spell is always known we overwrite!\n      // it's probably domain\n      items[duplicateSpell] = parseSpell(spell, character);\n    } else {\n      // we'll emit a console message if it doesn't match this case for future debugging\n      logger.info(`Duplicate Spell ${spell.definition.name} detected in class ${classInfo.name}.`);\n    }\n  });\n\n  // Race spells are handled slightly differently\n  ddb.character.spells.race.forEach((spell) => {\n    if (!spell.definition) return;\n    // for race spells the spell spellCastingAbilityId is on the spell\n    // if there is no ability on spell, we default to wis\n    let spellCastingAbility = \"wis\";\n    if (hasSpellCastingAbility(spell.spellCastingAbilityId)) {\n      spellCastingAbility = convertSpellCastingAbilityId(spell.spellCastingAbilityId);\n    }\n\n    const abilityModifier = utils.calculateModifier(characterAbilities[spellCastingAbility].value);\n\n    let raceInfo = lookups.race.find((rc) => rc.id === spell.componentId);\n\n    if (!raceInfo) {\n      // for some reason we haven't matched the race option id with the spell\n      // this happens with at least the SCAG optional spells casting half elf\n      raceInfo = {\n        name: \"Racial spell\",\n        id: spell.componentId,\n      };\n    }\n\n    // add some data for the parsing of the spells into the data structure\n    spell.flags = {\n      ddbimporter: {\n        dndbeyond: {\n          lookup: \"race\",\n          lookupName: raceInfo.name,\n          lookupId: raceInfo.id,\n          race: ddb.character.race.fullName,\n          level: spell.castAtLevel,\n          ability: spellCastingAbility,\n          mod: abilityModifier,\n          dc: 8 + proficiencyModifier + abilityModifier,\n          overrideDC: false,\n          id: spell.id,\n          entityTypeId: spell.entityTypeId,\n          healingBoost: healingBoost,\n          usesSpellSlot: spell.usesSpellSlot,\n        },\n      },\n    };\n\n    if (spell.alwaysPrepared && spell.limitedUse) {\n      // also parse spell as non-limited use\n      let unlimitedSpell = duplicate(spell);\n      unlimitedSpell.limitedUse = null;\n      unlimitedSpell.flags.ddbimporter.dndbeyond.usesSpellSlot = false;\n      unlimitedSpell.flags.ddbimporter.dndbeyond.granted = true;\n      unlimitedSpell.flags.ddbimporter.dndbeyond.lookup = \"classFeature\";\n      delete unlimitedSpell.id;\n      delete unlimitedSpell.flags.ddbimporter.dndbeyond.id;\n      items.push(parseSpell(unlimitedSpell, character));\n    }\n\n    items.push(parseSpell(spell, character));\n  });\n\n  // feat spells are handled slightly differently\n  ddb.character.spells.feat.forEach((spell) => {\n    if (!spell.definition) return;\n    // If the spell has an ability attached, use that\n    // if there is no ability on spell, we default to wis\n    let spellCastingAbility = \"wis\";\n    if (hasSpellCastingAbility(spell.spellCastingAbilityId)) {\n      spellCastingAbility = convertSpellCastingAbilityId(spell.spellCastingAbilityId);\n    }\n\n    const abilityModifier = utils.calculateModifier(characterAbilities[spellCastingAbility].value);\n\n    let featInfo = lookups.feat.find((ft) => ft.id === spell.componentId);\n\n    if (!featInfo) {\n      // for some reason we haven't matched the feat option id with the spell\n      // we fiddle the result\n      featInfo = {\n        name: \"Feat option spell\",\n        id: spell.componentId,\n      };\n    }\n\n    // add some data for the parsing of the spells into the data structure\n    spell.flags = {\n      ddbimporter: {\n        dndbeyond: {\n          lookup: \"feat\",\n          lookupName: featInfo.name,\n          lookupId: featInfo.id,\n          level: spell.castAtLevel,\n          ability: spellCastingAbility,\n          mod: abilityModifier,\n          dc: 8 + proficiencyModifier + abilityModifier,\n          overrideDC: false,\n          id: spell.id,\n          entityTypeId: spell.entityTypeId,\n          healingBoost: healingBoost,\n          usesSpellSlot: spell.usesSpellSlot,\n        },\n      },\n    };\n\n    if (spell.alwaysPrepared && spell.limitedUse) {\n      // also parse spell as non-limited use\n      let unlimitedSpell = duplicate(spell);\n      unlimitedSpell.limitedUse = null;\n      unlimitedSpell.flags.ddbimporter.dndbeyond.usesSpellSlot = false;\n      unlimitedSpell.flags.ddbimporter.dndbeyond.lookup = \"classFeature\";\n      unlimitedSpell.flags.ddbimporter.dndbeyond.granted = true;\n      delete unlimitedSpell.id;\n      delete unlimitedSpell.flags.ddbimporter.dndbeyond.id;\n      items.push(parseSpell(unlimitedSpell, character));\n    }\n\n    items.push(parseSpell(spell, character));\n  });\n\n  // background spells are handled slightly differently\n  if (!ddb.character.spells.background) ddb.character.spells.background = [];\n  ddb.character.spells.background.forEach((spell) => {\n    if (!spell.definition) return;\n    // If the spell has an ability attached, use that\n    // if there is no ability on spell, we default to wis\n    let spellCastingAbility = \"wis\";\n    if (hasSpellCastingAbility(spell.spellCastingAbilityId)) {\n      spellCastingAbility = convertSpellCastingAbilityId(spell.spellCastingAbilityId);\n    }\n\n    const abilityModifier = utils.calculateModifier(characterAbilities[spellCastingAbility].value);\n\n    // add some data for the parsing of the spells into the data structure\n    spell.flags = {\n      ddbimporter: {\n        dndbeyond: {\n          lookup: \"background\",\n          lookupName: \"Background\",\n          level: spell.castAtLevel,\n          ability: spellCastingAbility,\n          mod: abilityModifier,\n          dc: 8 + proficiencyModifier + abilityModifier,\n          overrideDC: false,\n          id: spell.id,\n          entityTypeId: spell.entityTypeId,\n          healingBoost: healingBoost,\n          usesSpellSlot: spell.usesSpellSlot,\n        },\n      },\n    };\n\n    if (spell.alwaysPrepared && spell.limitedUse) {\n      // also parse spell as non-limited use\n      let unlimitedSpell = duplicate(spell);\n      unlimitedSpell.limitedUse = null;\n      unlimitedSpell.flags.ddbimporter.dndbeyond.usesSpellSlot = false;\n      unlimitedSpell.flags.ddbimporter.dndbeyond.lookup = \"classFeature\";\n      unlimitedSpell.flags.ddbimporter.dndbeyond.granted = true;\n      delete unlimitedSpell.id;\n      delete unlimitedSpell.flags.ddbimporter.dndbeyond.id;\n      items.push(parseSpell(unlimitedSpell, character));\n    }\n\n    items.push(parseSpell(spell, character));\n  });\n\n  if (items) fixSpells(ddb, items);\n\n  return items;\n}\n\n","import utils from \"../../utils.js\";\n\n// Import parsing functions\nimport { getLookups } from \"./metadata.js\";\nimport { fixSpells } from \"./special.js\";\nimport { parseSpell } from \"./parseSpell.js\";\nimport { hasSpellCastingAbility, convertSpellCastingAbilityId } from \"./ability.js\";\n\n\nexport function getItemSpells(ddb, character) {\n  let items = [];\n  const proficiencyModifier = character.data.attributes.prof;\n  const lookups = getLookups(ddb.character);\n\n  // feat spells are handled slightly differently\n  ddb.character.spells.item.forEach((spell) => {\n    if (!spell.definition) return;\n\n    const itemInfo = lookups.item.find((it) => it.id === spell.componentId);\n    if (!itemInfo) return;\n\n    const active =\n      (!itemInfo.canEquip && !itemInfo.canAttune) || // if item just gives a thing\n      itemInfo.isAttuned || // if it is attuned (assume equipped)\n      (!itemInfo.canAttune && itemInfo.equipped); // can't attune but is equipped\n    // for item spells the spell dc is often on the item spell\n    let spellDC = 8;\n    if (spell.overrideSaveDc) {\n      spellDC = spell.overrideSaveDc;\n    } else if (spell.spellCastingAbilityId) {\n      // If the spell has an ability attached, use that\n      // if there is no ability on spell, we default to wis\n      let spellCastingAbility = \"wis\";\n      if (hasSpellCastingAbility(spell.spellCastingAbilityId)) {\n        spellCastingAbility = convertSpellCastingAbilityId(spell.spellCastingAbilityId);\n      }\n\n      const abilityModifier = utils.calculateModifier(character.flags.ddbimporter.dndbeyond.effectAbilities[spellCastingAbility].value);\n      spellDC = 8 + proficiencyModifier + abilityModifier;\n    } else {\n      spellDC = null;\n    }\n\n    // add some data for the parsing of the spells into the data structure\n    spell.flags = {\n      ddbimporter: {\n        dndbeyond: {\n          lookup: \"item\",\n          lookupName: itemInfo.name,\n          lookupId: itemInfo.id,\n          level: spell.castAtLevel,\n          dc: spellDC,\n          limitedUse: itemInfo.limitedUse,\n          nameOverride: `${spell.definition.name} (${itemInfo.name})`,\n          overrideDC: !!spell.overrideSaveDc,\n          spellLimitedUse: spell.limitedUse,\n          castAtLevel: spell.castAtLevel,\n          active: active,\n        },\n      },\n    };\n\n    items.push(parseSpell(spell, character));\n  });\n\n  if (items) fixSpells(ddb, items);\n\n  return items;\n}\n","// import DICTIONARY from '../dictionary.js';\nimport utils from \"../../utils.js\";\n\nfunction getDivineSmite() {\n  const restriction = \"Against undead or fiends\";\n  const flags = utils.isModuleInstalledAndActive(\"betterrolls5e\")\n    ? {\n      betterRolls5e: {\n        quickDamage: {\n          context: {\n            0: \"\",\n            1: restriction,\n          },\n          value: {\n            0: true,\n            1: true,\n          },\n          altValue: {\n            0: true,\n            1: true,\n          },\n        },\n      },\n    }\n    : {};\n\n  const damageTagInfo = utils.getDamageTag({ subType: \"radiant\", restriction: \"\" });\n  const regularDamage = utils.parseDiceString(\"2d8\", \"\", damageTagInfo.damageTag).diceString;\n  const extraDamageTagInfo = utils.getDamageTag({ subType: \"radiant\", restriction });\n  const extraDamage = utils.parseDiceString(\"1d8\", \"\", extraDamageTagInfo.damageTag).diceString;\n\n  let result = {\n    flags,\n    name: \"Divine Smite\",\n    type: \"spell\",\n    img: \"systems/dnd5e/icons/skills/light_05.jpg\",\n    data: {\n      description: {\n        value: \"<p>Starting at 2nd level, when you hit a creature with a melee weapon attack, you can expend one spell slot to deal radiant damage to the target, in addition to the weapon&rsquo;s damage.</p>\\n<p>The extra damage is 2d8 for a 1st-level spell slot, plus 1d8 for each spell level higher than 1st, to a maximum of 5d8. The damage increases by 1d8 if the target is an undead or a fiend.</p>\",\n        chat: \"\",\n        unidentified: \"\"\n      },\n      source: \"PHB PG. 85\",\n      activation: {\n        type: \"special\",\n        cost: null,\n        condition: \"\",\n      },\n      duration: {\n        value: null,\n        units: \"\",\n      },\n      target: {\n        value: 1,\n        units: \"\",\n        type: \"enemy\",\n      },\n      range: {\n        value: null,\n        long: null,\n        units: \"\",\n      },\n      uses: {\n        value: 0,\n        max: 0,\n        per: \"\",\n      },\n      consume: {\n        type: \"\",\n        target: \"\",\n        amount: null,\n      },\n      ability: \"\",\n      actionType: \"other\",\n      attackBonus: 0,\n      chatFlavor: \"\",\n      critical: null,\n      damage: {\n        parts: [\n          [`${regularDamage}`, \"radiant\"],\n        ],\n        versatile: \"\",\n      },\n      formula: \"\",\n      save: {\n        ability: \"\",\n        dc: null,\n        scaling: \"spell\",\n      },\n      level: 1,\n      school: \"\",\n      components: {\n        value: \"\",\n        vocal: false,\n        somatic: false,\n        material: false,\n        ritual: false,\n        concentration: false,\n      },\n      materials: {\n        value: \"\",\n        consumed: false,\n        cost: 0,\n        supply: 0,\n      },\n      preparation: {\n        mode: \"always\",\n        prepared: true,\n      },\n      scaling: {\n        mode: \"level\",\n        formula: \"1d8\",\n      },\n    },\n  };\n\n  if (utils.isModuleInstalledAndActive(\"betterrolls5e\")) {\n    result.data.damage.parts.push([`${extraDamage}`, \"radiant\"]);\n  } else {\n    result.data.formula = `${regularDamage} + ${extraDamage}`;\n    result.data.chatFlavor = `Use Other damage ${restriction.toLowerCase()}`;\n  }\n\n  return result;\n}\n\n/**\n * {\n *  character: character,\n *  features: features,\n *  classes: classes,\n *  inventory: inventory,\n *  spells: spells,\n *  actions: actions,\n *  itemSpells: itemSpells,\n * };\n *\n * @param {*} ddb\n * @param {*} characterJSON\n */\nexport default function special(characterJSON) {\n  const divineSmite = characterJSON.features\n    .concat(characterJSON.actions)\n    .some((f) => f.name === \"Divine Smite\" && f.type === \"feat\");\n  if (divineSmite) {\n    characterJSON.spells.push(getDivineSmite());\n  }\n}\n","import getCharacter from \"./character/index.js\";\nimport getActions from \"./features/actions.js\";\nimport getFeatures from \"./features/features.js\";\nimport { removeActionFeatures } from \"./features/special.js\";\nimport getClasses from \"./classes/index.js\";\nimport { getCharacterSpells } from \"./spells/getCharacterSpells.js\";\nimport { getItemSpells } from \"./spells/getItemSpells.js\";\nimport { getDDBRace } from \"../muncher/races/races.js\";\nimport getInventory from \"./inventory/index.js\";\nimport getSpecial from \"./special/index.js\";\nimport logger from \"../logger.js\";\nimport { getResourcesDialog } from \"./character/resources.js\";\n\nexport async function parseJson(currentActorId, ddb, resourceSelection = true) {\n  try {\n    logger.debug(\"Starting core character parse\");\n    let character = getCharacter(ddb);\n    if (resourceSelection) {\n      logger.debug(\"Character resources\");\n      character = await getResourcesDialog(currentActorId, ddb, character);\n    }\n    logger.debug(\"Character parse complete\");\n    let race = await getDDBRace(ddb);\n    logger.debug(\"Race parse complete\");\n    let features = [race, ...await getFeatures(ddb, character)];\n    logger.debug(\"Feature parse complete\");\n    let classes = getClasses(ddb);\n    logger.debug(\"Classes parse complete\");\n    let spells = getCharacterSpells(ddb, character);\n    logger.debug(\"Character Spells parse complete\");\n    let actions = await getActions(ddb, character);\n    logger.debug(\"Action parse complete\");\n    let itemSpells = getItemSpells(ddb, character);\n    logger.debug(\"Item Spells parse complete\");\n    let inventory = getInventory(ddb, character, itemSpells);\n    logger.debug(\"Inventory parse complete\");\n\n    [actions, features] = removeActionFeatures(actions, features);\n\n    let characterJSON = {\n      character,\n      features,\n      classes,\n      inventory,\n      spells,\n      actions,\n      itemSpells,\n    };\n\n    getSpecial(characterJSON);\n\n    return characterJSON;\n  } catch (error) {\n    logger.error(error);\n    logger.error(\"Error during parse:\", error.message);\n    throw (error);\n  }\n}\n","export async function disableDynamicUpdates(actor) {\n  actor.data.flags.ddbimporter.activeUpdate = false;\n  const activeUpdateData = { flags: { ddbimporter: { activeUpdate: false } } };\n  await actor.update(activeUpdateData);\n}\n\nexport async function enableDynamicUpdates(actor) {\n  actor.data.flags.ddbimporter.activeUpdate = true;\n  const activeUpdateData = { flags: { ddbimporter: { activeUpdate: true } } };\n  await actor.update(activeUpdateData);\n}\n\nexport async function updateDynamicUpdates(actor, state) {\n  actor.data.flags.ddbimporter.activeUpdate = state;\n  const activeUpdateData = { flags: { ddbimporter: { activeUpdate: state } } };\n  await actor.update(activeUpdateData);\n}\n\nexport function getCurrentDynamicUpdateState(actor) {\n  const activeUpdateState = actor.data.flags?.ddbimporter?.activeUpdate\n    ? actor.data.flags.ddbimporter.activeUpdate\n    : false;\n  return activeUpdateState;\n}\n\nexport async function setActiveSyncSpellsFlag(actor, state) {\n  actor.data.flags.ddbimporter.activeSyncSpells = state;\n  const activeUpdateData = { flags: { ddbimporter: { activeSyncSpells: state } } };\n  await actor.update(activeUpdateData);\n}\n","import utils from \"../utils.js\";\nimport logger from \"../logger.js\";\n\nconst CONDITION_MATRIX = [\n  { label: \"Blinded\", statusId: \"Convenient Effect: Blinded\", ddbId: 1, levelId: null, ddbType: 1 },\n  { label: \"Charmed\", statusId: \"Convenient Effect: Charmed\", ddbId: 2, levelId: null, ddbType: 1 },\n  { label: \"Deafened\", statusId: \"Convenient Effect: Deafened\", ddbId: 3, levelId: null, ddbType: 1 },\n  { label: \"Exhaustion 1\", statusId: \"Convenient Effect: Exhaustion 1\", ddbId: 4, levelId: 1, ddbType: 2 },\n  { label: \"Exhaustion 2\", statusId: \"Convenient Effect: Exhaustion 2\", ddbId: 4, levelId: 2, ddbType: 2 },\n  { label: \"Exhaustion 3\", statusId: \"Convenient Effect: Exhaustion 3\", ddbId: 4, levelId: 3, ddbType: 2 },\n  { label: \"Exhaustion 4\", statusId: \"Convenient Effect: Exhaustion 4\", ddbId: 4, levelId: 4, ddbType: 2 },\n  { label: \"Exhaustion 5\", statusId: \"Convenient Effect: Exhaustion 5\", ddbId: 4, levelId: 5, ddbType: 2 },\n  { label: \"Exhaustion 6\", statusId: \"Convenient Effect: Exhaustion 6\", ddbId: 4, levelId: 6, ddbType: 2 },\n  { label: \"Frightened\", statusId: \"Convenient Effect: Frightened\", ddbId: 5, levelId: null, ddbType: 1 },\n  { label: \"Grappled\", statusId: \"Convenient Effect: Grappled\", ddbId: 6, levelId: null, ddbType: 1 },\n  { label: \"Incapacitated\", statusId: \"Convenient Effect: Incapacitated\", ddbId: 7, levelId: null, ddbType: 1 },\n  { label: \"Invisible\", statusId: \"Convenient Effect: Invisible\", ddbId: 8, levelId: null, ddbType: 1 },\n  { label: \"Paralyzed\", statusId: \"Convenient Effect: Paralyzed\", ddbId: 9, levelId: null, ddbType: 1 },\n  { label: \"Petrified\", statusId: \"Convenient Effect: Petrified\", ddbId: 10, levelId: null, ddbType: 1 },\n  { label: \"Poisoned\", statusId: \"Convenient Effect: Poisoned\", ddbId: 11, levelId: null, ddbType: 1 },\n  { label: \"Prone\", statusId: \"Convenient Effect: Prone\", ddbId: 12, levelId: null, ddbType: 1 },\n  { label: \"Restrained\", statusId: \"Convenient Effect: Restrained\", ddbId: 13, levelId: null, ddbType: 1 },\n  { label: \"Stunned\", statusId: \"Convenient Effect: Stunned\", ddbId: 14, levelId: null, ddbType: 1 },\n  { label: \"Unconscious\", statusId: \"Convenient Effect: Unconscious\", ddbId: 15, levelId: null, ddbType: 1 },\n];\n\nexport function getCondition(conditionName) {\n  return CONDITION_MATRIX.find((condition) => condition.label === conditionName);\n}\n\nexport async function getActiveConditions(actor) {\n  const conditions = await Promise.all(CONDITION_MATRIX.filter(async (condition) => {\n    const conditionApplied = await game.dfreds.effectInterface.hasEffectApplied(condition.label, actor.uuid);\n    return conditionApplied;\n  }));\n  return conditions;\n}\n\nasync function effectAppliedAndActive(condition, actor) {\n  return actor.data.effects.some(\n    (activeEffect) =>\n      activeEffect?.data?.flags?.isConvenient &&\n      activeEffect?.data?.label == condition.label &&\n      !activeEffect?.data?.disabled\n  );\n}\n\nexport async function getActorConditionStates(actor, ddb) {\n  const conditions = await Promise.all(CONDITION_MATRIX.map(async (condition) => {\n    const conditionApplied = await effectAppliedAndActive(condition, actor);\n    const ddbCondition = ddb.character.conditions.some((conditionState) =>\n      conditionState.id === condition.ddbId &&\n      conditionState.level === condition.levelId\n    );\n    // eslint-disable-next-line require-atomic-updates\n    condition.ddbCondition = ddbCondition;\n    // eslint-disable-next-line require-atomic-updates\n    condition.applied = conditionApplied;\n    // eslint-disable-next-line require-atomic-updates\n    condition.needsUpdate = (ddbCondition && !conditionApplied) || (!ddbCondition && conditionApplied);\n    return condition;\n  }));\n  return conditions;\n}\n\n/**\n * Set conditions\n * @param {*} ddb\n * @param {*} actor\n */\nexport async function setConditions(actor, ddb) {\n  const dfConditionsOn = utils.isModuleInstalledAndActive(\"dfreds-convenient-effects\");\n  if (dfConditionsOn) {\n    const conditionStates = await getActorConditionStates(actor, ddb);\n    // console.warn(conditionStates);\n    await Promise.all(conditionStates.map(async (condition) => {\n      // console.warn(condition);\n      if (condition.needsUpdate) {\n        const state = condition.conditionApplied ? \"off\" : \"on\";\n        logger.info(`Toggling condition to ${state} for ${condition.label} to ${actor.name} (${actor.uuid})`);\n        await game.dfreds.effectInterface.toggleEffect(condition.label, { uuids: [actor.uuid] });\n      } else {\n        const state = condition.conditionApplied ? \"on\" : \"off\";\n        logger.info(`Condition ${condition.label} ignored (currently ${state}) for ${actor.name} (${actor.uuid})`);\n      }\n      return condition;\n    }));\n  }\n}\n","import logger from \"../logger.js\";\nimport utils from \"../utils.js\";\nimport { getCharacterData } from \"./import.js\";\nimport { isEqual } from \"../../vendor/lowdash/isequal.js\";\nimport { getCampaignId, getCompendiumType } from \"../muncher/utils.js\";\nimport { looseItemNameMatch } from \"../muncher/import.js\";\nimport DICTIONARY from \"../dictionary.js\";\nimport { getCobalt, checkCobalt } from \"../lib/Secrets.js\";\nimport { getCurrentDynamicUpdateState, updateDynamicUpdates, disableDynamicUpdates, setActiveSyncSpellsFlag } from \"./utils.js\";\nimport { getActorConditionStates, getCondition } from \"./conditions.js\";\n\nvar itemIndex;\n\nfunction activeUpdate() {\n  const dynamicSync = game.settings.get(\"ddb-importer\", \"dynamic-sync\");\n  const updateUser = game.settings.get(\"ddb-importer\", \"dynamic-sync-user\");\n  const gmSyncUser = game.user.isGM && game.user.id == updateUser;\n  // console.warn(`Dynamic sync: ${dynamicSync}`);\n  // console.warn(`Dynamic sync user: ${updateUser}`);\n  // console.warn(`gmSyncUser: ${gmSyncUser}`);\n  return dynamicSync && gmSyncUser;\n}\n\nexport async function getUpdateItemIndex() {\n  if (itemIndex) return itemIndex;\n  const compendium = await getCompendiumType(\"item\", false);\n\n  const indexFields = [\n    \"name\",\n    \"type\",\n    \"flags.ddbimporter.definitionId\",\n    \"flags.ddbimporter.definitionEntityTypeId\",\n  ];\n  // eslint-disable-next-line require-atomic-updates\n  itemIndex = await compendium.getIndex({ fields: indexFields });\n\n  return itemIndex;\n}\n\nasync function getCompendiumItemInfo(item) {\n  const index = await getUpdateItemIndex();\n  const match = await looseItemNameMatch(item, index, true, false, true);\n  return match;\n}\n\nasync function updateCharacterCall(actor, path, bodyContent) {\n  const characterId = actor.data.flags.ddbimporter.dndbeyond.characterId;\n  const cobaltCookie = getCobalt(actor.id);\n  const dynamicSync = activeUpdate();\n  const parsingApi = dynamicSync\n    ? game.settings.get(\"ddb-importer\", \"dynamic-api-endpoint\")\n    : game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const campaignId = getCampaignId();\n  const proxyCampaignId = campaignId === \"\" ? null : campaignId;\n  const coreBody = {\n    cobalt: cobaltCookie,\n    betaKey,\n    characterId,\n    campaignId: proxyCampaignId,\n    dynamicSync,\n  };\n  const body = { ...coreBody, ...bodyContent };\n\n  const url = dynamicSync\n    ? `${parsingApi}/dynamic/update/${path}`\n    : `${parsingApi}/proxy/update/${path}`;\n\n  logger.debug(\"Update body:\", bodyContent);\n\n  return new Promise((resolve, reject) => {\n    fetch(url, {\n      method: \"POST\",\n      cache: \"no-cache\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body), // body data type must match \"Content-Type\" header\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (!data.success) {\n          logger.warn(\"Update failed:\", data.message);\n          resolve(data);\n        }\n        logger.debug(`${path} updated`);\n        return data;\n      })\n      .then((data) => resolve(data))\n      .catch((error) => {\n        logger.error(`Setting ${path} failed`);\n        logger.error(error);\n        logger.error(error.stack);\n        reject(error);\n      });\n  });\n}\n\nasync function updateDDBSpellSlotsPact(actor) {\n  return new Promise((resolve) => {\n    let spellSlotPackData = {\n      spellslots: {},\n      pact: true,\n    };\n    spellSlotPackData.spellslots[`level${actor.data.data.spells.pact.level}`] = actor.data.data.spells.pact.value;\n    const spellPactSlots = updateCharacterCall(actor, \"spell/slots\", spellSlotPackData);\n    resolve(spellPactSlots);\n  });\n}\n\nasync function spellSlotsPact(actor, ddbData) {\n  return new Promise((resolve) => {\n    if (!game.settings.get(\"ddb-importer\", \"sync-policy-spells-slots\")) resolve();\n    if (\n      actor.data.data.spells.pact.max > 0 &&\n      ddbData.character.character.data.spells.pact.value !== actor.data.data.spells.pact.value\n    ) {\n      resolve(updateDDBSpellSlotsPact(actor));\n    } else {\n      resolve();\n    }\n  });\n}\n\nasync function updateDynamicDDBSpellSlots(actor, update) {\n  return new Promise((resolve) => {\n    let spellSlotData = { spellslots: {}, update: false };\n    for (let i = 1; i <= 9; i++) {\n      let spellData = actor.data.data.spells[`spell${i}`];\n      if (spellData.max > 0 && update.data.spells[`spell${i}`]) {\n        const used = spellData.max - spellData.value;\n        spellSlotData.spellslots[`level${i}`] = used;\n        spellSlotData[\"update\"] = true;\n      }\n    }\n    if (spellSlotData[\"update\"]) {\n      resolve(updateCharacterCall(actor, \"spells/slots\", spellSlotData));\n    } else {\n      resolve();\n    }\n  });\n}\n\nasync function spellSlots(actor, ddbData) {\n  return new Promise((resolve) => {\n    if (!game.settings.get(\"ddb-importer\", \"sync-policy-spells-slots\")) resolve();\n\n    let spellSlotData = { spellslots: {}, update: false };\n    for (let i = 1; i <= 9; i++) {\n      let spellData = actor.data.data.spells[`spell${i}`];\n      if (spellData.max > 0 && ddbData.character.character.data.spells[`spell${i}`].value !== spellData.value) {\n        const used = spellData.max - spellData.value;\n        spellSlotData.spellslots[`level${i}`] = used;\n        spellSlotData[\"update\"] = true;\n      }\n    }\n    if (spellSlotData[\"update\"]) {\n      resolve(updateCharacterCall(actor, \"spells/slots\", spellSlotData));\n    } else {\n      resolve();\n    }\n  });\n}\n\nasync function updateDDBCurrency(actor) {\n  return new Promise((resolve) => {\n    const value = {\n      pp: Number.isInteger(actor.data.data.currency.pp) ? actor.data.data.currency.pp : 0,\n      gp: Number.isInteger(actor.data.data.currency.gp) ? actor.data.data.currency.gp : 0,\n      ep: Number.isInteger(actor.data.data.currency.ep) ? actor.data.data.currency.ep : 0,\n      sp: Number.isInteger(actor.data.data.currency.sp) ? actor.data.data.currency.sp : 0,\n      cp: Number.isInteger(actor.data.data.currency.cp) ? actor.data.data.currency.cp : 0,\n    };\n\n    resolve(updateCharacterCall(actor, \"currency\", value));\n\n  });\n}\n\nasync function currency(actor, ddbData) {\n  return new Promise((resolve) => {\n    if (!game.settings.get(\"ddb-importer\", \"sync-policy-currency\")) resolve();\n\n    const value = {\n      pp: Number.isInteger(actor.data.data.currency.pp) ? actor.data.data.currency.pp : 0,\n      gp: Number.isInteger(actor.data.data.currency.gp) ? actor.data.data.currency.gp : 0,\n      ep: Number.isInteger(actor.data.data.currency.ep) ? actor.data.data.currency.ep : 0,\n      sp: Number.isInteger(actor.data.data.currency.sp) ? actor.data.data.currency.sp : 0,\n      cp: Number.isInteger(actor.data.data.currency.cp) ? actor.data.data.currency.cp : 0,\n    };\n\n    const same = isEqual(ddbData.character.character.data.currency, value);\n\n    if (!same) {\n      resolve(updateCharacterCall(actor, \"currency\", value));\n    } else {\n      resolve();\n    }\n\n  });\n}\n\nasync function updateDDBXP(actor) {\n  return new Promise((resolve) => {\n    resolve(updateCharacterCall(actor, \"xp\", { currentXp: actor.data.data.details.xp.value }));\n  });\n}\n\nasync function xp(actor, ddbData) {\n  return new Promise((resolve) => {\n    if (!game.settings.get(\"ddb-importer\", \"sync-policy-xp\")) resolve();\n    const same = ddbData.character.character.data.details.xp.value === actor.data.data.details.xp.value;\n\n    if (!same) {\n      resolve(updateDDBXP(actor));\n    } else {\n      resolve();\n    }\n  });\n}\n\nasync function updateDDBHitPoints(actor) {\n  return new Promise((resolve) => {\n    const temporaryHitPoints = actor.data.data.attributes.hp.temp ? actor.data.data.attributes.hp.temp : 0;\n    const removedHitPoints = actor.data.data.attributes.hp.max - actor.data.data.attributes.hp.value;\n    const hitPointData = {\n      removedHitPoints,\n      temporaryHitPoints,\n    };\n    resolve(updateCharacterCall(actor, \"hitpoints\", hitPointData));\n  });\n}\n\nasync function hitPoints(actor, ddbData) {\n  return new Promise((resolve) => {\n    if (!game.settings.get(\"ddb-importer\", \"sync-policy-hitpoints\")) resolve();\n    const temporaryHitPoints = actor.data.data.attributes.hp.temp ? actor.data.data.attributes.hp.temp : 0;\n    const same =\n      ddbData.character.character.data.attributes.hp.value === actor.data.data.attributes.hp.value &&\n      ddbData.character.character.data.attributes.hp.temp === temporaryHitPoints;\n\n    if (!same) {\n      resolve(updateDDBHitPoints(actor));\n    } else {\n      resolve();\n    }\n  });\n}\n\nasync function updateDDBInspiration(actor) {\n  return new Promise((resolve) => {\n    const inspiration = updateCharacterCall(actor, \"inspiration\", {\n      inspiration: actor.data.data.attributes.inspiration,\n    });\n    resolve(inspiration);\n  });\n}\n\nasync function inspiration(actor, ddbData) {\n  return new Promise((resolve) => {\n    if (!game.settings.get(\"ddb-importer\", \"sync-policy-inspiration\")) resolve();\n    const same = ddbData.character.character.data.attributes.inspiration === actor.data.data.attributes.inspiration;\n\n    if (!same) {\n      resolve(updateDDBInspiration(actor));\n    } else {\n      resolve();\n    }\n  });\n}\n\nasync function updateDDBExhaustion(actor) {\n  return new Promise((resolve) => {\n    let exhaustionData = {\n      conditionId: 4,\n      addCondition: false,\n    };\n    if (actor.data.data.attributes.exhaustion !== 0) {\n      exhaustionData[\"level\"] = actor.data.data.attributes.exhaustion;\n      exhaustionData[\"totalHP\"] = actor.data.data.attributes.hp.max;\n      exhaustionData[\"addCondition\"] = true;\n    }\n    resolve(updateCharacterCall(actor, \"condition\", exhaustionData));\n  });\n}\n\n\nasync function exhaustion(actor, ddbData) {\n  return new Promise((resolve) => {\n    if (!game.settings.get(\"ddb-importer\", \"sync-policy-condition\")) resolve();\n    const same = ddbData.character.character.data.attributes.exhaustion === actor.data.data.attributes.exhaustion;\n\n    if (!same) {\n      resolve(updateDDBExhaustion(actor));\n    } else {\n      resolve();\n    }\n\n  });\n}\n\nasync function updateDDBCondition(actor, condition) {\n  return new Promise((resolve) => {\n    const conditionData = {\n      conditionId: condition.ddbId,\n      addCondition: condition.applied,\n      level: null,\n      totalHP: actor.data.data.attributes.hp.max,\n    };\n\n    resolve(updateCharacterCall(actor, \"condition\", conditionData));\n  });\n}\n\nasync function conditions(actor, ddbData) {\n  return new Promise((resolve) => {\n    const dfConditionsOn = utils.isModuleInstalledAndActive(\"dfreds-convenient-effects\");\n    if (!game.settings.get(\"ddb-importer\", \"sync-policy-condition\") || !dfConditionsOn) resolve([]);\n    getActorConditionStates(actor, ddbData.ddb).then((conditions) => {\n      let results = [];\n      conditions.forEach((condition) => {\n        if (condition.needsUpdate) {\n          results.push(updateDDBCondition(actor, condition));\n        }\n      });\n      resolve(results);\n    });\n  });\n}\n\nasync function updateDDBDeathSaves(actor) {\n  return new Promise((resolve) => {\n    const deathSaveData = {\n      failCount: actor.data.data.attributes.death.failure,\n      successCount: actor.data.data.attributes.death.success,\n    };\n    resolve(updateCharacterCall(actor, \"deathsaves\", deathSaveData));\n  });\n}\n\nasync function deathSaves(actor, ddbData) {\n  return new Promise((resolve) => {\n    if (!game.settings.get(\"ddb-importer\", \"sync-policy-deathsaves\")) resolve();\n    const same = isEqual(ddbData.character.character.data.attributes.death, actor.data.data.attributes.death);\n\n    if (!same) {\n      resolve(updateDDBDeathSaves(actor));\n    } else {\n      resolve();\n    }\n  });\n}\n\nasync function updateDDBHitDice(actor, klass, update) {\n  return new Promise((resolve) => {\n    if (klass.data.flags?.ddbimporter?.id) {\n      let hitDiceData = {\n        classHitDiceUsed: {},\n        resetMaxHpModifier: false,\n      };\n      hitDiceData.classHitDiceUsed[klass.data.flags.ddbimporter.id] = update.data.hitDiceUsed;\n      resolve(updateCharacterCall(actor, \"hitdice\", { shortRest: hitDiceData }));\n    } else {\n      resolve();\n    }\n  });\n}\n\nasync function hitDice(actor, ddbData) {\n  return new Promise((resolve) => {\n    if (!game.settings.get(\"ddb-importer\", \"sync-policy-hitdice\")) resolve();\n\n    const ddbClasses = ddbData.character.classes;\n\n    const klasses = actor.data.items.filter(\n      (item) => item.type === \"class\" && item.data.flags.ddbimporter.id && item.data.flags.ddbimporter.definitionId\n    );\n\n    let hitDiceData = {\n      classHitDiceUsed: {},\n      resetMaxHpModifier: false,\n    };\n\n    klasses.forEach((klass) => {\n      const classMatch = ddbClasses.find((ddbClass) => ddbClass.flags.ddbimporter.id === klass.data.flags.ddbimporter.id);\n      if (classMatch && classMatch.data.hitDiceUsed !== klass.data.data.hitDiceUsed) {\n        hitDiceData.classHitDiceUsed[klass.data.flags.ddbimporter.id] = klass.data.data.hitDiceUsed;\n      }\n    });\n\n    const same = isEqual({}, hitDiceData.classHitDiceUsed);\n    if (!same) {\n      resolve(updateCharacterCall(actor, \"hitdice\", { shortRest: hitDiceData }));\n    }\n\n    resolve();\n  });\n}\n\nasync function updateSpellsPrepared(actor, spellPreparedData) {\n  return new Promise((resolve) => {\n    resolve(updateCharacterCall(actor, \"spell/prepare\", spellPreparedData));\n  });\n}\n\nasync function updateDDBSpellsPrepared(actor, spells) {\n  let promises = [];\n\n  const preparedSpells = spells.filter((spell) =>\n    spell.type === \"spell\" &&\n    spell.data.data.preparation?.mode === \"prepared\" &&\n    spell.data.flags.ddbimporter?.dndbeyond?.characterClassId &&\n    !spell.data.flags.ddbimporter.dndbeyond.granted\n  ).map((spell) => {\n    let spellPreparedData = {\n      spellInfo: {\n        spellId: spell.data.flags.ddbimporter.definitionId,\n        characterClassId: spell.data.flags.ddbimporter.dndbeyond.characterClassId,\n        entityTypeId: spell.data.flags.ddbimporter.entityTypeId,\n        id: spell.data.flags.ddbimporter.id,\n        prepared: spell.data.data.preparation.prepared === true,\n      }\n    };\n    return spellPreparedData;\n  });\n\n  preparedSpells.forEach((spellPreparedData) => {\n    promises.push(updateSpellsPrepared(actor, spellPreparedData));\n  });\n\n  return Promise.all(promises);\n}\n\nasync function spellsPrepared(actor, ddbData) {\n  if (!game.settings.get(\"ddb-importer\", \"sync-policy-spells-prepared\")) return [];\n  const ddbSpells = ddbData.character.spells;\n\n  const preparedSpells = actor.data.items.filter((item) => {\n    const spellMatch = ddbSpells.find((s) =>\n      s.name === item.name &&\n      item.data.data.preparation?.mode === \"prepared\" &&\n      item.data.flags.ddbimporter?.dndbeyond?.characterClassId &&\n      item.data.flags.ddbimporter?.dndbeyond?.characterClassId === s.flags.ddbimporter?.dndbeyond?.characterClassId\n    );\n    if (!spellMatch) return false;\n    const select = item.type === \"spell\" &&\n      item.data.data.preparation?.mode === \"prepared\" &&\n      item.data.data.preparation.prepared !== spellMatch.data.preparation?.prepared;\n    return spellMatch && select;\n  });\n\n  const results = updateDDBSpellsPrepared(actor, preparedSpells);\n\n  return results;\n}\n\nasync function updateItemsWithDDBInfo(itemsToAdd) {\n  return Promise.all(itemsToAdd.map(async (item) => {\n    if (!item.flags.ddbimporter?.definitionId && !item.flags.ddbimporter?.definitionEntityTypeId) {\n      const ddbCompendiumMatch = await getCompendiumItemInfo(item);\n      logger.debug(`Found item`, ddbCompendiumMatch);\n      if (ddbCompendiumMatch &&\n        ddbCompendiumMatch.flags?.ddbimporter?.definitionId &&\n        ddbCompendiumMatch.flags?.ddbimporter?.definitionEntityTypeId\n      ) {\n        logger.debug(`Adding ${item.name} from DDB compendium match:`, ddbCompendiumMatch);\n        setProperty(item, \"flags.ddbimporter.definitionId\", ddbCompendiumMatch.flags.ddbimporter.definitionId);\n        setProperty(item, \"flags.ddbimporter.definitionEntityTypeId\", ddbCompendiumMatch.flags.ddbimporter.definitionEntityTypeId);\n        setProperty(item, \"name\", ddbCompendiumMatch.name);\n        setProperty(item, \"type\", ddbCompendiumMatch.type);\n      }\n    }\n    return item;\n  }));\n}\n\nfunction generateItemsToAdd(actor, itemsToAdd) {\n  const results = {\n    items: [],\n    toAdd: [],\n    custom: [],\n  };\n\n  for (let i = 0; i < itemsToAdd.length; i++) {\n    let item = itemsToAdd[i];\n    if (item.flags.ddbimporter?.definitionId && item.flags.ddbimporter?.definitionEntityTypeId) {\n      results.toAdd.push({\n        containerEntityId: parseInt(actor.data.flags.ddbimporter?.dndbeyond?.characterId),\n        containerEntityTypeId: parseInt(\"1581111423\"),\n        entityId: parseInt(item.flags.ddbimporter.definitionId),\n        entityTypeId: parseInt(item.flags.ddbimporter.definitionEntityTypeId),\n        quantity: parseInt(item.data.quantity),\n      });\n    } else {\n      results.custom.push(item);\n    }\n    results.items.push(item);\n  }\n  return results;\n}\n\nasync function deleteDDBCustomItems(actor, itemsToDelete) {\n  return new Promise((resolve) => {\n    let customItemResults = [];\n    for (let i = 0; i < itemsToDelete.length; i++) {\n      const item = itemsToDelete[i];\n      const customData = {\n        itemState: \"DELETE\",\n        customValues: {\n          characterId: parseInt(actor.data.flags.ddbimporter.dndbeyond.characterId),\n          id: item.flags.ddbimporter.id,\n        }\n      };\n      const result = updateCharacterCall(actor, \"custom/item\", customData).then((data) => {\n        setProperty(item, \"flags.ddbimporter.id\", data.data.id);\n        setProperty(item, \"flags.ddbimporter.custom\", true);\n        return item;\n      });\n      customItemResults.push(result);\n    }\n\n    resolve(customItemResults);\n  });\n}\n\nasync function addDDBCustomItems(actor, itemsToAdd) {\n  let customItemResults = [];\n  for (let i = 0; i < itemsToAdd.length; i++) {\n    const item = itemsToAdd[i];\n    const customData = {\n      itemState: \"NEW\",\n      customValues: {\n        characterId: parseInt(actor.data.flags.ddbimporter.dndbeyond.characterId),\n        name: item.name,\n        description: item.data.description.value,\n      }\n    };\n    const result = updateCharacterCall(actor, \"custom/item\", customData).then((data) => {\n      setProperty(item, \"flags.ddbimporter.id\", data.data.id);\n      setProperty(item, \"flags.ddbimporter.custom\", true);\n      return item;\n    });\n    customItemResults.push(result);\n  }\n\n  return Promise.all(customItemResults);\n}\n\nasync function addDDBEquipment(actor, itemsToAdd) {\n  const ddbEnrichedItems = await updateItemsWithDDBInfo(itemsToAdd);\n  const generatedItemsToAddData = generateItemsToAdd(actor, ddbEnrichedItems);\n\n  logger.debug(`Generated items data`, generatedItemsToAddData);\n\n  const addItemData = {\n    equipment: generatedItemsToAddData.toAdd,\n  };\n\n  const customItems = await addDDBCustomItems(actor, generatedItemsToAddData.custom);\n  logger.debug(\"Adding custom items:\", customItems);\n\n  try {\n    const customItemResults = await actor.updateEmbeddedDocuments(\"Item\", customItems);\n    logger.debug(\"customItemResults\", customItemResults);\n  } catch (err) {\n    logger.error(`Unable to update character with equipment, got the error:`, err);\n    logger.error(err.stack);\n    logger.error(`Update payload:`, customItems);\n  }\n\n  if (addItemData.equipment.length > 0) {\n    const itemResults = await updateCharacterCall(actor, \"equipment/add\", addItemData);\n    try {\n      const itemUpdates = itemResults.data.addItems\n        .filter((addedItem) => ddbEnrichedItems.some((i) =>\n          i.flags.ddbimporter &&\n          i.flags.ddbimporter.definitionId === addedItem.definition.id &&\n          i.flags.ddbimporter.definitionEntityTypeId === addedItem.definition.entityTypeId\n        ))\n        .map((addedItem) => {\n          let updatedItem = ddbEnrichedItems.find((i) =>\n            i.flags.ddbimporter &&\n            i.flags.ddbimporter.definitionId === addedItem.definition.id &&\n            i.flags.ddbimporter.definitionEntityTypeId === addedItem.definition.entityTypeId\n          );\n          setProperty(updatedItem, \"flags.ddbimporter.id\", addedItem.id);\n          return updatedItem;\n        });\n\n      logger.debug(\"Character item updates:\", itemUpdates);\n      logger.debug(\"Character custom item updates:\", customItems);\n\n      try {\n        if (itemUpdates.length > 0) await actor.updateEmbeddedDocuments(\"Item\", itemUpdates);\n        if (customItems.length > 0) await actor.updateEmbeddedDocuments(\"Item\", customItems);\n      } catch (err) {\n        logger.error(`Unable to update character with equipment, got the error:`, err);\n        logger.error(`Update payload:`, itemUpdates);\n        logger.error(`Update custom payload:`, customItems);\n      }\n\n    } catch (err) {\n      logger.error(`Unable to filter updated equipment, got the error:`, err);\n      logger.error(`itemsToAdd`, itemsToAdd);\n      logger.error(`ddbEnrichedItems`, ddbEnrichedItems);\n      logger.error(`equipmentToAdd`, generatedItemsToAddData);\n      logger.error(`itemResults`, itemResults);\n      logger.error(`customItems`, customItems);\n    }\n\n    return itemResults;\n  } else {\n    return [];\n  }\n}\n\nasync function addEquipment(actor, ddbData) {\n  const syncItemReady = actor.data.flags.ddbimporter?.syncItemReady;\n  if (syncItemReady && !game.settings.get(\"ddb-importer\", \"sync-policy-equipment\")) return [];\n  const ddbItems = ddbData.character.inventory;\n\n  const itemsToAdd = actor.data.items.filter((item) =>\n    !item.data.flags.ddbimporter?.action &&\n    item.data.data.quantity !== 0 &&\n    DICTIONARY.types.inventory.includes(item.type) &&\n    !item.data.flags.ddbimporter?.custom &&\n    (!item.data.flags.ddbimporter?.id ||\n    !ddbItems.some((s) => s.flags.ddbimporter?.id === item.data.flags.ddbimporter?.id && s.type === item.type))\n  ).map((item) => item.toObject());\n\n  return addDDBEquipment(actor, itemsToAdd);\n}\n\n\n// updates custom names on regular items\nasync function updateDDBCustomNames(actor, items) {\n  let promises = [];\n\n  items.forEach((item) => {\n    const customData = {\n      customValues: {\n        characterId: parseInt(actor.data.flags.ddbimporter.dndbeyond.characterId),\n        contextId: null,\n        contextTypeId: null,\n        notes: null,\n        typeId: 8,\n        value: item.name,\n        valueId: `${item.flags.ddbimporter.id}`,\n        valueTypeId: `${item.flags.ddbimporter.entityTypeId}`,\n      }\n    };\n    // custom name on standard equipment\n    promises.push(updateCharacterCall(actor, \"equipment/custom\", customData));\n  });\n\n  return Promise.all(promises);\n\n}\n\n// updates names of items and actions\nasync function updateCustomNames(actor, ddbData) {\n  const syncItemReady = actor.data.flags.ddbimporter?.syncItemReady;\n  if (syncItemReady && !game.settings.get(\"ddb-importer\", \"sync-policy-equipment\")) return [];\n  const ddbItems = ddbData.character.inventory;\n\n  const itemsToName = actor.data.items.filter((item) =>\n    item.data.data.quantity !== 0 &&\n    (DICTIONARY.types.inventory.includes(item.type) || item.data.flags.ddbimporter?.action) &&\n    item.data.flags.ddbimporter?.id &&\n    // item.data.flags.ddbimporter?.entityTypeId &&\n    ddbItems.some((s) =>\n      s.flags.ddbimporter?.id === item.data.flags.ddbimporter.id &&\n      s.type === item.type && s.name !== item.name\n    )\n  ).map((item) => item.toObject());\n\n  return updateDDBCustomNames(actor, itemsToName);\n}\n\nasync function removeDDBEquipment(actor, itemsToRemove) {\n  let promises = [];\n\n  itemsToRemove.forEach((item) => {\n    if (item.flags?.ddbimporter?.id) {\n      logger.debug(`Removing item ${item.name}`);\n      if (item.flags?.ddbimporter?.custom) {\n        promises.push(deleteDDBCustomItems(actor, [item]));\n      } else {\n        promises.push(updateCharacterCall(actor, \"equipment/remove\", { itemId: parseInt(item.flags.ddbimporter.id) }));\n      }\n    }\n  });\n\n  return Promise.all(promises);\n}\n\nasync function removeEquipment(actor, ddbData) {\n  const syncItemReady = actor.data.flags.ddbimporter?.syncItemReady;\n  if (syncItemReady && !game.settings.get(\"ddb-importer\", \"sync-policy-equipment\")) return [];\n  const ddbItems = ddbData.character.inventory;\n\n  const itemsToRemove = ddbItems.filter((item) =>\n    (!actor.data.items.some((s) => (item.flags.ddbimporter?.id === s.data.flags.ddbimporter?.id && s.type === item.type) && !s.data.flags.ddbimporter?.action) ||\n    actor.data.items.some((s) => (item.flags.ddbimporter?.id === s.data.flags.ddbimporter?.id && s.type === item.type) && !s.data.flags.ddbimporter?.action && s.data.data.quantity == 0)) &&\n    DICTIONARY.types.inventory.includes(item.type) &&\n    item.flags.ddbimporter?.id\n  );\n\n  return removeDDBEquipment(actor, itemsToRemove);\n}\n\nasync function updateDDBEquipmentStatus(actor, updateItemDetails, ddbItems) {\n  const itemsToEquip = updateItemDetails.itemsToEquip || [];\n  const itemsToAttune = updateItemDetails.itemsToAttune || [];\n  const itemsToCharge = updateItemDetails.itemsToCharge || [];\n  const itemsToQuantity = updateItemDetails.itemsToQuantity || [];\n  const itemsToName = updateItemDetails.itemsToName || [];\n  const customItems = updateItemDetails.customItems || [];\n\n  let promises = [];\n\n  itemsToEquip.forEach((item) => {\n    const itemData = { itemId: item.data.flags.ddbimporter.id, value: item.data.data.equipped };\n    promises.push(updateCharacterCall(actor, \"equipment/equipped\", itemData));\n  });\n  itemsToAttune.forEach((item) => {\n    const itemData = { itemId: item.data.flags.ddbimporter.id, value: (item.data.data.attunement === 2) };\n    promises.push(updateCharacterCall(actor, \"equipment/attuned\", itemData));\n  });\n  itemsToCharge.forEach((item) => {\n    const itemData = {\n      itemId: item.data.flags.ddbimporter.id,\n      charges: parseInt(item.data.data.uses.max) - parseInt(item.data.data.uses.value),\n    };\n    promises.push(updateCharacterCall(actor, \"equipment/charges\", itemData));\n  });\n  itemsToQuantity.forEach((item) => {\n    const itemData = {\n      itemId: item.data.flags.ddbimporter.id,\n      quantity: parseInt(item.data.data.quantity),\n    };\n    promises.push(updateCharacterCall(actor, \"equipment/quantity\", itemData));\n  });\n  itemsToName.forEach((item) => {\n    // historically items may not have this metadata\n    const entityTypeId = item.data?.flags?.ddbimporter?.entityTypeId\n      ? item.data.flags.ddbimporter.entityTypeId\n      : ddbItems.find((dItem) => dItem.id === item.data.flags.ddbimporter.id).entityTypeId;\n    const customData = {\n      customValues: {\n        characterId: parseInt(actor.data.flags.ddbimporter.dndbeyond.characterId),\n        contextId: null,\n        contextTypeId: null,\n        notes: null,\n        typeId: 8,\n        value: item.name,\n        valueId: `${item.data.flags.ddbimporter.id}`,\n        valueTypeId: `${entityTypeId}`,\n      }\n    };\n    promises.push(updateCharacterCall(actor, \"equipment/custom\", customData));\n  });\n\n  customItems.forEach((item) => {\n    const customData = {\n      itemState: \"UPDATE\",\n      customValues: {\n        characterId: parseInt(actor.data.flags.ddbimporter.dndbeyond.characterId),\n        id: item.data.flags.ddbimporter.id,\n        name: item.name,\n        description: item.data.data.description.value,\n        // revist these need to be ints\n        // weight: `${item.data.data.weight}`,\n        // cost: ${item.data.data.price},\n        quantity: parseInt(item.data.data.quantity),\n      }\n    };\n    promises.push(updateCharacterCall(actor, \"custom/item\", customData));\n  });\n\n  return Promise.all(promises);\n}\n\n\nasync function equipmentStatus(actor, ddbData, addEquipmentResults) {\n  const syncItemReady = actor.data.flags.ddbimporter?.syncItemReady;\n  if (syncItemReady && !game.settings.get(\"ddb-importer\", \"sync-policy-equipment\")) return [];\n  // reload the actor following potential updates to equipment\n  let ddbItems = ddbData.ddb.character.inventory;\n  let customDDBItems = ddbData.ddb.character.customItems;\n  if (addEquipmentResults?.data) {\n    actor = game.actors.get(actor.id);\n    ddbItems = ddbItems.concat(addEquipmentResults.data.addItems);\n  }\n\n  const itemsToEquip = actor.data.items.filter((item) =>\n    !item.data.flags.ddbimporter?.action && item.data.flags.ddbimporter?.id &&\n    !item.data.flags.ddbimporter?.custom &&\n    ddbItems.some((dItem) =>\n      item.data.flags.ddbimporter.id === dItem.id &&\n      dItem.id === item.data.flags.ddbimporter?.id &&\n      item.data.data.equipped !== dItem.equipped\n    )\n  );\n  const itemsToAttune = actor.data.items.filter((item) =>\n    !item.data.flags.ddbimporter?.action && item.data.flags.ddbimporter?.id &&\n    !item.data.flags.ddbimporter?.custom &&\n    ddbItems.some((dItem) =>\n      item.data.flags.ddbimporter.id === dItem.id &&\n      dItem.id === item.data.flags.ddbimporter?.id &&\n      ((item.data.data.attunement === 2) !== dItem.isAttuned)\n    )\n  );\n  const itemsToCharge = actor.data.items.filter((item) =>\n    !item.data.flags.ddbimporter?.action && item.data.flags.ddbimporter?.id &&\n    !item.data.flags.ddbimporter?.custom &&\n    ddbItems.some((dItem) =>\n      item.data.flags.ddbimporter.id === dItem.id &&\n      dItem.id === item.data.flags.ddbimporter?.id &&\n      item.data.data.uses?.max && dItem.limitedUse?.numberUsed &&\n      ((parseInt(item.data.data.uses.max) - parseInt(item.data.data.uses.value)) !== dItem.limitedUse.numberUsed)\n    )\n  );\n  const itemsToQuantity = actor.data.items.filter((item) =>\n    !item.data.flags.ddbimporter?.action && item.data.flags.ddbimporter?.id &&\n    !item.data.data.quantity == 0 &&\n    !item.data.flags.ddbimporter?.custom &&\n    ((item.type !== \"weapon\" && item.type !== \"armor\") || item.data.flags.ddbimporter?.dndbeyond?.stackable) &&\n    !item.data.data?.armor?.type &&\n    ddbItems.some((dItem) =>\n      item.data.flags.ddbimporter.id === dItem.id &&\n      dItem.id === item.data.flags.ddbimporter?.id &&\n      item.data.data.quantity !== dItem.quantity\n    )\n  );\n  // this is for items that have been added and might have a different name\n  const itemsToName = actor.data.items.filter((item) =>\n    item.data.flags.ddbimporter?.id &&\n    item.data.data.quantity !== 0 &&\n    !item.data.flags.ddbimporter?.custom &&\n    ddbItems.some((dItem) =>\n      // item.data.flags.ddbimporter.id === dItem.id &&\n      item.data.flags.ddbimporter.originalName === dItem.definition.name &&\n      item.data.flags.ddbimporter.originalName !== item.data.name &&\n      !item.data.data.quantity == 0 &&\n      dItem.id === item.data.flags.ddbimporter?.id &&\n      item.data.name !== dItem.definition.name\n    )\n  );\n\n  // update.name || update.data?.description || update.data?.weight || update.data?.price || update.data?.quantity\n  const customItems = actor.data.items.filter((item) =>\n    item.data.flags.ddbimporter?.id &&\n    item.data.data.quantity !== 0 &&\n    item.data.flags.ddbimporter?.custom &&\n    customDDBItems.some((dItem) => dItem.id === item.data.flags.ddbimporter.id &&\n      (\n        item.data.name !== dItem.name ||\n        item.data.data.description.value != dItem.description ||\n        item.data.data.quantity != dItem.quantity ||\n        item.data.data.weight != dItem.weight ||\n        item.data.data.price != dItem.cost\n      )\n    )\n  );\n\n  const itemsToUpdate = {\n    itemsToEquip,\n    itemsToAttune,\n    itemsToCharge,\n    itemsToQuantity,\n    itemsToName,\n    customItems,\n  };\n\n  return updateDDBEquipmentStatus(actor, itemsToUpdate, ddbItems);\n\n}\n\nasync function updateActionUseStatus(actor, actionData) {\n  return new Promise((resolve) => {\n    resolve(updateCharacterCall(actor, \"action/use\", actionData));\n  });\n}\n\nasync function updateDDBActionUseStatus(actor, actions) {\n  let promises = [];\n  actions.forEach((action) => {\n    const actionData = {\n      actionId: action.data.flags.ddbimporter.id,\n      entityTypeId: action.data.flags.ddbimporter.entityTypeId,\n      uses: parseInt(action.data.data.uses.max) - parseInt(action.data.data.uses.value)\n    };\n    promises.push(updateActionUseStatus(actor, actionData));\n  });\n  return Promise.all(promises);\n}\n\nasync function actionUseStatus(actor, ddbData) {\n  const syncActionReady = actor.data.flags.ddbimporter?.syncActionReady;\n  if (syncActionReady && !game.settings.get(\"ddb-importer\", \"sync-policy-action-use\")) return [];\n\n  let ddbActions = ddbData.character.actions;\n\n  const actionsToCharge = actor.data.items.filter((item) =>\n    (item.data.flags.ddbimporter?.action || item.type === \"feat\") &&\n    item.data.flags.ddbimporter?.id && item.data.flags.ddbimporter?.entityTypeId &&\n    ddbActions.some((dItem) =>\n      item.data.flags.ddbimporter.id === dItem.flags.ddbimporter.id &&\n      item.data.flags.ddbimporter.entityTypeId === dItem.flags.ddbimporter.entityTypeId &&\n      item.name === dItem.name && item.type === dItem.type &&\n      item.data.data.uses?.value &&\n      item.data.data.uses.value !== dItem.data.uses.value\n    )\n  );\n\n  const actionChanges = updateDDBActionUseStatus(actor, actionsToCharge);\n\n  return actionChanges;\n}\n\nexport async function updateDDBCharacter(actor) {\n  const activeUpdateState = getCurrentDynamicUpdateState(actor);\n  await disableDynamicUpdates(actor);\n\n  const cobaltCheck = await checkCobalt(actor.id);\n\n  if (cobaltCheck.success) {\n    logger.debug(`Cobalt checked`);\n  } else {\n    logger.error(`Cobalt cookie expired, please reset`);\n    logger.error(cobaltCheck.message);\n    throw cobaltCheck.message;\n  }\n\n  const characterId = actor.data.flags.ddbimporter.dndbeyond.characterId;\n  const syncId = actor.data.flags[\"ddb-importer\"]?.syncId ? actor.data.flags[\"ddb-importer\"].syncId + 1 : 0;\n\n  const characterDataOptions = {\n    currentActorId: actor.id,\n    characterId: characterId,\n    syncId: syncId,\n    localCobaltPostFix: actor.id,\n    resourceSelection: false,\n  };\n  let ddbData = await getCharacterData(characterDataOptions);\n\n  logger.debug(\"Current actor:\", actor.data);\n  logger.debug(\"DDB Parsed data:\", ddbData);\n\n  let singlePromises = []\n    .concat(\n      currency(actor, ddbData),\n      hitPoints(actor, ddbData),\n      hitDice(actor, ddbData),\n      spellSlots(actor, ddbData),\n      spellSlotsPact(actor, ddbData),\n      inspiration(actor, ddbData),\n      exhaustion(actor, ddbData),\n      deathSaves(actor, ddbData),\n      xp(actor, ddbData),\n    ).flat();\n\n  const singleResults = await Promise.all(singlePromises);\n  const spellsPreparedResults = await spellsPrepared(actor, ddbData);\n  const actionStatusResults = await actionUseStatus(actor, ddbData);\n  const nameUpdateResults = await updateCustomNames(actor, ddbData);\n  const addEquipmentResults = await addEquipment(actor, ddbData);\n  const removeEquipmentResults = await removeEquipment(actor, ddbData);\n  const equipmentStatusResults = await equipmentStatus(actor, ddbData, addEquipmentResults);\n  const conditionResults = await conditions(actor, ddbData);\n  // if a known/choice spellcaster\n  // and new spell/ spells removed\n  // for each spell add or remove, e.g.\n  // const spellsData = {\n  //   characterClassId: 52134801,\n  //   spellId: 2019,\n  //   id: 136157,\n  //   entityTypeId: 435869154,\n  //   remove: true,\n  // };\n  // const spellSlots = updateCharacterCall(actor, \"spells\", spellsData);\n  // promises.push(spellSlots);\n\n  actor.setFlag(\"ddb-importer\", \"syncId\", syncId);\n  await setActiveSyncSpellsFlag(actor, true);\n\n  // we can now process item attunements and uses (not yet done)\n\n  const results = singleResults.concat(\n    nameUpdateResults,\n    addEquipmentResults,\n    spellsPreparedResults,\n    removeEquipmentResults,\n    equipmentStatusResults,\n    actionStatusResults,\n    conditionResults,\n  ).filter((result) => result !== undefined);\n\n  logger.debug(\"Update results\", results);\n  await updateDynamicUpdates(actor, activeUpdateState);\n\n  return results;\n}\n\n// Called when characters are updated\n// will dynamically sync status back to DDB\nasync function activeUpdateActor(actor, update) {\n  // eslint-disable-next-line complexity\n  return new Promise((resolve) => {\n\n    const promises = [];\n\n    const actorActiveUpdate = actor.data.flags.ddbimporter?.activeUpdate;\n\n    if (actorActiveUpdate) {\n      const syncHP = game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-hitpoints\");\n      const syncCurrency = game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-currency\");\n      const syncSpellSlots = game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-spells-slots\");\n      const syncInspiration = game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-inspiration\");\n      const syncConditions = game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-condition\");\n      const syncDeathSaves = game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-deathsaves\");\n      const syncXP = game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-xp\");\n\n\n      if (syncHP && update.data?.attributes?.hp) {\n        logger.debug(\"Updating DDB Hitpoints...\");\n        promises.push(updateDDBHitPoints(actor));\n      }\n      if (syncCurrency && update.data?.currency) {\n        logger.debug(\"Updating DDB Currency...\");\n        promises.push(updateDDBCurrency(actor));\n      }\n      if (syncSpellSlots && update.data?.spells) {\n        const spellKeys = Object.keys(update.data.spells);\n        if (spellKeys.includes(\"pact\")) {\n          logger.debug(\"Updating DDB SpellSlots Pack...\");\n          promises.push(updateDDBSpellSlotsPact(actor));\n        }\n        const spellLevelKeys = [\"spell1\", \"spell2\", \"spell3\", \"spell4\", \"spell5\", \"spell6\", \"spell7\", \"spell8\", \"spell9\"];\n        const foundSpells = spellKeys.some((spellKey) => spellLevelKeys.includes(spellKey));\n        if (foundSpells) {\n          logger.debug(\"Updating DDB SpellSlots...\");\n          promises.push(updateDynamicDDBSpellSlots(actor, update));\n        }\n      }\n      if (syncInspiration &&\n        (update.data?.attributes?.inspiration === true || update.data?.attributes?.inspiration === false)\n      ) {\n        logger.debug(\"Updating DDB Inspiration...\");\n        promises.push(updateDDBInspiration(actor));\n      }\n      if (syncConditions && update.data?.attributes?.exhaustion) {\n        logger.debug(\"Updating DDB Exhaustion...\");\n        promises.push(updateDDBExhaustion(actor));\n      }\n      if (syncDeathSaves && update.data?.attributes?.death) {\n        logger.debug(\"Updating DDB DeathSaves...\");\n        promises.push(updateDDBDeathSaves(actor));\n      }\n      if (syncXP && update.data?.attributes?.xp) {\n        logger.debug(\"Updating DDB XP...\");\n        promises.push(updateDDBXP(actor));\n      }\n    }\n    resolve(promises);\n\n  });\n}\n\nconst DISABLE_FOUNDRY_UPGRADE = {\n  applyFeatures: false,\n  addFeatures: false,\n  promptAddFeatures: false,\n};\n\nasync function generateDynamicItemChange(actor, document, update) {\n  const updateItemDetails = {\n    itemsToEquip: [],\n    itemsToAttune: [],\n    itemsToCharge: [],\n    itemsToQuantity: [],\n    itemsToName: [],\n    customItems: [],\n  };\n\n  // console.warn(\"Document\", document);\n  // console.warn(\"ItemUpdate\", update);\n\n  if (document.data.flags.ddbimporter?.custom) {\n    if (update.name || update.data?.description || update.data?.weight || update.data?.price || update.data?.quantity) {\n      updateItemDetails.customItems.push(document);\n    }\n  } else {\n    if (update.data?.uses) {\n      updateItemDetails.itemsToCharge.push(document);\n    }\n    if (update.data?.attunement) {\n      updateItemDetails.itemsToAttune.push(document);\n    }\n    if (update.data?.quantity) {\n      // if its a weapon or armor we actually need to push a new one\n      if (!document.data.flags.ddbimporter?.dndbeyond?.stackable && update.data.quantity > 1) {\n        // Some items are not stackable on DDB\n\n        await document.update({ data: { quantity: 1 } });\n        let newDocument = JSON.parse(JSON.stringify(document.toObject()));\n        delete newDocument._id;\n        delete newDocument.flags.ddbimporter.id;\n\n        let results = [];\n        for (let i = 1; i < update.data.quantity; i++) {\n          logger.debug(`Adding item # ${i}`);\n          // eslint-disable-next-line no-await-in-loop\n          let newDoc = await actor.createEmbeddedDocuments(\"Item\", [newDocument], DISABLE_FOUNDRY_UPGRADE);\n          results.push(newDoc);\n          // new doc/item push to ddb handled by the add item hook\n        }\n        return results;\n      } else {\n        updateItemDetails.itemsToQuantity.push(document);\n      }\n    }\n    if (update.data?.equipped) {\n      updateItemDetails.itemsToEquip.push(document);\n    }\n    if (update.name) {\n      updateItemDetails.itemsToName.push(document);\n    }\n  }\n\n  return updateDDBEquipmentStatus(actor, updateItemDetails, []);\n\n}\n\nasync function updateSpellPrep(actor, document) {\n  return new Promise((resolve) => {\n    const spellSyncFlag = actor.data.flags.ddbimporter?.activeSyncSpells;\n    if (spellSyncFlag) {\n      logger.debug(\"Updating DDB SpellsPrepared...\");\n      // get spells class\n      const klassName = document.data.flags.ddbimporter?.dndbeyond?.class;\n      const klass = actor.items.find((item) => item.name === klassName && item.type === \"class\");\n      if (klass) {\n        resolve(updateDDBSpellsPrepared(actor, [document]));\n      } else {\n        resolve([]);\n      }\n    } else {\n      logger.warn(\"Unable to sync spell prep status until character is imported or updated to DDB\");\n      resolve([]);\n    }\n  });\n}\n\n// Called when characters items are updated\n// will dynamically sync status back to DDB\nasync function activeUpdateUpdateItem(document, update) {\n  // eslint-disable-next-line complexity\n  return new Promise((resolve) => {\n\n    // we check to see if this is actually an embedded item\n    const parentActor = document.parent;\n    const actorActiveUpdate = parentActor && parentActor.data.flags.ddbimporter?.activeUpdate;\n\n    if (!parentActor || !actorActiveUpdate) {\n      resolve([]);\n    } else {\n      logger.debug(\"Preparing to sync item change to DDB...\");\n      const action = document.data.flags.ddbimporter?.action || document.type === \"feat\";\n      const syncEquipment = game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-equipment\");\n      const syncActionUse = game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-action-use\");\n      const syncHD = game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-hitdice\");\n      const syncSpellsPrepared = game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-spells-prepared\");\n      const isDDBItem = document.data.flags.ddbimporter?.id;\n      const customItem = document.data.flags.ddbimporter?.custom || false;\n\n      const customNameAllowed = DICTIONARY.types.inventory.includes(document.type) || document.data.flags.ddbimporter?.action;\n      if (!customItem && update.name && customNameAllowed) {\n        updateDDBCustomNames(parentActor, [document.toObject()]);\n      }\n\n      // is this a DDB action, or do we treat this as an item?\n      if (action && syncActionUse && isDDBItem) {\n        if (update.data?.uses) {\n          logger.debug(\"Updating action uses\", update);\n          updateDDBActionUseStatus(parentActor, [document]);\n        } else {\n          resolve([]);\n        }\n      } else if (document.type === \"class\" && syncHD && update.data?.hitDiceUsed) {\n        logger.debug(\"Updating hitdice on DDB\");\n        resolve(updateDDBHitDice(parentActor, document, update));\n      } else if (document.type === \"spell\" && syncSpellsPrepared &&\n        update.data?.preparation && document.data.data.preparation.mode === \"prepared\"\n      ) {\n        logger.debug(\"Updating DDB SpellsPrepared...\");\n        updateSpellPrep(parentActor, document).then((results) => {\n          logger.debug(\"Spell prep results\", results);\n          const failures = results.find((result) => result.success !== true);\n          if (failures) setActiveSyncSpellsFlag(parentActor, false);\n          resolve(results);\n        });\n      } else if (syncEquipment) {\n        resolve(generateDynamicItemChange(parentActor, document, update));\n      }\n    }\n  });\n}\n\n\n// Called when characters items are added/deleted\n// will dynamically sync status back to DDB\nasync function activeUpdateAddOrDeleteItem(document, state) {\n  return new Promise((resolve) => {\n    let promises = [];\n\n    const syncEquipment = game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-equipment\");\n    // we check to see if this is actually an embedded item\n    const parentActor = document.parent;\n    const actorActiveUpdate = parentActor && parentActor.data.flags.ddbimporter?.activeUpdate;\n\n    if (parentActor && actorActiveUpdate && syncEquipment) {\n      logger.debug(`Preparing to ${state.toLowerCase()} item on DDB...`);\n      const action = document.data.flags.ddbimporter?.action || document.type === \"feat\";\n      if (!action) {\n        logger.debug(`Attempting to ${state.toLowerCase()} new Item`, document);\n        switch (state) {\n          case \"CREATE\":\n            promises.push(addDDBEquipment(parentActor, [document.toObject()]));\n            break;\n          case \"DELETE\":\n            promises.push(removeDDBEquipment(parentActor, [document.toObject()]));\n            break;\n          // no default\n        }\n      }\n    }\n    resolve(promises);\n  });\n}\n\n// called when effects are added/deleted/updated\nasync function activeUpdateEffectTrigger(document, state) {\n  return new Promise((resolve) => {\n    let promises = [];\n\n    const syncConditions = game.settings.get(\"ddb-importer\", \"dynamic-sync-policy-condition\");\n    // we check to see if this is actually an embedded item\n    const parentActor = document.parent;\n    const actorActiveUpdate = parentActor && parentActor.data.flags.ddbimporter?.activeUpdate;\n\n    if (parentActor && actorActiveUpdate && syncConditions) {\n      logger.debug(`Preparing to ${state.toLowerCase()} condition on DDB...`);\n      // is it a condition?\n      // is it a suitable type?\n      const isConvenient = document.data?.flags?.isConvenient;\n      const condition = getCondition(document.data?.label);\n      // exhaustion is a special case, but also a condition effect, handled by character update\n      const notExhaustion = condition ? condition.ddbId !== 4 : false;\n\n      if (isConvenient && condition && notExhaustion) {\n        logger.debug(`Attempting to ${state.toLowerCase()} Condition`, document);\n        switch (state) {\n          case \"CREATE\":\n            condition.applied = true;\n            promises.push(updateDDBCondition(parentActor, condition));\n            break;\n          case \"UPDATE\":\n            condition.applied = !document.data.disabled;\n            promises.push(updateDDBCondition(parentActor, condition));\n            break;\n          case \"DELETE\":\n            condition.applied = false;\n            promises.push(updateDDBCondition(parentActor, condition));\n            break;\n          // no default\n        }\n      }\n    }\n    resolve(promises);\n  });\n}\n\nexport function activateUpdateHooks() {\n  // check to make sure we can sync back, currently only works for 1 gm user\n  if (activeUpdate()) {\n    Hooks.on(\"updateActor\", activeUpdateActor);\n    Hooks.on(\"updateItem\", activeUpdateUpdateItem);\n    Hooks.on(\"createItem\", (document) => activeUpdateAddOrDeleteItem(document, \"CREATE\"));\n    Hooks.on(\"deleteItem\", (document) => activeUpdateAddOrDeleteItem(document, \"DELETE\"));\n    // conditions syncing relies of Conv Effects\n    const dfConditionsOn = utils.isModuleInstalledAndActive(\"dfreds-convenient-effects\");\n    if (dfConditionsOn) {\n      Hooks.on(\"createActiveEffect\", (document) => activeUpdateEffectTrigger(document, \"CREATE\"));\n      Hooks.on(\"updateActiveEffect\", (document) => activeUpdateEffectTrigger(document, \"UPDATE\"));\n      Hooks.on(\"deleteActiveEffect\", (document) => activeUpdateEffectTrigger(document, \"DELETE\"));\n    }\n  }\n}\n","import DICTIONARY from \"../dictionary.js\";\nimport { generateOverrideChange } from \"./effects.js\";\n\nfunction buildBaseOverrideEffect(label) {\n  let effect = {\n    changes: [],\n    duration: {\n      seconds: null,\n      startTime: null,\n      rounds: null,\n      turns: null,\n      startRound: null,\n      startTurn: null,\n    },\n    origin: \"Ability.Override\",\n    label,\n    tint: \"\",\n    disabled: false,\n    transfer: true,\n    selectedKey: [],\n    icon: \"icons/svg/anchor.svg\",\n    flags: {\n      dae: { transfer: true },\n      ddbimporter: { disabled: false, itemId: null, entityTypeId: null }\n    },\n  };\n  return effect;\n}\n\n\nexport function abilityOverrideEffects(overrides) {\n  let effects = buildBaseOverrideEffect(\"Ability Overrides\");\n\n  DICTIONARY.character.abilities.forEach((ability) => {\n    if (overrides[ability.value] === 0) return;\n    effects.changes.push(generateOverrideChange(overrides[ability.value], 50, `data.abilities.${ability.value}.value`));\n  });\n\n  return effects;\n}\n","import utils from \"../utils.js\";\nimport logger from \"../logger.js\";\nimport { parseJson } from \"../parser/character.js\";\nimport {\n  copySupportedItemFlags,\n  addMagicItemSpells,\n  getCompendiumItems,\n  getSRDCompendiumItems,\n  copySRDIcons,\n  getDDBEquipmentIcons,\n  getDDBSpellSchoolIcons,\n  getDDBGenericItemIcons,\n  addItemEffectIcons,\n  retainExistingIcons,\n} from \"../muncher/import.js\";\nimport { download, getCampaignId, getCompendiumType } from \"../muncher/utils.js\";\nimport { addItemsDAESRD } from \"../muncher/dae.js\";\nimport { copyInbuiltIcons } from \"../icons/index.js\";\nimport { updateDDBCharacter } from \"./update.js\";\nimport { characterExtras } from \"./extras.js\";\nimport DICTIONARY from \"../dictionary.js\";\nimport { getCobalt, isLocalCobalt, deleteLocalCobalt } from \"../lib/Secrets.js\";\nimport { DDBCookie } from \"../lib/Settings.js\";\nimport { loadSRDRules } from \"../parser/templateStrings.js\";\nimport { abilityOverrideEffects } from \"../effects/abilityOverrides.js\";\nimport {\n  getCharacterImportSettings,\n  updateActorSettings,\n  setRecommendedCharacterActiveEffectSettings,\n} from \"../muncher/settings.js\";\nimport { getCurrentDynamicUpdateState, updateDynamicUpdates, disableDynamicUpdates } from \"./utils.js\";\nimport { setConditions } from \"./conditions.js\";\n\nconst FILTER_SECTIONS = [\"classes\", \"features\", \"actions\", \"inventory\", \"spells\"];\n\nconst DISABLE_FOUNDRY_UPGRADE = {\n  applyFeatures: false,\n  addFeatures: false,\n  promptAddFeatures: false,\n};\n\n// reference to the D&D Beyond popup\nconst POPUPS = {\n  json: null,\n  web: null,\n};\nconst renderPopup = (type, url) => {\n  if (POPUPS[type] && !POPUPS[type].close) {\n    POPUPS[type].focus();\n    POPUPS[type].location.href = url;\n  } else {\n    const ratio = window.innerWidth / window.innerHeight;\n    const width = Math.round(window.innerWidth * 0.5);\n    const height = Math.round(window.innerWidth * 0.5 * ratio);\n    POPUPS[type] = window.open(\n      url,\n      \"ddb_sheet_popup\",\n      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`\n    );\n  }\n  return true;\n};\n\n/**\n * Retrieves the character ID from a given URL, which can be one of the following:\n * - regular character sheet\n * - public sharing link\n * - direct link to the endpoint already\n * @param {string} url A given URL pointing to a character. Contains the character ID\n * @returns {string} characterId or null\n */\nconst getCharacterId = (url) => {\n  let matches;\n  const CONFIGS = [\n    () => {\n      const PATTERN = /.*dndbeyond\\.com\\/profile\\/[\\w-_]+\\/characters\\/(\\d+)/;\n      matches = url.match(PATTERN);\n      if (matches) {\n        return matches[1];\n      }\n      return null;\n    },\n    () => {\n      const PATTERN = /ddb.ac\\/characters\\/(\\d+)\\/[\\w-_]+/;\n      matches = url.match(PATTERN);\n      if (matches) {\n        return matches[1];\n      }\n      return null;\n    },\n    () => {\n      const PATTERN = /dndbeyond.com\\/characters\\/(\\d+)/;\n      matches = url.match(PATTERN);\n      if (matches) {\n        return matches[1];\n      }\n      return null;\n    },\n    () => {\n      const PATTERN = /character-service.dndbeyond.com\\/character\\/v\\d+\\/character\\/(\\d+)/;\n      matches = url.match(PATTERN);\n      if (matches) {\n        return matches[1];\n      }\n      return null;\n    },\n  ];\n\n  return CONFIGS.map((fn) => fn(url)).reduce((prev, cur) => (!prev && cur ? cur : prev), null);\n};\n\n/**\n * Creates the Character Endpoint URL from a given character ID\n * @param {string} characterId The character ID\n * @returns {string|null} The API endpoint\n */\nconst getCharacterAPIEndpoint = (characterId) => {\n  return characterId !== null ? `https://character-service.dndbeyond.com/character/v5/character/${characterId}` : null;\n};\n\nconst getCharacterUpdatePolicyTypes = (invert = false) => {\n  let itemTypes = [];\n\n  if (invert) {\n    if (!game.settings.get(\"ddb-importer\", \"character-update-policy-class\")) itemTypes.push(\"class\");\n    if (!game.settings.get(\"ddb-importer\", \"character-update-policy-feat\")) itemTypes.push(\"feat\");\n    if (!game.settings.get(\"ddb-importer\", \"character-update-policy-weapon\")) itemTypes.push(\"weapon\");\n    if (!game.settings.get(\"ddb-importer\", \"character-update-policy-equipment\"))\n      itemTypes = itemTypes.concat(DICTIONARY.types.equipment);\n    if (!game.settings.get(\"ddb-importer\", \"character-update-policy-spell\")) itemTypes.push(\"spell\");\n  } else {\n    if (game.settings.get(\"ddb-importer\", \"character-update-policy-class\")) itemTypes.push(\"class\");\n    if (game.settings.get(\"ddb-importer\", \"character-update-policy-feat\")) itemTypes.push(\"feat\");\n    if (game.settings.get(\"ddb-importer\", \"character-update-policy-weapon\")) itemTypes.push(\"weapon\");\n    if (game.settings.get(\"ddb-importer\", \"character-update-policy-equipment\"))\n      itemTypes = itemTypes.concat(DICTIONARY.types.equipment);\n    if (game.settings.get(\"ddb-importer\", \"character-update-policy-spell\")) itemTypes.push(\"spell\");\n  }\n  return itemTypes;\n};\n\n/**\n * Returns a combined array of all items to process, filtered by the user's selection on what to skip and what to include\n * @param {object} result object containing all character items sectioned as individual properties\n * @param {array[string]} sections an array of object properties which should be filtered\n */\nconst filterItemsByUserSelection = (result, sections, invert = false) => {\n  let items = [];\n  const validItemTypes = getCharacterUpdatePolicyTypes(invert);\n\n  for (const section of sections) {\n    items = items.concat(result[section]).filter((item) => validItemTypes.includes(item.type));\n  }\n  return items;\n};\n\nconst filterActorItemsByUserSelection = (actor, invert = false) => {\n  const validItemTypes = getCharacterUpdatePolicyTypes(invert);\n\n  const items = actor.items.filter((item) => validItemTypes.includes(item.type));\n\n  return items;\n};\n\nconst DEFAULT_CHARACTER_DATA_OPTIONS = {\n  currentActorId: undefined,\n  characterId: undefined,\n  syncId: undefined,\n  localCobaltPostFix: \"\",\n  resourceSelection: true,\n};\n\n/**\n * Loads and parses character in the proxy\n * @param {*} options.characterId\n */\n\nexport async function getCharacterData(optionsIn) {\n  const options = mergeObject(DEFAULT_CHARACTER_DATA_OPTIONS, optionsIn);\n  const cobaltCookie = getCobalt(options.localCobaltPostFix);\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const campaignId = getCampaignId();\n  const proxyCampaignId = campaignId === \"\" ? null : campaignId;\n  let body = { cobalt: cobaltCookie, betaKey: betaKey, characterId: options.characterId, campaignId: proxyCampaignId };\n  if (options.syncId) {\n    body[\"updateId\"] = options.syncId;\n  }\n\n  try {\n    const response = await fetch(`${parsingApi}/proxy/v5/character`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      redirect: \"follow\", // manual, *follow, error\n      body: JSON.stringify(body), // body data type must match \"Content-Type\" header\n    });\n    const data = await response.json();\n    if (!data.success) return data;\n\n    // load some required content\n    await loadSRDRules();\n\n    // construct the expected { character: {...} } object\n    let ddb = {};\n    if (data.ddb.character === undefined) {\n      ddb = {\n        character: data.ddb,\n        classOptions: data.ddb.classOptions,\n        originOptions: data.ddb.originOptions,\n        infusions: data.ddb.infusions,\n      };\n    } else {\n      // fallback to old proxy style\n      ddb = data.ddb;\n    }\n\n    logger.debug(\"DDB Data to parse:\", JSON.parse(JSON.stringify(ddb)));\n    logger.debug(\"currentActorId\", options.currentActorId);\n    try {\n      const character = await parseJson(options.currentActorId, ddb, options.resourceSelection);\n      const shouldChangeName = game.settings.get(\"ddb-importer\", \"character-update-policy-name\");\n      if (!shouldChangeName) {\n        character.character.name = undefined;\n        character.character.token.name = undefined;\n      }\n      data[\"character\"] = character;\n      return data;\n    } catch (error) {\n      const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n      if (debugJson) {\n        download(JSON.stringify(data), `${options.characterId}-raw.json`, \"application/json\");\n      }\n      throw error;\n    }\n  } catch (error) {\n    logger.error(\"JSON Fetch and Parse Error\");\n    logger.error(error);\n    logger.error(error.stack);\n    throw error;\n  }\n}\n\nexport default class CharacterImport extends FormApplication {\n  constructor(options, actor) {\n    super(options);\n    this.actor = game.actors.get(actor.id ? actor.id : actor._id);\n    this.migrateMetadata();\n    this.actorOriginal = JSON.parse(JSON.stringify(this.actor));\n    this.result = {};\n    this.nonMatchedItemIds = [];\n  }\n\n  migrateMetadata() {\n    if (this.actor.data.flags?.ddbimporter?.dndbeyond) {\n      const url = this.actor.data.flags.ddbimporter.dndbeyond.url || this.actor.data.flags.ddbimporter.dndbeyond.roUrl;\n\n      if (url && !this.actor.data.flags.ddbimporter.characterId) {\n        const characterId = getCharacterId(url);\n        if (characterId) {\n          const apiEndpointUrl = getCharacterAPIEndpoint(characterId);\n          this.actor.data.flags.ddbimporter.dndbeyond.characterId = characterId;\n          this.actor.data.flags.ddbimporter.dndbeyond.apiEndpointUrl = apiEndpointUrl;\n          this.actor.data.flags.ddbimporter.dndbeyond.url = url;\n        } else {\n          // clear the url, because it's malformed anyway\n          this.actor.data.flags.ddbimporter.dndbeyond.url = null;\n        }\n      }\n    }\n  }\n\n  /**\n   * Define default options for the PartySummary application\n   */\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    options.title = game.i18n.localize(\"ddb-importer.module-name\");\n    options.template = \"modules/ddb-importer/handlebars/character.hbs\";\n    options.width = 900;\n    options.height = \"auto\";\n    options.classes = [\"ddbimporter\", \"sheet\"];\n    options.tabs = [{ navSelector: \".tabs\", contentSelector: \"form\", initial: \"import\" }];\n\n    return options;\n  }\n\n  static showCurrentTask(html, title, message = null, isError = false) {\n    let element = $(html).find(\".task-name\");\n    element.html(`<h2 ${isError ? \" style='color:red'\" : \"\"}>${title}</h2>${message ? `<p>${message}</p>` : \"\"}`);\n    $(html).parent().parent().css(\"height\", \"auto\");\n  }\n\n  /**\n   * Loops through a characters items and updates flags\n   * @param {*} items\n   */\n  async copySupportedCharacterItemFlags(items) {\n    items.forEach((item) => {\n      const originalItem = this.actorOriginal.items.find(\n        (originalItem) => item.name === originalItem.name && item.type === originalItem.type\n      );\n      if (originalItem) {\n        copySupportedItemFlags(originalItem, item);\n      }\n    });\n  }\n\n  copyExistingJournalNotes() {\n    if (!this.actorOriginal) return;\n    const journalFields = [\n      \"notes1name\",\n      \"notes2name\",\n      \"notes3name\",\n      \"notes4name\",\n      \"notes1\",\n      \"notes2\",\n      \"notes3\",\n      \"notes4\",\n      \"notes\",\n    ];\n    journalFields.forEach((field) => {\n      if (this.actorOriginal.data.details[field]) {\n        this.actor.data.data.details[field] = this.actorOriginal.data.details[field];\n      }\n    });\n  }\n\n  async copyCharacterItemEffects(items) {\n    return new Promise((resolve) => {\n      resolve(\n        items.map((item) => {\n          const originalItem = this.actorOriginal.items.find(\n            (originalItem) => item.name === originalItem.name && item.type === originalItem.type\n          );\n          if (originalItem) {\n            if (!item.effects) item.effects = [];\n            if (originalItem.effects) {\n              logger.info(`Copying Effects for ${originalItem.name}`);\n              item.effects = originalItem.effects.map((m) => {\n                delete m._id;\n                return m;\n              });\n            }\n          }\n          return item;\n        })\n      );\n    });\n  }\n\n  /**\n   * Removes items\n   * @param {*} items\n   * @param {*} itemsToRemove\n   */\n  static async removeItems(items, itemsToRemove) {\n    return new Promise((resolve) => {\n      resolve(\n        items.filter(\n          (item) =>\n            !itemsToRemove.some((originalItem) => {\n              const originalNameMatch = originalItem.flags?.ddbimporter?.originalItemName\n                ? originalItem.flags.ddbimporter.originalItemName === item.name\n                : false;\n              const nameMatch = item.name === originalItem.name || originalNameMatch;\n              return nameMatch && item.type === originalItem.type;\n            })\n        )\n      );\n    });\n  }\n\n  /**\n   * Deletes items from the inventory bases on which sections a user wants to update\n   * Possible sections:\n   * - class\n   * - feat\n   * - weapon\n   * - equipment\n   * - inventory: consumable, loot, tool and backpack\n   * - spell\n   */\n  async clearItemsByUserSelection(excludedList = []) {\n    const includedItems = getCharacterUpdatePolicyTypes();\n    // collect all items belonging to one of those inventory item categories\n    const ownedItems = this.actor.getEmbeddedCollection(\"Item\");\n    const toRemove = ownedItems\n      .filter(\n        (item) =>\n          includedItems.includes(item.type) &&\n          !excludedList.some((excluded) => excluded._id === item.id) &&\n          !this.nonMatchedItemIds.includes(item.id)\n      )\n      .filter((item) => !item.data.flags.ddbimporter?.ignoreItemImport)\n      .map((item) => item.id);\n\n    logger.debug(\"Removing the following character items\", toRemove);\n    if (toRemove.length > 0) {\n      await this.actor.deleteEmbeddedDocuments(\"Item\", toRemove);\n    }\n    return toRemove;\n  }\n\n  async updateImage(html, data) {\n    // updating the image?\n    let imagePath = this.actor.img;\n    const decorations = data.character.decorations;\n    const userHasPermission = !(game.settings.get(\"ddb-importer\", \"restrict-to-trusted\") && !game.user.isTrusted);\n    if (\n      userHasPermission &&\n      decorations?.avatarUrl &&\n      decorations.avatarUrl !== \"\" &&\n      (imagePath.indexOf(\"mystery-man\") !== -1 || game.settings.get(\"ddb-importer\", \"character-update-policy-image\"))\n    ) {\n      CharacterImport.showCurrentTask(html, \"Uploading avatar image\");\n      let filename = data.character.name\n        .replace(/[^a-zA-Z]/g, \"-\")\n        .replace(/-+/g, \"-\")\n        .trim();\n\n      const uploadDirectory = game.settings.get(\"ddb-importer\", \"image-upload-directory\").replace(/^\\/|\\/$/g, \"\");\n      imagePath = await utils.uploadImage(decorations.avatarUrl, uploadDirectory, filename);\n      this.result.character.img = imagePath;\n      if (decorations?.frameAvatarUrl && decorations.frameAvatarUrl !== \"\") {\n        const framePath = await utils.uploadImage(decorations.frameAvatarUrl, uploadDirectory, `frame-${filename}`);\n        this.result.character.flags.ddbimporter[\"framePath\"] = framePath;\n      }\n    }\n  }\n\n  /* -------------------------------------------- */\n\n  async getData() {\n    // loads settings for actor\n    const importSettings = getCharacterImportSettings();\n\n    const characterId = this.actor.data.flags?.ddbimporter?.dndbeyond?.characterId;\n    const syncEnabled = characterId && importSettings.tiers.all;\n\n    const trustedUsersOnly = game.settings.get(\"ddb-importer\", \"restrict-to-trusted\");\n    const allowAllSync = game.settings.get(\"ddb-importer\", \"allow-all-sync\");\n    const syncOnly = trustedUsersOnly && allowAllSync && !game.user.isTrusted;\n\n    const localCobalt = isLocalCobalt(this.actor.id);\n    const cobaltCookie = getCobalt(this.actor.id);\n    const cobaltSet = localCobalt && cobaltCookie && cobaltCookie != \"\";\n    const itemCompendium = await getCompendiumType(\"item\", false);\n\n    const dynamicSync = game.settings.get(\"ddb-importer\", \"dynamic-sync\");\n    const updateUser = game.settings.get(\"ddb-importer\", \"dynamic-sync-user\");\n    const gmSyncUser = game.user.isGM && game.user.id == updateUser;\n    const dynamicUpdateAllowed = dynamicSync && gmSyncUser && importSettings.tiers.experimentalMid;\n    const dynamicUpdateStatus = this.actor.data.flags?.ddbimporter?.activeUpdate;\n    const resourceSelection =\n      !hasProperty(this.actor, \"data.flags.ddbimporter.resources.ask\") ||\n      (hasProperty(this.actor, \"data.flags.ddbimporter.resources.ask\") &&\n        this.actor.data.flags.ddbimporter.resources.ask);\n\n    const itemsMunched = syncEnabled && itemCompendium ? (await itemCompendium.index.size) !== 0 : false;\n\n    const actorSettings = {\n      actor: this.actor,\n      localCobalt: localCobalt,\n      cobaltSet: cobaltSet,\n      syncEnabled: syncEnabled && itemsMunched,\n      importAllowed: !syncOnly,\n      itemsMunched: itemsMunched,\n      dynamicUpdateAllowed,\n      dynamicUpdateStatus,\n      resourceSelection,\n    };\n\n    return mergeObject(importSettings, actorSettings);\n  }\n\n  /* -------------------------------------------- */\n\n  activateListeners(html) {\n    super.activateListeners(html);\n    // watch the change of the import-policy-selector checkboxes\n    $(html)\n      .find(\n        [\n          '.import-policy input[type=\"checkbox\"]',\n          '.advanced-import-config input[type=\"checkbox\"]',\n          '.effect-policy input[type=\"checkbox\"]',\n          '.effect-import-config input[type=\"checkbox\"]',\n          '.extras-import-config input[type=\"checkbox\"]',\n          '.import-config input[type=\"checkbox\"]',\n        ].join(\",\")\n      )\n      .on(\"change\", (event) => {\n        updateActorSettings(html, event);\n      });\n\n    $(html)\n      .find(\"#default-effects\")\n      .on(\"click\", async (event) => {\n        event.preventDefault();\n        setRecommendedCharacterActiveEffectSettings(html);\n      });\n\n    $(html)\n      .find(['.resource-selection input[type=\"checkbox\"]'].join(\",\"))\n      .on(\"change\", async (event) => {\n        const updateData = { flags: { ddbimporter: { resources: { ask: event.currentTarget.checked } } } };\n        await this.actor.update(updateData);\n      });\n\n    $(html)\n      .find('.sync-policy input[type=\"checkbox\"]')\n      .on(\"change\", (event) => {\n        game.settings.set(\n          \"ddb-importer\",\n          \"sync-policy-\" + event.currentTarget.dataset.section,\n          event.currentTarget.checked\n        );\n      });\n\n    $(html)\n      .find(\"#dndbeyond-character-dynamic-update\")\n      .on(\"change\", async (event) => {\n        const activeUpdateData = { flags: { ddbimporter: { activeUpdate: event.currentTarget.checked } } };\n        await this.actor.update(activeUpdateData);\n      });\n\n    $(html)\n      .find(\"#dndbeyond-character-import-start\")\n      .on(\"click\", async (event) => {\n        // retrieve the character data from the proxy\n        event.preventDefault();\n\n        try {\n          $(html).find(\"#dndbeyond-character-import-start\").prop(\"disabled\", true);\n          CharacterImport.showCurrentTask(html, \"Getting Character data\");\n          const characterId = this.actor.data.flags.ddbimporter.dndbeyond.characterId;\n          const characterDataOptions = {\n            currentActorId: this.actor.id,\n            characterId: characterId,\n            syncId: null,\n            localCobaltPostFix: this.actor.id,\n            resourceSelection: true,\n          };\n          const characterData = await getCharacterData(characterDataOptions);\n          logger.debug(\"import.js getCharacterData result\", characterData);\n          const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n          if (debugJson) {\n            download(JSON.stringify(characterData), `${characterId}.json`, \"application/json\");\n          }\n          if (characterData.success) {\n            // begin parsing the character data\n            await this.parseCharacterData(html, characterData);\n            CharacterImport.showCurrentTask(html, \"Loading Character data\", \"Done.\", false);\n            this.close();\n          } else {\n            CharacterImport.showCurrentTask(html, characterData.message, null, true);\n            return false;\n          }\n        } catch (error) {\n          switch (error) {\n            case \"Forbidden\":\n              CharacterImport.showCurrentTask(html, \"Error retrieving Character: \" + error, error, true);\n              break;\n            default:\n              logger.error(error);\n              logger.error(error.stack);\n              CharacterImport.showCurrentTask(html, \"Error parsing Character: \" + error, error, true);\n              break;\n          }\n          return false;\n        }\n\n        $(html).find(\"#dndbeyond-character-import-start\").prop(\"disabled\", false);\n        return true;\n      });\n\n    $(html)\n      .find(\"#dndbeyond-character-update\")\n      .on(\"click\", async () => {\n        try {\n          $(html).find(\"#dndbeyond-character-update\").prop(\"disabled\", true);\n          await updateDDBCharacter(this.actor).then((result) => {\n            const updateNotes = result\n              .flat()\n              .filter((r) => r !== undefined)\n              .map((r) => r.message)\n              .join(\" \");\n            logger.debug(updateNotes);\n            CharacterImport.showCurrentTask(html, \"Update complete\", updateNotes);\n            $(html).find(\"#dndbeyond-character-update\").prop(\"disabled\", false);\n          });\n        } catch (error) {\n          logger.error(error);\n          logger.error(error.stack);\n          CharacterImport.showCurrentTask(html, \"Error updating character\", error, true);\n        }\n      });\n\n    $(html)\n      .find(\"#delete-local-cobalt\")\n      .on(\"click\", async () => {\n        try {\n          deleteLocalCobalt(this.actor.id);\n          $(html).find(\"#delete-local-cobalt\").prop(\"disabled\", true);\n        } catch (error) {\n          logger.error(error);\n          logger.error(error.stack);\n          CharacterImport.showCurrentTask(html, \"Error deleting local cookie\", error, true);\n        }\n      });\n\n    $(html)\n      .find(\"#set-local-cobalt\")\n      .on(\"click\", async () => {\n        try {\n          new DDBCookie({}, this.actor, true).render(true);\n          $(html).find(\"#delete-local-cobalt\").prop(\"disabled\", false);\n        } catch (error) {\n          logger.error(error);\n          logger.error(error.stack);\n          CharacterImport.showCurrentTask(html, \"Error updating character\", error, true);\n        }\n      });\n\n    $(html)\n      .find(\"#dndbeyond-character-extras-start\")\n      .on(\"click\", async () => {\n        try {\n          $(html).find(\"#dndbeyond-character-extras-start\").prop(\"disabled\", true);\n          CharacterImport.showCurrentTask(html, \"Fetching character data\");\n          const characterId = this.actor.data.flags.ddbimporter.dndbeyond.characterId;\n          const characterDataOptions = {\n            currentActorId: this.actor.id,\n            characterId: characterId,\n            syncId: null,\n            localCobaltPostFix: this.actor.id,\n            resourceSelection: false,\n          };\n          const characterData = await getCharacterData(characterDataOptions);\n          logger.debug(\"import.js getCharacterData result\", characterData);\n          const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n          if (debugJson) {\n            download(JSON.stringify(characterData), `${characterId}.json`, \"application/json\");\n          }\n          if (characterData.success) {\n            await characterExtras(html, characterData, this.actor);\n            CharacterImport.showCurrentTask(html, \"Loading Extras\", \"Done.\", false);\n            $(html).find(\"#dndbeyond-character-extras-start\").prop(\"disabled\", true);\n            this.close();\n          } else {\n            CharacterImport.showCurrentTask(html, characterData.message, null, true);\n            return false;\n          }\n        } catch (error) {\n          switch (error) {\n            case \"Forbidden\":\n              CharacterImport.showCurrentTask(html, \"Error retrieving Character: \" + error, error, true);\n              break;\n            default:\n              logger.error(error);\n              logger.error(error.stack);\n              CharacterImport.showCurrentTask(html, \"Error parsing Character: \" + error, error, true);\n              break;\n          }\n          return false;\n        }\n        return true;\n      });\n\n    $(html)\n      .find(\"input[name=dndbeyond-url]\")\n      .on(\"input\", async (event) => {\n        let URL = event.target.value;\n        const characterId = getCharacterId(URL);\n\n        if (characterId) {\n          const apiEndpointUrl = getCharacterAPIEndpoint(characterId);\n          $(html)\n            .find(\".dndbeyond-url-status i\")\n            .replaceWith('<i class=\"fas fa-check-circle\" style=\"color: green\"></i>');\n          $(html).find(\"span.dndbeyond-character-id\").text(characterId);\n          $(html).find(\"#dndbeyond-character-import-start\").prop(\"disabled\", false);\n          $(html).find(\"#open-dndbeyond-url\").prop(\"disabled\", false);\n\n          CharacterImport.showCurrentTask(html, \"Saving reference\");\n          await this.actor.update({\n            flags: {\n              ddbimporter: {\n                dndbeyond: {\n                  url: URL,\n                  apiEndpointUrl: apiEndpointUrl,\n                  characterId: characterId,\n                },\n              },\n            },\n          });\n          CharacterImport.showCurrentTask(html, \"Status\");\n        } else {\n          CharacterImport.showCurrentTask(\n            html,\n            \"URL format incorrect\",\n            \"That seems not to be the URL we expected...\",\n            true\n          );\n          $(html)\n            .find(\".dndbeyond-url-status i\")\n            .replaceWith('<i class=\"fas fa-exclamation-triangle\" style=\"color:red\"></i>');\n        }\n      });\n\n    $(html)\n      .find(\"#open-dndbeyond-url\")\n      .on(\"click\", () => {\n        try {\n          const characterId = this.actor.data.flags.ddbimporter.dndbeyond.characterId;\n          const apiEndpointUrl = getCharacterAPIEndpoint(characterId);\n          renderPopup(\"json\", apiEndpointUrl);\n        } catch (error) {\n          CharacterImport.showCurrentTask(html, \"Error opening JSON URL\", error, true);\n        }\n      });\n  }\n\n  async enrichCharacterItems(html, items) {\n    const useInbuiltIcons = game.settings.get(\"ddb-importer\", \"character-update-policy-use-inbuilt-icons\");\n    const useSRDCompendiumItems = game.settings.get(\"ddb-importer\", \"character-update-policy-use-srd\");\n    const useSRDCompendiumIcons = game.settings.get(\"ddb-importer\", \"character-update-policy-use-srd-icons\");\n    const ddbSpellIcons = game.settings.get(\"ddb-importer\", \"character-update-policy-use-ddb-spell-icons\");\n    const ddbItemIcons = game.settings.get(\"ddb-importer\", \"character-update-policy-use-ddb-item-icons\");\n    const ddbGenericItemIcons = game.settings.get(\"ddb-importer\", \"character-update-policy-use-ddb-generic-item-icons\");\n    const activeEffectCopy = game.settings.get(\"ddb-importer\", \"character-update-policy-active-effect-copy\");\n    const daeEffectCopy = game.settings.get(\"ddb-importer\", \"character-update-policy-dae-effect-copy\");\n    const daeSRDInstalled = utils.isModuleInstalledAndActive(\"Dynamic-Effects-SRD\");\n    const daeMidiInstalled = utils.isModuleInstalledAndActive(\"midi-srd\");\n    const daeInstalled = utils.isModuleInstalledAndActive(\"dae\");\n    const addItemEffects = game.settings.get(\"ddb-importer\", \"character-update-policy-add-item-effects\");\n    const addCharacterEffects = game.settings.get(\"ddb-importer\", \"character-update-policy-add-character-effects\");\n\n    // if we still have items to add, add them\n    if (items.length > 0) {\n      CharacterImport.showCurrentTask(html, \"Copying existing data flags\");\n      await this.copySupportedCharacterItemFlags(items);\n\n      if (ddbItemIcons) {\n        CharacterImport.showCurrentTask(html, \"Fetching DDB Inventory Images\");\n        items = await getDDBEquipmentIcons(items, true);\n      }\n\n      if (useInbuiltIcons) {\n        CharacterImport.showCurrentTask(html, \"Adding SRD Icons\");\n        items = await copyInbuiltIcons(items);\n      }\n\n      if (useSRDCompendiumIcons && !useSRDCompendiumItems) {\n        CharacterImport.showCurrentTask(html, \"Adding SRD Icons\");\n        items = await copySRDIcons(items);\n      }\n\n      if (ddbSpellIcons) {\n        CharacterImport.showCurrentTask(html, \"Fetching DDB Spell School Images\");\n        items = await getDDBSpellSchoolIcons(items, true);\n      }\n\n      if (ddbGenericItemIcons) {\n        CharacterImport.showCurrentTask(html, \"Fetching DDB Generic Item Images\");\n        items = await getDDBGenericItemIcons(items, true);\n      }\n\n      if (activeEffectCopy) {\n        CharacterImport.showCurrentTask(html, \"Copying Item Active Effects\");\n        items = await this.copyCharacterItemEffects(items);\n      }\n\n      if (daeEffectCopy && daeInstalled && (daeSRDInstalled || daeMidiInstalled)) {\n        CharacterImport.showCurrentTask(html, \"Importing DAE Effects\");\n        items = await addItemsDAESRD(items);\n      }\n\n      if (daeInstalled && (addItemEffects || addCharacterEffects)) {\n        items = await addItemEffectIcons(items);\n      }\n\n      items = await retainExistingIcons(items);\n    }\n\n    items = items.map((item) => {\n      if (!item.effects) item.effects = [];\n      return item;\n    });\n\n    return Promise.all(items);\n  }\n\n  async createCharacterItems(items, keepIds) {\n    const options = JSON.parse(JSON.stringify(DISABLE_FOUNDRY_UPGRADE));\n    if (keepIds) options[\"keepId\"] = true;\n\n    // we have to break these out into class and non-class because of\n    // https://gitlab.com/foundrynet/foundryvtt/-/issues/5312\n    const klassItems = items.filter((item) => item.type === \"class\");\n    const nonKlassItems = items.filter((item) => item.type !== \"class\");\n\n    logger.debug(`Adding the following class items, keep Ids? ${keepIds}`, JSON.parse(JSON.stringify(klassItems)));\n    await this.actor.createEmbeddedDocuments(\"Item\", klassItems, options);\n\n    logger.debug(\n      `Adding the following non-class items, keep Ids? ${keepIds}`,\n      JSON.parse(JSON.stringify(nonKlassItems))\n    );\n    await this.actor.createEmbeddedDocuments(\"Item\", nonKlassItems, options);\n  }\n\n  async importCharacterItems(html, items, keepIds = false) {\n    if (items.length > 0) {\n      CharacterImport.showCurrentTask(html, \"Adding items to character\");\n\n      const newItems = items.filter((i) => !i._id || i._id === null || i._id === undefined);\n      const updateItems = items.filter((i) => i._id && i._id !== null && i._id !== undefined);\n\n      await this.createCharacterItems(newItems, false);\n      await this.createCharacterItems(updateItems, keepIds);\n    }\n  }\n\n  async keepNonDDBItems(ddbItems) {\n    const lastImportId = getProperty(this.actorOriginal, \"flags.ddbimporter.importId\");\n    const ignoreNonDDBItems = game.settings.get(\"ddb-importer\", \"character-update-policy-ignore-non-ddb-items\");\n    if (ignoreNonDDBItems) {\n      const items = this.actor.getEmbeddedCollection(\"Item\");\n      await items.forEach((item) => {\n        const ddbMatchedItem = ddbItems.some((ddbItem) =>\n          item.data.name === ddbItem.name &&\n          item.data.type === ddbItem.type &&\n          item.data.flags?.ddbimporter?.id === ddbItem.flags?.ddbimporter?.id\n        );\n        if (!ddbMatchedItem) {\n          // if item not replaced by compendium swap or\n          if (item.data.flags?.ddbimporter?.importId !== lastImportId) {\n            this.nonMatchedItemIds.push(item.id);\n          }\n        }\n      });\n    }\n  }\n\n  // returns items not updated\n  async mergeExistingItems(html, items) {\n    if (this.actorOriginal.flags.ddbimporter) {\n      const ownedItems = this.actor.getEmbeddedCollection(\"Item\");\n\n      let nonMatchedItems = [];\n      let matchedItems = [];\n\n      await items.forEach((item) => {\n        let ddbMatchedItem = ownedItems.find((owned) => {\n          const simpleMatch =\n            item.name === owned.data.name &&\n            item.type === owned.data.type &&\n            item.flags?.ddbimporter?.id === owned.data.flags?.ddbimporter?.id;\n          const isChoice =\n            hasProperty(item, \"flags.ddbimporter.dndbeyond.choice.choiceId\") &&\n            hasProperty(owned, \"data.flags.ddbimporter.dndbeyond.choice.choiceId\");\n          const choiceMatch = isChoice\n            ? item.flags.ddbimporter.dndbeyond.choice.choiceId ===\n              owned.data.flags.ddbimporter.dndbeyond.choice.choiceId\n            : true;\n\n          return simpleMatch && choiceMatch;\n        });\n\n        if (ddbMatchedItem) {\n          if (!ddbMatchedItem.data.flags.ddbimporter?.ignoreItemImport) {\n            item[\"_id\"] = ddbMatchedItem[\"id\"];\n            if (ddbMatchedItem.data.flags.ddbimporter?.ignoreIcon) {\n              item.flags.ddbimporter.matchedImg = ddbMatchedItem.data.img;\n              item.flags.ddbimporter.ignoreIcon = true;\n            }\n            if (ddbMatchedItem.data.flags.ddbimporter?.retainResourceConsumption) {\n              item.data.consume = ddbMatchedItem.data.data.consume;\n              item.flags.ddbimporter.retainResourceConsumption = true;\n            }\n\n            matchedItems.push(item);\n          }\n        } else {\n          nonMatchedItems.push(item);\n        }\n      });\n\n      logger.debug(\"Finished retaining items\");\n      return nonMatchedItems.concat(matchedItems);\n    } else {\n      return items;\n    }\n  }\n\n  async fetchCharacterItems(html) {\n    const magicItemsInstalled = utils.isModuleInstalledAndActive(\"magicitems\");\n    // items for actor\n    let items = [];\n\n    // process spells for magic items\n    if (magicItemsInstalled && this.result.itemSpells && Array.isArray(this.result.itemSpells)) {\n      CharacterImport.showCurrentTask(html, \"Preparing magicitem spells\");\n      await addMagicItemSpells(this.result);\n    }\n\n    logger.debug(\"Calculating items to create and update...\");\n    CharacterImport.showCurrentTask(html, \"Calculating items to create and update...\");\n    items = filterItemsByUserSelection(this.result, FILTER_SECTIONS);\n\n    logger.debug(\"Checking existing items for details...\");\n    CharacterImport.showCurrentTask(html, \"Checking existing items for details...\");\n\n    items = await this.mergeExistingItems(html, items);\n    await this.keepNonDDBItems(items);\n\n    logger.debug(\"Removing found items...\");\n    CharacterImport.showCurrentTask(html, \"Clearing items for recreation...\");\n    await this.clearItemsByUserSelection();\n\n    // If there is no magicitems module fall back to importing the magic\n    // item spells as normal spells fo the character\n    if (!magicItemsInstalled) {\n      items.push(\n        this.result.itemSpells.filter((item) => {\n          const active = item.flags.ddbimporter.dndbeyond && item.flags.ddbimporter.dndbeyond.active === true;\n          if (!active) logger.warn(`Missing active flag on item spell ${item.name}`);\n          return active;\n        })\n      );\n      items = items.flat();\n    }\n    return items;\n  }\n\n  async processCharacterItems(html, items) {\n    let compendiumItems = [];\n    let srdCompendiumItems = [];\n    let overrideCompendiumItems = [];\n    const useExistingCompendiumItems = game.settings.get(\"ddb-importer\", \"character-update-policy-use-existing\");\n    const useSRDCompendiumItems = game.settings.get(\"ddb-importer\", \"character-update-policy-use-srd\");\n    const useOverrideCompendiumItems = game.settings.get(\"ddb-importer\", \"character-update-policy-use-override\");\n\n    /**\n     * First choice is override compendium\n     */\n    if (useOverrideCompendiumItems) {\n      logger.info(\"Removing matching Override compendium items\");\n      const compendiumOverrideItems = await getCompendiumItems(items, \"custom\");\n      overrideCompendiumItems = compendiumOverrideItems;\n      // remove existing items from those to be imported\n      items = await CharacterImport.removeItems(items, overrideCompendiumItems);\n    }\n    /**\n     * If SRD is selected, we prefer this\n     */\n    if (useSRDCompendiumItems) {\n      logger.info(\"Removing compendium items\");\n      const compendiumFeatureItems = await getSRDCompendiumItems(items, \"features\");\n      const compendiumInventoryItems = await getSRDCompendiumItems(items, \"inventory\");\n      const compendiumSpellItems = await getSRDCompendiumItems(items, \"spells\");\n\n      srdCompendiumItems = compendiumItems.concat(\n        compendiumInventoryItems,\n        compendiumSpellItems,\n        compendiumFeatureItems\n      );\n      // remove existing items from those to be imported\n      items = await CharacterImport.removeItems(items, srdCompendiumItems);\n    }\n\n    if (useExistingCompendiumItems) {\n      logger.info(\"Removing compendium items\");\n      const compendiumFeatureItems = await getCompendiumItems(items, \"features\");\n      const compendiumInventoryItems = await getCompendiumItems(items, \"inventory\");\n      const compendiumSpellItems = await getCompendiumItems(items, \"spells\");\n\n      compendiumItems = compendiumItems.concat(compendiumInventoryItems, compendiumSpellItems, compendiumFeatureItems);\n      // remove existing items from those to be imported\n      items = await CharacterImport.removeItems(items, compendiumItems);\n    }\n\n    // import remaining items to character\n    if (items.length > 0) {\n      CharacterImport.showCurrentTask(html, \"Adding DDB generated items\");\n      logger.debug(`Adding DDB generated items...`, items);\n      items = await this.enrichCharacterItems(html, items);\n      await this.importCharacterItems(html, items, true);\n    }\n\n    // now import any compendium items that we matched\n    if (useExistingCompendiumItems) {\n      CharacterImport.showCurrentTask(html, \"Adding DDB compendium items\");\n      logger.info(\"Adding DDB compendium items:\", compendiumItems);\n      await this.createCharacterItems(compendiumItems, false);\n    }\n\n    if (useSRDCompendiumItems) {\n      CharacterImport.showCurrentTask(html, \"Adding SRD compendium items\");\n      logger.info(\"Adding SRD compendium items:\", srdCompendiumItems);\n      await this.createCharacterItems(srdCompendiumItems, false);\n    }\n\n    if (useOverrideCompendiumItems) {\n      CharacterImport.showCurrentTask(html, \"Adding Override compendium items\");\n      logger.info(\"Adding Override compendium items:\", overrideCompendiumItems);\n      await this.createCharacterItems(overrideCompendiumItems, false);\n    }\n\n    logger.debug(\"Finished importing items\");\n  }\n\n  async removeActiveEffects(activeEffectCopy) {\n    // remove current active effects\n    const excludedItems = filterActorItemsByUserSelection(this.actorOriginal, true);\n    const ignoredItemIds = this.actorOriginal.items\n      .filter(\n        (item) =>\n          item.effects &&\n          item.effects.length > 0 &&\n          (item.flags.ddbimporter?.ignoreItemImport ||\n            excludedItems.some((ei) => ei._id === item._id) ||\n            this.nonMatchedItemIds.includes(item._id))\n      )\n      .map((item) => item._id);\n\n    const itemEffects = this.actor.effects.filter(\n      (ae) => ae.data.origin?.includes(\".Item.\") && !ignoredItemIds.includes(ae.data.origin?.split(\".\").slice(-1)[0])\n    );\n    const ignoredEffects = this.actor.effects.filter(\n      (ae) =>\n        // is this an ignored item\n        ignoredItemIds.includes(ae.data.origin?.split(\".\").slice(-1)[0]) ||\n        // is this a core status effect (CUB)\n        ae.data.flags?.core?.statusId\n    );\n    const charEffects = this.actor.effects.filter(\n      (ae) => !ae.data.origin?.includes(\".Item.\") && !ae.data.flags.ddbimporter?.characterEffect\n    );\n    const ddbGeneratedCharEffects = this.actor.effects.filter(\n      (ae) => !ae.data.origin?.includes(\".Item.\") && ae.data.flags.ddbimporter?.characterEffect\n    );\n\n    // remove existing active item effects\n    await this.actor.deleteEmbeddedDocuments(\n      \"ActiveEffect\",\n      itemEffects.map((ae) => ae.id)\n    );\n    // clear down ddb generated character effects such as skill bonuses\n    await this.actor.deleteEmbeddedDocuments(\n      \"ActiveEffect\",\n      ddbGeneratedCharEffects.map((ae) => ae.id)\n    );\n\n    // are we trying to retain existing effects?\n    if (activeEffectCopy) {\n      // add retained character effects to result\n      this.result.character.effects = this.result.character.effects.concat(charEffects, ignoredEffects);\n    } else {\n      // if not retaining effects remove character effects\n      await this.actor.deleteEmbeddedDocuments(\n        \"ActiveEffect\",\n        charEffects.map((ae) => ae.id)\n      );\n      this.result.character.effects = this.result.character.effects.concat(ignoredEffects);\n    }\n\n  }\n\n  fixUpCharacterEffects(character) {\n    let abilityOverrides = abilityOverrideEffects(character.flags.ddbimporter.dndbeyond.abilityOverrides);\n    if (abilityOverrides.changes.length > 0) {\n      character.effects = character.effects.concat(abilityOverrides);\n    }\n\n    character.effects.forEach((effect) => {\n      const origins = [\"Ability.Override\", \"AC\", `Actor.${this.actor.data.flags.ddbimporter.dndbeyond.characterId}`];\n      if (origins.includes(effect.origin)) {\n        effect.origin = `Actor.${this.actor.id}`;\n      }\n    });\n  }\n\n  async addImportIdToItems() {\n    const importId = this.importId;\n    function addImportId(items) {\n      return items.map((item) => {\n        setProperty(item, \"flags.ddbimporter.importId\", importId);\n        return item;\n      });\n    }\n    this.result.actions = addImportId(this.result.actions);\n    this.result.classes = addImportId(this.result.classes);\n    this.result.features = addImportId(this.result.features);\n    this.result.inventory = addImportId(this.result.inventory);\n    this.result.itemSpells = addImportId(this.result.itemSpells);\n    this.result.spells = addImportId(this.result.spells);\n  }\n\n  async parseCharacterData(html, data) {\n    this.result = data.character;\n    this.importId = randomID();\n    setProperty(this.result.character, \"flags.ddbimporter.importId\", this.importId);\n    await this.addImportIdToItems();\n\n    logger.debug(\"Current Actor:\", this.actorOriginal);\n\n    // disable active sync\n    const activeUpdateState = getCurrentDynamicUpdateState(this.actor);\n    await disableDynamicUpdates(this.actor);\n\n    // handle active effects\n    const activeEffectCopy = game.settings.get(\"ddb-importer\", \"character-update-policy-active-effect-copy\");\n    CharacterImport.showCurrentTask(html, \"Calculating Active Effect Changes\");\n    this.fixUpCharacterEffects(this.result.character);\n    let items = await this.fetchCharacterItems(html);\n    await this.removeActiveEffects(activeEffectCopy);\n\n    // update image\n    await this.updateImage(html, data.ddb);\n\n    // manage updates of basic character data more intelligently\n    // revert some data if update not wanted\n    if (!game.settings.get(\"ddb-importer\", \"character-update-policy-hp\")) {\n      this.result.character.data.attributes.hp = this.actorOriginal.data.attributes.hp;\n    }\n    if (!game.settings.get(\"ddb-importer\", \"character-update-policy-hit-die\")) {\n      this.result.character.data.attributes.hd = this.actorOriginal.data.attributes.hd;\n      this.result.classes = this.result.classes.map((klass) => {\n        const originalKlass = this.actorOriginal.items.find(\n          (original) => original.name === klass.name && original.type === \"class\"\n        );\n        if (originalKlass) {\n          klass.data.hitDiceUsed = originalKlass.data.hitDiceUsed;\n        }\n        return klass;\n      });\n    }\n    if (!game.settings.get(\"ddb-importer\", \"character-update-policy-currency\")) {\n      this.result.character.data.currency = this.actorOriginal.data.currency;\n    }\n    if (!game.settings.get(\"ddb-importer\", \"character-update-policy-bio\")) {\n      const bioUpdates = [\"alignment\", \"appearance\", \"background\", \"biography\", \"bond\", \"flaw\", \"idea\", \"trait\"];\n      bioUpdates.forEach((option) => {\n        this.result.character.data.details[option] = this.actorOriginal.data.details[option];\n      });\n    }\n    if (\n      hasProperty(this.result.character, \"flags.ddbimporter.resources.ask\") &&\n      !this.result.character.flags.ddbimporter.resources.ask\n    ) {\n      this.result.character.data.resources = this.actorOriginal.data.resources;\n    }\n\n    // flag as having items ids\n    this.result.character.flags.ddbimporter[\"syncItemReady\"] = true;\n    this.result.character.flags.ddbimporter[\"syncActionReady\"] = true;\n    this.result.character.flags.ddbimporter[\"activeUpdate\"] = false;\n    this.result.character.flags.ddbimporter[\"activeSyncSpells\"] = true;\n    // remove unneeded flags (used for character parsing)\n    this.result.character.flags.ddbimporter.dndbeyond[\"templateStrings\"] = null;\n    this.result.character.flags.ddbimporter.dndbeyond[\"characterValues\"] = null;\n    this.result.character.flags.ddbimporter.dndbeyond[\"proficiencies\"] = null;\n    this.result.character.flags.ddbimporter.dndbeyond[\"proficienciesIncludingEffects\"] = null;\n    this.result.character.flags.ddbimporter.dndbeyond[\"effectAbilities\"] = null;\n    this.result.character.flags.ddbimporter.dndbeyond[\"abilityOverrides\"] = null;\n    setProperty(this.result.character.flags, \"ddb-importer.version\", CONFIG.DDBI.version);\n\n    if (this.actorOriginal.flags.dnd5e?.wildMagic === true) {\n      this.result.character.flags.dnd5e[\"wildMagic\"] = true;\n    }\n\n    // basic import\n    CharacterImport.showCurrentTask(html, \"Updating core character information\");\n    logger.debug(\"Character data importing: \", this.result.character);\n    await this.actor.update(this.result.character);\n\n    // copy existing journal notes\n    this.copyExistingJournalNotes();\n\n    // items import\n    await this.processCharacterItems(html, items);\n\n    if (activeEffectCopy) {\n      // find effects with a matching name that existed on previous actor\n      // and that have a different active state and activate them\n      const targetEffects = this.actor.data.effects.filter((ae) => {\n        const previousEffectDiff = this.actorOriginal.effects.find(\n          (oae) => oae.label === ae.label && oae.disabled !== ae.disabled\n        );\n        if (previousEffectDiff) return true;\n        return false;\n      });\n      targetEffects.forEach((ae) => {\n        this.actor.updateEmbeddedDocument(\"ActiveEffect\", { _id: ae._id, disabled: !ae.disabled });\n      });\n    }\n\n    this.actor.render();\n\n    await updateDynamicUpdates(this.actor, activeUpdateState);\n    await setConditions(this.actor, data.ddb);\n  }\n}\n\nexport async function importCharacterById(characterId, html) {\n  try {\n    if (!html) html = utils.htmlToDoc(\"\");\n    let actor = await Actor.create({\n      name: \"New Actor\",\n      type: \"character\",\n      flags: {\n        ddbimporter: {\n          dndbeyond: {\n            characterId: characterId,\n            url: `https://www.dndbeyond.com/characters/${characterId}`,\n          },\n        },\n      },\n    });\n\n    const characterDataOptions = {\n      currentActorId: actor.id,\n      characterId: characterId,\n      syncId: null,\n      localCobaltPostFix: actor.id,\n      resourceSelection: false,\n    };\n    const characterData = await getCharacterData(characterDataOptions);\n    const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n    if (debugJson) {\n      download(JSON.stringify(characterData), `${characterId}.json`, \"application/json\");\n    }\n    if (characterData.success) {\n      const importer = new CharacterImport(CharacterImport.defaultOptions, actor);\n      await importer.parseCharacterData(html, characterData);\n      return actor;\n    } else {\n      logger.error(\"ERROR:\", characterData.message);\n      return undefined;\n    }\n  } catch (error) {\n    switch (error) {\n      case \"Forbidden\":\n        logger.error(\"Error retrieving Character: \", error);\n        break;\n      default:\n        logger.error(\"Error parsing Character: \", error);\n        logger.error(error.stack);\n        break;\n    }\n    return undefined;\n  }\n}\n\nexport async function importCharacter(actor, html) {\n  try {\n    if (!html) html = utils.htmlToDoc(\"\");\n    const actorData = actor.toObject();\n    const characterId = actorData.flags.ddbimporter.dndbeyond.characterId;\n    const characterDataOptions = {\n      currentActorId: actorData._id,\n      characterId: characterId,\n      syncId: null,\n      localCobaltPostFix: actorData._id,\n      resourceSelection: true,\n    };\n    const characterData = await getCharacterData(characterDataOptions);\n    logger.debug(\"import.js importCharacter getCharacterData result\", characterData);\n    const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n    if (debugJson) {\n      download(JSON.stringify(characterData), `${characterId}.json`, \"application/json\");\n    }\n    if (characterData.success) {\n      // begin parsing the character data\n      const importer = new CharacterImport(CharacterImport.defaultOptions, actorData);\n      await importer.parseCharacterData(html, characterData);\n      CharacterImport.showCurrentTask(html, \"Loading Character data\", \"Done.\", false);\n      logger.info(\"Loading Character data\");\n      return true;\n    } else {\n      logger.error(\"Error Loading Character data\", characterData.message);\n      return false;\n    }\n  } catch (error) {\n    switch (error) {\n      case \"Forbidden\":\n        logger.error(\"Error retrieving Character: \", error);\n        break;\n      default:\n        logger.error(\"Error parsing Character: \", error);\n        logger.error(error.stack);\n        break;\n    }\n    return false;\n  }\n}\n","// Main module class\nimport { checkMonsterCompendium } from \"./importMonster.js\";\nimport { munchNote, download, getPatreonTiers, getCompendiumLabel } from \"./utils.js\";\nimport logger from \"../logger.js\";\nimport utils from \"../utils.js\";\nimport { getCobalt } from \"../lib/Secrets.js\";\nimport { getAvailableCampaigns } from \"../lib/Settings.js\";\nimport { parseCritters } from \"./monsters.js\";\nimport {\n  getCharacterImportSettings,\n  getMuncherSettings,\n  updateActorSettings,\n  updateMuncherSettings,\n  setRecommendedCharacterActiveEffectSettings,\n} from \"./settings.js\";\nimport Helpers from \"./adventure/common.js\";\nimport { importCharacterById } from \"../character/import.js\";\n\nconst DIFFICULTY_LEVELS = [\n  { id: null, name: \"No challenge\", color: \"grey\" },\n  { id: 1, name: \"Easy\", color: \"green\" },\n  { id: 2, name: \"Medium\", color: \"brown\" },\n  { id: 3, name: \"Hard\", color: \"orange\" },\n  { id: 4, name: \"Deadly\", color: \"red\" },\n];\n\nconst SCENE_IMG = [\n  { name: \"Bar\", img: \"modules/ddb-importer/img/encounters/bar.webp\" },\n  { name: \"Cobbles\", img: \"modules/ddb-importer/img/encounters/cobbles.webp\" },\n  { name: \"Dungeon\", img: \"modules/ddb-importer/img/encounters/dungeon.png\" },\n  { name: \"Grass\", img: \"modules/ddb-importer/img/encounters/grass.webp\" },\n  { name: \"Snow\", img: \"modules/ddb-importer/img/encounters/snow.webp\" },\n  { name: \"Stone\", img: \"modules/ddb-importer/img/encounters/stone.webp\" },\n  { name: \"Void\", img: \"modules/ddb-importer/img/encounters/void.webp\" },\n];\n\nasync function getEncounterData() {\n  const cobaltCookie = getCobalt();\n  const betaKey = game.settings.get(\"ddb-importer\", \"beta-key\");\n  const parsingApi = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  const debugJson = game.settings.get(\"ddb-importer\", \"debug-json\");\n\n  const body = {\n    cobalt: cobaltCookie,\n    betaKey: betaKey,\n  };\n\n  return new Promise((resolve, reject) => {\n    fetch(`${parsingApi}/proxy/encounters`, {\n      method: \"POST\",\n      mode: \"cors\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(body), // body data type must match \"Content-Type\" header\n    })\n      .then((response) => response.json())\n      .then((data) => {\n        if (!data.success) {\n          munchNote(`API Failure: ${data.message}`);\n          reject(data.message);\n        }\n        if (debugJson) {\n          download(JSON.stringify(data), `encounters-raw.json`, \"application/json\");\n        }\n        return data;\n      })\n      .then((data) => {\n        munchNote(`Retrieved ${data.data.length} encounters, starting parse...`, true, false);\n        logger.info(`Retrieved ${data.data.length} encounters`);\n        resolve(data.data);\n      })\n      .catch((error) => reject(error));\n  });\n}\n\nexport async function parseEncounters() {\n  const encounters = await getEncounterData();\n  logger.debug(\"Fetched encounters\", encounters);\n  munchNote(`Fetched Available DDB Encounters`);\n  CONFIG.DDBI.ENCOUNTERS = encounters;\n  munchNote(\"\");\n  return CONFIG.DDBI.ENCOUNTERS;\n}\n\nasync function filterEncounters(campaignId) {\n  const campaigns = await getAvailableCampaigns();\n  const campaignIds = campaigns.map((c) => c.id);\n  const allEncounters = CONFIG.DDBI.ENCOUNTERS ? CONFIG.DDBI.ENCOUNTERS : await parseEncounters();\n\n  logger.debug(`${allEncounters.length} encounters`, allEncounters);\n  logger.debug(\"CampaignIds\", campaignIds);\n  if (!campaignId || campaignId === \"\" || !campaignIds.includes(parseInt(campaignId))) return allEncounters;\n  logger.debug(`CampaignId to find ${campaignId}`);\n  const filteredEncounters = allEncounters.filter((encounter) => encounter.campaign.id == campaignId);\n  logger.debug(`${filteredEncounters.length} filtered encounters`, filteredEncounters);\n  return filteredEncounters;\n}\n\nexport class DDBEncounterMunch extends Application {\n  constructor(options = {}) {\n    super(options);\n    this.encounter = {};\n    this.img = \"\";\n    this.sceneId = \"\";\n    this.journal = undefined;\n    this.combat = undefined;\n    this.tokens = [];\n    this.folders = {};\n  }\n\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    options.baseApplication = \"DDBEncounterMuncher\";\n    options.id = \"ddb-importer-encounters\";\n    options.template = \"modules/ddb-importer/handlebars/encounters.hbs\";\n    options.resizable = false;\n    options.height = \"auto\";\n    options.width = 800;\n    options.title = \"MrPrimate's DDB Encounter Muncher\";\n    options.classes = [\"ddb-muncher\", \"sheet\"];\n    options.tabs = [{ navSelector: \".tabs\", contentSelector: \"div\", initial: \"settings\" }];\n    return options;\n  }\n\n  async parseEncounter(id) {\n    logger.debug(`Looking for Encounter \"${id}\"`);\n    if (!CONFIG.DDBI.ENCOUNTERS) return this.encounter;\n    const monsterPack = checkMonsterCompendium();\n    await monsterPack.getIndex({ fields: [\"name\", \"flags.ddbimporter.id\"] });\n\n    // console.warn(CONFIG.DDBI.ENCOUNTERS);\n    const encounter = CONFIG.DDBI.ENCOUNTERS.find((e) => e.id == id.trim());\n    // console.warn(encounter);\n\n    // if (!encounter) return this.encounter;\n\n    let goodMonsterIds = [];\n    let missingMonsterIds = [];\n    logger.debug(\"Parsing encounter\", encounter);\n    encounter.monsters.forEach((monster) => {\n      const id = monster.id;\n      const monsterInPack = monsterPack.index.find((f) => f.flags?.ddbimporter?.id == id);\n      if (monsterInPack) {\n        goodMonsterIds.push({ ddbId: id, name: monsterInPack.name, id: monsterInPack._id, quantity: monster.quantity });\n      } else {\n        missingMonsterIds.push({ ddbId: id, quantity: monster.quantity });\n      }\n    });\n\n    let goodCharacterData = [];\n    let missingCharacterData = [];\n    encounter.players\n      .filter((character) => !character.hidden)\n      .forEach((character) => {\n        const characterInGame = game.actors.find(\n          (actor) =>\n            actor.data.flags?.ddbimporter?.dndbeyond?.characterId &&\n            actor.data.flags.ddbimporter.dndbeyond.characterId == character.id\n        );\n        if (characterInGame) {\n          goodCharacterData.push({ id: characterInGame.id, name: characterInGame.name, ddbId: character.id });\n        } else {\n          missingCharacterData.push({ ddbId: character.id, name: character.name });\n        }\n      });\n\n    const difficulty = DIFFICULTY_LEVELS.find((level) => level.id == encounter.difficulty);\n\n    this.encounter = {\n      id,\n      name: encounter.name,\n      inProgress: encounter.inProgress,\n      turnNum: encounter.turnNum,\n      roundNum: encounter.roundNum,\n      difficulty,\n      description: encounter.description,\n      rewards: encounter.rewards,\n      summary: encounter.flavorText,\n      campaign: encounter.campaign,\n      monsters: encounter.monsters,\n      characters: encounter.players,\n      goodMonsterIds,\n      missingMonsterIds,\n      goodCharacterData,\n      missingCharacterData,\n      missingMonsters: missingMonsterIds.length !== 0,\n      missingCharacters: missingCharacterData.length !== 0,\n    };\n\n    this.folders = {};\n\n    logger.debug(\"Current encounter\", this.encounter);\n\n    return this.encounter;\n  }\n\n  resetEncounter(html) {\n    const nameHtml = html.find(\"#ddb-encounter-name\");\n    const summaryHtml = html.find(\"#ddb-encounter-summary\");\n    const charactersHtml = html.find(\"#ddb-encounter-characters\");\n    const monstersHtml = html.find(\"#ddb-encounter-monsters\");\n    const difficultyHtml = html.find(\"#ddb-encounter-difficulty\");\n    const rewardsHtml = html.find(\"#ddb-encounter-rewards\");\n    const progressHtml = html.find(\"#ddb-encounter-progress\");\n\n    nameHtml[0].innerHTML = `<p id=\"ddb-encounter-name\"><i class='fas fa-question'></i> <b>Encounter:</b></p>`;\n    summaryHtml[0].innerHTML = `<p id=\"ddb-encounter-summary\"><i class='fas fa-question'></i> <b>Summary:</b></p>`;\n    charactersHtml[0].innerHTML = `<p id=\"ddb-encounter-characters\"><i class='fas fa-question'></i> <b>Characters:</b></p>`;\n    monstersHtml[0].innerHTML = `<p id=\"ddb-encounter-monsters\"><i class='fas fa-question'></i> <b>Monsters:</b></p>`;\n    difficultyHtml[0].innerHTML = `<p id=\"ddb-encounter-difficulty\"><i class='fas fa-question'></i> <b>Difficulty:</b></p>`;\n    rewardsHtml[0].innerHTML = `<p id=\"ddb-encounter-rewards\"><i class='fas fa-question'></i> <b>Rewards:</b></p>`;\n    progressHtml[0].innerHTML = `<p id=\"ddb-encounter-progress\"><i class='fas fa-question'></i> <b>In Progress:</b></p>`;\n\n    $(\"#ddb-importer-encounters\").css(\"height\", \"auto\");\n    $(\"#encounter-button\").prop(\"disabled\", true);\n    $(\"#encounter-button\").prop(\"innerText\", \"Import Encounter\");\n    $(\"#encounter-import-policy-use-ddb-save\").prop(\"disabled\", true);\n    this.encounter = {};\n    this.journal = undefined;\n    this.combat = undefined;\n    this.tokens = [];\n  }\n\n  async importMonsters() {\n    const importMonsters = game.settings.get(\"ddb-importer\", \"encounter-import-policy-missing-monsters\");\n\n    if (importMonsters && this.encounter.missingMonsters && this.encounter.missingMonsterIds.length > 0) {\n      logger.debug(\"Importing missing monsters from DDB\");\n      await parseCritters(this.encounter.missingMonsterIds.map((monster) => monster.ddbId));\n      logger.debug(\"Finised Importing missing monsters from DDB\");\n    }\n\n    const monsterPack = checkMonsterCompendium();\n    await monsterPack.getIndex({ fields: [\"name\", \"flags.ddbimporter.id\"] });\n    const compendiumName = getCompendiumLabel(\"monster\");\n\n    let monstersToAddToWorld = [];\n    this.encounter.monsterData = [];\n    this.encounter.worldMonsters = [];\n    let journalMonsterInfo = new Map();\n    this.encounter.monsters.forEach((monster) => {\n      const id = monster.id;\n      const monsterInPack = monsterPack.index.find((f) => f.flags?.ddbimporter?.id == id);\n      if (monsterInPack) {\n        let monsterData = {\n          ddbId: id,\n          name: monsterInPack.name,\n          id: monsterInPack._id,\n          quantity: monster.quantity,\n          journalLink: `@Compendium[${compendiumName}.${monsterInPack.name}]{${monsterInPack.name}}`,\n        };\n        if (journalMonsterInfo.has(monsterData.ddbId)) {\n          monsterData = journalMonsterInfo.get(monsterData.ddbId);\n          monsterData.quantity += monster.quantity;\n        }\n        journalMonsterInfo.set(monsterData.ddbId, monsterData);\n\n        for (let i = 0; i < monster.quantity; i++) {\n          let addData = deepClone(monsterData);\n          addData.quantity = 1;\n          addData.uniqueId = monster.uniqueId;\n          addData.initiative = monster.initiative;\n          addData.currentHitPoints = monster.currentHitPoints;\n          addData.maximumHitPoints = monster.maximumHitPoints;\n          addData.temporaryHitPoints = monster.temporaryHitPoints;\n          addData.ddbName = monster.name ? monster.name : monsterInPack.name;\n          monstersToAddToWorld.push(addData);\n        }\n      }\n    });\n    this.encounter.monsterData = Object.values(journalMonsterInfo);\n\n    const encounterMonsterFolder = await utils.getFolder(\n      \"npc\",\n      this.encounter.name,\n      \"D&D Beyond Encounters\",\n      \"#6f0006\",\n      \"#98020a\",\n      false\n    );\n\n    logger.debug(\"Trying to import monsters from compendium\", monstersToAddToWorld);\n    await Helpers.asyncForEach(monstersToAddToWorld, async (actor) => {\n      let worldActor = game.actors.find(\n        (a) => a.data.folder == encounterMonsterFolder.id && a.data.flags?.ddbimporter?.id == actor.ddbId\n      );\n      if (!worldActor) {\n        logger.info(\n          `Importing monster ${actor.name} with DDB ID ${actor.ddbId} from ${monsterPack.metadata.name} with id ${actor.id}`\n        );\n        try {\n          worldActor = await game.actors.importFromCompendium(monsterPack, actor.id, {\n            folder: encounterMonsterFolder.id,\n          });\n        } catch (err) {\n          logger.error(err);\n          logger.warn(`Unable to import actor ${actor.name} with id ${actor.id} from DDB Compendium`);\n          logger.debug(\n            `Failed on: game.actors.importFromCompendium(monsterCompendium, \"${actor.id}\", { folder: \"${encounterMonsterFolder.id}\" });`\n          );\n        }\n      }\n      this.encounter.worldMonsters.push(mergeObject(actor, { id: worldActor.id }));\n    });\n\n    return new Promise((resolve) => {\n      resolve(this.encounter.worldMonsters);\n    });\n  }\n\n  async importCharacters(html) {\n    const importCharacters = game.settings.get(\"ddb-importer\", \"encounter-import-policy-missing-characters\");\n    if (importCharacters && this.encounter.missingCharacters) {\n      await Helpers.asyncForEach(this.encounter.missingCharacterData, async (character) => {\n        await importCharacterById(character.ddbId, html);\n      });\n    }\n  }\n\n  async createJournalEntry() {\n    logger.debug(`Creating journal entry`);\n    const journal = {\n      name: this.encounter.name,\n      flags: {\n        ddbimporter: {\n          encounterId: this.encounter.id,\n        },\n      },\n    };\n\n    const importJournal = game.settings.get(\"ddb-importer\", \"encounter-import-policy-create-journal\");\n    if (importJournal) {\n      const journalFolder = await utils.getFolder(\n        \"journal\",\n        this.encounter.name,\n        \"D&D Beyond Encounters\",\n        \"#6f0006\",\n        \"#98020a\",\n        false\n      );\n      journal.folder = journalFolder.id;\n      journal.content = `<h1>${this.encounter.name}</h1>`;\n      if (this.encounter.summary && this.encounter.summary != \"\") {\n        journal.content += `<h2>Summary</h2>${this.encounter.summary}`;\n      }\n      if (this.encounter.monsterData && this.encounter.monsterData.length > 0) {\n        journal.content += `<h2>Monsters</h2><ul>`;\n        this.encounter.monsterData.forEach((monster) => {\n          journal.content += `<li><p>${monster.journalLink} x${monster.quantity}</p></li>`;\n        });\n        journal.content += `</ul>`;\n      }\n      if (this.encounter.difficulty && this.encounter.difficulty != \"\") {\n        journal.content += `<h2>Difficulty: <span style=\"color: ${this.encounter.difficulty.color}\">${this.encounter.difficulty.name}</span></h3>`;\n      }\n      if (this.encounter.description && this.encounter.description != \"\") {\n        journal.content += `<h2>Description</h2>${this.encounter.description}`;\n      }\n      if (this.encounter.rewards && this.encounter.rewards != \"\") {\n        journal.content += `<h2>Rewards</h2>${this.encounter.rewards}`;\n      }\n\n      let worldJournal = game.journal.find(\n        (a) => a.data.folder == journalFolder.id && a.data.flags?.ddbimporter?.encounterId == this.encounter.id\n      );\n      if (!worldJournal) {\n        logger.info(`Importing journal ${journal.name}`);\n        try {\n          worldJournal = await JournalEntry.create(journal);\n        } catch (err) {\n          logger.error(err);\n          logger.warn(`Unable to create journal ${journal.name}`);\n        }\n      } else {\n        logger.info(`Updating journal ${journal.name}`);\n        journal._id = worldJournal.id;\n        await worldJournal.update(journal);\n      }\n      this.journal = worldJournal;\n    }\n\n    return new Promise((resolve) => {\n      resolve(journal);\n    });\n  }\n\n\n  async createNewScene() {\n    this.folders[\"scene\"] = await utils.getFolder(\n      \"scene\",\n      this.encounter.name,\n      \"D&D Beyond Encounters\",\n      \"#6f0006\",\n      \"#98020a\",\n      false\n    );\n\n    let sceneData = {\n      name: this.encounter.name,\n      flags: {\n        ddbimporter: {\n          encounterId: this.encounter.id,\n          encounters: true,\n        },\n      },\n      width: 1000,\n      height: 1000,\n      grid: 100,\n      padding: 0.25,\n      initial: {\n        x: 500,\n        y: 500,\n        scale: 0.57,\n      },\n      img: this.img,\n      tokenVision: false,\n      fogExploration: false,\n      folder: this.folders[\"scene\"].id,\n    };\n\n    return sceneData;\n\n  }\n\n  async createScene() {\n    const importDDBIScene = game.settings.get(\"ddb-importer\", \"encounter-import-policy-create-scene\");\n    const useExistingScene = game.settings.get(\"ddb-importer\", \"encounter-import-policy-existing-scene\");\n\n    let sceneData; \n    let worldScene;\n\n    if (importDDBIScene) {\n      logger.debug(`Creating scene for encounter \"${this.encounter.name}\"\"`);\n      sceneData = await this.createNewScene();\n    } else if (useExistingScene) {\n      worldScene = game.scenes.find((s) => s.id == this.sceneId);\n      if (worldScene) {\n        logger.debug(`Using existing scene \"${worldScene.data.name}\" for encounter \"${this.encounter.name}\"\"`);\n        sceneData = worldScene.toObject();\n      } else {\n        logger.warn(`Unable to find scene ${this.sceneId}, creating a new scene `);\n        throw new Error(`Unable to find scene ${this.sceneId}, creating a new scene `);\n      }\n      this.scene = worldScene;\n    }\n\n    if (sceneData) {\n      let tokenData = [];\n      const useDDBSave =\n        this.encounter.inProgress && game.settings.get(\"ddb-importer\", \"encounter-import-policy-use-ddb-save\");\n      const xSquares = sceneData.width / sceneData.grid;\n      const ySquares = sceneData.height / sceneData.grid;\n      const midSquareOffset = sceneData.grid / 2;\n      const widthPaddingOffset = sceneData.width * sceneData.padding;\n      const heightPaddingOffset = sceneData.height * sceneData.padding;\n      const xPCOffset = sceneData.grid * (xSquares - 1);\n      const xStartPixelMonster = widthPaddingOffset + midSquareOffset;\n      const xStartPixelPC = xStartPixelMonster + xPCOffset;\n      const yStartPixel = heightPaddingOffset + midSquareOffset;\n      let characterCount = 0;\n      this.encounter.characters\n        .filter((character) => !character.hidden)\n        .forEach(async (character) => {\n          logger.info(`Generating token ${character.name} for ${this.encounter.name}`);\n          const characterInGame = game.actors.find(\n            (actor) =>\n              actor.data.flags?.ddbimporter?.dndbeyond?.characterId &&\n              actor.data.flags.ddbimporter.dndbeyond.characterId == character.id\n          );\n          if (characterInGame) {\n            const onScene = useExistingScene && worldScene.data.tokens\n              .some((t) => t.actor.data?.flags?.ddbimporter?.id == character.id && t.actor.type == \"character\");\n\n            if (!onScene) {\n              const linkedToken = JSON.parse(JSON.stringify(await characterInGame.getTokenData()));\n              if (useDDBSave) {\n                setProperty(linkedToken, \"flags.ddbimporter.dndbeyond.initiative\", character.initiative);\n              }\n              setProperty(linkedToken, \"actorData.flags.ddbimporter.encounters\", true);\n              setProperty(linkedToken, \"actorData.flags.ddbimporter.encounterId\", this.encounter.id);\n              linkedToken.x = xStartPixelPC;\n              const yOffsetChange = characterCount * sceneData.grid;\n              linkedToken.y = yStartPixel + yOffsetChange;\n              tokenData.push(linkedToken);\n              characterCount++;\n            }\n          }\n        });\n\n      let monsterDepth = 0;\n      let monsterRows = 0;\n      let rowMonsterWidth = 1;\n      this.encounter.worldMonsters.forEach(async (worldMonster) => {\n        logger.info(`Generating token ${worldMonster.ddbName} (${worldMonster.name}) for ${this.encounter.name}`);\n        const monster = game.actors.get(worldMonster.id);\n        const linkedToken = JSON.parse(JSON.stringify(await monster.getTokenData()));\n        if (monsterDepth + linkedToken.height > ySquares) {\n          monsterDepth = 0;\n          monsterRows += rowMonsterWidth;\n          rowMonsterWidth = 1;\n        }\n\n        setProperty(linkedToken, \"name\", worldMonster.ddbName);\n        setProperty(linkedToken, \"actorData.name\", worldMonster.ddbName);\n        setProperty(linkedToken, \"flags.ddbimporter.dndbeyond.uniqueId\", worldMonster.uniqueId);\n        setProperty(linkedToken, \"flags.ddbimporter.encounterId\", this.encounter.id);\n        setProperty(linkedToken, \"actorData.flags.ddbimporter.dndbeyond.uniqueId\", worldMonster.uniqueId);\n        setProperty(linkedToken, \"actorData.flags.ddbimporter.encounters\", true);\n        setProperty(linkedToken, \"actorData.flags.ddbimporter.encounterId\", this.encounter.id);\n        const xOffsetChange = sceneData.grid * monsterRows;\n        const yOffsetChange = monsterDepth * sceneData.grid;\n        linkedToken.x = xStartPixelMonster + xOffsetChange;\n        linkedToken.y = yStartPixel + yOffsetChange;\n        if (useDDBSave) {\n          setProperty(linkedToken, \"flags.ddbimporter.dndbeyond.initiative\", worldMonster.initiative);\n          // if no hp changes have been made on a monster on ddb it says 0 here\n          if (worldMonster.maximumHitPoints !== 0) {\n            setProperty(linkedToken, \"actorData.data.attributes.hp.max\", worldMonster.maximumHitPoints);\n            setProperty(\n              linkedToken,\n              \"actorData.data.attributes.hp.value\",\n              worldMonster.currentHitPoints + worldMonster.temporaryHitPoints\n            );\n          }\n        }\n\n        tokenData.push(linkedToken);\n        monsterDepth += linkedToken.height;\n        if (linkedToken.width > rowMonsterWidth) rowMonsterWidth = linkedToken.width;\n      });\n\n      if (this.journal?.id) sceneData.journal = this.journal.id;\n\n      if (importDDBIScene) {\n        worldScene = game.scenes.find(\n          (a) => a.data.folder == this.folders[\"scene\"].id &&\n          a.data.flags?.ddbimporter?.encounterId == this.encounter.id\n        );\n      }\n\n      if (worldScene) {\n        logger.info(`Updating scene ${sceneData.name}`);\n        await Combat.deleteDocuments(game.combats.filter((c) => c.scene.id == worldScene.id).map((c) => c.id));\n        if (importDDBIScene) {\n          logger.info(`Updating DDBI scene ${sceneData.name}`);\n          sceneData._id = worldScene.id;\n          await worldScene.deleteEmbeddedDocuments(\"Token\", [], { deleteAll: true });\n          await Scene.update(mergeObject(worldScene.data.toObject(), sceneData));\n        } else if (useExistingScene) {\n          logger.info(`Checking existing scene ${sceneData.name} for encounter monsters`);\n          const existingSceneMonsterIds = worldScene.data.tokens\n            .filter((t) => t.data?.flags?.ddbimporter?.encounterId == this.encounter.id && t.actor.type == \"npc\")\n            .map((t) => t.id);\n          await worldScene.deleteEmbeddedDocuments(\"Token\", existingSceneMonsterIds);\n        }\n      } else if (importDDBIScene) {\n        logger.info(`Importing scene ${sceneData.name}`);\n        try {\n          // eslint-disable-next-line require-atomic-updates\n          worldScene = await Scene.create(sceneData);\n        } catch (err) {\n          logger.error(err);\n          logger.warn(`Unable to create scene ${sceneData.name}`);\n        }\n      }\n\n      const thumbData = await worldScene.createThumbnail();\n      const thumbScene = worldScene.data.toObject();\n      thumbScene[\"thumb\"] = thumbData.thumb;\n\n      // eslint-disable-next-line require-atomic-updates\n      worldScene = await worldScene.update(thumbScene, { keepId: true });\n\n      await worldScene.createEmbeddedDocuments(\"Token\", tokenData);\n\n      this.scene = worldScene;\n    }\n\n    return new Promise((resolve) => {\n      resolve(this.scene);\n    });\n  }\n\n  async createCombatEncounter() {\n    const importCombat = game.settings.get(\"ddb-importer\", \"encounter-import-policy-create-scene\") ||\n      game.settings.get(\"ddb-importer\", \"encounter-import-policy-existing-scene\");\n\n    if (!importCombat) return undefined;\n    logger.debug(`Creating combat for encounter ${this.encounter.name}`);\n\n    const useDDBSave =\n      this.encounter.inProgress && game.settings.get(\"ddb-importer\", \"encounter-import-policy-use-ddb-save\");\n\n    await this.scene.view();\n    this.combat = await Combat.create({ scene: this.scene.id });\n    await this.combat.activate();\n\n    let toCreate = [];\n    const tokens = canvas.tokens.placeables\n      .filter((t) => t.data?.flags?.ddbimporter?.encounterId == this.encounter.id || t.actor.type == \"character\");\n    if (tokens.length) {\n      tokens.forEach((t) => {\n        let combatant = { tokenId: t.id, actorId: t.data.actorId, hidden: t.data.hidden };\n        if (useDDBSave && t.data.flags.ddbimporter?.dndbeyond?.initiative)\n          combatant.initiative = t.data.flags.ddbimporter.dndbeyond.initiative;\n        if (!t.inCombat) toCreate.push(combatant);\n      });\n      const combatants = await this.combat.createEmbeddedDocuments(\"Combatant\", toCreate);\n\n      const rollMonsterInitiative = game.settings.get(\n        \"ddb-importer\",\n        \"encounter-import-policy-roll-monster-initiative\"\n      );\n      combatants\n        .filter((c) => rollMonsterInitiative && c.actor.type === \"npc\" && c.initiative === null)\n        .forEach(async (c) => {\n          if (c.initiative === null) await this.combat.rollInitiative(c.id);\n        });\n    }\n\n    return this.combat;\n  }\n\n  activateListeners(html) {\n    super.activateListeners(html);\n\n    $(html)\n      .find(\n        ['.munching-generic-config input[type=\"checkbox\"]', '.munching-monster-config input[type=\"checkbox\"]'].join(\",\")\n      )\n      .on(\"change\", (event) => {\n        updateMuncherSettings(html, event);\n      });\n\n    $(html)\n      .find(\n        [\n          '.import-policy input[type=\"checkbox\"]',\n          '.advanced-import-config input[type=\"checkbox\"]',\n          '.effect-policy input[type=\"checkbox\"]',\n          '.effect-import-config input[type=\"checkbox\"]',\n          '.extras-import-config input[type=\"checkbox\"]',\n          '.import-config input[type=\"checkbox\"]',\n        ].join(\",\")\n      )\n      .on(\"change\", (event) => {\n        updateActorSettings(html, event);\n      });\n\n    $(html)\n      .find(\"#default-effects\")\n      .on(\"click\", async (event) => {\n        event.preventDefault();\n        setRecommendedCharacterActiveEffectSettings(html);\n      });\n\n    $(html)\n      .find('.sync-policy input[type=\"checkbox\"]')\n      .on(\"change\", (event) => {\n        game.settings.set(\n          \"ddb-importer\",\n          \"sync-policy-\" + event.currentTarget.dataset.section,\n          event.currentTarget.checked\n        );\n      });\n\n    $(html)\n      .find('.encounter-config input[type=\"checkbox\"]')\n      .on(\"change\", (event) => {\n        switch (event.currentTarget.dataset.section) {\n          case \"create-scene\": {\n            game.settings.set(\"ddb-importer\", \"encounter-import-policy-existing-scene\", false);\n            if (event.currentTarget.checked) $(\"#encounter-scene-select\").prop(\"disabled\", true);\n            $(\"#encounter-scene-img-select\").prop(\"disabled\", !event.currentTarget.checked);\n            $(\"#encounter-import-policy-existing-scene\").prop('checked', false);\n            break;\n          }\n          case \"existing-scene\": {\n            game.settings.set(\"ddb-importer\", \"encounter-import-policy-create-scene\", false);\n            if (event.currentTarget.checked) $(\"#encounter-scene-img-select\").prop(\"disabled\", true);\n            $(\"#encounter-scene-select\").prop(\"disabled\", !event.currentTarget.checked);\n            $(\"#encounter-import-policy-create-scene\").prop('checked', false);\n            break;\n          }\n          // no default\n        };\n        game.settings.set(\n          \"ddb-importer\",\n          \"encounter-import-policy-\" + event.currentTarget.dataset.section,\n          event.currentTarget.checked\n        );\n      });\n\n    // img change\n    html.find(\"#encounter-scene-img-select\").on(\"change\", async () => {\n      const imgSelect = html.find(\"#encounter-scene-img-select\");\n      this.img = imgSelect[0].selectedOptions[0] ? imgSelect[0].selectedOptions[0].value : \"\";\n    });\n\n    html.find(\"#encounter-scene-select\").on(\"change\", async () => {\n      const imgSelect = html.find(\"#encounter-scene-select\");\n      this.sceneId = imgSelect[0].selectedOptions[0] ? imgSelect[0].selectedOptions[0].value : \"\";\n    });\n\n    // filter campaigns\n    html.find(\"#encounter-campaign-select\").on(\"change\", async () => {\n      const campaignSelection = html.find(\"#encounter-campaign-select\");\n      // get selected campaign from html selection\n      const campaignId = campaignSelection[0].selectedOptions[0]\n        ? campaignSelection[0].selectedOptions[0].value\n        : undefined;\n      const encounters = await filterEncounters(campaignId);\n      const campaignSelected = campaignId && campaignId !== \"\";\n      let encounterList = `<option value=\"\">Select encounter:</option>`;\n      encounters.forEach((encounter) => {\n        encounterList += `<option value=\"${encounter.id}\">${encounter.name}${\n          campaignSelected ? \"\" : ` (${encounter.campaign.name})`\n        }</option>\\n`;\n      });\n      const list = html.find(\"#encounter-select\");\n      list[0].innerHTML = encounterList;\n      this.resetEncounter(html);\n    });\n\n    // encounter change\n    html.find(\"#encounter-select\").on(\"change\", async () => {\n      this.resetEncounter(html);\n      const encounterSelection = html.find(\"#encounter-select\");\n      const encounterId = encounterSelection[0].selectedOptions[0]\n        ? encounterSelection[0].selectedOptions[0].value\n        : undefined;\n\n      const encounter = await this.parseEncounter(encounterId);\n      // console.warn(encounter);\n\n      const nameHtml = html.find(\"#ddb-encounter-name\");\n      const summaryHtml = html.find(\"#ddb-encounter-summary\");\n      const charactersHtml = html.find(\"#ddb-encounter-characters\");\n      const monstersHtml = html.find(\"#ddb-encounter-monsters\");\n      const difficultyHtml = html.find(\"#ddb-encounter-difficulty\");\n      const rewardsHtml = html.find(\"#ddb-encounter-rewards\");\n      const progressHtml = html.find(\"#ddb-encounter-progress\");\n\n      const missingCharacters = encounter.missingCharacters\n        ? `fa-times-circle' style='color: red`\n        : `fa-check-circle' style='color: green`;\n      const missingMonsters = encounter.missingMonsters\n        ? `fa-times-circle' style='color: red`\n        : `fa-check-circle' style='color: green`;\n\n      const goodCharacters = encounter.goodCharacterData.map((character) => `${character.name}`).join(\", \");\n      const goodMonsters = encounter.goodMonsterIds.map((monster) => `${monster.name}`).join(\", \");\n      const neededCharactersHTML = encounter.missingCharacters\n        ? ` <span style=\"color: red\"> Missing ${\n          encounter.missingCharacterData.length\n        }: ${encounter.missingCharacterData.map((character) => character.name).join(\", \")}</span>`\n        : \"\";\n      const neededMonstersHTML = encounter.missingMonsters\n        ? ` <span style=\"color: red\"> Missing ${\n          encounter.missingMonsterIds.length\n        }. DDB Id's: ${encounter.missingMonsterIds.map((monster) => monster.ddbId).join(\", \")}</span>`\n        : \"\";\n\n      nameHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Encounter:</b> ${encounter.name}`;\n      if (encounter.summary && encounter.summary.trim() !== \"\") {\n        summaryHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Summary:</b> ${encounter.summary}`;\n      }\n      if (encounter.goodCharacterData.length > 0 || encounter.missingCharacterData.length > 0) {\n        charactersHtml[0].innerHTML = `<i class='fas ${missingCharacters}'></i> <b>Characters:</b> ${goodCharacters}${neededCharactersHTML}`;\n      }\n      if (encounter.goodMonsterIds.length > 0 || encounter.missingMonsterIds.length > 0) {\n        monstersHtml[0].innerHTML = `<i class='fas ${missingMonsters}'></i> <b>Monsters:</b> ${goodMonsters}${neededMonstersHTML}`;\n      }\n      difficultyHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Difficulty:</b> <span style=\"color: ${encounter.difficulty.color}\">${encounter.difficulty.name}</span>`;\n      if (encounter.rewards && encounter.rewards.trim() !== \"\") {\n        rewardsHtml[0].innerHTML = `<i class='fas fa-check-circle' style='color: green'></i> <b>Rewards:</b> ${encounter.rewards}`;\n      }\n\n      progressHtml[0].innerHTML = encounter.inProgress\n        ? `<i class='fas fa-times-circle' style='color: red'></i> <b>In Progress:</b> <span style=\"color: red\"> Encounter in progress on <a href=\"https://www.dndbeyond.com/combat-tracker/${this.encounter.id}\">D&D Beyond!</a></span>`\n        : `<i class='fas fa-check-circle' style='color: green'></i> <b>In Progress:</b> No`;\n\n      $(\"#encounter-import-policy-use-ddb-save\").prop(\"disabled\", !encounter.inProgress);\n      $(\"#ddb-importer-encounters\").css(\"height\", \"auto\");\n      $(\"#encounter-button\").prop(\"disabled\", false);\n    });\n\n    // import encounter\n    html.find(\"#encounter-button\").click(async (event) => {\n      event.preventDefault();\n      $(\"#encounter-button\").prop(\"disabled\", true);\n      $(\"#encounter-button\").prop(\"innerText\", \"Munching...\");\n\n      await this.importMonsters();\n      await this.importCharacters(html);\n      await this.createJournalEntry();\n      await this.createScene();\n      await this.createCombatEncounter();\n\n      // to do:\n      // adjust monsters hp?\n      // add initiative if combat in progress?\n      // - extra import?\n      // - attempt to find magic items and add them to the world?\n\n      $(\"#encounter-button\").prop(\"innerText\", \"Encounter Munched\");\n      const campaignFluff =\n        this.encounter.campaign?.name && this.encounter.campaign.name.trim() !== \"\" ? ` of ${this.encounter.name}` : \"\";\n      ui.notifications.warn(`Prepare to battle heroes${campaignFluff}, your doom awaits in ${this.encounter.name}!`);\n    });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async getData() {\n    const tier = game.settings.get(\"ddb-importer\", \"patreon-tier\");\n    const tiers = getPatreonTiers(tier);\n    const availableCampaigns = await getAvailableCampaigns();\n    const availableEncounters = await filterEncounters();\n\n    const characterSettings = getCharacterImportSettings();\n    const muncherSettings = getMuncherSettings(false);\n\n    const importSettings = mergeObject(characterSettings, muncherSettings);\n\n    const encounterConfig = [\n      {\n        name: \"missing-characters\",\n        isChecked: game.settings.get(\"ddb-importer\", \"encounter-import-policy-missing-characters\"),\n        enabled: true,\n        description: \"Import missing characters?\",\n      },\n      {\n        name: \"missing-monsters\",\n        isChecked: game.settings.get(\"ddb-importer\", \"encounter-import-policy-missing-monsters\"),\n        enabled: true,\n        description: \"Import missing monsters?\",\n      },\n      {\n        name: \"create-journal\",\n        isChecked: game.settings.get(\"ddb-importer\", \"encounter-import-policy-create-journal\"),\n        enabled: true,\n        description: \"Create encounter journal entry?\",\n      },\n      {\n        name: \"use-ddb-save\",\n        isChecked: game.settings.get(\"ddb-importer\", \"encounter-import-policy-use-ddb-save\"),\n        enabled: false,\n        description: \"Use save information from Encounter (HP for monsters and initiative for all)?\",\n      },\n      {\n        name: \"create-scene\",\n        isChecked: game.settings.get(\"ddb-importer\", \"encounter-import-policy-create-scene\"),\n        enabled: true,\n        description: \"Create/update a scene to use, and add available characters and NPC's?\",\n      },\n      {\n        name: \"existing-scene\",\n        isChecked: game.settings.get(\"ddb-importer\", \"encounter-import-policy-existing-scene\"),\n        enabled: true,\n        description: \"Use an existing scene?\",\n      },\n    ];\n\n    const scenes = game.scenes.filter((scene) => !scene.data.flags?.ddbimporter?.encounters)\n      .map((scene) => {\n        const folderName = scene.folder ? `[${scene.folder.name}] ` : \"\";\n        const s = {\n          name: `${folderName}${scene.name}`,\n          id: scene.id,\n        };\n        return s;\n      })\n      .sort((a, b) => a.name.localeCompare(b.name));\n\n    const encounterSettings = {\n      tiers,\n      availableCampaigns,\n      availableEncounters,\n      encounterConfig,\n      sceneImg: SCENE_IMG,\n      scenes,\n      createSceneSelect: game.settings.get(\"ddb-importer\", \"encounter-import-policy-create-scene\"),\n      existingSceneSelect: game.settings.get(\"ddb-importer\", \"encounter-import-policy-existing-scene\"),\n    };\n\n    const data = mergeObject(importSettings, encounterSettings);\n    logger.debug(\"Encounter muncher form data\", data);\n\n    return data;\n  }\n}\n","import logger from '../../logger.js';\n\nlet sanitize = (text) => {\n  if (text && typeof text === \"string\") {\n    return text.replace(/\\s/g, '-').toLowerCase();\n  }\n  return text;\n};\n\nlet createIfNotExists = async (settingName, compendiumType, compendiumLabel) => {\n  const compendiumName = game.settings.get(\"ddb-importer\", settingName);\n  const compendium = await game.packs.get(compendiumName);\n  if (compendium) {\n    logger.info(`Compendium '${compendiumName}' found, will not create compendium.`);\n    return false;\n  } else {\n    logger.info(`Compendium for ${compendiumLabel}, was not found, creating it now.`);\n    const sanitizedLabel = sanitize(compendiumLabel);\n    const name = `ddb-${game.world.data.name}-${sanitizedLabel}`;\n    const defaultCompendium = await game.packs.get(`world.${name}`);\n    if (defaultCompendium) {\n      logger.warn(`Could not load Compendium '${compendiumName}', and could not create default Compendium '${name}' as it already exists. Please check your DDB Importer Compendium setup.`);\n    } else {\n      // create a compendium for the user\n      await CompendiumCollection.createCompendium({\n        entity: compendiumType,\n        label: `DDB ${compendiumLabel}`,\n        name: name,\n        package: \"world\",\n      });\n      await game.settings.set(\"ddb-importer\", settingName, `world.${name}`);\n    }\n    return true;\n  }\n};\n\nexport const ddbCompendiums = [\n  { name: \"entity-spell-compendium\", label: \"Spells\", type: \"Item\" },\n  { name: \"entity-item-compendium\", label: \"Items\", type: \"Item\" },\n  { name: \"entity-monster-compendium\", label: \"Monsters\", type: \"Actor\" },\n  { name: \"entity-feat-compendium\", label: \"Feats\", type: \"Item\" },\n  { name: \"entity-feature-compendium\", label: \"Class Features\", type: \"Item\" },\n  { name: \"entity-class-compendium\", label: \"Classes\", type: \"Item\" },\n  { name: \"entity-trait-compendium\", label: \"Racial Traits\", type: \"Item\" },\n  { name: \"entity-race-compendium\", label: \"Races\", type: \"Item\" },\n  { name: \"entity-override-compendium\", label: \"Override\", type: \"Item\" },\n  { name: \"entity-table-compendium\", label: \"Tables\", type: \"RollTable\" },\n];\n\nexport function getCompendiumNames() {\n  return ddbCompendiums.map((ddbCompendium) => {\n    return game.settings.get(\"ddb-importer\", ddbCompendium.name);\n  });\n}\n\nexport default async function () {\n  const autoCreate = game.settings.get(\"ddb-importer\", \"auto-create-compendium\");\n\n  if (autoCreate) {\n    let promises = [];\n    ddbCompendiums.forEach((compendium) => {\n      promises.push(createIfNotExists(compendium.name, compendium.type, compendium.label));\n    });\n    let results = await Promise.all(promises);\n\n    const reload = results.some((result) => result.value);\n\n    if (reload) {\n      logger.warn(\"RELOADING!\");\n      // location.reload();\n    }\n  }\n\n}\n","// for exports\nimport { parseMonsters } from \"../../muncher/monster/monster.js\";\nimport { parseSpells } from \"../../muncher/spells.js\";\nimport { parseItems } from \"../../muncher/items.js\";\nimport { parseCritters } from \"../../muncher/monsters.js\";\nimport { migrateExistingCompendium, createCompendiumFolderStructure } from \"../../muncher/compendiumFolders.js\";\nimport { parseEncounters, DDBEncounterMunch } from \"../../muncher/encounters.js\";\nimport { generateAdventureConfig } from \"../../muncher/adventure.js\";\nimport { updateDDBCharacter } from \"../../character/update.js\";\nimport { importCharacter, importCharacterById } from \"../../character/import.js\";\nimport { getPatreonTier, getPatreonTiers, setPatreonTier, checkPatreon } from \"../../muncher/utils.js\";\nimport { checkCobalt } from \"../../lib/Secrets.js\";\nimport { base64Check } from \"../../lib/Base64Check.js\";\nimport { getFeats } from \"../../muncher/feats/feats.js\";\nimport { getCompendiumNames } from \"../ready/checkCompendiums.js\";\n\nfunction resetSecrets() {\n  game.settings.set(\"ddb-importer\", \"cobalt-cookie-local\", false);\n  game.settings.set(\"ddb-importer\", \"cobalt-cookie\", \"\");\n  game.settings.set(\"ddb-importer\", \"campaign-id\", \"\");\n}\n\nfunction resetProxy() {\n  game.settings.set(\"ddb-importer\", \"api-endpoint\", \"https://proxy.ddb.mrprimate.co.uk\");\n  game.settings.set(\"ddb-importer\", \"custom-proxy\", false);\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction migrateAllCompendiums(value, key, map) {\n  if (!value.locked) game.dnd5e.migrations.migrateCompendium(value);\n}\n\nfunction migrateCompendiums() {\n  const compendiumNames = getCompendiumNames();\n  game.packs\n    .filter((pack) => compendiumNames.includes(pack.collection))\n    .forEach(migrateAllCompendiums);\n}\n\nexport function registerWindow() {\n  window.DDBImporter = {\n    parseCritters,\n    parseMonsters,\n    parseSpells,\n    parseItems,\n    parseEncounters,\n    generateAdventureConfig,\n    migrateCompendiums,\n    resetProxy,\n    resetSecrets,\n    updateDDBCharacter,\n    getPatreonTier,\n    getPatreonTiers,\n    setPatreonTier,\n    checkPatreon,\n    checkCobalt,\n    DDBEncounterMunch,\n    migrateExistingCompendiumToCompendiumFolders: migrateExistingCompendium,\n    createCompendiumFolderStructure,\n    importCharacter,\n    importCharacterById,\n    parseFeats: getFeats,\n    base64Check: base64Check,\n  };\n}\n","import logger from \"../logger.js\";\n\nexport class DDBAdventureFlags extends FormApplication {\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    options.title = \"DDB Adventure Imported Flags\";\n    options.template = \"modules/ddb-importer/handlebars/flag-details.hbs\";\n    options.classes = [\"ddb-importer-flags\", \"sheet\"];\n    options.width = 800;\n    return options;\n  }\n\n  /** @override */\n  async getData() { // eslint-disable-line class-methods-use-this\n    // console.warn(this);\n    // console.warn(this.object);\n    let item = this.object.data;\n\n    let flags = {};\n\n    const flagGroups = [\"ddb\", \"ddbimporter\", \"monsterMunch\", \"ddb-importer\"];\n    const ignoredSubFlagGroups = [\"ddbimporter.acEffects\", \"ddbimporter.autoAC\"];\n\n    function generateFlagLookup(flagData, flagName, flagGroupName) {\n      logger.debug(`FlagName ${flagName}, flagGroupName ${flagGroupName}`, flagData);\n      for (const flagKey in flagData) {\n        logger.debug(\"flagkey\", flagKey);\n        const flagValue = (flagKey === \"userData\") ? flagData[flagKey][\"userDisplayName\"] : flagData[flagKey];\n        const flagGroupSubName = `${flagGroupName}.${flagKey}`;\n        if (typeof flagValue === \"object\" && !ignoredSubFlagGroups.includes(flagGroupName) && !Array.isArray(flagValue)) {\n          logger.info(`recursive generateFlag call for ${flagName}`);\n          generateFlagLookup(flagValue, flagKey, flagGroupSubName);\n        } else if (!ignoredSubFlagGroups.includes(flagGroupName) && !ignoredSubFlagGroups.includes(flagGroupSubName)) {\n          if (!flags[flagGroupName]) flags[flagGroupName] = [];\n          flags[flagGroupName].push({\n            key: flagKey,\n            value: Array.isArray(flagValue) ? JSON.stringify(flagValue) : flagValue,\n          });\n        }\n      }\n    };\n\n    flagGroups.forEach((flagGroup) => {\n      logger.debug(`Flag group ${flagGroup}`, item.flags);\n      generateFlagLookup(item.flags[flagGroup], flagGroup, flagGroup);\n    });\n\n    const result = {\n      name: item.name,\n      flags,\n    };\n\n    if (item.link) result[\"link\"] = item.link;\n    if (flags.bookCode && flags.slug) result[\"ddbLink\"] = `https://www.dndbeyond.com/${flags.bookCode}/${flags.slug}`;\n\n    logger.debug(\"flags\", flags);\n    return result;\n  }\n\n}\n","import CharacterImport from \"../../character/import.js\";\nimport logger from \"../../logger.js\";\nimport { DDBSetup, isSetupComplete } from \"../../lib/Settings.js\";\nimport { DDBAdventureFlags } from \"../../lib/adventureFlags.js\";\n\nconst API_ENDPOINT = \"https://character-service.dndbeyond.com/character/v5/character/\";\n// reference to the D&D Beyond popup\nconst POPUPS = {\n  json: null,\n  web: null,\n};\nconst renderPopup = (type, url) => {\n  if (POPUPS[type] && !POPUPS[type].close) {\n    POPUPS[type].focus();\n    POPUPS[type].location.href = url;\n  } else {\n    const ratio = window.innerWidth / window.innerHeight;\n    const width = Math.round(window.innerWidth * 0.5);\n    const height = Math.round(window.innerWidth * 0.5 * ratio);\n    POPUPS[type] = window.open(\n      url,\n      \"ddb_sheet_popup\",\n      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`\n    );\n  }\n  return true;\n};\n\nexport default function () {\n  /**\n   * Character sheets\n   */\n  const pcSheetNames = Object.values(CONFIG.Actor.sheetClasses.character)\n    .map((sheetClass) => sheetClass.cls)\n    .map((sheet) => sheet.name);\n\n  const trustedUsersOnly = game.settings.get(\"ddb-importer\", \"restrict-to-trusted\");\n  const allowAllSync = game.settings.get(\"ddb-importer\", \"allow-all-sync\");\n  const characterLink = game.settings.get(\"ddb-importer\", \"character-link-title\");\n  const monsterLink = game.settings.get(\"ddb-importer\", \"monster-link-title\");\n  const whiteTitle = (game.settings.get(\"ddb-importer\", \"link-title-colour-white\")) ? \" white\" : \"\";\n\n  pcSheetNames.forEach((sheetName) => {\n    Hooks.on(\"render\" + sheetName, (app, html, data) => {\n      // only for GMs or the owner of this character\n      if (!data.owner || !data.actor || (!allowAllSync && trustedUsersOnly && !game.user.isTrusted)) return;\n\n      let url = null;\n      if (app.document.data.flags.ddbimporter?.dndbeyond?.url) {\n        url = app.document.data.flags.ddbimporter.dndbeyond.url;\n      }\n\n      let jsonURL = null;\n      if (app.document.data.flags.ddbimporter?.dndbeyond?.json) {\n        jsonURL = app.document.data.flags.ddbimporter.dndbeyond.json;\n      }\n\n      let button;\n\n      if (characterLink) {\n        button = $(`<a class=\"ddb-open-url\" title=\"DDB Importer\"><i class=\"fab fa-d-and-d-beyond${whiteTitle}\"></i></a>`);\n      } else {\n        // don't add the button multiple times\n        if ($(html).find(\"#ddbImporterButton\").length > 0) return;\n        button = $('<button type=\"button\" id=\"ddbImporterButton\" class=\"inactive\"><i class=\"fab fa-d-and-d-beyond\"></button>');\n        if (app.document.data.flags.ddbimporter?.dndbeyond?.url) button.removeClass(\"inactive\");\n      }\n\n      button.click((event) => {\n        if (event.shiftKey && event.ctrlKey) {\n          new DDBAdventureFlags(app.document, {}).render(true);\n        } else if (event.shiftKey) {\n          event.preventDefault();\n          return renderPopup(\"web\", url);\n        } else if (event.altKey && jsonURL) {\n          event.preventDefault();\n          return renderPopup(\"json\", jsonURL);\n        } else if (event.altKey && !jsonURL) {\n          // get the character ID\n          const characterId = url.split(\"/\").pop();\n          if (characterId) {\n            event.preventDefault();\n            return renderPopup(\"json\", API_ENDPOINT + characterId);\n          }\n        } else if ((!event.shiftKey && !event.ctrlKey && !event.altKey) || url === null) {\n          const setupComplete = isSetupComplete(false);\n\n          if (setupComplete) {\n            let characterImport = new CharacterImport(CharacterImport.defaultOptions, data.actor);\n            characterImport.render(true);\n          } else {\n            new DDBSetup().render(true);\n          }\n\n          return true;\n        }\n\n        return false;\n      });\n\n      if (characterLink) {\n        html.closest('.app').find('.ddb-open-url').remove();\n        let titleElement = html.closest('.app').find('.window-title');\n        if (!app._minimized) button.insertAfter(titleElement);\n      } else {\n        let wrap = $('<div class=\"ddbCharacterName\"></div>');\n        $(html).find(\"input[name='name']\").wrap(wrap);\n        $(html).find(\"input[name='name']\").parent().prepend(button);\n      }\n    });\n  });\n\n\n  /**\n   * NPC sheets\n   */\n  const npcSheetNames = Object.values(CONFIG.Actor.sheetClasses.npc)\n    .map((sheetClass) => sheetClass.cls)\n    .map((sheet) => sheet.name);\n\n  npcSheetNames.forEach((sheetName) => {\n    Hooks.on(\"render\" + sheetName, (app, html, data) => {\n      // only for GMs or the owner of this npc\n      if (!data.owner || !data.actor) return;\n      if (!app.document.data.flags?.monsterMunch?.url) return;\n      let url = app.document.data.flags.monsterMunch.url;\n\n      let button;\n\n      if (monsterLink) {\n        button = $(`<a class=\"ddb-open-url\" title=\"D&D Beyond\"><i class=\"fab fa-d-and-d-beyond${whiteTitle}\"></i></a>`);\n      } else {\n        // don't add the button multiple times\n        if ($(html).find(\"#ddbImporterButton\").length > 0) return;\n        button = $('<button type=\"button\" id=\"ddbImporterButton\"><i class=\"fab fa-d-and-d-beyond\"></button>');\n      }\n\n      // eslint-disable-next-line no-unused-vars\n      button.click((event) => {\n        if (event.shiftKey && event.ctrlKey) {\n          new DDBAdventureFlags(app.document, {}).render(true);\n        } else {\n          logger.debug(`Clicked for url ${url}`);\n          renderPopup(\"web\", url);\n        }\n      });\n\n      if (monsterLink) {\n        html.closest('.app').find('.ddb-open-url').remove();\n        let titleElement = html.closest('.app').find('.window-title');\n        if (!app._minimized) button.insertAfter(titleElement);\n      } else {\n        let wrap = $('<div class=\"ddbCharacterName\"></div>');\n        $(html).find(\"input[name='name']\").wrap(wrap);\n        $(html).find(\"input[name='name']\").parent().prepend(button);\n      }\n    });\n  });\n}\n","import { DirectoryPicker } from \"../../lib/DirectoryPicker.js\";\nimport { DDBSetup, DDBCompendiumSetup, DDBDynamicUpdateSetup } from \"../../lib/Settings.js\";\nimport logger from \"../../logger.js\";\n\nCONFIG.DDBI = {\n  module: \"DDB Muncher\",\n  schemaVersion: \"1.1\",\n  ADVENTURE: {},\n};\n\nexport default function () {\n\n  game.settings.registerMenu(\"ddb-importer\", 'setupMenu', {\n    name: \"ddb-importer.setup.name\",\n    label: \"ddb-importer.setup.name\",\n    hint: \"ddb-importer.setup.hint\",\n    icon: 'fas fa-wrench',\n    type: DDBSetup,\n    restricted: true\n  });\n\n  game.settings.registerMenu(\"ddb-importer\", 'compendiumMenu', {\n    name: \"ddb-importer.compendium-setup.name\",\n    label: \"ddb-importer.compendium-setup.name\",\n    hint: \"ddb-importer.compendium-setup.hint\",\n    icon: 'fas fa-wrench',\n    type: DDBCompendiumSetup,\n    restricted: true\n  });\n\n  game.settings.registerMenu(\"ddb-importer\", 'dynamicUpdateMenu', {\n    name: \"ddb-importer.dynamic-update-setup.name\",\n    label: \"ddb-importer.dynamic-update-setup.name\",\n    hint: \"ddb-importer.dynamic-update-setup.hint\",\n    icon: 'fas fa-wrench',\n    type: DDBDynamicUpdateSetup,\n    restricted: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"image-upload-directory\", {\n    name: \"ddb-importer.image-upload-directory.name\",\n    hint: \"ddb-importer.image-upload-directory.hint\",\n    scope: \"world\",\n    config: false,\n    type: DirectoryPicker.Directory,\n    default: \"[data] ddb-images/characters\",\n  });\n\n  game.settings.register(\"ddb-importer\", \"other-image-upload-directory\", {\n    name: \"ddb-importer.image-upload-directory.name\",\n    hint: \"ddb-importer.image-upload-directory.hint\",\n    scope: \"world\",\n    config: false,\n    type: DirectoryPicker.Directory,\n    default: \"[data] ddb-images/other\",\n  });\n\n  if (game.user.isGM) {\n    const characterUploads = game.settings.get(\"ddb-importer\", \"image-upload-directory\");\n    const otherUploads = game.settings.get(\"ddb-importer\", \"other-image-upload-directory\");\n    if (characterUploads !== \"[data] ddb-images/characters\" && otherUploads === \"[data] ddb-images/other\") {\n      game.settings.set(\"ddb-importer\", \"other-image-upload-directory\", characterUploads);\n    } else {\n      DirectoryPicker.verifyPath(DirectoryPicker.parse(otherUploads));\n    }\n    DirectoryPicker.verifyPath(DirectoryPicker.parse(characterUploads));\n  }\n\n  game.settings.register(\"ddb-importer\", \"frame-image-upload-directory\", {\n    name: \"ddb-importer.frame-upload-directory.name\",\n    hint: \"ddb-importer.frame-upload-directory.hint\",\n    scope: \"world\",\n    config: false,\n    type: DirectoryPicker.Directory,\n    default: \"[data] ddb-images/frames\",\n  });\n\n  if (game.user.isGM) {\n    const frameUploads = game.settings.get(\"ddb-importer\", \"frame-image-upload-directory\");\n    DirectoryPicker.verifyPath(DirectoryPicker.parse(frameUploads));\n  }\n\n  game.settings.register(\"ddb-importer\", \"settings-call-muncher\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"update-check\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"allow-scene-download\", {\n    name: \"ddb-importer.allow-scene-download.name\",\n    hint: \"ddb-importer.allow-scene-download.hint\",\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"allow-third-party-scene-download\", {\n    name: \"ddb-importer.allow-third-party-scene-download.name\",\n    hint: \"ddb-importer.allow-third-party-scene-download.hint\",\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"allow-note-generation\", {\n    name: \"ddb-importer.allow-note-generation.name\",\n    hint: \"ddb-importer.allow-note-generation.hint\",\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"auto-create-compendium\", {\n    name: \"ddb-importer.auto-create-compendium.name\",\n    hint: \"ddb-importer.auto-create-compendium.hint\",\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"use-full-source\", {\n    name: \"ddb-importer.use-full-source.name\",\n    hint: \"ddb-importer.use-full-source.hint\",\n    scope: \"world\",\n    config: true,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"use-damage-hints\", {\n    name: \"ddb-importer.use-damage-hints.name\",\n    hint: \"ddb-importer.use-damage-hints.hint\",\n    scope: \"world\",\n    config: true,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"add-damage-restrictions-to-hints\", {\n    name: \"ddb-importer.add-damage-restrictions-to-hints.name\",\n    hint: \"ddb-importer.add-damage-restrictions-to-hints.hint\",\n    scope: \"world\",\n    config: true,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"restrict-to-trusted\", {\n    name: \"ddb-importer.restrict-to-trusted.name\",\n    hint: \"ddb-importer.restrict-to-trusted.hint\",\n    scope: \"world\",\n    config: true,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"allow-all-sync\", {\n    name: \"ddb-importer.allow-all-sync.name\",\n    hint: \"ddb-importer.allow-all-sync.hint\",\n    scope: \"world\",\n    config: true,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"monster-link-title\", {\n    name: \"ddb-importer.monster-link-title.name\",\n    hint: \"ddb-importer.monster-link-title.hint\",\n    scope: \"world\",\n    config: true,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-link-title\", {\n    name: \"ddb-importer.character-link-title.name\",\n    hint: \"ddb-importer.character-link-title.hint\",\n    scope: \"world\",\n    config: true,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"link-title-colour-white\", {\n    name: \"ddb-importer.link-title-colour-white.name\",\n    hint: \"ddb-importer.link-title-colour-white.hint\",\n    scope: \"world\",\n    config: true,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"show-munch-top\", {\n    name: \"ddb-importer.show-munch-top.name\",\n    hint: \"ddb-importer.show-munch-top.hint\",\n    scope: \"world\",\n    config: true,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"entity-item-compendium\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n  });\n\n  game.settings.register(\"ddb-importer\", \"entity-feature-compendium\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n  });\n\n  game.settings.register(\"ddb-importer\", \"entity-class-compendium\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n  });\n\n  game.settings.register(\"ddb-importer\", \"entity-race-compendium\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n  });\n\n  game.settings.register(\"ddb-importer\", \"entity-trait-compendium\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n  });\n\n  game.settings.register(\"ddb-importer\", \"entity-feat-compendium\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n  });\n\n  game.settings.register(\"ddb-importer\", \"entity-spell-compendium\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n  });\n\n  game.settings.register(\"ddb-importer\", \"entity-override-compendium\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n  });\n\n  game.settings.register(\"ddb-importer\", \"entity-table-compendium\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n  });\n\n  game.settings.register(\"ddb-importer\", \"entity-monster-compendium\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n  });\n\n  game.settings.register(\"ddb-importer\", \"adventure-import-path\", {\n    name: \"ddb-importer.adventure-import-path.name\",\n    hint: \"ddb-importer.adventure-import-path.hint\",\n    scope: \"world\",\n    config: true,\n    default: \"[data] adventures/import\",\n    type: DirectoryPicker.Directory\n  });\n\n  game.settings.register(\"ddb-importer\", \"adventure-upload-path\", {\n    name: \"ddb-importer.adventure-upload-path.name\",\n    hint: \"ddb-importer.adventure-upload-path.hint\",\n    scope: \"world\",\n    config: true,\n    default: \"[data] ddb-images/adventures\",\n    type: DirectoryPicker.Directory\n  });\n\n  const adventureUploads = game.settings.get(\"ddb-importer\", \"adventure-upload-path\");\n\n  if (game.user.isGM) {\n    const oldDirPath = `[data] worlds/${game.world.id}/adventures`;\n    const oldDir = DirectoryPicker.parse(oldDirPath);\n\n    if (adventureUploads === \"[data] ddb-images/adventures\") {\n      DirectoryPicker.browse(oldDir.activeSource, oldDir.current, { bucket: oldDir.bucket }).then((uploadFileList) => {\n        if (uploadFileList.dirs.length !== 0 || uploadFileList.files.length !== 0) {\n          logger.warn(\"Updating adventure uploads to historic default\");\n          game.settings.set(\"ddb-importer\", \"adventure-upload-path\", oldDirPath);\n        }\n      }).catch((e) => {\n        if (\n          e.startsWith(\"The requested file storage undefined does not exist!\") ||\n          e.includes(\"does not exist or is not accessible in this storage location\")\n        ) {\n          logger.debug(\"Adventure directory check successful\");\n        }\n      });\n    }\n\n    DirectoryPicker.verifyPath(DirectoryPicker.parse(adventureUploads));\n  }\n\n  const baseAdventureMiscPath = adventureUploads.startsWith(\"[data]\")\n    ? `${adventureUploads}/misc`\n    : \"[data] ddb-images/adventures/misc\";\n\n  game.settings.register(\"ddb-importer\", \"adventure-misc-path\", {\n    name: \"ddb-importer.adventure-misc-path.name\",\n    hint: \"ddb-importer.adventure-misc-path.hint\",\n    scope: \"world\",\n    config: true,\n    default: baseAdventureMiscPath,\n    type: DirectoryPicker.Directory\n  });\n\n  if (game.user.isGM) {\n    const iconUploads = game.settings.get(\"ddb-importer\", \"adventure-misc-path\");\n    DirectoryPicker.verifyPath(DirectoryPicker.parse(iconUploads));\n  }\n\n  game.settings.register(\"ddb-importer\", \"log-level\", {\n    name: \"ddb-importer.log-level.name\",\n    hint: \"ddb-importer.log-level.hint\",\n    scope: \"world\",\n    config: true,\n    type: String,\n    choices: {\n      DEBUG: \"DEBUG\",\n      INFO: \"INFO\",\n      WARN: \"WARN\",\n      ERR: \"ERROR \",\n      OFF: \"OFF\",\n    },\n    default: \"INFO\",\n  });\n\n  game.settings.register(\"ddb-importer\", \"api-endpoint\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n    default: \"https://proxy.ddb.mrprimate.co.uk\",\n  });\n\n  const ddbProxy = game.settings.get(\"ddb-importer\", \"api-endpoint\");\n  if (ddbProxy === \"https://ddb.mrprimate.co.uk\") {\n    game.settings.set(\"ddb-importer\", \"api-endpoint\", \"https://proxy.ddb.mrprimate.co.uk\");\n  }\n\n  game.settings.register(\"ddb-importer\", \"cors-endpoint\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n    default: \"https://images.ddb.mrprimate.co.uk/\",\n  });\n\n  const corsEndpoint = game.settings.get(\"ddb-importer\", \"cors-endpoint\");\n  if (corsEndpoint === \"https://london.drop.mrprimate.co.uk/\") {\n    game.settings.set(\"ddb-importer\", \"cors-endpoint\", \"https://images.ddb.mrprimate.co.uk/\");\n  }\n\n  game.settings.register(\"ddb-importer\", \"dynamic-api-endpoint\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n    default: \"https://dynamic.ddb.mrprimate.co.uk\",\n  });\n\n  game.settings.register(\"ddb-importer\", \"cors-encode\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"beta-key\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n    default: \"\",\n  });\n\n  game.settings.register(\"ddb-importer\", \"patreon-user\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n    default: null,\n  });\n\n  game.settings.register(\"ddb-importer\", \"debug-json\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  /** Character update settings, stored per user and non-configurable in the settings screen */\n  game.settings.register(\"ddb-importer\", \"character-update-policy-add-character-effects\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  //\n  // Character effect generation options\n  //\n  // ITEM\n  // N/A\n  // RACE\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-race-damages\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-race-speed\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-race-senses\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-race-hp\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-race-spell-bonus\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n\n  // CLASS\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-class-damages\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-class-speed\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-class-senses\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-class-hp\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-class-spell-bonus\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n\n  // FEAT\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-feat-proficiencies\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-feat-languages\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-feat-damages\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-feat-speed\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-feat-senses\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-feat-hp\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-feat-spell-bonus\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-feat-ability-bonus\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  // BACKGROUND\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-background-proficiencies\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-background-languages\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-background-damages\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-background-speed\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-background-senses\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-background-hp\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-background-spell-bonus\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-effect-background-ability-bonus\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  //\n  //\n  game.settings.register(\"ddb-importer\", \"character-update-policy-add-item-effects\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-add-spell-effects\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-generate-ac-feature-effects\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-use-existing\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-ignore-non-ddb-items\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-use-override\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-use-srd\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  // Character update policy\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-name\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-hp\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-hit-die\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-class\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-feat\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-weapon\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-equipment\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-bio\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-import-extras\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  // = consumable, tool & loot\n  game.settings.register(\"ddb-importer\", \"character-update-policy-inventory\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-currency\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-spell\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-image\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-use-ddb-spell-icons\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-use-ddb-generic-item-icons\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-use-ddb-item-icons\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-use-inbuilt-icons\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-use-srd-icons\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-use-full-description\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-use-action-and-feature\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-use-actions-as-features\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-dae-copy\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-dae-effect-copy\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-active-effect-copy\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"character-update-policy-active-effect-character-copy\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  /** Munching update settings, stored per user and non-configurable in the settings screen */\n  game.settings.register(\"ddb-importer\", \"munching-policy-update-existing\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-use-srd\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  // build compendium folders?\n  game.settings.register(\"ddb-importer\", \"munching-policy-use-compendium-folders\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-selection-compendium-folders-monster\", {\n    name: \"ddb-importer.munching-selection-compendium-folders-monster.name\",\n    hint: \"ddb-importer.munching-selection-compendium-folders-monster.hint\",\n    scope: \"world\",\n    config: true,\n    type: String,\n    choices: {\n      TYPE: \"Creature type, e.g. Undead\",\n      CR: \"Challenge Rating\",\n      ALPHA: \"Alphabetical\",\n    },\n    default: \"TYPE\",\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-selection-compendium-folders-spell\", {\n    name: \"ddb-importer.munching-selection-compendium-folders-spell.name\",\n    hint: \"ddb-importer.munching-selection-compendium-folders-spell.hint\",\n    scope: \"world\",\n    config: true,\n    type: String,\n    choices: {\n      SCHOOL: \"School of Magic\",\n      LEVEL: \"Level\",\n    },\n    default: \"SCHOOL\",\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-selection-compendium-folders-item\", {\n    name: \"ddb-importer.munching-selection-compendium-folders-item.name\",\n    hint: \"ddb-importer.munching-selection-compendium-folders-item.hint\",\n    scope: \"world\",\n    config: true,\n    type: String,\n    choices: {\n      TYPE: \"Item Type\",\n      RARITY: \"Rarity\",\n    },\n    default: \"TYPE\",\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-use-srd-icons\", {\n    name: \"ddb-importer.munching-policy-use-srd-icons.name\",\n    hint: \"ddb-importer.munching-policy-use-srd-icons.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-use-inbuilt-icons\", {\n    name: \"ddb-importer.munching-policy-use-inbuilt-icons.name\",\n    hint: \"ddb-importer.munching-policy-use-inbuilt-icons.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-use-ddb-item-icons\", {\n    name: \"ddb-importer.munching-policy-use-ddb-item-icons.name\",\n    hint: \"ddb-importer.munching-policy-use-ddb-item-icons.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-use-ddb-spell-icons\", {\n    name: \"ddb-importer.munching-policy-use-ddb-spell-icons.name\",\n    hint: \"ddb-importer.munching-policy-use-ddb-spell-icons.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-use-ddb-generic-item-icons\", {\n    name: \"ddb-importer.munching-policy-use-ddb-generic-item-icons.name\",\n    hint: \"ddb-importer.munching-policy-use-ddb-generic-item-icons.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-use-full-token-image\", {\n    name: \"ddb-importer.munching-policy-use-full-token-image.name\",\n    hint: \"ddb-importer.munching-policy-use-full-token-image.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-use-token-avatar-image\", {\n    name: \"ddb-importer.munching-policy-use-token-avatar-image.name\",\n    hint: \"ddb-importer.munching-policy-use-token-avatar-image.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-remote-images\", {\n    name: \"ddb-importer.munching-policy-remote-images.name\",\n    hint: \"ddb-importer.munching-policy-remote-images.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-add-effects\", {\n    name: \"ddb-importer.munching-policy-add-effects.name\",\n    hint: \"ddb-importer.munching-policy-add-effects.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  /** Generate spell effects for munched spells? */\n  game.settings.register(\"ddb-importer\", \"munching-policy-add-spell-effects\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-add-ac-armor-effects\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-download-images\", {\n    name: \"ddb-importer.munching-policy-download-images.name\",\n    hint: \"ddb-importer.munching-policy-download-images.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-dae-copy\", {\n    name: \"ddb-importer.munching-policy-dae-copy.name\",\n    hint: \"ddb-importer.munching-policy-dae-copy.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-use-dae-effects\", {\n    name: \"ddb-importer.munching-policy-use-dae-effects.name\",\n    hint: \"ddb-importer.munching-policy-use-dae-effects.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-hide-description\", {\n    name: \"ddb-importer.munching-policy-hide-description.name\",\n    hint: \"ddb-importer.munching-policy-hide-description.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-monster-items\", {\n    name: \"ddb-importer.munching-policy-monster-items.name\",\n    hint: \"ddb-importer.munching-policy-monster-items.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-monster-homebrew\", {\n    name: \"ddb-importer.munching-policy-monster-homebrew.name\",\n    hint: \"ddb-importer.munching-policy-monster-homebrew.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-monster-homebrew-only\", {\n    name: \"ddb-importer.munching-policy-monster-homebrew-only.name\",\n    hint: \"ddb-importer.munching-policy-monster-homebrew-only.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-update-images\", {\n    name: \"ddb-importer.munching-policy-update-images.name\",\n    hint: \"ddb-importer.munching-policy-update-images.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-monster-exact-match\", {\n    name: \"ddb-importer.munching-policy-monster-match.name\",\n    hint: \"ddb-importer.munching-policy-monster-match.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-use-source-filter\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-muncher-sources\", {\n    scope: \"player\",\n    config: false,\n    type: Array,\n    default: [],\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-monster-use-item-ac\", {\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"munching-policy-monster-use-vision\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  // sets the current tutorial step the user has completed\n  // game.settings.register(\"ddb-importer\", \"tutorial-step\", {\n  //   scope: \"world\",\n  //   config: false,\n  //   type: Number,\n  //   default: 0,\n  // });\n  // sets the current tutorial step the user has completed\n  // game.settings.register(\"ddb-importer\", \"tutorial-user\", {\n  //   scope: \"world\",\n  //   config: false,\n  //   type: String,\n  //   default: \"\",\n  // });\n  // sets the current tutorial step the user has completed\n  // game.settings.register(\"ddb-importer\", \"popup-version\", {\n  //   scope: \"world\",\n  //   config: false,\n  //   type: String,\n  //   default: \"1.0.0\",\n  // });\n  // sets the user submission name for scene adjustments\n  // game.settings.register(\"ddb-importer\", \"scene-submission-username\", {\n  //   scope: \"user\",\n  //   config: false,\n  //   type: String,\n  //   default: \"\",\n  // });\n  game.settings.register(\"ddb-importer\", \"cobalt-cookie\", {\n    name: \"ddb-importer.cobalt-cookie.name\",\n    hint: \"ddb-importer.cobalt-cookie.hint\",\n    scope: \"world\",\n    config: false,\n    type: String,\n    default: \"\",\n  });\n\n  game.settings.register(\"ddb-importer\", \"cobalt-cookie-local\", {\n    name: \"ddb-importer.cobalt-cookie-local.name\",\n    hint: \"ddb-importer.cobalt-cookie-local.hint\",\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  if (game.user.isGM && game.settings.get(\"ddb-importer\", \"cobalt-cookie-local\") &&\n    game.settings.get(\"ddb-importer\", \"cobalt-cookie\") != \"\") {\n    game.settings.set(\"ddb-importer\", \"cobalt-cookie-local\", false);\n  }\n\n  game.settings.register(\"ddb-importer\", \"campaign-id\", {\n    name: \"ddb-importer.campaign-id.name\",\n    hint: \"ddb-importer.campaign-id.hint\",\n    scope: \"world\",\n    config: false,\n    type: String,\n    default: \"\",\n  });\n\n  game.settings.register(\"ddb-importer\", \"sync-policy-currency\", {\n    name: \"ddb-importer.sync-policy-currency.name\",\n    hint: \"ddb-importer.sync-policy-currency.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"sync-policy-hitpoints\", {\n    name: \"ddb-importer.sync-policy-hitpoints.name\",\n    hint: \"ddb-importer.sync-policy-hitpoints.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"sync-policy-hitdice\", {\n    name: \"ddb-importer.sync-policy-hitdice.name\",\n    hint: \"ddb-importer.sync-policy-hitdice.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"sync-policy-action-use\", {\n    name: \"ddb-importer.sync-policy-action-use.name\",\n    hint: \"ddb-importer.sync-policy-action-use.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"sync-policy-inspiration\", {\n    name: \"ddb-importer.sync-policy-inspiration.name\",\n    hint: \"ddb-importer.sync-policy-inspiration.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"sync-policy-condition\", {\n    name: \"ddb-importer.sync-policy-condition.name\",\n    hint: \"ddb-importer.sync-policy-condition.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"sync-policy-deathsaves\", {\n    name: \"ddb-importer.sync-policy-deathsaves.name\",\n    hint: \"ddb-importer.sync-policy-deathsaves.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"sync-policy-spells-prepared\", {\n    name: \"ddb-importer.sync-policy-spells-prepared.name\",\n    hint: \"ddb-importer.sync-policy-spells-prepared.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"sync-policy-spells-slots\", {\n    name: \"ddb-importer.sync-policy-spells-slots.name\",\n    hint: \"ddb-importer.sync-policy-spells-slots.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"sync-policy-spells-sync\", {\n    name: \"ddb-importer.sync-policy-spells-sync.name\",\n    hint: \"ddb-importer.sync-policy-spells-sync.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"sync-policy-equipment\", {\n    name: \"ddb-importer.sync-policy-equipment.name\",\n    hint: \"ddb-importer.sync-policy-equipment.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"sync-policy-xp\", {\n    name: \"ddb-importer.sync-policy-xp.name\",\n    hint: \"ddb-importer.sync-policy-xp.hint\",\n    scope: \"player\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"encounter-import-policy-create-scene\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"encounter-import-policy-existing-scene\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"encounter-import-policy-missing-characters\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"encounter-import-policy-missing-monsters\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"encounter-import-policy-create-journal\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"encounter-import-policy-roll-monster-initiative\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"encounter-import-policy-use-ddb-save\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"adventure-muncher-full-config\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync-user\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n    default: \"\",\n  });\n\n  if (game.settings.get(\"ddb-importer\", \"dynamic-sync-user\") === \"\" && game.user.isGM) {\n    game.settings.set(\"ddb-importer\", \"dynamic-sync-user\", game.user.id);\n  }\n\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync-policy-currency\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync-policy-hitpoints\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync-policy-hitdice\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync-policy-action-use\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync-policy-inspiration\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync-policy-condition\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync-policy-deathsaves\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync-policy-spells-prepared\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync-policy-spells-slots\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync-policy-spells-sync\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync-policy-equipment\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"dynamic-sync-policy-xp\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"third-party-scenes-partial\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n}\n","export class DDBItemConfig extends FormApplication {\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    options.title = \"DDB Owned Item Config\";\n    options.template = \"modules/ddb-importer/handlebars/item-config.hbs\";\n    options.classes = [\"ddbimporter\", \"sheet\"];\n    options.width = 500;\n    return options;\n  }\n\n  /** @override */\n  async getData() { // eslint-disable-line class-methods-use-this\n    // console.warn(this);\n    // console.warn(this.object);\n    let item = this.object.data;\n\n    const icon = item.flags.ddbimporter?.ignoreIcon;\n    const itemImport = item.flags.ddbimporter?.ignoreItemImport;\n    const resource = item.flags.ddbimporter?.retainResourceConsumption;\n    // const itemSync = item.flags.ddbimporter?.ignoreItemSync;\n\n    const settings = [\n      {\n        name: \"ignoreItemImport\",\n        isChecked: itemImport,\n        description: \"Ignore this item when importing the character (implies all other settings here).\",\n      },\n      {\n        name: \"ignoreIcon\",\n        isChecked: icon,\n        description: \"Ignore icon updates.\",\n      },\n      {\n        name: \"retainResourceConsumption\",\n        isChecked: resource,\n        description: \"Retain Resource Consumption linking.\",\n      },\n      // {\n      //   name: \"ignoreItemSync\",\n      //   isChecked: itemSync,\n      //   description: \"Ignore this item when when syncing the character\",\n      // },\n    ];\n\n    const result = {\n      name: item.name,\n      img: item.img,\n      character: this.object.actor.name,\n      settings: settings,\n    };\n\n    return result;\n  }\n\n  get id() {\n    const actor = this.object;\n    let id = `ddb-actor-${actor.id}`;\n    return id;\n  }\n\n  /** @override */\n  // eslint-disable-next-line no-unused-vars\n  async _updateObject(event, formData) {\n    event.preventDefault();\n\n    let item = {\n      _id: this.object.data._id,\n      flags: this.object.data.flags,\n    };\n\n    if (!item.flags.ddbimporter) item.flags.ddbimporter = {};\n    item.flags.ddbimporter['ignoreIcon'] = formData['ignoreIcon'];\n    item.flags.ddbimporter['ignoreItemImport'] = formData['ignoreItemImport'];\n    item.flags.ddbimporter['retainResourceConsumption'] = formData['retainResourceConsumption'];\n    // item.flags.ddbimporter['ignoreItemSync'] = formData['ignoreItemSync'];\n    this.object.actor.updateEmbeddedDocuments(\"Item\", [item]);\n\n  }\n}\n","import { DDBItemConfig } from \"../../lib/itemConfig.js\";\nimport { DDBAdventureFlags } from \"../../lib/adventureFlags.js\";\n\nfunction initItemSheetHook(app, html) {\n  if (!app.document.isOwned) return;\n  // console.error(app.entity);\n  // console.log(data);\n  const title = `DDB Importer Item Config`;\n  const whiteTitle = (game.settings.get(\"ddb-importer\", \"link-title-colour-white\")) ? \" white\" : \"\";\n  let button = $(`<a class=\"open-item-ddb-importer\" title=\"${title}\"><i class=\"fab fa-d-and-d-beyond${whiteTitle}\"></i></a>`);\n  button.click((event) => {\n    if (event.shiftKey && event.ctrlKey) {\n      new DDBAdventureFlags(app.document, {}).render(true);\n    } else {\n      new DDBItemConfig(app.document, {}).render(true);\n    }\n  });\n  html.closest('.app').find('.open-item-ddb-importer').remove();\n  let titleElement = html.closest('.app').find('.window-title');\n  button.insertAfter(titleElement);\n}\n\nexport function itemSheets() {\n  Hooks.on('renderItemSheet', initItemSheetHook);\n}\n\n","import utils from \"../../utils.js\";\nimport logger from \"../../logger.js\";\n\nconst MODULE_TITLE = \"DDB Importer\";\nconst MODULE_NAME = \"ddb-importer\";\nconst MODULE_AUTHOR = \"MrPrimate\";\nconst _GITHUB_API_LATEST = `https://api.github.com/repos/${MODULE_AUTHOR}/${MODULE_NAME}/releases/latest`;\nconst _GITHUB_MODULE_JSON_LATEST = `https://raw.githubusercontent.com/${MODULE_AUTHOR}/${MODULE_NAME}/master/module-template.json`;\nconst MINIMUM_5E_VERSION = \"1.5.5\";\n\n// eslint-disable-next-line consistent-return\nasync function getLatestModuleVersion() {\n  try {\n    const { tag_name: latestVersion, prerelease } = await $.getJSON(_GITHUB_API_LATEST);\n    return { latestVersion, prerelease };\n  } catch (error) {\n    logger.error(error);\n  }\n}\n\n// eslint-disable-next-line consistent-return\nasync function getLatestModuleMinimumCoreVersion() {\n  try {\n    const { minimumCoreVersion, compatibleCoreVersion } = await $.getJSON(_GITHUB_MODULE_JSON_LATEST);\n    return { minimumCoreVersion, compatibleCoreVersion };\n  } catch (error) {\n    logger.error(error);\n  }\n}\n\nexport default async () => {\n  const moduleInfo = game.modules.get(MODULE_NAME).data;\n  const installedVersion = moduleInfo.version;\n  CONFIG.DDBI.version = installedVersion;\n  const foundryVersion = game.version ? game.version : game.data.version;\n  try {\n    if (!game.user.isGM) return;\n    const { minimumCoreVersion, compatibleCoreVersion } = await getLatestModuleMinimumCoreVersion();\n    const compatibleMinimumSystem = utils.versionCompare(game.data.system.data.version, MINIMUM_5E_VERSION) >= 0;\n\n    if (!compatibleMinimumSystem) {\n      ui.notifications.error(`${MODULE_TITLE} strongly recommends 5e system v${MINIMUM_5E_VERSION} to run correctly. Pleas update your 5e version.`, { permanent: true });\n    }\n\n    // check version number only for GMs\n    const coreCheck = game.settings.get(\"ddb-importer\", \"update-check\");\n    if (!coreCheck) return;\n\n    const { latestVersion, prerelease: preRelease } = await getLatestModuleVersion();\n\n    const newModuleVersion = utils.versionCompare(latestVersion, installedVersion) === 1;\n    const compatibleCore = utils.versionCompare(foundryVersion, compatibleCoreVersion) >= 0;\n    const compatibleMinimumCore = utils.versionCompare(foundryVersion, minimumCoreVersion) >= 0;\n\n    const needToUpdate = newModuleVersion && compatibleCore && compatibleMinimumCore;\n\n    // console.log(utils.versionCompare(\"1.0.1\", \"1.0.1\")); // 0\n    // console.log(utils.versionCompare(\"1.0.0\", \"1.0.1\")); // -1\n    // console.log(utils.versionCompare(\"2.0.0\", \"1.0.1\")); // 1\n\n    if (preRelease) logger.debug(`Prerelease of ${MODULE_TITLE} detected`);\n\n    if (needToUpdate) {\n      let text = $(\n        `<h2>${MODULE_TITLE} Update!</h2><p>A new <b>${MODULE_NAME}</b> version is available. Please update to <b>v${latestVersion}</b> if you are experiencing issues and before reporting a bug.</p>`\n      );\n      window.DDBImporter.notification.show(text, null);\n    }\n  } catch (error) {\n    logger.warn(error);\n    window.DDBImporter.notification.show(`Could not retrieve latest ${MODULE_NAME} version`);\n  }\n};\n","export function earlySettings() {\n\n  game.settings.register(\"ddb-importer\", \"show-munch-top\", {\n    name: \"ddb-importer.show-munch-top.name\",\n    hint: \"ddb-importer.show-munch-top.hint\",\n    scope: \"world\",\n    config: true,\n    type: Boolean,\n    default: true,\n  });\n\n  game.settings.register(\"ddb-importer\", \"patreon-tier\", {\n    scope: \"world\",\n    config: false,\n    type: String,\n    default: null,\n  });\n\n  game.settings.register(\"ddb-importer\", \"custom-proxy\", {\n    name: \"ddb-importer.custom-proxy.name\",\n    hint: \"ddb-importer.custom-proxy.hint\",\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n  game.settings.register(\"ddb-importer\", \"encounter-muncher-enabled\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: true,\n  });\n\n  // for D&D 5e 1.4 ac migrtion\n  game.settings.register(\"ddb-importer\", \"ac-migration-complete-v1-4\", {\n    scope: \"world\",\n    config: false,\n    type: Boolean,\n    default: false,\n  });\n\n}\n","import DDBMuncher from \"../../muncher/ddb.js\";\nimport { DDBSetup, DDBCookie, isSetupComplete, isValidKey } from \"../../lib/Settings.js\";\nimport { checkCobalt } from \"../../lib/Secrets.js\";\n\n\nexport function addMuncher (app, html) {\n  if (app.options.id == \"compendium\" && game.user.isGM) {\n    let button = $(\"<div class='header-actions action-buttons flexrow'><button class='ddb-muncher'><i class='fas fa-pastafarianism'></i> DDB Muncher</button></div>\");\n\n    button.click(async () => {\n      ui.notifications.info(\"Checking your DDB details - this might take a few seconds!\");\n      const setupComplete = isSetupComplete();\n\n      if (setupComplete) {\n        const cobaltStatus = await checkCobalt();\n        if (cobaltStatus.success) {\n          let validKey = await isValidKey();\n          if (validKey) {\n            new DDBMuncher().render(true);\n          }\n        } else {\n          new DDBCookie().render(true);\n        }\n      } else {\n        game.settings.set(\"ddb-importer\", \"settings-call-muncher\", true);\n        new DDBSetup().render(true);\n      }\n    });\n\n    const top = game.settings.get(\"ddb-importer\", \"show-munch-top\");\n    if (top) {\n      $(html).find(\".directory-header\").append(button);\n    } else {\n      $(html).find(\".directory-footer\").append(button);\n    }\n\n  }\n}\n","import { DDBEncounterMunch } from \"../../muncher/encounters.js\";\nimport { DDBSetup, DDBCookie, isSetupComplete, isValidKey } from \"../../lib/Settings.js\";\nimport { checkCobalt } from \"../../lib/Secrets.js\";\nimport { getPatreonTiers } from \"../../muncher/utils.js\";\nimport logger from \"../../logger.js\";\n\n\nexport function addEncounterMuncher (app, html) {\n  const tier = game.settings.get(\"ddb-importer\", \"patreon-tier\");\n  const tiers = getPatreonTiers(tier);\n  const enabled = game.settings.get(\"ddb-importer\", \"encounter-muncher-enabled\");\n\n  if (enabled && app.options.id == \"scenes\" && game.user.isGM && tiers.supporter) {\n    let button = $(\"<div class='header-actions action-buttons flexrow'><button class='ddb-muncher' id='ddb-encounter-munch-open'><i class='fas fa-dungeon'></i> DDB Encounter Muncher</button></div>\");\n\n    const actualButton = button.find('#ddb-encounter-munch-open');\n    button.click(async () => {\n      actualButton.prop('disabled', true);\n      ui.notifications.info(\"Fetching your DDB Encounter Information, this might take a few seconds!\");\n      try {\n        const setupComplete = isSetupComplete();\n\n        if (setupComplete) {\n          const cobaltStatus = await checkCobalt();\n          if (cobaltStatus.success) {\n            let validKey = await isValidKey();\n            if (validKey) {\n              new DDBEncounterMunch().render(true);\n            }\n          } else {\n            actualButton.prop('disabled', false);\n            new DDBCookie().render(true);\n          }\n        } else {\n          actualButton.prop('disabled', false);\n          new DDBSetup().render(true);\n        }\n      } catch (e) {\n        logger.error(e);\n        actualButton.prop('disabled', false);\n      }\n    });\n\n    const top = game.settings.get(\"ddb-importer\", \"show-munch-top\");\n    if (top) {\n      $(html).find(\".directory-header\").prepend(button);\n    } else {\n      $(html).find(\".directory-footer\").append(button);\n    }\n\n    Hooks.on(\"closeApplication\", (app) => {\n      if (app instanceof DDBEncounterMunch) {\n        actualButton.prop('disabled', false);\n      }\n    });\n\n  }\n}\n","function onShowImage (data) {\n  const src = data.src;\n  const type = data.type.toLowerCase();\n\n  // check for an existing popout with that source\n  let isDisplayed = false;\n  $(`div.ddbimporter-image-popout ${type}`).each((index, element) => {\n    if ($(element).attr(\"src\") === src) isDisplayed = true;\n  });\n  if (isDisplayed) return;\n\n  // create the image popup\n  const popout = $(\n    `<div class=\"ddbimporter-image-popout\"><${type} src=\"${src}\" ${\n      type === \"video\" ? ' \"preload=\"auto\" autoplay=\"autoplay\" loop=\"loop\"' : \"\"\n    }/></div>`\n  );\n  popout.on(\"click\", () => {\n    $(popout).hide(400, () => {\n      $(popout).remove();\n    });\n  });\n  $(\"body\").prepend(popout);\n  $(popout).show(400);\n}\n\nexport function onSocketMessage (sender, data) {\n  switch (data.action) {\n    case \"showImage\": {\n      onShowImage(data);\n    }\n    // no default\n  }\n}\n","export function linkTables(type, html) {\n\n  // if journal\n  let content;\n  let findString;\n  switch (type) {\n    case \"journal\":\n      content = $(html).find(`div[data-edit=\"content\"]`);\n      findString = \"a.entity-link[data-entity='RollTable']\";\n      break;\n    case \"item\": {\n      const tableCompendium = game.settings.get(\"ddb-importer\", \"entity-table-compendium\");\n      content = $(html).find(`div[data-edit=\"data.description.value\"]`);\n      findString = `a.entity-link[data-pack='${tableCompendium}']`;\n      break;\n    }\n    // no default\n  }\n\n\n  // Add a direct roll button into DDB-imported rolltables\n  $(content)\n    .find(findString)\n    .each(async (_, link) => {\n      const data = $(link).data();\n      const pack = game.packs.get(data.pack);\n\n      const table = pack\n        ? await pack.getDocument(data.id)\n        : game.tables.get(data.id);\n\n      if (table?.data?.flags?.ddb?.contentChunkId || pack) {\n        const button = $(\n          `<a title=\"Click: Roll | Shift-Click: Self Roll\" class=\"ddbimporter roll\"><i class=\"fas fa-dice-d20\"></i>  Roll!</a>`\n        );\n\n        $(link).after(button);\n        $(button).on(\"click\", async (event) => {\n          event.preventDefault();\n          const rollMode = event.shiftKey ? \"selfroll\" : \"roll\";\n\n          // fix: Table description is undefined\n          if (!table.data.description) table.data.description = table.data.name;\n\n          const draw = await table.roll();\n\n          draw.results = draw.results.map((result) => {\n            if (!result.img)\n              result.img = \"icons/svg/d20-highlight.svg\";\n            return result;\n          });\n\n          await table.toMessage(draw.results, {\n            roll: draw.roll,\n            messageOptions: {\n              speaker: game.user.name,\n              rollMode: rollMode,\n            },\n          });\n\n        });\n      }\n    });\n}\n","import utils from \"../../utils.js\";\n\nexport function linkImages(html) {\n  if (!game.user.isGM) return;\n  // does this functionality exist from anther module?\n  const funcExists = utils.isModuleInstalledAndActive(\"vtta-dndbeyond\") ||\n    utils.isModuleInstalledAndActive(\"vtta-ddb\") ||\n    utils.isModuleInstalledAndActive(\"token-hud-art-button\");\n\n  if (funcExists) return;\n\n  // mark all images\n  $(html)\n    .find('div[data-edit=\"content\"] img, div[data-edit=\"content\"] video')\n    .each((index, element) => {\n      const showPlayersButton = $(\"<a class='ddbimporter-button'><i class='fas fa-eye'></i>&nbsp;Show Players</a>\");\n\n      $(element).wrap(\"<div class='ddbimporter-image-container'></div>\");\n      // show the button on mouseenter of the image\n      $(element)\n        .parent()\n        .mouseenter(function addHover() {\n          // eslint-disable-next-line no-invalid-this\n          $(this).append(showPlayersButton);\n          $(showPlayersButton).click((event) => {\n            event.preventDefault();\n            event.stopPropagation();\n            game.socket.emit(\"module.ddb-importer\", {\n              sender: game.user.data._id,\n              action: \"showImage\",\n              src: $(element).attr(\"src\"),\n              type: element.nodeName,\n            });\n          });\n        });\n      $(element)\n        .parent()\n        .mouseleave(function removeHover() {\n          // eslint-disable-next-line no-invalid-this\n          $(this).find(\"a\").remove();\n        });\n    });\n}\n","function copyToClipboard(text) {\n  var dummy = document.createElement(\"textarea\");\n  document.body.appendChild(dummy);\n  dummy.value = text;\n  dummy.select();\n  document.execCommand(\"copy\");\n  document.body.removeChild(dummy);\n}\n\nvar clippy = {};\nvar tableInUse = false;\n\nfunction getNoteButton(name, type) {\n  return $(\n    `<a id='ddb-note-${name}' class='ddb-button'><i class='fas fa-clipboard-check'></i>&nbsp;Copy ${type} ${name} </a>`\n  );\n}\n\nfunction getTableButton() {\n  return $(\n    `<a id='ddb-table-name' class='ddb-button'><i class='fas fa-clipboard-check'></i>&nbsp;Copy table details </a>`\n  );\n}\n\nfunction buildNotes(html, data) {\n  if (!game.user.isGM) return;\n  const allow = game.settings.get(\"ddb-importer\", \"allow-note-generation\");\n  if (!allow) return;\n\n  // mark all headers\n  $(html)\n    .find(\"h1, h2, h3, h4, h5, figure, p\")\n    .each((index, element) => {\n      $(element).wrap(\"<div class='ddbimporter-note-container'></div>\");\n      // show the button on mouseenter\n      $(element)\n        .parent()\n        .mouseenter(function Hovering() {\n          if (tableInUse) return;\n          const tagName = $(element).prop(\"tagName\");\n          const showStartButton = $(this).append(getNoteButton(\"start\", tagName));\n          const showEndButton = $(this).append(getNoteButton(\"end\", tagName));\n          $(showStartButton).click((e) => {\n            // const src = $(element).attr(\"src\");\n            // In 0.8.x for some reason I need to now wrap these in the target id check?\n            if (e.target.id === \"ddb-note-start\") {\n              clippy = {\n                ddbId: data.data.flags.ddb.ddbId,\n                cobaltId: data.data.flags.ddb.cobaltId,\n                parentId: data.data.flags.ddb.parentId,\n                splitTag: tagName.toLowerCase(),\n                slug: data.data.flags.ddb.slug,\n                tagIdFirst: $(element).prop(\"id\"),\n                contentChunkIdStart: $(element).attr(\"data-content-chunk-id\"),\n                tagIdLast: \"\",\n                contentChunkIdStop: \"EOF\",\n                sceneName: data.data.name,\n              };\n              copyToClipboard(JSON.stringify(clippy, null, 2));\n            }\n          });\n          $(showEndButton).click((e) => {\n            if (e.target.id === \"ddb-note-end\") {\n              clippy.tagIdLast = $(element).prop(\"id\");\n              clippy.contentChunkIdStop = $(element).attr(\"data-content-chunk-id\");\n              copyToClipboard(JSON.stringify(clippy, null, 2));\n            }\n          });\n        });\n      $(element)\n        .parent()\n        .mouseleave(function Unhovering() {\n          $(this).find(\"#ddb-note-start\").remove();\n          $(this).find(\"#ddb-note-end\").remove();\n        });\n    });\n\n  // mark all headers\n  $(html)\n    .find(\"table\")\n    .each((index, element) => {\n      $(element).wrap(\"<div class='ddbimporter-table-container'></div>\");\n      // show the button on mouseenter\n      $(element)\n        .parent()\n        .mouseenter(function Hovering() {\n          tableInUse = true;\n          const showButton = $(this).append(getTableButton());\n          $(showButton).click((e) => {\n            if (e.target.id === \"ddb-table-name\") {\n              clippy = {\n                ddbId: data.data.flags.ddb.ddbId,\n                cobaltId: data.data.flags.ddb.cobaltId,\n                parentId: data.data.flags.ddb.parentId,\n                slug: data.data.flags.ddb.slug,\n                tagIdFirst: $(element).prop(\"id\"),\n                contentChunkId: $(element).attr(\"data-content-chunk-id\"),\n                sceneName: data.data.name,\n                tableName: \"\",\n              };\n              copyToClipboard(JSON.stringify(clippy, null, 2));\n            }\n          });\n        });\n      $(element)\n        .parent()\n        .mouseleave(function Unhovering() {\n          $(this).find(\"#ddb-table-name\").remove();\n          tableInUse = false;\n        });\n    });\n}\n\nexport default buildNotes;\n","import { DDBAdventureFlags } from \"../../lib/adventureFlags.js\";\nimport buildNotes from \"./buildNotes.js\";\nimport { DDB_CONFIG } from \"../../ddbConfig.js\";\n\nconst POPUPS = {\n  json: null,\n  web: null,\n};\nconst renderPopup = (type, url) => {\n  if (POPUPS[type] && !POPUPS[type].close) {\n    POPUPS[type].focus();\n    POPUPS[type].location.href = url;\n  } else {\n    const ratio = window.innerWidth / window.innerHeight;\n    const width = Math.round(window.innerWidth * 0.5);\n    const height = Math.round(window.innerWidth * 0.5 * ratio);\n    POPUPS[type] = window.open(\n      url,\n      \"ddb_sheet_popup\",\n      `resizeable,scrollbars,location=no,width=${width},height=${height},toolbar=1`\n    );\n  }\n  return true;\n};\n\nfunction adventureFlags(app, html, data) {\n  if (!game.user.isGM || !app.document.data.flags.ddb) return;\n  const existingLink = html.closest('.app').find('.open-adventure-ddb-importer');\n  if (existingLink.length > 0) return;\n\n  const title = `Go to DDB`;\n  const whiteTitle = (game.settings.get(\"ddb-importer\", \"link-title-colour-white\")) ? \" white\" : \"\";\n  let button = $(`<a class=\"open-adventure-ddb-importer\" title=\"${title}\"><i class=\"fab fa-d-and-d-beyond${whiteTitle}\"></i></a>`);\n  button.click((event) => {\n    if (event.shiftKey && event.ctrlKey) {\n      new DDBAdventureFlags(app.document, {}).render(true);\n    } else {\n      event.preventDefault();\n      const flags = app.document.data.flags.ddb;\n      const bookSource = DDB_CONFIG.sources.find((book) => flags.bookCode.toLowerCase() === book.name.toLowerCase());\n      return renderPopup(\"web\", `https://www.dndbeyond.com/${bookSource.sourceURL}/${flags.slug}`);\n    }\n    return true;\n  });\n\n  let titleElement = html.closest('.app').find('.window-title');\n  button.insertAfter(titleElement);\n  buildNotes(html, data);\n}\n\n\nexport default adventureFlags;\n","/**\n * Shows notifcations and hints to the user\n */\nconst MARGIN = 10;\n\nconst registerNotifications = () => {\n  // register the notification global object\n\n  if ($(\"#ddbimporter-notifications\").length === 0) {\n    $(\"body\").append(`<div id=\"ddbimporter-notifications\"></div>`);\n  }\n  if ($(\"#ddbimporter-hints\").length === 0) {\n    $(\"body\").append(`<div id=\"ddbimporter-hints\"></div>`);\n  }\n\n  window.DDBImporter.notification = {\n    clear: () => {\n      $(\"#ddbimporter-notifications div\").fadeOut(200, () => {\n        $(\"#ddbimporter-notifications\").empty();\n      });\n    },\n    show: (message, timeout = 4000) => {\n      $(\"#ddbimporter-notifications\").css(\"left\", $(\"#players\").css(\"left\"));\n      // prettier-ignore\n      $(\"#ddbimporter-notifications\").css(\"bottom\", $(\"#players\").height() + (2 * MARGIN));\n\n      let note = $(`<div style=\"display: none\"></div>`).append(message);\n      $(\"#ddbimporter-notifications\").append(note);\n      $(note).fadeIn(200);\n\n      if (timeout)\n        setTimeout(() => {\n          $(note).fadeOut(200, () => {\n            $(note).remove();\n          });\n        }, timeout);\n      else\n        $(note).append('<p style=\"text-align: center; color: #7e7e7e; margin: 0px;\"><small>Click to close</small>');\n\n      $(note).on(\"click\", () => {\n        $(note).fadeOut(200, () => {\n          $(note).remove();\n        });\n      });\n    },\n  };\n  window.DDBImporter.hint = {\n    clear: () => {\n      $(\"#ddbimporter-hints div\").hide(200, () => {\n        $(\"#ddbimporter-hints\").empty();\n      });\n    },\n    show: (message, options = {}) => {\n      return new Promise((resolve) => {\n        $(\"#ddbimporter-hints\").css(\"width\", options.width ? options.width : 300);\n\n        // construct the note\n        let note = $(`<div style=\"display: none\"></div>`);\n        $(note).append(message);\n        $(note).append('<div class=\"buttons\"></div>');\n        $(\"#ddbimporter-hints\").append(note);\n        $(note).fadeIn(200);\n\n        if (!options.align) options.align = options.element ? \"RIGHT\" : \"CENTER\";\n\n        let anchor = {\n          width: 0,\n          height: 0,\n          top: Math.round(window.innerHeight / 2),\n          left: Math.round(window.innerWidth / 2),\n        };\n\n        if (options.element) {\n          anchor = Object.assign(\n            { width: $(options.element).width(), height: $(options.element).height() },\n            $(options.element).offset()\n          );\n        }\n        const noteInfo = Object.assign(\n          { width: $(\"#ddbimporter-hints\").width(), height: $(\"#ddbimporter-hints\").height() },\n          $(\"#ddbimporter-hints\").position()\n        );\n\n        switch (options.align) {\n          case \"RIGHT\":\n            $(\"#ddbimporter-hints\").css(\"top\", anchor.top);\n            $(\"#ddbimporter-hints\").css(\"left\", anchor.left + anchor.width + MARGIN);\n            break;\n          case \"LEFT\":\n            $(\"#ddbimporter-hints\").css(\"top\", anchor.top);\n            $(\"#ddbimporter-hints\").css(\"left\", anchor.left - noteInfo.width - MARGIN);\n            break;\n          case \"TOP\":\n            $(\"#ddbimporter-hints\").css(\"top\", anchor.top - noteInfo.height - MARGIN);\n            $(\"#ddbimporter-hints\").css(\"left\", anchor.left);\n            break;\n          case \"BOTTOM\":\n            $(\"#ddbimporter-hints\").css(\"top\", anchor.top + anchor.height + MARGIN);\n            $(\"#ddbimporter-hints\").css(\"left\", anchor.left);\n            break;\n\n          default:\n            // eslint-disable-next-line no-mixed-operators\n            $(\"#ddbimporter-hints\").css(\"top\", anchor.top - Math.round(noteInfo.height / 2));\n            // eslint-disable-next-line no-mixed-operators\n            $(\"#ddbimporter-hints\").css(\"left\", anchor.left - Math.round(noteInfo.width / 2));\n        }\n\n        if (options.buttons) {\n          for (let name of options.buttons) {\n            let btn = $(\"<button>\" + name + \"</button>\");\n            $(\"div.buttons\", note).append(btn);\n            $(btn).on(\"click\", () => {\n              $(note).fadeOut(100, () => {\n                $(note).remove();\n                resolve(name);\n              });\n            });\n          }\n        }\n        if (options.hide) {\n          $(options.hide.selector).on(options.hide.event, () => {\n            $(note).fadeOut(100, () => {\n              $(note).remove();\n              resolve(true);\n            });\n          });\n        }\n      });\n    },\n  };\n};\n\nexport default registerNotifications;\n","import logger from \"./logger.js\";\n\n// init hooks\nimport setupLogging from \"./hooks/init/setupLogging.js\";\nimport { registerWindow } from \"./hooks/init/window.js\";\n\n// ready hooks\nimport registerSheets from \"./hooks/ready/registerSheets.js\";\nimport checkCompendiums from \"./hooks/ready/checkCompendiums.js\";\nimport registerGameSettings from \"./hooks/ready/registerGameSettings.js\";\nimport { itemSheets } from \"./hooks/ready/items.js\";\nimport checkVersion from \"./hooks/ready/checkVersion.js\";\nimport { loadDDBConfig } from \"./ddbConfig.js\";\n\n// monster muncher\nimport { earlySettings } from \"./hooks/renderMuncher/settings.js\";\nimport { addMuncher } from \"./hooks/renderMuncher/addMuncher.js\";\nimport { addEncounterMuncher } from \"./hooks/renderMuncher/addEncounterMuncher.js\";\n\n// socket messaging\nimport { onSocketMessage } from \"./hooks/socket/onSocketMessage.js\";\n\n// image hooks\nimport { linkTables } from \"./hooks/renderJournalSheet/linkTables.js\";\nimport { linkImages } from \"./hooks/renderJournalSheet/linkImages.js\";\nimport adventureFlags from \"./hooks/renderJournalSheet/adventure.js\";\n\nimport registerNotifications from \"./lib/Notification.js\";\n\nimport { activateUpdateHooks } from \"./character/update.js\";\n\n\n// foundry is initializing\nexport function init() {\n  setupLogging();\n  registerWindow();\n  logger.info(\"Init\");\n}\n\n// foundry is ready\nexport function onceReady() {\n  // register the game settings\n  registerGameSettings();\n\n  // check for valid compendiums\n  checkCompendiums();\n\n  // notificaitons\n  registerNotifications();\n\n  // delay the startup just a tiny little bit\n  setTimeout(() => {\n    // register the D&DBeyond Button on the character sheets\n    registerSheets();\n    itemSheets();\n    checkVersion();\n    loadDDBConfig();\n    activateUpdateHooks();\n\n  }, 500);\n}\n\nexport function onReady() {\n  game.socket.on(\"module.ddb-importer\", (data) => {\n    if (data.sender === game.user.data._id) {\n      return;\n    }\n\n    const sender = game.users.get(data.sender);\n    delete data.sender;\n    onSocketMessage(sender, data);\n  });\n}\n\nexport function renderSidebarTab(app, html) {\n  earlySettings();\n  addEncounterMuncher(app, html);\n  addMuncher(app, html);\n}\n\nexport function renderItemSheet(sheet, html) {\n  linkTables(\"item\", html);\n  linkImages(html);\n}\n\nexport function renderJournalSheet(sheet, html, data) {\n  linkTables(\"journal\", html);\n  linkImages(html);\n  adventureFlags(sheet, html, data);\n}\n","import { download } from \"./utils.js\";\nimport { getSourcesLookups } from \"./ddb.js\";\nimport { DDB_CONFIG } from \"../ddbConfig.js\";\nimport logger from \"../logger.js\";\n\n/**\n   * Extracts all notes that have been placed by ddb-importer\n   * Creates the expected data structure for the database by\n   * getting the real label from the appropriate Journal Entry\n   * @param {Scene} scene The scene to extract the notes from\n  */\nfunction getNotes(scene, bookCode) {\n  // get all notes in the Journal related to this scene\n  const relatedJournalEntries = game.journal.filter((journal) =>\n    journal.data.flags.ddb?.bookCode &&\n    journal.data.flags.ddb.bookCode === bookCode\n  );\n\n  // get all notes placed on the map\n  const notes = scene.data.notes\n    // the user might have placed a note, unless it is based on an imported Journal Entry, we will not carry\n    // that one over\n    .filter((note) => relatedJournalEntries.some((journal) => journal.id === note.data.entryId))\n    .map((note) => {\n      const journal = relatedJournalEntries.find((journal) => journal.id === note.data.entryId);\n      const idx = parseInt(journal.data.flags.ddb.ddbId);\n      // removed un-needed userdata\n      const flags = journal.data.flags.ddb;\n      if (flags?.userData) delete flags.userData;\n      return {\n        index: idx,\n        label: journal.data.name,\n        flags: {\n          ddb: flags,\n        },\n        iconSize: note.data.iconSize,\n        iconTint: note.data.iconTint,\n        textColor: note.data.textColor,\n        textAnchor: note.data.textAnchor,\n        x: note.data.x,\n        y: note.data.y,\n      };\n    })\n    .reduce((notes, note) => {\n      const idx = notes.find((n) => n.index === note.index);\n      if (idx) {\n        idx.positions.push({ x: note.x, y: note.y });\n      } else {\n        const n = {\n          label: note.label,\n          flags: note.flags,\n          index: note.index,\n          iconSize: note.iconSize,\n          iconTint: note.iconTint,\n          textColor: note.textColor,\n          textAnchor: note.textAnchor,\n          positions: [{ x: note.x, y: note.y }]\n        };\n        notes.push(n);\n      }\n      return notes;\n    }, [])\n    .sort((a, b) => {\n      return a.index - b.index;\n    })\n    .map((note) => ({\n      label: note.label,\n      flags: note.flags,\n      positions: note.positions,\n      iconSize: note.iconSize,\n      iconTint: note.iconTint,\n      textColor: note.textColor,\n      textAnchor: note.textAnchor,\n    }));\n\n  return notes;\n}\n\n/**\n * Prepares the scene data for download\n * @param {Scene} scene\n */\nexport function collectSceneData(scene, bookCode) {\n\n  const notes = getNotes(scene, bookCode);\n\n  const data = {\n    flags: scene.data.flags,\n    name: scene.data.name,\n    navName: scene.data.navName,\n    // dimensions\n    width: scene.data.width,\n    height: scene.data.height,\n    // grid\n    grid: scene.data.grid,\n    gridDistance: scene.data.gridDistance,\n    gridType: scene.data.gridType,\n    gridUnits: scene.data.gridUnits,\n    shiftX: scene.data.shiftX,\n    shiftY: scene.data.shiftY,\n    padding: scene.data.padding,\n    // initial\n    initial: scene.data.initial,\n    // customization\n    backgroundColor: scene.data.backgroundColor,\n    walls: scene.data.walls.map((wall) => {\n      const w = wall.toObject();\n      delete w._id;\n      return w;\n    }),\n    //\n    drawings: scene.data.drawings,\n    weather: scene.data.weather,\n    // lights\n    darkness: scene.data.darkness,\n    tokenVision: scene.data.tokenVision,\n    globalLight: scene.data.globalLight,\n    globalLightThreshold: scene.data.globalLightThreshold,\n    lights: scene.data.lights.map((light) => {\n      const l = light.toObject();\n      delete l._id;\n      return l;\n    }),\n  };\n\n  if (!data.flags.ddb) data.flags.ddb = {};\n  data.flags.ddb.foundryVersion = game.version ? game.version : game.data.version;\n\n  if (data.flags.ddb.tokens) delete data.flags.ddb.tokens;\n  data.flags.ddb.tokens = scene.data.tokens\n    .filter((token) => !token.actorLink)\n    .map((token) => {\n      let result = {\n        _id: token.data._id,\n        name: token.data.name,\n        width: token.data.width,\n        height: token.data.height,\n        scale: token.data.scale,\n        x: token.data.x,\n        y: token.data.y,\n        disposition: token.data.disposition,\n        flags: token.data.flags,\n        actorLink: false,\n        bar1: { attribute: \"attributes.hp\" },\n        effects: [],\n        elevation: token.data.elevation,\n        hidden: token.data.hidden,\n        lightAlpha: token.data.lightAlpha,\n        lightAngle: token.data.lightAngle,\n        lightAnimation: token.data.lightAnimation,\n        tint: token.data.tint,\n        actorData: token.data.actorData,\n      };\n\n      // the token actor flags here help us match up actors using the DDB ID\n      if (token.actor) {\n        if (token.actor.data.flags.ddbimporter) {\n          result.flags.ddbActorFlags = token.actor.data.flags.ddbimporter;\n          result.flags.ddbActorFlags.name = token.actor.data.token?.name ? token.actor.data.token.name : token.actor.data.name;\n        }\n      }\n\n      return result;\n    });\n\n\n  // removed un-needed userdata\n  if (data.flags.ddb?.userData) delete data.flags.ddb.userData;\n\n  data.flags.ddb.notes = notes;\n\n  if (!data.flags.ddbimporter) data.flags.ddbimporter = {};\n  data.flags.ddbimporter['version'] = game.modules.get(\"ddb-importer\").data.version;\n\n  return data;\n}\n\nfunction getCompendiumScenes(compendiumCollection, selectedId) {\n  let scenes = [];\n  const compendium = game.packs.find((pack) => pack.collection === compendiumCollection);\n  if (compendium) {\n    compendium.index.forEach((scene) => {\n      const option = {\n        _id: scene._id,\n        name: scene.name,\n        selected: selectedId && selectedId == scene._id,\n      };\n      scenes.push(option);\n    });\n  }\n\n  return scenes;\n}\n\n\n// scene.data.flags.ddb.bookCode\n\n\n// window.DDBScene = {\n//   exportScene: exportScene,\n// };\n\nconst ddbFlags = [\"ddb\", \"ddbimporter\"];\nconst allowedFlags = [\"stairways\", \"perfect-vision\", \"dynamic-illumination\"];\n\n\nexport class SceneEnhancerExport extends Application {\n\n  // eslint-disable-next-line complexity\n  constructor(scene) {\n    super();\n    this.sceneSet = false;\n    this.compendiumBookSet = false;\n    this.downloadBookSet = false;\n\n    this.scene = scene;\n    const sceneExportFlags = this.scene.data.flags.ddbimporter?.export;\n\n    this.description = sceneExportFlags?.description || \"\";\n    this.url = sceneExportFlags?.url || \"\";\n    this.compendium = sceneExportFlags?.compendium;\n    this.compendiumScene = sceneExportFlags?.scene;\n    this.bookCode = this.scene.data.flags?.ddb?.bookCode.toLowerCase();\n    this.compendiumScenes = this.compendium ? getCompendiumScenes(this.compendium, this.compendiumScene) : [];\n\n    if (this.compendiumScene && this.compendiumScenes) this.sceneSet = true;\n\n    this.compendiums = game.packs\n      .filter((pack) => pack.metadata?.entity === \"Scene\")\n      .map((pack) => {\n        if (this.compendium && this.compendium === pack.collection) pack.selected = true;\n        else pack.selected = false;\n        return pack;\n      })\n      .sort((a, b) => a.metadata.label.localeCompare(b.metadata.label));\n\n    const selectedBooks = this.bookCode\n      ? DDB_CONFIG.sources.filter((s) => s.name.toLowerCase() === this.bookCode).map((s) => s.id)\n      : [];\n    this.books = getSourcesLookups(selectedBooks).map((b) => {\n      if (b.selected) {\n        this.compendiumBookSet = true;\n        this.downloadBookSet = true;\n      }\n      return {\n        code: b.acronym.toLowerCase(),\n        name: b.label,\n        selected: b.selected,\n      };\n    }).sort((a, b) => a.name.localeCompare(b.name));\n\n    this.exportOptionsCompendium = {\n      actors: sceneExportFlags?.actors !== undefined ? sceneExportFlags.actors : true,\n      notes: sceneExportFlags?.notes !== undefined ? sceneExportFlags.notes : true,\n      lights: sceneExportFlags?.lights !== undefined ? sceneExportFlags.lights : false,\n      walls: sceneExportFlags?.walls !== undefined ? sceneExportFlags.walls : false,\n      drawings: sceneExportFlags?.drawings !== undefined ? sceneExportFlags.drawings : false,\n      config: sceneExportFlags?.config !== undefined ? sceneExportFlags.config : false,\n    };\n    this.exportOptionsDownload = {\n      actors: sceneExportFlags?.actors !== undefined ? sceneExportFlags.actors : true,\n      notes: sceneExportFlags?.notes !== undefined ? sceneExportFlags.notes : true,\n      lights: sceneExportFlags?.lights !== undefined ? sceneExportFlags.lights : true,\n      walls: sceneExportFlags?.walls !== undefined ? sceneExportFlags.walls : true,\n      drawings: sceneExportFlags?.drawings !== undefined ? sceneExportFlags.drawings : true,\n      config: sceneExportFlags?.config !== undefined ? sceneExportFlags.config : true,\n    };\n    this.compendiumDisabled = !this.sceneSet || !this.compendiumBookSet;\n    this.downloadDisabled = !this.downloadBookSet || this.url === \"\" || !this.url.startsWith(\"http\");\n  }\n\n  static get defaultOptions() {\n    const options = super.defaultOptions;\n    options.baseApplication = \"SceneEnhancerExport\";\n    options.id = \"ddb-importer-scene-enhancer\";\n    options.template = \"modules/ddb-importer/handlebars/enhance-export.hbs\";\n    options.width = 500;\n    options.resizable = false;\n    options.height = \"auto\";\n    options.classes = [\"ddb-muncher\", \"sheet\"];\n    options.tabs = [{ navSelector: \".tabs\", contentSelector: \"div\", initial: \"compendium\" }];\n    return options;\n  }\n\n  get title() {\n    return `DDB Importer Scene Enhancer Exporter: ${this.scene.name}`;\n  }\n\n  /** @override */\n  getData() {\n    let templateData = {\n      sceneName: this.scene.name,\n      compendiums: this.compendiums,\n      compendiumScenes: this.compendiumScenes,\n      description: this.description,\n      books: this.books,\n      url: this.url,\n      exportOptionsCompendium: this.exportOptionsCompendium,\n      exportOptionsDownload: this.exportOptionsDownload,\n      compendiumDisabled: this.compendiumDisabled,\n      downloadDisabled: this.downloadDisabled,\n    };\n\n    return templateData;\n  }\n\n  checkState() {\n    if (this.sceneSet && this.compendiumBookSet) {\n      this.compendiumDisabled = false;\n      $(\"#compendium-button\").prop(\"disabled\", false);\n    } else {\n      $(\"#compendium-button\").prop(\"disabled\", true);\n    }\n    if (this.downloadBookSet && this.url !== \"\" && this.url.startsWith(\"http\")) {\n      this.downloadDisabled = false;\n      $(\"#download-button\").prop(\"disabled\", false);\n    } else {\n      $(\"#download-button\").prop(\"disabled\", true);\n    }\n  }\n\n  activateListeners(html) {\n    super.activateListeners(html);\n    $(\"#ddb-importer-scene-enhancer\").css(\"height\", \"auto\");\n\n    html.find('#compendium-form').submit(async (event) => {\n      const form = document.querySelector('#compendium-form');\n      const data = Object.fromEntries(new FormData(form).entries());\n      this.buttonClick(event, data);\n    });\n\n    html.find('#download-form').submit(async (event) => {\n      const form = document.querySelector('#download-form');\n      const data = Object.fromEntries(new FormData(form).entries());\n      this.buttonClick(event, data);\n    });\n\n    html.find(\"#select-compendium\").on(\"change\", async () => {\n      const compendiumSelection = html.find(\"#select-compendium\");\n\n      // get selected campaign from html selection\n      const compendiumCollection = compendiumSelection[0].selectedOptions[0]\n        ? compendiumSelection[0].selectedOptions[0].value\n        : undefined;\n\n      let sceneList = \"\";\n\n      if (compendiumCollection && compendiumCollection !== \"\") {\n        const scenes = getCompendiumScenes(compendiumCollection);\n        sceneList = `<option value=\"\">Select...</option>`;\n        scenes.forEach((scene) => {\n          const selected = scene.selected ? \" selected\" : \"\";\n          sceneList += `<option value=\"${scene._id}\"${selected}>${scene.name}</option>`;\n        });\n      }\n      const sceneSelection = html.find(\"#select-scene\");\n      sceneSelection[0].innerHTML = sceneList;\n    });\n\n    html.find(\"#select-scene\").on(\"change\", async () => {\n      const sceneSelection = html.find(\"#select-scene\");\n      const scene = sceneSelection[0].selectedOptions[0]\n        ? sceneSelection[0].selectedOptions[0].value\n        : undefined;\n      this.sceneSet = scene && scene !== \"\";\n      this.checkState();\n    });\n\n    html.find(\"#select-book-compendium\").on(\"change\", async () => {\n      const bookSelection = html.find(\"#select-book-compendium\");\n      const book = bookSelection[0].selectedOptions[0]\n        ? bookSelection[0].selectedOptions[0].value\n        : undefined;\n      this.compendiumBookSet = book && book !== \"\";\n      this.checkState();\n    });\n\n    html.find(\"#select-book-download\").on(\"change\", async () => {\n      const bookSelection = html.find(\"#select-book-download\");\n      const book = bookSelection[0].selectedOptions[0]\n        ? bookSelection[0].selectedOptions[0].value\n        : undefined;\n      this.downloadBookSet = book && book !== \"\";\n      this.checkState();\n    });\n\n    html.find(\"#download-url\").on(\"change\", async () => {\n      const bookSelection = html.find(\"#download-url\");\n      const url = bookSelection[0].value;\n      if (url && url !== \"\" && url.startsWith(\"http\")) {\n        this.url = url;\n      }\n      this.checkState();\n    });\n\n  }\n\n\n  async buttonClick(event, formData) { // eslint-disable-line class-methods-use-this\n    event.preventDefault();\n\n    let sceneFlags = JSON.parse(JSON.stringify(this.scene.data.flags));\n\n    if (!sceneFlags.ddb) sceneFlags.ddb = {};\n    if (!sceneFlags.ddbimporter) sceneFlags.ddbimporter = {};\n    if (!sceneFlags.ddbimporter.export) sceneFlags.ddbimporter.export = {};\n\n    sceneFlags.ddb[\"bookCode\"] = formData[\"select-book\"];\n    sceneFlags.ddbimporter.export['description'] = formData[\"description\"];\n    sceneFlags.ddbimporter.export['actors'] = formData[\"export-actors\"] == \"on\";\n    sceneFlags.ddbimporter.export['notes'] = formData[\"export-notes\"] == \"on\";\n    sceneFlags.ddbimporter.export['lights'] = formData[\"export-lights\"] == \"on\";\n    sceneFlags.ddbimporter.export['walls'] = formData[\"export-walls\"] == \"on\";\n    sceneFlags.ddbimporter.export['drawings'] = formData[\"export-drawings\"] == \"on\";\n    sceneFlags.ddbimporter.export['config'] = formData[\"export-config\"] == \"on\";\n\n    if (formData[\"download-url\"]) {\n      sceneFlags.ddbimporter.export['url'] = formData[\"download-url\"];\n    } else {\n      sceneFlags.ddbimporter.export['compendium'] = formData[\"select-compendium\"];\n      sceneFlags.ddbimporter.export['scene'] = formData[\"select-scene\"];\n    }\n\n    await this.scene.update({ flags: sceneFlags });\n\n    let sceneData = collectSceneData(this.scene, formData[\"select-book\"]);\n\n    Object.keys(sceneData.flags).forEach((flag) => {\n      if (!allowedFlags.includes(flag) && !ddbFlags.includes(flag)) delete sceneData.flags[flag];\n    });\n\n    if (formData[\"export-actors\"] !== \"on\") delete sceneData.flags.ddb.tokens;\n    if (formData[\"export-notes\"] !== \"on\") delete sceneData.flags.ddb.notes;\n    if (formData[\"export-lights\"] !== \"on\") delete sceneData.lights;\n    if (formData[\"export-walls\"] !== \"on\") delete sceneData.walls;\n    if (formData[\"export-drawings\"] !== \"on\") delete sceneData.drawings;\n    if (formData[\"export-config\"] !== \"on\") {\n      delete sceneData.navName;\n      delete sceneData.width;\n      delete sceneData.height;\n      delete sceneData.grid;\n      delete sceneData.gridDistance;\n      delete sceneData.gridType;\n      delete sceneData.gridUnits;\n      delete sceneData.shiftX;\n      delete sceneData.shiftY;\n      delete sceneData.padding;\n      delete sceneData.weather;\n      delete sceneData.darkness;\n      delete sceneData.tokenVision;\n      delete sceneData.globalLight;\n      delete sceneData.globalLightThreshold;\n      delete sceneData.backgroundColor;\n      delete sceneData.initial;\n      Object.keys(sceneData.flags).forEach((flag) => {\n        if (!ddbFlags.includes(flag)) delete sceneData.flags[flag];\n      });\n    }\n\n    logger.debug(sceneData);\n    const name = sceneData.name.replace(/[^a-z0-9_-]/gi, '').toLowerCase();\n    const sceneRef = `ddb-enhanced-scene-${name}`;\n    download(JSON.stringify(sceneData, null, 4), `${sceneRef}.json`, \"application/json\");\n\n    this.close();\n  }\n}\n\n","// import utils from \"../../utils.js\";\nimport { download } from \"../../muncher/utils.js\";\nimport { collectSceneData, SceneEnhancerExport } from \"../../muncher/sceneEnhancer.js\";\n\nfunction getSceneId(li) {\n  return $(li).attr(\"data-document-id\")\n    ? $(li).attr(\"data-document-id\")\n    : $(li).attr(\"data-scene-id\")\n      ? $(li).attr(\"data-scene-id\")\n      : $(li).attr(\"data-entity-id\");\n}\n\nexport default function (html, contextOptions) {\n  contextOptions.push({\n    name: \"ddb-importer.scenes.download\",\n    callback: (li) => {\n      const scene = game.scenes.get(getSceneId(li));\n      const data = collectSceneData(scene, scene.data.flags.ddb.bookCode);\n      const bookCode = `${scene.data.flags.ddb.bookCode}-${scene.data.flags.ddb.ddbId}`;\n      const cobaltId = scene.data.flags.ddb?.cobaltId ? `-${scene.data.flags.ddb.cobaltId}` : \"\";\n      const parentId = scene.data.flags.ddb?.parentId ? `-${scene.data.flags.ddb.parentId}` : \"\";\n      const contentChunkId = scene.data.flags.ddb?.contentChunkId ? `-${scene.data.flags.ddb.contentChunkId}` : \"\";\n      const name = scene.data.name.replace(/[^a-z0-9_-]/gi, '').toLowerCase();\n      const sceneRef = `${bookCode}${cobaltId}${parentId}${contentChunkId}-${name}`;\n      return download(JSON.stringify(data, null, 4), `${sceneRef}-scene.json`, \"application/json\");\n    },\n    condition: (li) => {\n      const scene = game.scenes.get(getSceneId(li));\n      const sceneDownload = game.settings.get(\"ddb-importer\", \"allow-scene-download\");\n      const allowDownload = game.user.isGM && sceneDownload && scene.data.flags.ddb?.ddbId;\n      return allowDownload;\n    },\n    icon: '<i class=\"fas fa-share-alt\"></i>',\n  });\n\n  contextOptions.push({\n    name: \"ddb-importer.scenes.third-party-download\",\n    callback: (li) => {\n      const scene = game.scenes.get(getSceneId(li));\n      new SceneEnhancerExport(scene).render(true);\n    },\n    condition: (li) => {\n      const scene = game.scenes.get(getSceneId(li));\n      const sceneDownload = game.settings.get(\"ddb-importer\", \"allow-third-party-scene-download\");\n      const allowDownload = game.user.isGM && sceneDownload && !scene.data.flags.ddb?.ddbId;\n      return allowDownload;\n    },\n    icon: '<i class=\"fas fa-share-alt\"></i>',\n  });\n}\n","import {\n  init,\n  onReady,\n  onceReady,\n  renderSidebarTab,\n  renderItemSheet,\n  renderJournalSheet,\n} from \"./hooks.js\";\nimport extendSceneNavigationContext from \"./hooks/navigationContext/extendSceneNavigationContext.js\";\n\n// register hooks\nHooks.once(\"init\", init);\nHooks.once(\"ready\", onceReady);\nHooks.on(\"ready\", onReady);\nHooks.on(\"renderSidebarTab\", renderSidebarTab);\nHooks.on(\"renderJournalSheet\", renderJournalSheet);\nHooks.on(\"renderItemSheet\", renderItemSheet);\nHooks.on(\"getSceneNavigationContext\", extendSceneNavigationContext);\nHooks.on(\"getSceneDirectoryEntryContext\", extendSceneNavigationContext);\n\n"],"names":[],"sourceRoot":""}